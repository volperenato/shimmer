; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30133.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_7PSMVocoder@@6B@				; PSMVocoder::`vftable'
PUBLIC	??_R2IAudioSignalProcessor@@8			; IAudioSignalProcessor::`RTTI Base Class Array'
PUBLIC	??_R0?AVModulation@@@8				; Modulation `RTTI Type Descriptor'
PUBLIC	?INTERVALS_NAMES_STRING@@3PAPEADA		; INTERVALS_NAMES_STRING
PUBLIC	??_R4ModDelay@@6B@				; ModDelay::`RTTI Complete Object Locator'
PUBLIC	??_R2Modulation@@8				; Modulation::`RTTI Base Class Array'
PUBLIC	??_C@_07GLGBIDLM@2nd?5Maj@			; `string'
PUBLIC	??_C@_07GNMKOBCE@3rd?5Min@			; `string'
PUBLIC	??_C@_07HLFHFJI@3rd?5Maj@			; `string'
PUBLIC	??_C@_07DOADDGAH@4th?5Per@			; `string'
PUBLIC	??_C@_07PCKJDGJJ@5th?5Per@			; `string'
PUBLIC	??_C@_07FLEHIOLN@6th?5Maj@			; `string'
PUBLIC	??_C@_07JHONIOCD@7th?5Maj@			; `string'
PUBLIC	??_C@_07JNPNFIPA@1st?5Oct@			; `string'
PUBLIC	??_C@_07EOOPKDLB@1?5Oct?$CL5@			; `string'
PUBLIC	??_C@_07FEMGBGFB@1?$CL2?5Oct@			; `string'
PUBLIC	??_C@_01LKDEMHDF@s@				; `string'
PUBLIC	??_C@_02KLOHGLOJ@Hz@				; `string'
PUBLIC	??_C@_03BHCFKDFC@Mix@				; `string'
PUBLIC	??_C@_04EBKMHHBE@Size@				; `string'
PUBLIC	??_C@_07CNCNAGDO@Shimmer@			; `string'
PUBLIC	??_C@_05BFFNNFFO@Decay@				; `string'
PUBLIC	??_C@_07HJKIPEFI@Damping@			; `string'
PUBLIC	??_C@_05OMHELODH@Space@				; `string'
PUBLIC	??_C@_09ONNCCMEP@Intervals@			; `string'
PUBLIC	??_C@_08MNIOIDHF@Mod?5Rate@			; `string'
PUBLIC	??_C@_09DPAPPDMJ@Mod?5Depth@			; `string'
PUBLIC	??_C@_03MFOGABFF@LPF@				; `string'
PUBLIC	??_C@_03EKIEJGAC@HPF@				; `string'
PUBLIC	??_C@_07MCAEODGB@Default@			; `string'
PUBLIC	??_C@_0L@GEJFJLEL@Small?5Room@			; `string'
PUBLIC	??_C@_04FKEBJNOD@Hall@				; `string'
PUBLIC	??_C@_0BA@JIEKPJGJ@Ambience?5Damped@		; `string'
PUBLIC	??_C@_0BD@CJOOIIIC@Ambience?5Modulated@		; `string'
PUBLIC	??_C@_09KHHOPKD@Fox?5Suite@			; `string'
PUBLIC	??_R0?AVPSMVocoder@@@8				; PSMVocoder `RTTI Type Descriptor'
PUBLIC	??_7Shimmer@@6B@				; Shimmer::`vftable'
PUBLIC	??_R3PSMVocoder@@8				; PSMVocoder::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R4IAudioSignalProcessor@@6B@			; IAudioSignalProcessor::`RTTI Complete Object Locator'
PUBLIC	??_R1A@?0A@EJ@Delay@@8				; Delay::`RTTI Base Class Descriptor at (0,-1,0,73)'
PUBLIC	??_R3IAudioSignalProcessor@@8			; IAudioSignalProcessor::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R1A@?0A@EJ@CombFilter@@8			; CombFilter::`RTTI Base Class Descriptor at (0,-1,0,73)'
PUBLIC	??_R1A@?0A@EA@Shimmer@@8			; Shimmer::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EJ@LPCombFilter@@8			; LPCombFilter::`RTTI Base Class Descriptor at (0,-1,0,73)'
PUBLIC	??_R1A@?0A@EA@ModDelay@@8			; ModDelay::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3Modulation@@8				; Modulation::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVModDelay@@@8				; ModDelay `RTTI Type Descriptor'
PUBLIC	??_7IAudioSignalProcessor@@6B@			; IAudioSignalProcessor::`vftable'
PUBLIC	??_R3Shimmer@@8					; Shimmer::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R1A@?0A@EA@IAudioSignalProcessor@@8		; IAudioSignalProcessor::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4PSMVocoder@@6B@				; PSMVocoder::`RTTI Complete Object Locator'
PUBLIC	??_R3ModDelay@@8				; ModDelay::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R1A@?0A@EA@PSMVocoder@@8			; PSMVocoder::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4Shimmer@@6B@				; Shimmer::`RTTI Complete Object Locator'
PUBLIC	??_R4Modulation@@6B@				; Modulation::`RTTI Complete Object Locator'
PUBLIC	??_R2Shimmer@@8					; Shimmer::`RTTI Base Class Array'
PUBLIC	??_R0?AVShimmer@@@8				; Shimmer `RTTI Type Descriptor'
PUBLIC	??_7ModDelay@@6B@				; ModDelay::`vftable'
PUBLIC	??_R1A@?0A@EN@ModDelay@@8			; ModDelay::`RTTI Base Class Descriptor at (0,-1,0,77)'
PUBLIC	??_R1A@?0A@EA@Modulation@@8			; Modulation::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVIAudioSignalProcessor@@@8		; IAudioSignalProcessor `RTTI Type Descriptor'
PUBLIC	??_7Modulation@@6B@				; Modulation::`vftable'
PUBLIC	??_R2PSMVocoder@@8				; PSMVocoder::`RTTI Base Class Array'
PUBLIC	??_R2ModDelay@@8				; ModDelay::`RTTI Base Class Array'
EXTRN	__imp_strcpy:PROC
EXTRN	__imp_abs:PROC
EXTRN	__imp_srand:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp_round:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_atan2:PROC
EXTRN	__imp_fabs:PROC
EXTRN	__imp_rand:PROC
;	COMDAT ??_R2ModDelay@@8
rdata$r	SEGMENT
??_R2ModDelay@@8 DD imagerel ??_R1A@?0A@EA@ModDelay@@8	; ModDelay::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@LPCombFilter@@8
	DD	imagerel ??_R1A@?0A@EA@CombFilter@@8
	DD	imagerel ??_R1A@?0A@EA@Delay@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R2PSMVocoder@@8
rdata$r	SEGMENT
??_R2PSMVocoder@@8 DD imagerel ??_R1A@?0A@EA@PSMVocoder@@8 ; PSMVocoder::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@IAudioSignalProcessor@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_7Modulation@@6B@
CONST	SEGMENT
??_7Modulation@@6B@ DQ FLAT:??_R4Modulation@@6B@	; Modulation::`vftable'
	DQ	FLAT:?init@LPCombFilter@@UEAAXMH@Z
	DQ	FLAT:?setSampleRate@Modulation@@UEAAXH@Z
	DQ	FLAT:?processAudio@Modulation@@UEAAMM@Z
CONST	ENDS
;	COMDAT ??_R0?AVIAudioSignalProcessor@@@8
data$rs	SEGMENT
??_R0?AVIAudioSignalProcessor@@@8 DQ FLAT:??_7type_info@@6B@ ; IAudioSignalProcessor `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVIAudioSignalProcessor@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@Modulation@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Modulation@@8 DD imagerel ??_R0?AVModulation@@@8 ; Modulation::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3Modulation@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EN@ModDelay@@8
rdata$r	SEGMENT
??_R1A@?0A@EN@ModDelay@@8 DD imagerel ??_R0?AVModDelay@@@8 ; ModDelay::`RTTI Base Class Descriptor at (0,-1,0,77)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	04dH
	DD	imagerel ??_R3ModDelay@@8
rdata$r	ENDS
;	COMDAT ??_7ModDelay@@6B@
CONST	SEGMENT
??_7ModDelay@@6B@ DQ FLAT:??_R4ModDelay@@6B@		; ModDelay::`vftable'
	DQ	FLAT:?init@LPCombFilter@@UEAAXMH@Z
	DQ	FLAT:?setSampleRate@ModDelay@@UEAAXH@Z
	DQ	FLAT:?processAudio@ModDelay@@UEAAMM@Z
CONST	ENDS
;	COMDAT ??_R0?AVShimmer@@@8
data$rs	SEGMENT
??_R0?AVShimmer@@@8 DQ FLAT:??_7type_info@@6B@		; Shimmer `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVShimmer@@', 00H
data$rs	ENDS
;	COMDAT ??_R2Shimmer@@8
rdata$r	SEGMENT
??_R2Shimmer@@8 DD imagerel ??_R1A@?0A@EA@Shimmer@@8	; Shimmer::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@AudioEffectX@@8
	DD	imagerel ??_R1A@?0A@EA@AudioEffect@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R4Modulation@@6B@
rdata$r	SEGMENT
??_R4Modulation@@6B@ DD 01H				; Modulation::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVModulation@@@8
	DD	imagerel ??_R3Modulation@@8
	DD	imagerel ??_R4Modulation@@6B@
rdata$r	ENDS
;	COMDAT ??_R4Shimmer@@6B@
rdata$r	SEGMENT
??_R4Shimmer@@6B@ DD 01H				; Shimmer::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVShimmer@@@8
	DD	imagerel ??_R3Shimmer@@8
	DD	imagerel ??_R4Shimmer@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@PSMVocoder@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@PSMVocoder@@8 DD imagerel ??_R0?AVPSMVocoder@@@8 ; PSMVocoder::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3PSMVocoder@@8
rdata$r	ENDS
;	COMDAT ??_R3ModDelay@@8
rdata$r	SEGMENT
??_R3ModDelay@@8 DD 00H					; ModDelay::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	imagerel ??_R2ModDelay@@8
rdata$r	ENDS
;	COMDAT ??_R4PSMVocoder@@6B@
rdata$r	SEGMENT
??_R4PSMVocoder@@6B@ DD 01H				; PSMVocoder::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVPSMVocoder@@@8
	DD	imagerel ??_R3PSMVocoder@@8
	DD	imagerel ??_R4PSMVocoder@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@IAudioSignalProcessor@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@IAudioSignalProcessor@@8 DD imagerel ??_R0?AVIAudioSignalProcessor@@@8 ; IAudioSignalProcessor::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3IAudioSignalProcessor@@8
rdata$r	ENDS
;	COMDAT ??_R3Shimmer@@8
rdata$r	SEGMENT
??_R3Shimmer@@8 DD 00H					; Shimmer::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2Shimmer@@8
rdata$r	ENDS
;	COMDAT ??_7IAudioSignalProcessor@@6B@
CONST	SEGMENT
??_7IAudioSignalProcessor@@6B@ DQ FLAT:??_R4IAudioSignalProcessor@@6B@ ; IAudioSignalProcessor::`vftable'
	DQ	FLAT:_purecall
	DQ	FLAT:_purecall
	DQ	FLAT:_purecall
	DQ	FLAT:?setSampleRate@IAudioSignalProcessor@@UEAAXN@Z
	DQ	FLAT:?enableAuxInput@IAudioSignalProcessor@@UEAAX_N@Z
	DQ	FLAT:?processAuxInputAudioSample@IAudioSignalProcessor@@UEAANN@Z
	DQ	FLAT:?processAudioFrame@IAudioSignalProcessor@@UEAA_NPEBMPEAMII@Z
CONST	ENDS
;	COMDAT ??_R0?AVModDelay@@@8
data$rs	SEGMENT
??_R0?AVModDelay@@@8 DQ FLAT:??_7type_info@@6B@		; ModDelay `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVModDelay@@', 00H
data$rs	ENDS
;	COMDAT ??_R3Modulation@@8
rdata$r	SEGMENT
??_R3Modulation@@8 DD 00H				; Modulation::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	imagerel ??_R2Modulation@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ModDelay@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ModDelay@@8 DD imagerel ??_R0?AVModDelay@@@8 ; ModDelay::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3ModDelay@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EJ@LPCombFilter@@8
rdata$r	SEGMENT
??_R1A@?0A@EJ@LPCombFilter@@8 DD imagerel ??_R0?AVLPCombFilter@@@8 ; LPCombFilter::`RTTI Base Class Descriptor at (0,-1,0,73)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	049H
	DD	imagerel ??_R3LPCombFilter@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Shimmer@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Shimmer@@8 DD imagerel ??_R0?AVShimmer@@@8 ; Shimmer::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3Shimmer@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EJ@CombFilter@@8
rdata$r	SEGMENT
??_R1A@?0A@EJ@CombFilter@@8 DD imagerel ??_R0?AVCombFilter@@@8 ; CombFilter::`RTTI Base Class Descriptor at (0,-1,0,73)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	049H
	DD	imagerel ??_R3CombFilter@@8
rdata$r	ENDS
;	COMDAT ??_R3IAudioSignalProcessor@@8
rdata$r	SEGMENT
??_R3IAudioSignalProcessor@@8 DD 00H			; IAudioSignalProcessor::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2IAudioSignalProcessor@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EJ@Delay@@8
rdata$r	SEGMENT
??_R1A@?0A@EJ@Delay@@8 DD imagerel ??_R0?AVDelay@@@8	; Delay::`RTTI Base Class Descriptor at (0,-1,0,73)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	049H
	DD	imagerel ??_R3Delay@@8
rdata$r	ENDS
;	COMDAT ??_R4IAudioSignalProcessor@@6B@
rdata$r	SEGMENT
??_R4IAudioSignalProcessor@@6B@ DD 01H			; IAudioSignalProcessor::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVIAudioSignalProcessor@@@8
	DD	imagerel ??_R3IAudioSignalProcessor@@8
	DD	imagerel ??_R4IAudioSignalProcessor@@6B@
rdata$r	ENDS
;	COMDAT ??_R3PSMVocoder@@8
rdata$r	SEGMENT
??_R3PSMVocoder@@8 DD 00H				; PSMVocoder::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2PSMVocoder@@8
rdata$r	ENDS
;	COMDAT ??_7Shimmer@@6B@
CONST	SEGMENT
??_7Shimmer@@6B@ DQ FLAT:??_R4Shimmer@@6B@		; Shimmer::`vftable'
	DQ	FLAT:??_EShimmer@@UEAAPEAXI@Z
	DQ	FLAT:?dispatcher@AudioEffectX@@UEAA_JHH_JPEAXM@Z
	DQ	FLAT:?open@AudioEffect@@UEAAXXZ
	DQ	FLAT:?close@AudioEffect@@UEAAXXZ
	DQ	FLAT:?suspend@AudioEffect@@UEAAXXZ
	DQ	FLAT:?resume@AudioEffectX@@UEAAXXZ
	DQ	FLAT:?setSampleRate@Shimmer@@UEAAXM@Z
	DQ	FLAT:?setBlockSize@AudioEffect@@UEAAXH@Z
	DQ	FLAT:?processReplacing@Shimmer@@UEAAXPEAPEAM0H@Z
	DQ	FLAT:?processDoubleReplacing@AudioEffect@@UEAAXPEAPEAN0H@Z
	DQ	FLAT:?setParameter@Shimmer@@UEAAXHM@Z
	DQ	FLAT:?getParameter@Shimmer@@UEAAMH@Z
	DQ	FLAT:?setParameterAutomated@AudioEffect@@UEAAXHM@Z
	DQ	FLAT:?getProgram@AudioEffect@@UEAAHXZ
	DQ	FLAT:?setProgram@Shimmer@@UEAAXH@Z
	DQ	FLAT:?setProgramName@AudioEffect@@UEAAXPEAD@Z
	DQ	FLAT:?getProgramName@Shimmer@@UEAAXPEAD@Z
	DQ	FLAT:?getParameterLabel@Shimmer@@UEAAXHPEAD@Z
	DQ	FLAT:?getParameterDisplay@Shimmer@@UEAAXHPEAD@Z
	DQ	FLAT:?getParameterName@Shimmer@@UEAAXHPEAD@Z
	DQ	FLAT:?getChunk@Shimmer@@UEAAHPEAPEAX_N@Z
	DQ	FLAT:?setChunk@Shimmer@@UEAAHPEAXH_N@Z
	DQ	FLAT:?setUniqueID@AudioEffect@@UEAAXH@Z
	DQ	FLAT:?setNumInputs@AudioEffect@@UEAAXH@Z
	DQ	FLAT:?setNumOutputs@AudioEffect@@UEAAXH@Z
	DQ	FLAT:?canProcessReplacing@AudioEffect@@UEAAX_N@Z
	DQ	FLAT:?canDoubleReplacing@AudioEffect@@UEAAX_N@Z
	DQ	FLAT:?programsAreChunks@AudioEffect@@UEAAX_N@Z
	DQ	FLAT:?setInitialDelay@AudioEffect@@UEAAXH@Z
	DQ	FLAT:?getEditor@AudioEffect@@UEAAPEAVAEffEditor@@XZ
	DQ	FLAT:?getAeffect@AudioEffect@@UEAAPEAUAEffect@@XZ
	DQ	FLAT:?getSampleRate@AudioEffect@@UEAAMXZ
	DQ	FLAT:?getBlockSize@AudioEffect@@UEAAHXZ
	DQ	FLAT:?getMasterVersion@AudioEffect@@UEAAHXZ
	DQ	FLAT:?getCurrentUniqueId@AudioEffect@@UEAAHXZ
	DQ	FLAT:?masterIdle@AudioEffect@@UEAAXXZ
	DQ	FLAT:?dB2string@AudioEffect@@UEAAXMPEADH@Z
	DQ	FLAT:?Hz2string@AudioEffect@@UEAAXMPEADH@Z
	DQ	FLAT:?ms2string@AudioEffect@@UEAAXMPEADH@Z
	DQ	FLAT:?float2string@AudioEffect@@UEAAXMPEADH@Z
	DQ	FLAT:?int2string@AudioEffect@@UEAAXHPEADH@Z
	DQ	FLAT:?__processDeprecated@AudioEffect@@UEAAXPEAPEAM0H@Z
	DQ	FLAT:?__getVuDeprecated@AudioEffect@@UEAAMXZ
	DQ	FLAT:?__hasVuDeprecated@AudioEffect@@UEAAX_N@Z
	DQ	FLAT:?__hasClipDeprecated@AudioEffect@@UEAAX_N@Z
	DQ	FLAT:?__canMonoDeprecated@AudioEffect@@UEAAX_N@Z
	DQ	FLAT:?__setRealtimeQualitiesDeprecated@AudioEffect@@UEAAXH@Z
	DQ	FLAT:?__setOfflineQualitiesDeprecated@AudioEffect@@UEAAXH@Z
	DQ	FLAT:?__isInputConnectedDeprecated@AudioEffect@@UEAA_NH@Z
	DQ	FLAT:?__isOutputConnectedDeprecated@AudioEffect@@UEAA_NH@Z
	DQ	FLAT:?canParameterBeAutomated@AudioEffectX@@UEAA_NH@Z
	DQ	FLAT:?string2parameter@AudioEffectX@@UEAA_NHPEAD@Z
	DQ	FLAT:?getParameterProperties@AudioEffectX@@UEAA_NHPEAUVstParameterProperties@@@Z
	DQ	FLAT:?beginEdit@AudioEffectX@@UEAA_NH@Z
	DQ	FLAT:?endEdit@AudioEffectX@@UEAA_NH@Z
	DQ	FLAT:?getProgramNameIndexed@Shimmer@@UEAA_NHHPEAD@Z
	DQ	FLAT:?beginSetProgram@AudioEffectX@@UEAA_NXZ
	DQ	FLAT:?endSetProgram@AudioEffectX@@UEAA_NXZ
	DQ	FLAT:?beginLoadBank@AudioEffectX@@UEAAHPEAUVstPatchChunkInfo@@@Z
	DQ	FLAT:?beginLoadProgram@AudioEffectX@@UEAAHPEAUVstPatchChunkInfo@@@Z
	DQ	FLAT:?ioChanged@AudioEffectX@@UEAA_NXZ
	DQ	FLAT:?updateSampleRate@AudioEffectX@@UEAANXZ
	DQ	FLAT:?updateBlockSize@AudioEffectX@@UEAAHXZ
	DQ	FLAT:?getInputLatency@AudioEffectX@@UEAAHXZ
	DQ	FLAT:?getOutputLatency@AudioEffectX@@UEAAHXZ
	DQ	FLAT:?getInputProperties@AudioEffectX@@UEAA_NHPEAUVstPinProperties@@@Z
	DQ	FLAT:?getOutputProperties@AudioEffectX@@UEAA_NHPEAUVstPinProperties@@@Z
	DQ	FLAT:?setSpeakerArrangement@AudioEffectX@@UEAA_NPEAUVstSpeakerArrangement@@0@Z
	DQ	FLAT:?getSpeakerArrangement@AudioEffectX@@UEAA_NPEAPEAUVstSpeakerArrangement@@0@Z
	DQ	FLAT:?setBypass@AudioEffectX@@UEAA_N_N@Z
	DQ	FLAT:?setPanLaw@AudioEffectX@@UEAA_NHM@Z
	DQ	FLAT:?setProcessPrecision@AudioEffectX@@UEAA_NH@Z
	DQ	FLAT:?getNumMidiInputChannels@AudioEffectX@@UEAAHXZ
	DQ	FLAT:?getNumMidiOutputChannels@AudioEffectX@@UEAAHXZ
	DQ	FLAT:?getTimeInfo@AudioEffectX@@UEAAPEAUVstTimeInfo@@H@Z
	DQ	FLAT:?getCurrentProcessLevel@AudioEffectX@@UEAAHXZ
	DQ	FLAT:?getAutomationState@AudioEffectX@@UEAAHXZ
	DQ	FLAT:?processEvents@AudioEffectX@@UEAAHPEAUVstEvents@@@Z
	DQ	FLAT:?startProcess@AudioEffectX@@UEAAHXZ
	DQ	FLAT:?stopProcess@AudioEffectX@@UEAAHXZ
	DQ	FLAT:?processVariableIo@AudioEffectX@@UEAA_NPEAUVstVariableIo@@@Z
	DQ	FLAT:?setTotalSampleToProcess@AudioEffectX@@UEAAHH@Z
	DQ	FLAT:?getHostVendorString@AudioEffectX@@UEAA_NPEAD@Z
	DQ	FLAT:?getHostProductString@AudioEffectX@@UEAA_NPEAD@Z
	DQ	FLAT:?getHostVendorVersion@AudioEffectX@@UEAAHXZ
	DQ	FLAT:?hostVendorSpecific@AudioEffectX@@UEAA_JH_JPEAXM@Z
	DQ	FLAT:?canHostDo@AudioEffectX@@UEAAHPEAD@Z
	DQ	FLAT:?getHostLanguage@AudioEffectX@@UEAAHXZ
	DQ	FLAT:?isSynth@AudioEffectX@@UEAAX_N@Z
	DQ	FLAT:?noTail@AudioEffectX@@UEAAX_N@Z
	DQ	FLAT:?getGetTailSize@AudioEffectX@@UEAAHXZ
	DQ	FLAT:?getDirectory@AudioEffectX@@UEAAPEAXXZ
	DQ	FLAT:?getEffectName@Shimmer@@UEAA_NPEAD@Z
	DQ	FLAT:?getVendorString@Shimmer@@UEAA_NPEAD@Z
	DQ	FLAT:?getProductString@AudioEffectX@@UEAA_NPEAD@Z
	DQ	FLAT:?getVendorVersion@AudioEffectX@@UEAAHXZ
	DQ	FLAT:?vendorSpecific@AudioEffectX@@UEAA_JH_JPEAXM@Z
	DQ	FLAT:?canDo@AudioEffectX@@UEAAHPEAD@Z
	DQ	FLAT:?getVstVersion@AudioEffectX@@UEAAHXZ
	DQ	FLAT:?getPlugCategory@AudioEffectX@@UEAA?AW4VstPlugCategory@@XZ
	DQ	FLAT:?getMidiProgramName@AudioEffectX@@UEAAHHPEAUMidiProgramName@@@Z
	DQ	FLAT:?getCurrentMidiProgram@AudioEffectX@@UEAAHHPEAUMidiProgramName@@@Z
	DQ	FLAT:?getMidiProgramCategory@AudioEffectX@@UEAAHHPEAUMidiProgramCategory@@@Z
	DQ	FLAT:?hasMidiProgramsChanged@AudioEffectX@@UEAA_NH@Z
	DQ	FLAT:?getMidiKeyName@AudioEffectX@@UEAA_NHPEAUMidiKeyName@@@Z
	DQ	FLAT:?updateDisplay@AudioEffectX@@UEAA_NXZ
	DQ	FLAT:?sizeWindow@AudioEffectX@@UEAA_NHH@Z
	DQ	FLAT:?openFileSelector@AudioEffectX@@UEAA_NPEAUVstFileSelect@@@Z
	DQ	FLAT:?closeFileSelector@AudioEffectX@@UEAA_NPEAUVstFileSelect@@@Z
	DQ	FLAT:?getNextShellPlugin@AudioEffectX@@UEAAHPEAD@Z
	DQ	FLAT:?allocateArrangement@AudioEffectX@@UEAA_NPEAPEAUVstSpeakerArrangement@@H@Z
	DQ	FLAT:?deallocateArrangement@AudioEffectX@@UEAA_NPEAPEAUVstSpeakerArrangement@@@Z
	DQ	FLAT:?copySpeaker@AudioEffectX@@UEAA_NPEAUVstSpeakerProperties@@0@Z
	DQ	FLAT:?matchArrangement@AudioEffectX@@UEAA_NPEAPEAUVstSpeakerArrangement@@PEAU2@@Z
	DQ	FLAT:?offlineRead@AudioEffectX@@UEAA_NPEAUVstOfflineTask@@W4VstOfflineOption@@_N@Z
	DQ	FLAT:?offlineWrite@AudioEffectX@@UEAA_NPEAUVstOfflineTask@@W4VstOfflineOption@@@Z
	DQ	FLAT:?offlineStart@AudioEffectX@@UEAA_NPEAUVstAudioFile@@HH@Z
	DQ	FLAT:?offlineGetCurrentPass@AudioEffectX@@UEAAHXZ
	DQ	FLAT:?offlineGetCurrentMetaPass@AudioEffectX@@UEAAHXZ
	DQ	FLAT:?offlineNotify@AudioEffectX@@UEAA_NPEAUVstAudioFile@@H_N@Z
	DQ	FLAT:?offlinePrepare@AudioEffectX@@UEAA_NPEAUVstOfflineTask@@H@Z
	DQ	FLAT:?offlineRun@AudioEffectX@@UEAA_NPEAUVstOfflineTask@@H@Z
	DQ	FLAT:?offlineGetNumPasses@AudioEffectX@@UEAAHXZ
	DQ	FLAT:?offlineGetNumMetaPasses@AudioEffectX@@UEAAHXZ
	DQ	FLAT:?__wantEventsDeprecated@AudioEffectX@@UEAAXH@Z
	DQ	FLAT:?__tempoAtDeprecated@AudioEffectX@@UEAAHH@Z
	DQ	FLAT:?__getNumAutomatableParametersDeprecated@AudioEffectX@@UEAAHXZ
	DQ	FLAT:?__getParameterQuantizationDeprecated@AudioEffectX@@UEAAHXZ
	DQ	FLAT:?__getNumCategoriesDeprecated@AudioEffectX@@UEAAHXZ
	DQ	FLAT:?__copyProgramDeprecated@AudioEffectX@@UEAA_NH@Z
	DQ	FLAT:?__needIdleDeprecated@AudioEffectX@@UEAA_NXZ
	DQ	FLAT:?__getPreviousPlugDeprecated@AudioEffectX@@UEAAPEAUAEffect@@H@Z
	DQ	FLAT:?__getNextPlugDeprecated@AudioEffectX@@UEAAPEAUAEffect@@H@Z
	DQ	FLAT:?__inputConnectedDeprecated@AudioEffectX@@UEAAXH_N@Z
	DQ	FLAT:?__outputConnectedDeprecated@AudioEffectX@@UEAAXH_N@Z
	DQ	FLAT:?__willProcessReplacingDeprecated@AudioEffectX@@UEAAHXZ
	DQ	FLAT:?__wantAsyncOperationDeprecated@AudioEffectX@@UEAAX_N@Z
	DQ	FLAT:?__hasExternalBufferDeprecated@AudioEffectX@@UEAAX_N@Z
	DQ	FLAT:?__reportCurrentPositionDeprecated@AudioEffectX@@UEAAHXZ
	DQ	FLAT:?__reportDestinationBufferDeprecated@AudioEffectX@@UEAAPEAMXZ
	DQ	FLAT:?__setOutputSamplerateDeprecated@AudioEffectX@@UEAAXM@Z
	DQ	FLAT:?__getInputSpeakerArrangementDeprecated@AudioEffectX@@UEAAPEAUVstSpeakerArrangement@@XZ
	DQ	FLAT:?__getOutputSpeakerArrangementDeprecated@AudioEffectX@@UEAAPEAUVstSpeakerArrangement@@XZ
	DQ	FLAT:?__openWindowDeprecated@AudioEffectX@@UEAAPEAXPEAU__VstWindowDeprecated@@@Z
	DQ	FLAT:?__closeWindowDeprecated@AudioEffectX@@UEAA_NPEAU__VstWindowDeprecated@@@Z
	DQ	FLAT:?__setBlockSizeAndSampleRateDeprecated@AudioEffectX@@UEAAXHM@Z
	DQ	FLAT:?__getErrorTextDeprecated@AudioEffectX@@UEAA_NPEAD@Z
	DQ	FLAT:?__getIconDeprecated@AudioEffectX@@UEAAPEAXXZ
	DQ	FLAT:?__setViewPositionDeprecated@AudioEffectX@@UEAA_NHH@Z
	DQ	FLAT:?__fxIdleDeprecated@AudioEffectX@@UEAAHXZ
	DQ	FLAT:?__keysRequiredDeprecated@AudioEffectX@@UEAA_NXZ
	DQ	FLAT:?__getChunkFileDeprecated@AudioEffectX@@UEAA_NPEAX@Z
CONST	ENDS
;	COMDAT ??_R0?AVPSMVocoder@@@8
data$rs	SEGMENT
??_R0?AVPSMVocoder@@@8 DQ FLAT:??_7type_info@@6B@	; PSMVocoder `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVPSMVocoder@@', 00H
data$rs	ENDS
;	COMDAT ??_C@_09KHHOPKD@Fox?5Suite@
CONST	SEGMENT
??_C@_09KHHOPKD@Fox?5Suite@ DB 'Fox Suite', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CJOOIIIC@Ambience?5Modulated@
CONST	SEGMENT
??_C@_0BD@CJOOIIIC@Ambience?5Modulated@ DB 'Ambience Modulated', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JIEKPJGJ@Ambience?5Damped@
CONST	SEGMENT
??_C@_0BA@JIEKPJGJ@Ambience?5Damped@ DB 'Ambience Damped', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04FKEBJNOD@Hall@
CONST	SEGMENT
??_C@_04FKEBJNOD@Hall@ DB 'Hall', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GEJFJLEL@Small?5Room@
CONST	SEGMENT
??_C@_0L@GEJFJLEL@Small?5Room@ DB 'Small Room', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07MCAEODGB@Default@
CONST	SEGMENT
??_C@_07MCAEODGB@Default@ DB 'Default', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03EKIEJGAC@HPF@
CONST	SEGMENT
??_C@_03EKIEJGAC@HPF@ DB 'HPF', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03MFOGABFF@LPF@
CONST	SEGMENT
??_C@_03MFOGABFF@LPF@ DB 'LPF', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09DPAPPDMJ@Mod?5Depth@
CONST	SEGMENT
??_C@_09DPAPPDMJ@Mod?5Depth@ DB 'Mod Depth', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08MNIOIDHF@Mod?5Rate@
CONST	SEGMENT
??_C@_08MNIOIDHF@Mod?5Rate@ DB 'Mod Rate', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09ONNCCMEP@Intervals@
CONST	SEGMENT
??_C@_09ONNCCMEP@Intervals@ DB 'Intervals', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05OMHELODH@Space@
CONST	SEGMENT
??_C@_05OMHELODH@Space@ DB 'Space', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07HJKIPEFI@Damping@
CONST	SEGMENT
??_C@_07HJKIPEFI@Damping@ DB 'Damping', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05BFFNNFFO@Decay@
CONST	SEGMENT
??_C@_05BFFNNFFO@Decay@ DB 'Decay', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07CNCNAGDO@Shimmer@
CONST	SEGMENT
??_C@_07CNCNAGDO@Shimmer@ DB 'Shimmer', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04EBKMHHBE@Size@
CONST	SEGMENT
??_C@_04EBKMHHBE@Size@ DB 'Size', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03BHCFKDFC@Mix@
CONST	SEGMENT
??_C@_03BHCFKDFC@Mix@ DB 'Mix', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KLOHGLOJ@Hz@
CONST	SEGMENT
??_C@_02KLOHGLOJ@Hz@ DB 'Hz', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01LKDEMHDF@s@
CONST	SEGMENT
??_C@_01LKDEMHDF@s@ DB 's', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_07FEMGBGFB@1?$CL2?5Oct@
CONST	SEGMENT
??_C@_07FEMGBGFB@1?$CL2?5Oct@ DB '1+2 Oct', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07EOOPKDLB@1?5Oct?$CL5@
CONST	SEGMENT
??_C@_07EOOPKDLB@1?5Oct?$CL5@ DB '1 Oct+5', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07JNPNFIPA@1st?5Oct@
CONST	SEGMENT
??_C@_07JNPNFIPA@1st?5Oct@ DB '1st Oct', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07JHONIOCD@7th?5Maj@
CONST	SEGMENT
??_C@_07JHONIOCD@7th?5Maj@ DB '7th Maj', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07FLEHIOLN@6th?5Maj@
CONST	SEGMENT
??_C@_07FLEHIOLN@6th?5Maj@ DB '6th Maj', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07PCKJDGJJ@5th?5Per@
CONST	SEGMENT
??_C@_07PCKJDGJJ@5th?5Per@ DB '5th Per', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07DOADDGAH@4th?5Per@
CONST	SEGMENT
??_C@_07DOADDGAH@4th?5Per@ DB '4th Per', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07HLFHFJI@3rd?5Maj@
CONST	SEGMENT
??_C@_07HLFHFJI@3rd?5Maj@ DB '3rd Maj', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07GNMKOBCE@3rd?5Min@
CONST	SEGMENT
??_C@_07GNMKOBCE@3rd?5Min@ DB '3rd Min', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07GLGBIDLM@2nd?5Maj@
CONST	SEGMENT
??_C@_07GLGBIDLM@2nd?5Maj@ DB '2nd Maj', 00H		; `string'
CONST	ENDS
;	COMDAT ??_R2Modulation@@8
rdata$r	SEGMENT
??_R2Modulation@@8 DD imagerel ??_R1A@?0A@EA@Modulation@@8 ; Modulation::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EN@ModDelay@@8
	DD	imagerel ??_R1A@?0A@EJ@LPCombFilter@@8
	DD	imagerel ??_R1A@?0A@EJ@CombFilter@@8
	DD	imagerel ??_R1A@?0A@EJ@Delay@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R4ModDelay@@6B@
rdata$r	SEGMENT
??_R4ModDelay@@6B@ DD 01H				; ModDelay::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVModDelay@@@8
	DD	imagerel ??_R3ModDelay@@8
	DD	imagerel ??_R4ModDelay@@6B@
rdata$r	ENDS
;	COMDAT ??_R0?AVModulation@@@8
data$rs	SEGMENT
??_R0?AVModulation@@@8 DQ FLAT:??_7type_info@@6B@	; Modulation `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVModulation@@', 00H
data$rs	ENDS
;	COMDAT ??_R2IAudioSignalProcessor@@8
rdata$r	SEGMENT
??_R2IAudioSignalProcessor@@8 DD imagerel ??_R1A@?0A@EA@IAudioSignalProcessor@@8 ; IAudioSignalProcessor::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_7PSMVocoder@@6B@
CONST	SEGMENT
??_7PSMVocoder@@6B@ DQ FLAT:??_R4PSMVocoder@@6B@	; PSMVocoder::`vftable'
	DQ	FLAT:?reset@PSMVocoder@@UEAA_NN@Z
	DQ	FLAT:?processAudioSample@PSMVocoder@@UEAANN@Z
	DQ	FLAT:?canProcessAudioFrame@PSMVocoder@@UEAA_NXZ
	DQ	FLAT:?setSampleRate@IAudioSignalProcessor@@UEAAXN@Z
	DQ	FLAT:?enableAuxInput@IAudioSignalProcessor@@UEAAX_N@Z
	DQ	FLAT:?processAuxInputAudioSample@IAudioSignalProcessor@@UEAANN@Z
	DQ	FLAT:?processAudioFrame@IAudioSignalProcessor@@UEAA_NPEBMPEAMII@Z
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
	ORG $+4
?INTERVALS_IN_SEMITONES_PITCH2@@3QBMB DD 000000000r ; 0	; INTERVALS_IN_SEMITONES_PITCH2
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	041980000r			; 19
	DD	041c00000r			; 24
?INTERVALS_NAMES_STRING@@3PAPEADA DQ FLAT:??_C@_07GLGBIDLM@2nd?5Maj@ ; INTERVALS_NAMES_STRING
	DQ	FLAT:??_C@_07GNMKOBCE@3rd?5Min@
	DQ	FLAT:??_C@_07HLFHFJI@3rd?5Maj@
	DQ	FLAT:??_C@_07DOADDGAH@4th?5Per@
	DQ	FLAT:??_C@_07PCKJDGJJ@5th?5Per@
	DQ	FLAT:??_C@_07FLEHIOLN@6th?5Maj@
	DQ	FLAT:??_C@_07JHONIOCD@7th?5Maj@
	DQ	FLAT:??_C@_07JNPNFIPA@1st?5Oct@
	DQ	FLAT:??_C@_07EOOPKDLB@1?5Oct?$CL5@
	DQ	FLAT:??_C@_07FEMGBGFB@1?$CL2?5Oct@
?INTERVALS_IN_SEMITONES_PITCH1@@3QBMB DD 040000000r ; 2	; INTERVALS_IN_SEMITONES_PITCH1
	DD	040400000r			; 3
	DD	040800000r			; 4
	DD	040a00000r			; 5
	DD	040e00000r			; 7
	DD	041100000r			; 9
	DD	041300000r			; 11
	DD	041400000r			; 12
	DD	041400000r			; 12
	DD	041400000r			; 12
PUBLIC	??$construct@M$$V@?$_Default_allocator_traits@V?$allocator@M@std@@@std@@SAXAEAV?$allocator@M@1@QEAM@Z ; std::_Default_allocator_traits<std::allocator<float> >::construct<float>
PUBLIC	??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@M@std@@@std@@QEAAXXZ ; std::_Uninitialized_backout_al<std::allocator<float> >::_Emplace_back<>
PUBLIC	??$_Zero_range@PEAM@std@@YAPEAMQEAM0@Z		; std::_Zero_range<float *>
PUBLIC	??$_Emplace_back@PEAVDelay@@@?$_Uninitialized_backout_al@V?$allocator@PEAVDelay@@@std@@@std@@QEAAX$$QEAPEAVDelay@@@Z ; std::_Uninitialized_backout_al<std::allocator<Delay *> >::_Emplace_back<Delay *>
PUBLIC	??$_To_address@PEAPEAVDelay@@@std@@YA?A_PAEBQEAPEAVDelay@@@Z ; std::_To_address<Delay * *>
PUBLIC	??$_Copy_memmove@PEAPEAVDelay@@PEAPEAV1@@std@@YAPEAPEAVDelay@@PEAPEAV1@00@Z ; std::_Copy_memmove<Delay * *,Delay * *>
PUBLIC	??$_Emplace_back@H@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QEAAX$$QEAH@Z ; std::_Uninitialized_backout_al<std::allocator<int> >::_Emplace_back<int>
PUBLIC	??$_To_address@PEAH@std@@YA?A_PAEBQEAH@Z	; std::_To_address<int *>
PUBLIC	??$_Copy_memmove@PEAHPEAH@std@@YAPEAHPEAH00@Z	; std::_Copy_memmove<int *,int *>
PUBLIC	??$_Emplace_back@PEAVModDelay@@@?$_Uninitialized_backout_al@V?$allocator@PEAVModDelay@@@std@@@std@@QEAAX$$QEAPEAVModDelay@@@Z ; std::_Uninitialized_backout_al<std::allocator<ModDelay *> >::_Emplace_back<ModDelay *>
PUBLIC	??$_To_address@PEAPEAVModDelay@@@std@@YA?A_PAEBQEAPEAVModDelay@@@Z ; std::_To_address<ModDelay * *>
PUBLIC	??$_Copy_memmove@PEAPEAVModDelay@@PEAPEAV1@@std@@YAPEAPEAVModDelay@@PEAPEAV1@00@Z ; std::_Copy_memmove<ModDelay * *,ModDelay * *>
PUBLIC	??$_Emplace_back@PEAVMultiChannelDiffuser@@@?$_Uninitialized_backout_al@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEAAX$$QEAPEAVMultiChannelDiffuser@@@Z ; std::_Uninitialized_backout_al<std::allocator<MultiChannelDiffuser *> >::_Emplace_back<MultiChannelDiffuser *>
PUBLIC	??$_To_address@PEAPEAVMultiChannelDiffuser@@@std@@YA?A_PAEBQEAPEAVMultiChannelDiffuser@@@Z ; std::_To_address<MultiChannelDiffuser * *>
PUBLIC	??$_Copy_memmove@PEAPEAVMultiChannelDiffuser@@PEAPEAV1@@std@@YAPEAPEAVMultiChannelDiffuser@@PEAPEAV1@00@Z ; std::_Copy_memmove<MultiChannelDiffuser * *,MultiChannelDiffuser * *>
PUBLIC	??$_Emplace_back@PEAVModMultiChannelDiffuser@@@?$_Uninitialized_backout_al@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEAAX$$QEAPEAVModMultiChannelDiffuser@@@Z ; std::_Uninitialized_backout_al<std::allocator<ModMultiChannelDiffuser *> >::_Emplace_back<ModMultiChannelDiffuser *>
PUBLIC	??$_To_address@PEAPEAVModMultiChannelDiffuser@@@std@@YA?A_PAEBQEAPEAVModMultiChannelDiffuser@@@Z ; std::_To_address<ModMultiChannelDiffuser * *>
PUBLIC	??$_Copy_memmove@PEAPEAVModMultiChannelDiffuser@@PEAPEAV1@@std@@YAPEAPEAVModMultiChannelDiffuser@@PEAPEAV1@00@Z ; std::_Copy_memmove<ModMultiChannelDiffuser * *,ModMultiChannelDiffuser * *>
PUBLIC	??$_Emplace_back@PEAVLowPassFilter@@@?$_Uninitialized_backout_al@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEAAX$$QEAPEAVLowPassFilter@@@Z ; std::_Uninitialized_backout_al<std::allocator<LowPassFilter *> >::_Emplace_back<LowPassFilter *>
PUBLIC	??$_To_address@PEAPEAVLowPassFilter@@@std@@YA?A_PAEBQEAPEAVLowPassFilter@@@Z ; std::_To_address<LowPassFilter * *>
PUBLIC	??$_Copy_memmove@PEAPEAVLowPassFilter@@PEAPEAV1@@std@@YAPEAPEAVLowPassFilter@@PEAPEAV1@00@Z ; std::_Copy_memmove<LowPassFilter * *,LowPassFilter * *>
PUBLIC	??$_Emplace_back@PEAVModulation@@@?$_Uninitialized_backout_al@V?$allocator@PEAVModulation@@@std@@@std@@QEAAX$$QEAPEAVModulation@@@Z ; std::_Uninitialized_backout_al<std::allocator<Modulation *> >::_Emplace_back<Modulation *>
PUBLIC	??$_To_address@PEAPEAVModulation@@@std@@YA?A_PAEBQEAPEAVModulation@@@Z ; std::_To_address<Modulation * *>
PUBLIC	??$_Copy_memmove@PEAPEAVModulation@@PEAPEAV1@@std@@YAPEAPEAVModulation@@PEAPEAV1@00@Z ; std::_Copy_memmove<Modulation * *,Modulation * *>
PUBLIC	??$_Emplace_back@PEAVHighPassFilter@@@?$_Uninitialized_backout_al@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEAAX$$QEAPEAVHighPassFilter@@@Z ; std::_Uninitialized_backout_al<std::allocator<HighPassFilter *> >::_Emplace_back<HighPassFilter *>
PUBLIC	??$_To_address@PEAPEAVHighPassFilter@@@std@@YA?A_PAEBQEAPEAVHighPassFilter@@@Z ; std::_To_address<HighPassFilter * *>
PUBLIC	??$_Copy_memmove@PEAPEAVHighPassFilter@@PEAPEAV1@@std@@YAPEAPEAVHighPassFilter@@PEAPEAV1@00@Z ; std::_Copy_memmove<HighPassFilter * *,HighPassFilter * *>
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEAA@PEAPEAVHighPassFilter@@AEAV?$allocator@PEAVHighPassFilter@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<HighPassFilter *> >::_Uninitialized_backout_al<std::allocator<HighPassFilter *> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<HighPassFilter *> >::~_Uninitialized_backout_al<std::allocator<HighPassFilter *> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEAAPEAPEAVHighPassFilter@@XZ ; std::_Uninitialized_backout_al<std::allocator<HighPassFilter *> >::_Release
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@PEAVModulation@@@std@@@std@@QEAA@PEAPEAVModulation@@AEAV?$allocator@PEAVModulation@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<Modulation *> >::_Uninitialized_backout_al<std::allocator<Modulation *> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@PEAVModulation@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<Modulation *> >::~_Uninitialized_backout_al<std::allocator<Modulation *> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@PEAVModulation@@@std@@@std@@QEAAPEAPEAVModulation@@XZ ; std::_Uninitialized_backout_al<std::allocator<Modulation *> >::_Release
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEAA@PEAPEAVLowPassFilter@@AEAV?$allocator@PEAVLowPassFilter@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<LowPassFilter *> >::_Uninitialized_backout_al<std::allocator<LowPassFilter *> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<LowPassFilter *> >::~_Uninitialized_backout_al<std::allocator<LowPassFilter *> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEAAPEAPEAVLowPassFilter@@XZ ; std::_Uninitialized_backout_al<std::allocator<LowPassFilter *> >::_Release
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEAA@PEAPEAVModMultiChannelDiffuser@@AEAV?$allocator@PEAVModMultiChannelDiffuser@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<ModMultiChannelDiffuser *> >::_Uninitialized_backout_al<std::allocator<ModMultiChannelDiffuser *> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<ModMultiChannelDiffuser *> >::~_Uninitialized_backout_al<std::allocator<ModMultiChannelDiffuser *> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEAAPEAPEAVModMultiChannelDiffuser@@XZ ; std::_Uninitialized_backout_al<std::allocator<ModMultiChannelDiffuser *> >::_Release
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEAA@PEAPEAVMultiChannelDiffuser@@AEAV?$allocator@PEAVMultiChannelDiffuser@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<MultiChannelDiffuser *> >::_Uninitialized_backout_al<std::allocator<MultiChannelDiffuser *> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<MultiChannelDiffuser *> >::~_Uninitialized_backout_al<std::allocator<MultiChannelDiffuser *> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEAAPEAPEAVMultiChannelDiffuser@@XZ ; std::_Uninitialized_backout_al<std::allocator<MultiChannelDiffuser *> >::_Release
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@PEAVModDelay@@@std@@@std@@QEAA@PEAPEAVModDelay@@AEAV?$allocator@PEAVModDelay@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<ModDelay *> >::_Uninitialized_backout_al<std::allocator<ModDelay *> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@PEAVModDelay@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<ModDelay *> >::~_Uninitialized_backout_al<std::allocator<ModDelay *> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@PEAVModDelay@@@std@@@std@@QEAAPEAPEAVModDelay@@XZ ; std::_Uninitialized_backout_al<std::allocator<ModDelay *> >::_Release
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QEAA@PEAHAEAV?$allocator@H@1@@Z ; std::_Uninitialized_backout_al<std::allocator<int> >::_Uninitialized_backout_al<std::allocator<int> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<int> >::~_Uninitialized_backout_al<std::allocator<int> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QEAAPEAHXZ ; std::_Uninitialized_backout_al<std::allocator<int> >::_Release
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@PEAVDelay@@@std@@@std@@QEAA@PEAPEAVDelay@@AEAV?$allocator@PEAVDelay@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<Delay *> >::_Uninitialized_backout_al<std::allocator<Delay *> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@PEAVDelay@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<Delay *> >::~_Uninitialized_backout_al<std::allocator<Delay *> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@PEAVDelay@@@std@@@std@@QEAAPEAPEAVDelay@@XZ ; std::_Uninitialized_backout_al<std::allocator<Delay *> >::_Release
PUBLIC	??$_Uninitialized_value_construct_n@V?$allocator@M@std@@@std@@YAPEAMPEAM_KAEAV?$allocator@M@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<float> >
PUBLIC	??$_Get_unwrapped@AEBQEAPEAVDelay@@@std@@YA?A_TAEBQEAPEAVDelay@@@Z ; std::_Get_unwrapped<Delay * * const &>
PUBLIC	??$_Uninitialized_move@PEAPEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@YAPEAPEAVDelay@@QEAPEAV1@0PEAPEAV1@AEAV?$allocator@PEAVDelay@@@0@@Z ; std::_Uninitialized_move<Delay * *,std::allocator<Delay *> >
PUBLIC	??$_Get_unwrapped@AEBQEAH@std@@YA?A_TAEBQEAH@Z	; std::_Get_unwrapped<int * const &>
PUBLIC	??$_Uninitialized_move@PEAHV?$allocator@H@std@@@std@@YAPEAHQEAH0PEAHAEAV?$allocator@H@0@@Z ; std::_Uninitialized_move<int *,std::allocator<int> >
PUBLIC	??$_Get_unwrapped@AEBQEAPEAVModDelay@@@std@@YA?A_TAEBQEAPEAVModDelay@@@Z ; std::_Get_unwrapped<ModDelay * * const &>
PUBLIC	??$_Uninitialized_move@PEAPEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@YAPEAPEAVModDelay@@QEAPEAV1@0PEAPEAV1@AEAV?$allocator@PEAVModDelay@@@0@@Z ; std::_Uninitialized_move<ModDelay * *,std::allocator<ModDelay *> >
PUBLIC	??$_Get_unwrapped@AEBQEAPEAVMultiChannelDiffuser@@@std@@YA?A_TAEBQEAPEAVMultiChannelDiffuser@@@Z ; std::_Get_unwrapped<MultiChannelDiffuser * * const &>
PUBLIC	??$_Uninitialized_move@PEAPEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@YAPEAPEAVMultiChannelDiffuser@@QEAPEAV1@0PEAPEAV1@AEAV?$allocator@PEAVMultiChannelDiffuser@@@0@@Z ; std::_Uninitialized_move<MultiChannelDiffuser * *,std::allocator<MultiChannelDiffuser *> >
PUBLIC	??$_Get_unwrapped@AEBQEAPEAVModMultiChannelDiffuser@@@std@@YA?A_TAEBQEAPEAVModMultiChannelDiffuser@@@Z ; std::_Get_unwrapped<ModMultiChannelDiffuser * * const &>
PUBLIC	??$_Uninitialized_move@PEAPEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@YAPEAPEAVModMultiChannelDiffuser@@QEAPEAV1@0PEAPEAV1@AEAV?$allocator@PEAVModMultiChannelDiffuser@@@0@@Z ; std::_Uninitialized_move<ModMultiChannelDiffuser * *,std::allocator<ModMultiChannelDiffuser *> >
PUBLIC	??$_Get_unwrapped@AEBQEAPEAVLowPassFilter@@@std@@YA?A_TAEBQEAPEAVLowPassFilter@@@Z ; std::_Get_unwrapped<LowPassFilter * * const &>
PUBLIC	??$_Uninitialized_move@PEAPEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@YAPEAPEAVLowPassFilter@@QEAPEAV1@0PEAPEAV1@AEAV?$allocator@PEAVLowPassFilter@@@0@@Z ; std::_Uninitialized_move<LowPassFilter * *,std::allocator<LowPassFilter *> >
PUBLIC	??$_Get_unwrapped@AEBQEAPEAVModulation@@@std@@YA?A_TAEBQEAPEAVModulation@@@Z ; std::_Get_unwrapped<Modulation * * const &>
PUBLIC	??$_Uninitialized_move@PEAPEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@YAPEAPEAVModulation@@QEAPEAV1@0PEAPEAV1@AEAV?$allocator@PEAVModulation@@@0@@Z ; std::_Uninitialized_move<Modulation * *,std::allocator<Modulation *> >
PUBLIC	??$_Get_size_of_n@$07@std@@YA_K_K@Z		; std::_Get_size_of_n<8>
PUBLIC	??$_Get_unwrapped@AEBQEAPEAVHighPassFilter@@@std@@YA?A_TAEBQEAPEAVHighPassFilter@@@Z ; std::_Get_unwrapped<HighPassFilter * * const &>
PUBLIC	??$_Uninitialized_move@PEAPEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@YAPEAPEAVHighPassFilter@@QEAPEAV1@0PEAPEAV1@AEAV?$allocator@PEAVHighPassFilter@@@0@@Z ; std::_Uninitialized_move<HighPassFilter * *,std::allocator<HighPassFilter *> >
PUBLIC	??$forward@AEBV?$allocator@M@std@@@std@@YAAEBV?$allocator@M@0@AEBV10@@Z ; std::forward<std::allocator<float> const &>
PUBLIC	??$forward@PEAM@std@@YA$$QEAPEAMAEAPEAM@Z	; std::forward<float *>
PUBLIC	??$forward@V?$allocator@M@std@@@std@@YA$$QEAV?$allocator@M@0@AEAV10@@Z ; std::forward<std::allocator<float> >
PUBLIC	??$_Voidify_iter@PEAPEAVDelay@@@std@@YAPEAXPEAPEAVDelay@@@Z ; std::_Voidify_iter<Delay * *>
PUBLIC	??$_Voidify_iter@PEAH@std@@YAPEAXPEAH@Z		; std::_Voidify_iter<int *>
PUBLIC	??$_Voidify_iter@PEAPEAVModDelay@@@std@@YAPEAXPEAPEAVModDelay@@@Z ; std::_Voidify_iter<ModDelay * *>
PUBLIC	??$_Voidify_iter@PEAPEAVMultiChannelDiffuser@@@std@@YAPEAXPEAPEAVMultiChannelDiffuser@@@Z ; std::_Voidify_iter<MultiChannelDiffuser * *>
PUBLIC	??$_Voidify_iter@PEAPEAVModMultiChannelDiffuser@@@std@@YAPEAXPEAPEAVModMultiChannelDiffuser@@@Z ; std::_Voidify_iter<ModMultiChannelDiffuser * *>
PUBLIC	??$_Voidify_iter@PEAPEAVLowPassFilter@@@std@@YAPEAXPEAPEAVLowPassFilter@@@Z ; std::_Voidify_iter<LowPassFilter * *>
PUBLIC	??$_Voidify_iter@PEAPEAVModulation@@@std@@YAPEAXPEAPEAVModulation@@@Z ; std::_Voidify_iter<Modulation * *>
PUBLIC	??$_Voidify_iter@PEAPEAVHighPassFilter@@@std@@YAPEAXPEAPEAVHighPassFilter@@@Z ; std::_Voidify_iter<HighPassFilter * *>
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@PEAVDelay@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVDelay@@@std@@@2@$00@std@@QEBAAEBV?$allocator@PEAVDelay@@@2@XZ ; std::_Compressed_pair<std::allocator<Delay *>,std::_Vector_val<std::_Simple_types<Delay *> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QEBAAEBV?$allocator@H@2@XZ ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@PEAVModDelay@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVModDelay@@@std@@@2@$00@std@@QEBAAEBV?$allocator@PEAVModDelay@@@2@XZ ; std::_Compressed_pair<std::allocator<ModDelay *>,std::_Vector_val<std::_Simple_types<ModDelay *> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@PEAVMultiChannelDiffuser@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVMultiChannelDiffuser@@@std@@@2@$00@std@@QEBAAEBV?$allocator@PEAVMultiChannelDiffuser@@@2@XZ ; std::_Compressed_pair<std::allocator<MultiChannelDiffuser *>,std::_Vector_val<std::_Simple_types<MultiChannelDiffuser *> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVModMultiChannelDiffuser@@@std@@@2@$00@std@@QEBAAEBV?$allocator@PEAVModMultiChannelDiffuser@@@2@XZ ; std::_Compressed_pair<std::allocator<ModMultiChannelDiffuser *>,std::_Vector_val<std::_Simple_types<ModMultiChannelDiffuser *> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@PEAVLowPassFilter@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVLowPassFilter@@@std@@@2@$00@std@@QEBAAEBV?$allocator@PEAVLowPassFilter@@@2@XZ ; std::_Compressed_pair<std::allocator<LowPassFilter *>,std::_Vector_val<std::_Simple_types<LowPassFilter *> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@PEAVModulation@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVModulation@@@std@@@2@$00@std@@QEBAAEBV?$allocator@PEAVModulation@@@2@XZ ; std::_Compressed_pair<std::allocator<Modulation *>,std::_Vector_val<std::_Simple_types<Modulation *> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@PEAVHighPassFilter@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVHighPassFilter@@@std@@@2@$00@std@@QEBAAEBV?$allocator@PEAVHighPassFilter@@@2@XZ ; std::_Compressed_pair<std::allocator<HighPassFilter *>,std::_Vector_val<std::_Simple_types<HighPassFilter *> >,1>::_Get_first
PUBLIC	?_Buy_raw@?$vector@MV?$allocator@M@std@@@std@@AEAAX_K@Z ; std::vector<float,std::allocator<float> >::_Buy_raw
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@PEAVDelay@@@std@@@std@@SA_KAEBV?$allocator@PEAVDelay@@@2@@Z ; std::_Default_allocator_traits<std::allocator<Delay *> >::max_size
PUBLIC	?capacity@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@QEBA_KXZ ; std::vector<Delay *,std::allocator<Delay *> >::capacity
PUBLIC	?_Umove_if_noexcept1@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@AEAAXPEAPEAVDelay@@00U?$integral_constant@_N$00@2@@Z ; std::vector<Delay *,std::allocator<Delay *> >::_Umove_if_noexcept1
PUBLIC	?_Getal@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@AEBAAEBV?$allocator@PEAVDelay@@@2@XZ ; std::vector<Delay *,std::allocator<Delay *> >::_Getal
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SA_KAEBV?$allocator@H@2@@Z ; std::_Default_allocator_traits<std::allocator<int> >::max_size
PUBLIC	?capacity@?$vector@HV?$allocator@H@std@@@std@@QEBA_KXZ ; std::vector<int,std::allocator<int> >::capacity
PUBLIC	?_Umove_if_noexcept1@?$vector@HV?$allocator@H@std@@@std@@AEAAXPEAH00U?$integral_constant@_N$00@2@@Z ; std::vector<int,std::allocator<int> >::_Umove_if_noexcept1
PUBLIC	?_Getal@?$vector@HV?$allocator@H@std@@@std@@AEBAAEBV?$allocator@H@2@XZ ; std::vector<int,std::allocator<int> >::_Getal
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@PEAVModDelay@@@std@@@std@@SA_KAEBV?$allocator@PEAVModDelay@@@2@@Z ; std::_Default_allocator_traits<std::allocator<ModDelay *> >::max_size
PUBLIC	?capacity@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEBA_KXZ ; std::vector<ModDelay *,std::allocator<ModDelay *> >::capacity
PUBLIC	?_Umove_if_noexcept1@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@AEAAXPEAPEAVModDelay@@00U?$integral_constant@_N$00@2@@Z ; std::vector<ModDelay *,std::allocator<ModDelay *> >::_Umove_if_noexcept1
PUBLIC	?_Getal@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@AEBAAEBV?$allocator@PEAVModDelay@@@2@XZ ; std::vector<ModDelay *,std::allocator<ModDelay *> >::_Getal
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@SA_KAEBV?$allocator@PEAVMultiChannelDiffuser@@@2@@Z ; std::_Default_allocator_traits<std::allocator<MultiChannelDiffuser *> >::max_size
PUBLIC	?capacity@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEBA_KXZ ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::capacity
PUBLIC	?_Umove_if_noexcept1@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@AEAAXPEAPEAVMultiChannelDiffuser@@00U?$integral_constant@_N$00@2@@Z ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::_Umove_if_noexcept1
PUBLIC	?_Getal@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@AEBAAEBV?$allocator@PEAVMultiChannelDiffuser@@@2@XZ ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::_Getal
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@SA_KAEBV?$allocator@PEAVModMultiChannelDiffuser@@@2@@Z ; std::_Default_allocator_traits<std::allocator<ModMultiChannelDiffuser *> >::max_size
PUBLIC	?capacity@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEBA_KXZ ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::capacity
PUBLIC	?_Umove_if_noexcept1@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@AEAAXPEAPEAVModMultiChannelDiffuser@@00U?$integral_constant@_N$00@2@@Z ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::_Umove_if_noexcept1
PUBLIC	?_Getal@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@AEBAAEBV?$allocator@PEAVModMultiChannelDiffuser@@@2@XZ ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::_Getal
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@PEAVLowPassFilter@@@std@@@std@@SA_KAEBV?$allocator@PEAVLowPassFilter@@@2@@Z ; std::_Default_allocator_traits<std::allocator<LowPassFilter *> >::max_size
PUBLIC	?capacity@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEBA_KXZ ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::capacity
PUBLIC	?_Umove_if_noexcept1@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@AEAAXPEAPEAVLowPassFilter@@00U?$integral_constant@_N$00@2@@Z ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::_Umove_if_noexcept1
PUBLIC	?_Getal@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@AEBAAEBV?$allocator@PEAVLowPassFilter@@@2@XZ ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::_Getal
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@PEAVModulation@@@std@@@std@@SA_KAEBV?$allocator@PEAVModulation@@@2@@Z ; std::_Default_allocator_traits<std::allocator<Modulation *> >::max_size
PUBLIC	?capacity@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@QEBA_KXZ ; std::vector<Modulation *,std::allocator<Modulation *> >::capacity
PUBLIC	?_Umove_if_noexcept1@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@AEAAXPEAPEAVModulation@@00U?$integral_constant@_N$00@2@@Z ; std::vector<Modulation *,std::allocator<Modulation *> >::_Umove_if_noexcept1
PUBLIC	?_Getal@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@AEBAAEBV?$allocator@PEAVModulation@@@2@XZ ; std::vector<Modulation *,std::allocator<Modulation *> >::_Getal
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@PEAVHighPassFilter@@@std@@@std@@SA_KAEBV?$allocator@PEAVHighPassFilter@@@2@@Z ; std::_Default_allocator_traits<std::allocator<HighPassFilter *> >::max_size
PUBLIC	?capacity@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEBA_KXZ ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::capacity
PUBLIC	?_Umove_if_noexcept1@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@AEAAXPEAPEAVHighPassFilter@@00U?$integral_constant@_N$00@2@@Z ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::_Umove_if_noexcept1
PUBLIC	?_Getal@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@AEBAAEBV?$allocator@PEAVHighPassFilter@@@2@XZ ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::_Getal
PUBLIC	?_Ufill@?$vector@MV?$allocator@M@std@@@std@@AEAAPEAMPEAM_KU_Value_init_tag@2@@Z ; std::vector<float,std::allocator<float> >::_Ufill
PUBLIC	?_Buy_nonzero@?$vector@MV?$allocator@M@std@@@std@@AEAAX_K@Z ; std::vector<float,std::allocator<float> >::_Buy_nonzero
PUBLIC	??0?$_Vector_val@U?$_Simple_types@M@std@@@std@@QEAA@PEAM00@Z ; std::_Vector_val<std::_Simple_types<float> >::_Vector_val<std::_Simple_types<float> >
PUBLIC	??0?$allocator@PEAVDelay@@@std@@QEAA@XZ		; std::allocator<Delay *>::allocator<Delay *>
PUBLIC	?allocate@?$allocator@PEAVDelay@@@std@@QEAAPEAPEAVDelay@@_K@Z ; std::allocator<Delay *>::allocate
PUBLIC	?max_size@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@QEBA_KXZ ; std::vector<Delay *,std::allocator<Delay *> >::max_size
PUBLIC	?_Umove@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@AEAAPEAPEAVDelay@@PEAPEAV3@00@Z ; std::vector<Delay *,std::allocator<Delay *> >::_Umove
PUBLIC	?_Umove_if_noexcept@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@AEAAXPEAPEAVDelay@@00@Z ; std::vector<Delay *,std::allocator<Delay *> >::_Umove_if_noexcept
PUBLIC	?_Calculate_growth@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@AEBA_K_K@Z ; std::vector<Delay *,std::allocator<Delay *> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@AEAAXQEAPEAVDelay@@_K1@Z ; std::vector<Delay *,std::allocator<Delay *> >::_Change_array
PUBLIC	?_Xlength@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@CAXXZ ; std::vector<Delay *,std::allocator<Delay *> >::_Xlength
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PEAVDelay@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<Delay *> >::_Vector_val<std::_Simple_types<Delay *> >
PUBLIC	??0?$allocator@H@std@@QEAA@XZ			; std::allocator<int>::allocator<int>
PUBLIC	?allocate@?$allocator@H@std@@QEAAPEAH_K@Z	; std::allocator<int>::allocate
PUBLIC	?max_size@?$vector@HV?$allocator@H@std@@@std@@QEBA_KXZ ; std::vector<int,std::allocator<int> >::max_size
PUBLIC	?_Umove@?$vector@HV?$allocator@H@std@@@std@@AEAAPEAHPEAH00@Z ; std::vector<int,std::allocator<int> >::_Umove
PUBLIC	?_Umove_if_noexcept@?$vector@HV?$allocator@H@std@@@std@@AEAAXPEAH00@Z ; std::vector<int,std::allocator<int> >::_Umove_if_noexcept
PUBLIC	?_Calculate_growth@?$vector@HV?$allocator@H@std@@@std@@AEBA_K_K@Z ; std::vector<int,std::allocator<int> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@HV?$allocator@H@std@@@std@@AEAAXQEAH_K1@Z ; std::vector<int,std::allocator<int> >::_Change_array
PUBLIC	?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ ; std::vector<int,std::allocator<int> >::_Xlength
PUBLIC	??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<int> >::_Vector_val<std::_Simple_types<int> >
PUBLIC	??0?$allocator@PEAVModDelay@@@std@@QEAA@XZ	; std::allocator<ModDelay *>::allocator<ModDelay *>
PUBLIC	?allocate@?$allocator@PEAVModDelay@@@std@@QEAAPEAPEAVModDelay@@_K@Z ; std::allocator<ModDelay *>::allocate
PUBLIC	?max_size@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEBA_KXZ ; std::vector<ModDelay *,std::allocator<ModDelay *> >::max_size
PUBLIC	?_Umove@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@AEAAPEAPEAVModDelay@@PEAPEAV3@00@Z ; std::vector<ModDelay *,std::allocator<ModDelay *> >::_Umove
PUBLIC	?_Umove_if_noexcept@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@AEAAXPEAPEAVModDelay@@00@Z ; std::vector<ModDelay *,std::allocator<ModDelay *> >::_Umove_if_noexcept
PUBLIC	?_Calculate_growth@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@AEBA_K_K@Z ; std::vector<ModDelay *,std::allocator<ModDelay *> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@AEAAXQEAPEAVModDelay@@_K1@Z ; std::vector<ModDelay *,std::allocator<ModDelay *> >::_Change_array
PUBLIC	?_Xlength@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@CAXXZ ; std::vector<ModDelay *,std::allocator<ModDelay *> >::_Xlength
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PEAVModDelay@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<ModDelay *> >::_Vector_val<std::_Simple_types<ModDelay *> >
PUBLIC	??0?$allocator@PEAVMultiChannelDiffuser@@@std@@QEAA@XZ ; std::allocator<MultiChannelDiffuser *>::allocator<MultiChannelDiffuser *>
PUBLIC	?allocate@?$allocator@PEAVMultiChannelDiffuser@@@std@@QEAAPEAPEAVMultiChannelDiffuser@@_K@Z ; std::allocator<MultiChannelDiffuser *>::allocate
PUBLIC	?max_size@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEBA_KXZ ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::max_size
PUBLIC	?_Umove@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@AEAAPEAPEAVMultiChannelDiffuser@@PEAPEAV3@00@Z ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::_Umove
PUBLIC	?_Umove_if_noexcept@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@AEAAXPEAPEAVMultiChannelDiffuser@@00@Z ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::_Umove_if_noexcept
PUBLIC	?_Calculate_growth@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@AEBA_K_K@Z ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@AEAAXQEAPEAVMultiChannelDiffuser@@_K1@Z ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::_Change_array
PUBLIC	?_Xlength@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@CAXXZ ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::_Xlength
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PEAVMultiChannelDiffuser@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<MultiChannelDiffuser *> >::_Vector_val<std::_Simple_types<MultiChannelDiffuser *> >
PUBLIC	??0?$allocator@PEAVModMultiChannelDiffuser@@@std@@QEAA@XZ ; std::allocator<ModMultiChannelDiffuser *>::allocator<ModMultiChannelDiffuser *>
PUBLIC	?allocate@?$allocator@PEAVModMultiChannelDiffuser@@@std@@QEAAPEAPEAVModMultiChannelDiffuser@@_K@Z ; std::allocator<ModMultiChannelDiffuser *>::allocate
PUBLIC	?max_size@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEBA_KXZ ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::max_size
PUBLIC	?_Umove@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@AEAAPEAPEAVModMultiChannelDiffuser@@PEAPEAV3@00@Z ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::_Umove
PUBLIC	?_Umove_if_noexcept@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@AEAAXPEAPEAVModMultiChannelDiffuser@@00@Z ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::_Umove_if_noexcept
PUBLIC	?_Calculate_growth@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@AEBA_K_K@Z ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@AEAAXQEAPEAVModMultiChannelDiffuser@@_K1@Z ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::_Change_array
PUBLIC	?_Xlength@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@CAXXZ ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::_Xlength
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PEAVModMultiChannelDiffuser@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<ModMultiChannelDiffuser *> >::_Vector_val<std::_Simple_types<ModMultiChannelDiffuser *> >
PUBLIC	??0?$allocator@PEAVLowPassFilter@@@std@@QEAA@XZ	; std::allocator<LowPassFilter *>::allocator<LowPassFilter *>
PUBLIC	?allocate@?$allocator@PEAVLowPassFilter@@@std@@QEAAPEAPEAVLowPassFilter@@_K@Z ; std::allocator<LowPassFilter *>::allocate
PUBLIC	?max_size@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEBA_KXZ ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::max_size
PUBLIC	?_Umove@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@AEAAPEAPEAVLowPassFilter@@PEAPEAV3@00@Z ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::_Umove
PUBLIC	?_Umove_if_noexcept@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@AEAAXPEAPEAVLowPassFilter@@00@Z ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::_Umove_if_noexcept
PUBLIC	?_Calculate_growth@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@AEBA_K_K@Z ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@AEAAXQEAPEAVLowPassFilter@@_K1@Z ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::_Change_array
PUBLIC	?_Xlength@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@CAXXZ ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::_Xlength
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PEAVLowPassFilter@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<LowPassFilter *> >::_Vector_val<std::_Simple_types<LowPassFilter *> >
PUBLIC	??0?$allocator@PEAVModulation@@@std@@QEAA@XZ	; std::allocator<Modulation *>::allocator<Modulation *>
PUBLIC	?allocate@?$allocator@PEAVModulation@@@std@@QEAAPEAPEAVModulation@@_K@Z ; std::allocator<Modulation *>::allocate
PUBLIC	?max_size@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@QEBA_KXZ ; std::vector<Modulation *,std::allocator<Modulation *> >::max_size
PUBLIC	?_Umove@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@AEAAPEAPEAVModulation@@PEAPEAV3@00@Z ; std::vector<Modulation *,std::allocator<Modulation *> >::_Umove
PUBLIC	?_Umove_if_noexcept@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@AEAAXPEAPEAVModulation@@00@Z ; std::vector<Modulation *,std::allocator<Modulation *> >::_Umove_if_noexcept
PUBLIC	?_Calculate_growth@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@AEBA_K_K@Z ; std::vector<Modulation *,std::allocator<Modulation *> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@AEAAXQEAPEAVModulation@@_K1@Z ; std::vector<Modulation *,std::allocator<Modulation *> >::_Change_array
PUBLIC	?_Xlength@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@CAXXZ ; std::vector<Modulation *,std::allocator<Modulation *> >::_Xlength
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PEAVModulation@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<Modulation *> >::_Vector_val<std::_Simple_types<Modulation *> >
PUBLIC	??0?$allocator@PEAVHighPassFilter@@@std@@QEAA@XZ ; std::allocator<HighPassFilter *>::allocator<HighPassFilter *>
PUBLIC	?allocate@?$allocator@PEAVHighPassFilter@@@std@@QEAAPEAPEAVHighPassFilter@@_K@Z ; std::allocator<HighPassFilter *>::allocate
PUBLIC	?max_size@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEBA_KXZ ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::max_size
PUBLIC	?_Umove@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@AEAAPEAPEAVHighPassFilter@@PEAPEAV3@00@Z ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::_Umove
PUBLIC	?_Umove_if_noexcept@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@AEAAXPEAPEAVHighPassFilter@@00@Z ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::_Umove_if_noexcept
PUBLIC	?_Calculate_growth@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@AEBA_K_K@Z ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@AEAAXQEAPEAVHighPassFilter@@_K1@Z ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::_Change_array
PUBLIC	?_Xlength@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@CAXXZ ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::_Xlength
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PEAVHighPassFilter@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<HighPassFilter *> >::_Vector_val<std::_Simple_types<HighPassFilter *> >
PUBLIC	??1?$_Tidy_guard@V?$vector@MV?$allocator@M@std@@@std@@@std@@QEAA@XZ ; std::_Tidy_guard<std::vector<float,std::allocator<float> > >::~_Tidy_guard<std::vector<float,std::allocator<float> > >
PUBLIC	??$_Pocma@V?$allocator@M@std@@@std@@YAXAEAV?$allocator@M@0@0@Z ; std::_Pocma<std::allocator<float> >
PUBLIC	??$_Destroy_range@V?$allocator@PEAVDelay@@@std@@@std@@YAXPEAPEAVDelay@@QEAPEAV1@AEAV?$allocator@PEAVDelay@@@0@@Z ; std::_Destroy_range<std::allocator<Delay *> >
PUBLIC	??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPEAHQEAHAEAV?$allocator@H@0@@Z ; std::_Destroy_range<std::allocator<int> >
PUBLIC	??$_Destroy_range@V?$allocator@PEAVModDelay@@@std@@@std@@YAXPEAPEAVModDelay@@QEAPEAV1@AEAV?$allocator@PEAVModDelay@@@0@@Z ; std::_Destroy_range<std::allocator<ModDelay *> >
PUBLIC	??$_Destroy_range@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@YAXPEAPEAVMultiChannelDiffuser@@QEAPEAV1@AEAV?$allocator@PEAVMultiChannelDiffuser@@@0@@Z ; std::_Destroy_range<std::allocator<MultiChannelDiffuser *> >
PUBLIC	??$_Destroy_range@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@YAXPEAPEAVModMultiChannelDiffuser@@QEAPEAV1@AEAV?$allocator@PEAVModMultiChannelDiffuser@@@0@@Z ; std::_Destroy_range<std::allocator<ModMultiChannelDiffuser *> >
PUBLIC	??$_Destroy_range@V?$allocator@PEAVLowPassFilter@@@std@@@std@@YAXPEAPEAVLowPassFilter@@QEAPEAV1@AEAV?$allocator@PEAVLowPassFilter@@@0@@Z ; std::_Destroy_range<std::allocator<LowPassFilter *> >
PUBLIC	??$_Destroy_range@V?$allocator@PEAVModulation@@@std@@@std@@YAXPEAPEAVModulation@@QEAPEAV1@AEAV?$allocator@PEAVModulation@@@0@@Z ; std::_Destroy_range<std::allocator<Modulation *> >
PUBLIC	??$_Destroy_range@V?$allocator@PEAVHighPassFilter@@@std@@@std@@YAXPEAPEAVHighPassFilter@@QEAPEAV1@AEAV?$allocator@PEAVHighPassFilter@@@0@@Z ; std::_Destroy_range<std::allocator<HighPassFilter *> >
PUBLIC	??$_Construct_n_copies_of_ty@U_Value_init_tag@std@@@?$vector@MV?$allocator@M@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<float,std::allocator<float> >::_Construct_n_copies_of_ty<std::_Value_init_tag>
PUBLIC	??$?0AEBV?$allocator@M@std@@$$V@?$_Compressed_pair@V?$allocator@M@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@M@1@@Z ; std::_Compressed_pair<std::allocator<float>,std::_Vector_val<std::_Simple_types<float> >,1>::_Compressed_pair<std::allocator<float>,std::_Vector_val<std::_Simple_types<float> >,1><std::allocator<float> const &>
PUBLIC	??$?0V?$allocator@M@std@@PEAMPEAMPEAM@?$_Compressed_pair@V?$allocator@M@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@M@1@$$QEAPEAM22@Z ; std::_Compressed_pair<std::allocator<float>,std::_Vector_val<std::_Simple_types<float> >,1>::_Compressed_pair<std::allocator<float>,std::_Vector_val<std::_Simple_types<float> >,1><std::allocator<float>,float *,float *,float *>
PUBLIC	??$exchange@PEAM$$T@std@@YAPEAMAEAPEAM$$QEA$$T@Z ; std::exchange<float *,std::nullptr_t>
PUBLIC	??$move@AEAV?$allocator@M@std@@@std@@YA$$QEAV?$allocator@M@0@AEAV10@@Z ; std::move<std::allocator<float> &>
PUBLIC	??$addressof@V?$vector@MV?$allocator@M@std@@@std@@@std@@YAPEAV?$vector@MV?$allocator@M@std@@@0@AEAV10@@Z ; std::addressof<std::vector<float,std::allocator<float> > >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@PEAVDelay@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVDelay@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<Delay *>,std::_Vector_val<std::_Simple_types<Delay *> >,1>::_Compressed_pair<std::allocator<Delay *>,std::_Vector_val<std::_Simple_types<Delay *> >,1><>
PUBLIC	??$_Emplace_reallocate@PEAVDelay@@@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@QEAAPEAPEAVDelay@@QEAPEAV2@$$QEAPEAV2@@Z ; std::vector<Delay *,std::allocator<Delay *> >::_Emplace_reallocate<Delay *>
PUBLIC	??$construct@PEAVDelay@@PEAV1@@?$_Default_allocator_traits@V?$allocator@PEAVDelay@@@std@@@std@@SAXAEAV?$allocator@PEAVDelay@@@1@QEAPEAVDelay@@$$QEAPEAV3@@Z ; std::_Default_allocator_traits<std::allocator<Delay *> >::construct<Delay *,Delay *>
PUBLIC	??$_Unfancy@PEAVDelay@@@std@@YAPEAPEAVDelay@@PEAPEAV1@@Z ; std::_Unfancy<Delay *>
PUBLIC	??$forward@PEAVDelay@@@std@@YA$$QEAPEAVDelay@@AEAPEAV1@@Z ; std::forward<Delay *>
PUBLIC	??$move@AEAPEAVDelay@@@std@@YA$$QEAPEAVDelay@@AEAPEAV1@@Z ; std::move<Delay * &>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><>
PUBLIC	??$_Emplace_reallocate@H@?$vector@HV?$allocator@H@std@@@std@@QEAAPEAHQEAH$$QEAH@Z ; std::vector<int,std::allocator<int> >::_Emplace_reallocate<int>
PUBLIC	??$construct@HH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAEAV?$allocator@H@1@QEAH$$QEAH@Z ; std::_Default_allocator_traits<std::allocator<int> >::construct<int,int>
PUBLIC	??$_Unfancy@H@std@@YAPEAHPEAH@Z			; std::_Unfancy<int>
PUBLIC	??$forward@H@std@@YA$$QEAHAEAH@Z		; std::forward<int>
PUBLIC	??$move@AEAH@std@@YA$$QEAHAEAH@Z		; std::move<int &>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@PEAVModDelay@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVModDelay@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<ModDelay *>,std::_Vector_val<std::_Simple_types<ModDelay *> >,1>::_Compressed_pair<std::allocator<ModDelay *>,std::_Vector_val<std::_Simple_types<ModDelay *> >,1><>
PUBLIC	??$_Emplace_reallocate@PEAVModDelay@@@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEAAPEAPEAVModDelay@@QEAPEAV2@$$QEAPEAV2@@Z ; std::vector<ModDelay *,std::allocator<ModDelay *> >::_Emplace_reallocate<ModDelay *>
PUBLIC	??$construct@PEAVModDelay@@PEAV1@@?$_Default_allocator_traits@V?$allocator@PEAVModDelay@@@std@@@std@@SAXAEAV?$allocator@PEAVModDelay@@@1@QEAPEAVModDelay@@$$QEAPEAV3@@Z ; std::_Default_allocator_traits<std::allocator<ModDelay *> >::construct<ModDelay *,ModDelay *>
PUBLIC	??$_Unfancy@PEAVModDelay@@@std@@YAPEAPEAVModDelay@@PEAPEAV1@@Z ; std::_Unfancy<ModDelay *>
PUBLIC	??$forward@PEAVModDelay@@@std@@YA$$QEAPEAVModDelay@@AEAPEAV1@@Z ; std::forward<ModDelay *>
PUBLIC	??$move@AEAPEAVModDelay@@@std@@YA$$QEAPEAVModDelay@@AEAPEAV1@@Z ; std::move<ModDelay * &>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@PEAVMultiChannelDiffuser@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVMultiChannelDiffuser@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<MultiChannelDiffuser *>,std::_Vector_val<std::_Simple_types<MultiChannelDiffuser *> >,1>::_Compressed_pair<std::allocator<MultiChannelDiffuser *>,std::_Vector_val<std::_Simple_types<MultiChannelDiffuser *> >,1><>
PUBLIC	??$_Emplace_reallocate@PEAVMultiChannelDiffuser@@@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEAAPEAPEAVMultiChannelDiffuser@@QEAPEAV2@$$QEAPEAV2@@Z ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::_Emplace_reallocate<MultiChannelDiffuser *>
PUBLIC	??$construct@PEAVMultiChannelDiffuser@@PEAV1@@?$_Default_allocator_traits@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@SAXAEAV?$allocator@PEAVMultiChannelDiffuser@@@1@QEAPEAVMultiChannelDiffuser@@$$QEAPEAV3@@Z ; std::_Default_allocator_traits<std::allocator<MultiChannelDiffuser *> >::construct<MultiChannelDiffuser *,MultiChannelDiffuser *>
PUBLIC	??$_Unfancy@PEAVMultiChannelDiffuser@@@std@@YAPEAPEAVMultiChannelDiffuser@@PEAPEAV1@@Z ; std::_Unfancy<MultiChannelDiffuser *>
PUBLIC	??$forward@PEAVMultiChannelDiffuser@@@std@@YA$$QEAPEAVMultiChannelDiffuser@@AEAPEAV1@@Z ; std::forward<MultiChannelDiffuser *>
PUBLIC	??$move@AEAPEAVMultiChannelDiffuser@@@std@@YA$$QEAPEAVMultiChannelDiffuser@@AEAPEAV1@@Z ; std::move<MultiChannelDiffuser * &>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVModMultiChannelDiffuser@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<ModMultiChannelDiffuser *>,std::_Vector_val<std::_Simple_types<ModMultiChannelDiffuser *> >,1>::_Compressed_pair<std::allocator<ModMultiChannelDiffuser *>,std::_Vector_val<std::_Simple_types<ModMultiChannelDiffuser *> >,1><>
PUBLIC	??$_Emplace_reallocate@PEAVModMultiChannelDiffuser@@@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEAAPEAPEAVModMultiChannelDiffuser@@QEAPEAV2@$$QEAPEAV2@@Z ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::_Emplace_reallocate<ModMultiChannelDiffuser *>
PUBLIC	??$construct@PEAVModMultiChannelDiffuser@@PEAV1@@?$_Default_allocator_traits@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@SAXAEAV?$allocator@PEAVModMultiChannelDiffuser@@@1@QEAPEAVModMultiChannelDiffuser@@$$QEAPEAV3@@Z ; std::_Default_allocator_traits<std::allocator<ModMultiChannelDiffuser *> >::construct<ModMultiChannelDiffuser *,ModMultiChannelDiffuser *>
PUBLIC	??$_Unfancy@PEAVModMultiChannelDiffuser@@@std@@YAPEAPEAVModMultiChannelDiffuser@@PEAPEAV1@@Z ; std::_Unfancy<ModMultiChannelDiffuser *>
PUBLIC	??$forward@PEAVModMultiChannelDiffuser@@@std@@YA$$QEAPEAVModMultiChannelDiffuser@@AEAPEAV1@@Z ; std::forward<ModMultiChannelDiffuser *>
PUBLIC	??$move@AEAPEAVModMultiChannelDiffuser@@@std@@YA$$QEAPEAVModMultiChannelDiffuser@@AEAPEAV1@@Z ; std::move<ModMultiChannelDiffuser * &>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@PEAVLowPassFilter@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVLowPassFilter@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<LowPassFilter *>,std::_Vector_val<std::_Simple_types<LowPassFilter *> >,1>::_Compressed_pair<std::allocator<LowPassFilter *>,std::_Vector_val<std::_Simple_types<LowPassFilter *> >,1><>
PUBLIC	??$_Emplace_reallocate@PEAVLowPassFilter@@@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEAAPEAPEAVLowPassFilter@@QEAPEAV2@$$QEAPEAV2@@Z ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::_Emplace_reallocate<LowPassFilter *>
PUBLIC	??$construct@PEAVLowPassFilter@@PEAV1@@?$_Default_allocator_traits@V?$allocator@PEAVLowPassFilter@@@std@@@std@@SAXAEAV?$allocator@PEAVLowPassFilter@@@1@QEAPEAVLowPassFilter@@$$QEAPEAV3@@Z ; std::_Default_allocator_traits<std::allocator<LowPassFilter *> >::construct<LowPassFilter *,LowPassFilter *>
PUBLIC	??$_Unfancy@PEAVLowPassFilter@@@std@@YAPEAPEAVLowPassFilter@@PEAPEAV1@@Z ; std::_Unfancy<LowPassFilter *>
PUBLIC	??$forward@PEAVLowPassFilter@@@std@@YA$$QEAPEAVLowPassFilter@@AEAPEAV1@@Z ; std::forward<LowPassFilter *>
PUBLIC	??$move@AEAPEAVLowPassFilter@@@std@@YA$$QEAPEAVLowPassFilter@@AEAPEAV1@@Z ; std::move<LowPassFilter * &>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@PEAVModulation@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVModulation@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<Modulation *>,std::_Vector_val<std::_Simple_types<Modulation *> >,1>::_Compressed_pair<std::allocator<Modulation *>,std::_Vector_val<std::_Simple_types<Modulation *> >,1><>
PUBLIC	??$_Emplace_reallocate@PEAVModulation@@@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@QEAAPEAPEAVModulation@@QEAPEAV2@$$QEAPEAV2@@Z ; std::vector<Modulation *,std::allocator<Modulation *> >::_Emplace_reallocate<Modulation *>
PUBLIC	??$construct@PEAVModulation@@PEAV1@@?$_Default_allocator_traits@V?$allocator@PEAVModulation@@@std@@@std@@SAXAEAV?$allocator@PEAVModulation@@@1@QEAPEAVModulation@@$$QEAPEAV3@@Z ; std::_Default_allocator_traits<std::allocator<Modulation *> >::construct<Modulation *,Modulation *>
PUBLIC	??$_Unfancy@PEAVModulation@@@std@@YAPEAPEAVModulation@@PEAPEAV1@@Z ; std::_Unfancy<Modulation *>
PUBLIC	??$forward@PEAVModulation@@@std@@YA$$QEAPEAVModulation@@AEAPEAV1@@Z ; std::forward<Modulation *>
PUBLIC	??$move@AEAPEAVModulation@@@std@@YA$$QEAPEAVModulation@@AEAPEAV1@@Z ; std::move<Modulation * &>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@PEAVHighPassFilter@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVHighPassFilter@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<HighPassFilter *>,std::_Vector_val<std::_Simple_types<HighPassFilter *> >,1>::_Compressed_pair<std::allocator<HighPassFilter *>,std::_Vector_val<std::_Simple_types<HighPassFilter *> >,1><>
PUBLIC	??$_Emplace_reallocate@PEAVHighPassFilter@@@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEAAPEAPEAVHighPassFilter@@QEAPEAV2@$$QEAPEAV2@@Z ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::_Emplace_reallocate<HighPassFilter *>
PUBLIC	??$construct@PEAVHighPassFilter@@PEAV1@@?$_Default_allocator_traits@V?$allocator@PEAVHighPassFilter@@@std@@@std@@SAXAEAV?$allocator@PEAVHighPassFilter@@@1@QEAPEAVHighPassFilter@@$$QEAPEAV3@@Z ; std::_Default_allocator_traits<std::allocator<HighPassFilter *> >::construct<HighPassFilter *,HighPassFilter *>
PUBLIC	??$_Unfancy@PEAVHighPassFilter@@@std@@YAPEAPEAVHighPassFilter@@PEAPEAV1@@Z ; std::_Unfancy<HighPassFilter *>
PUBLIC	??$forward@PEAVHighPassFilter@@@std@@YA$$QEAPEAVHighPassFilter@@AEAPEAV1@@Z ; std::forward<HighPassFilter *>
PUBLIC	??$move@AEAPEAVHighPassFilter@@@std@@YA$$QEAPEAVHighPassFilter@@AEAPEAV1@@Z ; std::move<HighPassFilter * &>
PUBLIC	?_Take_contents@?$_Vector_val@U?$_Simple_types@M@std@@@std@@QEAAXAEAV12@@Z ; std::_Vector_val<std::_Simple_types<float> >::_Take_contents
PUBLIC	?deallocate@?$allocator@PEAVDelay@@@std@@QEAAXQEAPEAVDelay@@_K@Z ; std::allocator<Delay *>::deallocate
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@PEAVDelay@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVDelay@@@std@@@2@$00@std@@QEAAAEAV?$allocator@PEAVDelay@@@2@XZ ; std::_Compressed_pair<std::allocator<Delay *>,std::_Vector_val<std::_Simple_types<Delay *> >,1>::_Get_first
PUBLIC	?deallocate@?$allocator@H@std@@QEAAXQEAH_K@Z	; std::allocator<int>::deallocate
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QEAAAEAV?$allocator@H@2@XZ ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first
PUBLIC	?deallocate@?$allocator@PEAVModDelay@@@std@@QEAAXQEAPEAVModDelay@@_K@Z ; std::allocator<ModDelay *>::deallocate
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@PEAVModDelay@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVModDelay@@@std@@@2@$00@std@@QEAAAEAV?$allocator@PEAVModDelay@@@2@XZ ; std::_Compressed_pair<std::allocator<ModDelay *>,std::_Vector_val<std::_Simple_types<ModDelay *> >,1>::_Get_first
PUBLIC	?deallocate@?$allocator@PEAVMultiChannelDiffuser@@@std@@QEAAXQEAPEAVMultiChannelDiffuser@@_K@Z ; std::allocator<MultiChannelDiffuser *>::deallocate
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@PEAVMultiChannelDiffuser@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVMultiChannelDiffuser@@@std@@@2@$00@std@@QEAAAEAV?$allocator@PEAVMultiChannelDiffuser@@@2@XZ ; std::_Compressed_pair<std::allocator<MultiChannelDiffuser *>,std::_Vector_val<std::_Simple_types<MultiChannelDiffuser *> >,1>::_Get_first
PUBLIC	?deallocate@?$allocator@PEAVModMultiChannelDiffuser@@@std@@QEAAXQEAPEAVModMultiChannelDiffuser@@_K@Z ; std::allocator<ModMultiChannelDiffuser *>::deallocate
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVModMultiChannelDiffuser@@@std@@@2@$00@std@@QEAAAEAV?$allocator@PEAVModMultiChannelDiffuser@@@2@XZ ; std::_Compressed_pair<std::allocator<ModMultiChannelDiffuser *>,std::_Vector_val<std::_Simple_types<ModMultiChannelDiffuser *> >,1>::_Get_first
PUBLIC	?deallocate@?$allocator@PEAVLowPassFilter@@@std@@QEAAXQEAPEAVLowPassFilter@@_K@Z ; std::allocator<LowPassFilter *>::deallocate
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@PEAVLowPassFilter@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVLowPassFilter@@@std@@@2@$00@std@@QEAAAEAV?$allocator@PEAVLowPassFilter@@@2@XZ ; std::_Compressed_pair<std::allocator<LowPassFilter *>,std::_Vector_val<std::_Simple_types<LowPassFilter *> >,1>::_Get_first
PUBLIC	?deallocate@?$allocator@PEAVModulation@@@std@@QEAAXQEAPEAVModulation@@_K@Z ; std::allocator<Modulation *>::deallocate
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@PEAVModulation@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVModulation@@@std@@@2@$00@std@@QEAAAEAV?$allocator@PEAVModulation@@@2@XZ ; std::_Compressed_pair<std::allocator<Modulation *>,std::_Vector_val<std::_Simple_types<Modulation *> >,1>::_Get_first
PUBLIC	?deallocate@?$allocator@PEAVHighPassFilter@@@std@@QEAAXQEAPEAVHighPassFilter@@_K@Z ; std::allocator<HighPassFilter *>::deallocate
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@PEAVHighPassFilter@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVHighPassFilter@@@std@@@2@$00@std@@QEAAAEAV?$allocator@PEAVHighPassFilter@@@2@XZ ; std::_Compressed_pair<std::allocator<HighPassFilter *>,std::_Vector_val<std::_Simple_types<HighPassFilter *> >,1>::_Get_first
PUBLIC	?_Move_assign@?$vector@MV?$allocator@M@std@@@std@@AEAAXAEAV12@U_Equal_allocators@2@@Z ; std::vector<float,std::allocator<float> >::_Move_assign
PUBLIC	?_Reallocate_exactly@?$vector@MV?$allocator@M@std@@@std@@AEAAX_K@Z ; std::vector<float,std::allocator<float> >::_Reallocate_exactly
PUBLIC	?_Destroy@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@AEAAXPEAPEAVDelay@@0@Z ; std::vector<Delay *,std::allocator<Delay *> >::_Destroy
PUBLIC	?_Tidy@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@AEAAXXZ ; std::vector<Delay *,std::allocator<Delay *> >::_Tidy
PUBLIC	?_Orphan_range@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@AEBAXPEAPEAVDelay@@0@Z ; std::vector<Delay *,std::allocator<Delay *> >::_Orphan_range
PUBLIC	?_Getal@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@AEAAAEAV?$allocator@PEAVDelay@@@2@XZ ; std::vector<Delay *,std::allocator<Delay *> >::_Getal
PUBLIC	?_Destroy@?$vector@HV?$allocator@H@std@@@std@@AEAAXPEAH0@Z ; std::vector<int,std::allocator<int> >::_Destroy
PUBLIC	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AEAAXXZ ; std::vector<int,std::allocator<int> >::_Tidy
PUBLIC	?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@AEBAXPEAH0@Z ; std::vector<int,std::allocator<int> >::_Orphan_range
PUBLIC	?_Getal@?$vector@HV?$allocator@H@std@@@std@@AEAAAEAV?$allocator@H@2@XZ ; std::vector<int,std::allocator<int> >::_Getal
PUBLIC	?_Destroy@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@AEAAXPEAPEAVModDelay@@0@Z ; std::vector<ModDelay *,std::allocator<ModDelay *> >::_Destroy
PUBLIC	?_Tidy@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@AEAAXXZ ; std::vector<ModDelay *,std::allocator<ModDelay *> >::_Tidy
PUBLIC	?_Orphan_range@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@AEBAXPEAPEAVModDelay@@0@Z ; std::vector<ModDelay *,std::allocator<ModDelay *> >::_Orphan_range
PUBLIC	?_Getal@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@AEAAAEAV?$allocator@PEAVModDelay@@@2@XZ ; std::vector<ModDelay *,std::allocator<ModDelay *> >::_Getal
PUBLIC	?_Destroy@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@AEAAXPEAPEAVMultiChannelDiffuser@@0@Z ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::_Destroy
PUBLIC	?_Tidy@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@AEAAXXZ ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::_Tidy
PUBLIC	?_Orphan_range@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@AEBAXPEAPEAVMultiChannelDiffuser@@0@Z ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::_Orphan_range
PUBLIC	?_Getal@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@AEAAAEAV?$allocator@PEAVMultiChannelDiffuser@@@2@XZ ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::_Getal
PUBLIC	?_Destroy@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@AEAAXPEAPEAVModMultiChannelDiffuser@@0@Z ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::_Destroy
PUBLIC	?_Tidy@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@AEAAXXZ ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::_Tidy
PUBLIC	?_Orphan_range@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@AEBAXPEAPEAVModMultiChannelDiffuser@@0@Z ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::_Orphan_range
PUBLIC	?_Getal@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@AEAAAEAV?$allocator@PEAVModMultiChannelDiffuser@@@2@XZ ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::_Getal
PUBLIC	?_Destroy@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@AEAAXPEAPEAVLowPassFilter@@0@Z ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::_Destroy
PUBLIC	?_Tidy@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@AEAAXXZ ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::_Tidy
PUBLIC	?_Orphan_range@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@AEBAXPEAPEAVLowPassFilter@@0@Z ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::_Orphan_range
PUBLIC	?_Getal@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@AEAAAEAV?$allocator@PEAVLowPassFilter@@@2@XZ ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::_Getal
PUBLIC	?_Destroy@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@AEAAXPEAPEAVModulation@@0@Z ; std::vector<Modulation *,std::allocator<Modulation *> >::_Destroy
PUBLIC	?_Tidy@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@AEAAXXZ ; std::vector<Modulation *,std::allocator<Modulation *> >::_Tidy
PUBLIC	?_Orphan_range@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@AEBAXPEAPEAVModulation@@0@Z ; std::vector<Modulation *,std::allocator<Modulation *> >::_Orphan_range
PUBLIC	?_Getal@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@AEAAAEAV?$allocator@PEAVModulation@@@2@XZ ; std::vector<Modulation *,std::allocator<Modulation *> >::_Getal
PUBLIC	?_Destroy@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@AEAAXPEAPEAVHighPassFilter@@0@Z ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::_Destroy
PUBLIC	?_Tidy@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@AEAAXXZ ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::_Tidy
PUBLIC	?_Orphan_range@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@AEBAXPEAPEAVHighPassFilter@@0@Z ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::_Orphan_range
PUBLIC	?_Getal@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@AEAAAEAV?$allocator@PEAVHighPassFilter@@@2@XZ ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::_Getal
PUBLIC	??0?$vector@MV?$allocator@M@std@@@std@@QEAA@_KAEBV?$allocator@M@1@@Z ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
PUBLIC	??0?$vector@MV?$allocator@M@std@@@std@@QEAA@$$QEAV01@@Z ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
PUBLIC	??4?$vector@MV?$allocator@M@std@@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::vector<float,std::allocator<float> >::operator=
PUBLIC	?reserve@?$vector@MV?$allocator@M@std@@@std@@QEAAX_K@Z ; std::vector<float,std::allocator<float> >::reserve
PUBLIC	??0?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@QEAA@XZ ; std::vector<Delay *,std::allocator<Delay *> >::vector<Delay *,std::allocator<Delay *> >
PUBLIC	??1?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@QEAA@XZ ; std::vector<Delay *,std::allocator<Delay *> >::~vector<Delay *,std::allocator<Delay *> >
PUBLIC	??$_Emplace_back_with_unused_capacity@PEAVDelay@@@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@AEAA?A_T$$QEAPEAVDelay@@@Z ; std::vector<Delay *,std::allocator<Delay *> >::_Emplace_back_with_unused_capacity<Delay *>
PUBLIC	??$emplace_back@PEAVDelay@@@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@QEAA?A_T$$QEAPEAVDelay@@@Z ; std::vector<Delay *,std::allocator<Delay *> >::emplace_back<Delay *>
PUBLIC	?push_back@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@QEAAX$$QEAPEAVDelay@@@Z ; std::vector<Delay *,std::allocator<Delay *> >::push_back
PUBLIC	?clear@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@QEAAXXZ ; std::vector<Delay *,std::allocator<Delay *> >::clear
PUBLIC	?empty@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@QEBA_NXZ ; std::vector<Delay *,std::allocator<Delay *> >::empty
PUBLIC	?size@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@QEBA_KXZ ; std::vector<Delay *,std::allocator<Delay *> >::size
PUBLIC	??A?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@QEAAAEAPEAVDelay@@_K@Z ; std::vector<Delay *,std::allocator<Delay *> >::operator[]
PUBLIC	??0?$vector@HV?$allocator@H@std@@@std@@QEAA@XZ	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
PUBLIC	??1?$vector@HV?$allocator@H@std@@@std@@QEAA@XZ	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
PUBLIC	??$_Emplace_back_with_unused_capacity@H@?$vector@HV?$allocator@H@std@@@std@@AEAA?A_T$$QEAH@Z ; std::vector<int,std::allocator<int> >::_Emplace_back_with_unused_capacity<int>
PUBLIC	??$emplace_back@H@?$vector@HV?$allocator@H@std@@@std@@QEAA?A_T$$QEAH@Z ; std::vector<int,std::allocator<int> >::emplace_back<int>
PUBLIC	?push_back@?$vector@HV?$allocator@H@std@@@std@@QEAAX$$QEAH@Z ; std::vector<int,std::allocator<int> >::push_back
PUBLIC	?clear@?$vector@HV?$allocator@H@std@@@std@@QEAAXXZ ; std::vector<int,std::allocator<int> >::clear
PUBLIC	?empty@?$vector@HV?$allocator@H@std@@@std@@QEBA_NXZ ; std::vector<int,std::allocator<int> >::empty
PUBLIC	??A?$vector@HV?$allocator@H@std@@@std@@QEAAAEAH_K@Z ; std::vector<int,std::allocator<int> >::operator[]
PUBLIC	??0?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEAA@XZ ; std::vector<ModDelay *,std::allocator<ModDelay *> >::vector<ModDelay *,std::allocator<ModDelay *> >
PUBLIC	??1?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEAA@XZ ; std::vector<ModDelay *,std::allocator<ModDelay *> >::~vector<ModDelay *,std::allocator<ModDelay *> >
PUBLIC	??$_Emplace_back_with_unused_capacity@PEAVModDelay@@@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@AEAA?A_T$$QEAPEAVModDelay@@@Z ; std::vector<ModDelay *,std::allocator<ModDelay *> >::_Emplace_back_with_unused_capacity<ModDelay *>
PUBLIC	??$emplace_back@PEAVModDelay@@@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEAA?A_T$$QEAPEAVModDelay@@@Z ; std::vector<ModDelay *,std::allocator<ModDelay *> >::emplace_back<ModDelay *>
PUBLIC	?push_back@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEAAX$$QEAPEAVModDelay@@@Z ; std::vector<ModDelay *,std::allocator<ModDelay *> >::push_back
PUBLIC	?clear@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEAAXXZ ; std::vector<ModDelay *,std::allocator<ModDelay *> >::clear
PUBLIC	?empty@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEBA_NXZ ; std::vector<ModDelay *,std::allocator<ModDelay *> >::empty
PUBLIC	?size@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEBA_KXZ ; std::vector<ModDelay *,std::allocator<ModDelay *> >::size
PUBLIC	??A?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEAAAEAPEAVModDelay@@_K@Z ; std::vector<ModDelay *,std::allocator<ModDelay *> >::operator[]
PUBLIC	??0?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEAA@XZ ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >
PUBLIC	??1?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEAA@XZ ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::~vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >
PUBLIC	??$_Emplace_back_with_unused_capacity@PEAVMultiChannelDiffuser@@@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@AEAA?A_T$$QEAPEAVMultiChannelDiffuser@@@Z ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::_Emplace_back_with_unused_capacity<MultiChannelDiffuser *>
PUBLIC	??$emplace_back@PEAVMultiChannelDiffuser@@@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEAA?A_T$$QEAPEAVMultiChannelDiffuser@@@Z ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::emplace_back<MultiChannelDiffuser *>
PUBLIC	?push_back@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEAAX$$QEAPEAVMultiChannelDiffuser@@@Z ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::push_back
PUBLIC	?clear@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEAAXXZ ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::clear
PUBLIC	?empty@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEBA_NXZ ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::empty
PUBLIC	?size@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEBA_KXZ ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::size
PUBLIC	??A?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEAAAEAPEAVMultiChannelDiffuser@@_K@Z ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::operator[]
PUBLIC	??0?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEAA@XZ ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >
PUBLIC	??1?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEAA@XZ ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::~vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >
PUBLIC	??$_Emplace_back_with_unused_capacity@PEAVModMultiChannelDiffuser@@@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@AEAA?A_T$$QEAPEAVModMultiChannelDiffuser@@@Z ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::_Emplace_back_with_unused_capacity<ModMultiChannelDiffuser *>
PUBLIC	??$emplace_back@PEAVModMultiChannelDiffuser@@@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEAA?A_T$$QEAPEAVModMultiChannelDiffuser@@@Z ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::emplace_back<ModMultiChannelDiffuser *>
PUBLIC	?push_back@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEAAX$$QEAPEAVModMultiChannelDiffuser@@@Z ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::push_back
PUBLIC	?clear@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEAAXXZ ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::clear
PUBLIC	?empty@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEBA_NXZ ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::empty
PUBLIC	?size@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEBA_KXZ ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::size
PUBLIC	??A?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEAAAEAPEAVModMultiChannelDiffuser@@_K@Z ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::operator[]
PUBLIC	??0?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEAA@XZ ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::vector<LowPassFilter *,std::allocator<LowPassFilter *> >
PUBLIC	??1?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEAA@XZ ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::~vector<LowPassFilter *,std::allocator<LowPassFilter *> >
PUBLIC	??$_Emplace_back_with_unused_capacity@PEAVLowPassFilter@@@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@AEAA?A_T$$QEAPEAVLowPassFilter@@@Z ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::_Emplace_back_with_unused_capacity<LowPassFilter *>
PUBLIC	??$emplace_back@PEAVLowPassFilter@@@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEAA?A_T$$QEAPEAVLowPassFilter@@@Z ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::emplace_back<LowPassFilter *>
PUBLIC	?push_back@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEAAX$$QEAPEAVLowPassFilter@@@Z ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::push_back
PUBLIC	?clear@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEAAXXZ ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::clear
PUBLIC	?empty@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEBA_NXZ ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::empty
PUBLIC	?size@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEBA_KXZ ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::size
PUBLIC	??A?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEAAAEAPEAVLowPassFilter@@_K@Z ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::operator[]
PUBLIC	??0?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@QEAA@XZ ; std::vector<Modulation *,std::allocator<Modulation *> >::vector<Modulation *,std::allocator<Modulation *> >
PUBLIC	??1?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@QEAA@XZ ; std::vector<Modulation *,std::allocator<Modulation *> >::~vector<Modulation *,std::allocator<Modulation *> >
PUBLIC	??$_Emplace_back_with_unused_capacity@PEAVModulation@@@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@AEAA?A_T$$QEAPEAVModulation@@@Z ; std::vector<Modulation *,std::allocator<Modulation *> >::_Emplace_back_with_unused_capacity<Modulation *>
PUBLIC	??$emplace_back@PEAVModulation@@@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@QEAA?A_T$$QEAPEAVModulation@@@Z ; std::vector<Modulation *,std::allocator<Modulation *> >::emplace_back<Modulation *>
PUBLIC	?push_back@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@QEAAX$$QEAPEAVModulation@@@Z ; std::vector<Modulation *,std::allocator<Modulation *> >::push_back
PUBLIC	?clear@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@QEAAXXZ ; std::vector<Modulation *,std::allocator<Modulation *> >::clear
PUBLIC	?empty@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@QEBA_NXZ ; std::vector<Modulation *,std::allocator<Modulation *> >::empty
PUBLIC	?size@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@QEBA_KXZ ; std::vector<Modulation *,std::allocator<Modulation *> >::size
PUBLIC	??A?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@QEAAAEAPEAVModulation@@_K@Z ; std::vector<Modulation *,std::allocator<Modulation *> >::operator[]
PUBLIC	??0?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEAA@XZ ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::vector<HighPassFilter *,std::allocator<HighPassFilter *> >
PUBLIC	??1?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEAA@XZ ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::~vector<HighPassFilter *,std::allocator<HighPassFilter *> >
PUBLIC	??$_Emplace_back_with_unused_capacity@PEAVHighPassFilter@@@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@AEAA?A_T$$QEAPEAVHighPassFilter@@@Z ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::_Emplace_back_with_unused_capacity<HighPassFilter *>
PUBLIC	??$emplace_back@PEAVHighPassFilter@@@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEAA?A_T$$QEAPEAVHighPassFilter@@@Z ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::emplace_back<HighPassFilter *>
PUBLIC	?push_back@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEAAX$$QEAPEAVHighPassFilter@@@Z ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::push_back
PUBLIC	?clear@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEAAXXZ ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::clear
PUBLIC	?empty@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEBA_NXZ ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::empty
PUBLIC	?size@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEBA_KXZ ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::size
PUBLIC	??A?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEAAAEAPEAVHighPassFilter@@_K@Z ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::operator[]
PUBLIC	??_GPSMVocoder@@QEAAPEAXI@Z			; PSMVocoder::`scalar deleting destructor'
PUBLIC	??_GFDN@@QEAAPEAXI@Z				; FDN::`scalar deleting destructor'
PUBLIC	??1Shimmer@@UEAA@XZ				; Shimmer::~Shimmer
PUBLIC	?getVendorString@Shimmer@@UEAA_NPEAD@Z		; Shimmer::getVendorString
PUBLIC	?getEffectName@Shimmer@@UEAA_NPEAD@Z		; Shimmer::getEffectName
PUBLIC	?setChunk@Shimmer@@UEAAHPEAXH_N@Z		; Shimmer::setChunk
PUBLIC	?getChunk@Shimmer@@UEAAHPEAPEAX_N@Z		; Shimmer::getChunk
PUBLIC	?getProgramNameIndexed@Shimmer@@UEAA_NHHPEAD@Z	; Shimmer::getProgramNameIndexed
PUBLIC	?getProgramName@Shimmer@@UEAAXPEAD@Z		; Shimmer::getProgramName
PUBLIC	?setProgram@Shimmer@@UEAAXH@Z			; Shimmer::setProgram
PUBLIC	?InitPresets@Shimmer@@AEAAXXZ			; Shimmer::InitPresets
PUBLIC	?getParameterName@Shimmer@@UEAAXHPEAD@Z		; Shimmer::getParameterName
PUBLIC	?getParameterDisplay@Shimmer@@UEAAXHPEAD@Z	; Shimmer::getParameterDisplay
PUBLIC	?getParameterLabel@Shimmer@@UEAAXHPEAD@Z	; Shimmer::getParameterLabel
PUBLIC	?getParameter@Shimmer@@UEAAMH@Z			; Shimmer::getParameter
PUBLIC	?setParameter@Shimmer@@UEAAXHM@Z		; Shimmer::setParameter
PUBLIC	?processReplacing@Shimmer@@UEAAXPEAPEAM0H@Z	; Shimmer::processReplacing
PUBLIC	?setSampleRate@Shimmer@@UEAAXM@Z		; Shimmer::setSampleRate
PUBLIC	?InitPlugin@Shimmer@@AEAAXXZ			; Shimmer::InitPlugin
PUBLIC	??_GShimmer@@UEAAPEAXI@Z			; Shimmer::`scalar deleting destructor'
PUBLIC	??0Shimmer@@QEAA@P6A_JPEAUAEffect@@HH_JPEAXM@Z@Z ; Shimmer::Shimmer
PUBLIC	?updateMixPitchShifters@Shimmer@@AEAAXM@Z	; Shimmer::updateMixPitchShifters
PUBLIC	?updateMix@Shimmer@@AEAAXXZ			; Shimmer::updateMix
PUBLIC	??0IAudioSignalProcessor@@QEAA@XZ		; IAudioSignalProcessor::IAudioSignalProcessor
PUBLIC	?setParameters@PSMVocoder@@QEAAXAEBUPSMVocoderParameters@@@Z ; PSMVocoder::setParameters
PUBLIC	?getParameters@PSMVocoder@@QEAA?AUPSMVocoderParameters@@XZ ; PSMVocoder::getParameters
PUBLIC	?processAudioSample@PSMVocoder@@UEAANN@Z	; PSMVocoder::processAudioSample
PUBLIC	?findPeaksAndRegionsOfInfluence@PSMVocoder@@QEAAXXZ ; PSMVocoder::findPeaksAndRegionsOfInfluence
PUBLIC	?findPreviousNearestPeak@PSMVocoder@@QEAAHH@Z	; PSMVocoder::findPreviousNearestPeak
PUBLIC	?setPitchShift@PSMVocoder@@QEAAXN@Z		; PSMVocoder::setPitchShift
PUBLIC	?canProcessAudioFrame@PSMVocoder@@UEAA_NXZ	; PSMVocoder::canProcessAudioFrame
PUBLIC	?reset@PSMVocoder@@UEAA_NN@Z			; PSMVocoder::reset
PUBLIC	??1PSMVocoder@@QEAA@XZ				; PSMVocoder::~PSMVocoder
PUBLIC	??0PSMVocoder@@QEAA@XZ				; PSMVocoder::PSMVocoder
PUBLIC	?getIFFTData@PhaseVocoder@@QEAAPEAY01NXZ	; PhaseVocoder::getIFFTData
PUBLIC	?getFFTData@PhaseVocoder@@QEAAPEAY01NXZ		; PhaseVocoder::getFFTData
PUBLIC	??1PhaseVocoder@@QEAA@XZ			; PhaseVocoder::~PhaseVocoder
PUBLIC	??0PhaseVocoder@@QEAA@XZ			; PhaseVocoder::PhaseVocoder
PUBLIC	?reset@BinData@@QEAAXXZ				; BinData::reset
PUBLIC	??4BinData@@QEAAAEAU0@AEBU0@@Z			; BinData::operator=
PUBLIC	??0BinData@@QEAA@XZ				; BinData::BinData
PUBLIC	??4PSMVocoderParameters@@QEAAAEAU0@AEBU0@@Z	; PSMVocoderParameters::operator=
PUBLIC	??0PSMVocoderParameters@@QEAA@XZ		; PSMVocoderParameters::PSMVocoderParameters
PUBLIC	?processAudioFrame@IAudioSignalProcessor@@UEAA_NPEBMPEAMII@Z ; IAudioSignalProcessor::processAudioFrame
PUBLIC	?processAuxInputAudioSample@IAudioSignalProcessor@@UEAANN@Z ; IAudioSignalProcessor::processAuxInputAudioSample
PUBLIC	?enableAuxInput@IAudioSignalProcessor@@UEAAX_N@Z ; IAudioSignalProcessor::enableAuxInput
PUBLIC	?setSampleRate@IAudioSignalProcessor@@UEAAXN@Z	; IAudioSignalProcessor::setSampleRate
PUBLIC	?resample@@YA_NPEAN0IIW4interpolation@@N0@Z	; resample
PUBLIC	?doLagrangeInterpolation@@YANPEAN0HN@Z		; doLagrangeInterpolation
PUBLIC	?doLinearInterpolation@@YANNNN@Z		; doLinearInterpolation
PUBLIC	?principalArg@@YANN@Z				; principalArg
PUBLIC	?getPhase@@YANNN@Z				; getPhase
PUBLIC	?getMagnitude@@YANNN@Z				; getMagnitude
PUBLIC	??_GModulation@@QEAAPEAXI@Z			; Modulation::`scalar deleting destructor'
PUBLIC	??_GHighPassFilter@@QEAAPEAXI@Z			; HighPassFilter::`scalar deleting destructor'
PUBLIC	??_GModMultiChannelFeedback@@QEAAPEAXI@Z	; ModMultiChannelFeedback::`scalar deleting destructor'
PUBLIC	??_GModMultiChannelDiffuser@@QEAAPEAXI@Z	; ModMultiChannelDiffuser::`scalar deleting destructor'
PUBLIC	??_GMultiChannelDiffuser@@QEAAPEAXI@Z		; MultiChannelDiffuser::`scalar deleting destructor'
PUBLIC	??_GChannelMixer@@QEAAPEAXI@Z			; ChannelMixer::`scalar deleting destructor'
PUBLIC	??_GChannelSplitter@@QEAAPEAXI@Z		; ChannelSplitter::`scalar deleting destructor'
PUBLIC	?deleteInternalArrays@FDN@@AEAAXXZ		; FDN::deleteInternalArrays
PUBLIC	?initInternalArrays@FDN@@AEAAXXZ		; FDN::initInternalArrays
PUBLIC	?deleteChorus@FDN@@AEAAXXZ			; FDN::deleteChorus
PUBLIC	?deleteFilters@FDN@@AEAAXXZ			; FDN::deleteFilters
PUBLIC	?deleteFeedbackBlock@FDN@@AEAAXXZ		; FDN::deleteFeedbackBlock
PUBLIC	?deleteDiffusionBlocks@FDN@@AEAAXXZ		; FDN::deleteDiffusionBlocks
PUBLIC	?deleteInterfaceBlocks@FDN@@AEAAXXZ		; FDN::deleteInterfaceBlocks
PUBLIC	?constructModulation@FDN@@AEAAXXZ		; FDN::constructModulation
PUBLIC	?constructFilters@FDN@@AEAAXXZ			; FDN::constructFilters
PUBLIC	?constructDiffusionBlocks@FDN@@AEAAXXZ		; FDN::constructDiffusionBlocks
PUBLIC	?constructFDN@FDN@@AEAAXHHHHH@Z			; FDN::constructFDN
PUBLIC	?setEqualDiffuserDelayLengths@FDN@@AEAAXMMW4DelayDistribution@@@Z ; FDN::setEqualDiffuserDelayLengths
PUBLIC	?setDoubledDiffuserDelayLengths@FDN@@AEAAXMMW4DelayDistribution@@@Z ; FDN::setDoubledDiffuserDelayLengths
PUBLIC	?processAudio@FDN@@QEAAXPEAM0@Z			; FDN::processAudio
PUBLIC	?setMixMode@FDN@@QEAAXW4MixMode@@@Z		; FDN::setMixMode
PUBLIC	?setSampleRate@FDN@@QEAAXH@Z			; FDN::setSampleRate
PUBLIC	?setEarlyReflWeight@FDN@@QEAAXM@Z		; FDN::setEarlyReflWeight
PUBLIC	?setFeedbackDelayLengths@FDN@@QEAAXMMW4DelayDistribution@@@Z ; FDN::setFeedbackDelayLengths
PUBLIC	?setDiffuserDelayLengths@FDN@@QEAAXMW4DiffuserDelayLogic@@W4DelayDistribution@@M@Z ; FDN::setDiffuserDelayLengths
PUBLIC	?setStereoSpread@FDN@@QEAAXM@Z			; FDN::setStereoSpread
PUBLIC	?setHighPassType@FDN@@QEAAXW4HPFilterType@@@Z	; FDN::setHighPassType
PUBLIC	?setLowPassType@FDN@@QEAAXW4LPFilterType@@@Z	; FDN::setLowPassType
PUBLIC	?setHighPassFrequency@FDN@@QEAAXM@Z		; FDN::setHighPassFrequency
PUBLIC	?setLowPassFrequency@FDN@@QEAAXM@Z		; FDN::setLowPassFrequency
PUBLIC	?setDampingType@FDN@@QEAAXW4LPFilterType@@@Z	; FDN::setDampingType
PUBLIC	?setDampingFrequency@FDN@@QEAAXM@Z		; FDN::setDampingFrequency
PUBLIC	?setModMix@FDN@@QEAAXM@Z			; FDN::setModMix
PUBLIC	?setModFeedback@FDN@@QEAAXM@Z			; FDN::setModFeedback
PUBLIC	?setModDepth@FDN@@QEAAXM@Z			; FDN::setModDepth
PUBLIC	?setModRate@FDN@@QEAAXM@Z			; FDN::setModRate
PUBLIC	?setRoomSize@FDN@@QEAAXMW4DiffuserDelayLogic@@W4DelayDistribution@@1@Z ; FDN::setRoomSize
PUBLIC	?setDecayInSeconds@FDN@@QEAAXM@Z		; FDN::setDecayInSeconds
PUBLIC	?initialize@FDN@@QEAAXMMHM@Z			; FDN::initialize
PUBLIC	??1FDN@@QEAA@XZ					; FDN::~FDN
PUBLIC	??0FDN@@QEAA@HHHHH@Z				; FDN::FDN
PUBLIC	?processAudio@Modulation@@UEAAMM@Z		; Modulation::processAudio
PUBLIC	?setModType@Modulation@@QEAAXW4ModulationType@@@Z ; Modulation::setModType
PUBLIC	?setSampleRate@Modulation@@UEAAXH@Z		; Modulation::setSampleRate
PUBLIC	?setModMix@Modulation@@QEAAXM@Z			; Modulation::setModMix
PUBLIC	?setModFeedback@Modulation@@QEAAXM@Z		; Modulation::setModFeedback
PUBLIC	?setModRate@Modulation@@QEAAXM@Z		; Modulation::setModRate
PUBLIC	?setModDepth@Modulation@@QEAAXM@Z		; Modulation::setModDepth
PUBLIC	?setModWet@Modulation@@QEAAXM@Z			; Modulation::setModWet
PUBLIC	?setModDry@Modulation@@QEAAXM@Z			; Modulation::setModDry
PUBLIC	?init@Modulation@@QEAAXW4ModulationType@@H@Z	; Modulation::init
PUBLIC	??1Modulation@@QEAA@XZ				; Modulation::~Modulation
PUBLIC	??0Modulation@@QEAA@XZ				; Modulation::Modulation
PUBLIC	?setModulationValue@Modulation@@AEAAXM@Z	; Modulation::setModulationValue
PUBLIC	?processAudio@HighPassFilter@@QEAAMM@Z		; HighPassFilter::processAudio
PUBLIC	?updateBuffers@HighPassFilter@@QEAAXMM@Z	; HighPassFilter::updateBuffers
PUBLIC	?updateGains@HighPassFilter@@QEAAXXZ		; HighPassFilter::updateGains
PUBLIC	?setFilterType@HighPassFilter@@QEAAXW4HPFilterType@@@Z ; HighPassFilter::setFilterType
PUBLIC	?setCutoffFrequency@HighPassFilter@@QEAAXM@Z	; HighPassFilter::setCutoffFrequency
PUBLIC	?setSampleRate@HighPassFilter@@QEAAXH@Z		; HighPassFilter::setSampleRate
PUBLIC	?init@HighPassFilter@@QEAAXH@Z			; HighPassFilter::init
PUBLIC	??1HighPassFilter@@QEAA@XZ			; HighPassFilter::~HighPassFilter
PUBLIC	??0HighPassFilter@@QEAA@HMW4HPFilterType@@@Z	; HighPassFilter::HighPassFilter
PUBLIC	?processAudio@ChannelMixer@@QEAAXPEAM0@Z	; ChannelMixer::processAudio
PUBLIC	?setMixMode@ChannelMixer@@QEAAXW4MixMode@@@Z	; ChannelMixer::setMixMode
PUBLIC	?setNumberOfOutputChannels@ChannelMixer@@QEAAXH@Z ; ChannelMixer::setNumberOfOutputChannels
PUBLIC	?setNumberOfInputChannels@ChannelMixer@@QEAAXH@Z ; ChannelMixer::setNumberOfInputChannels
PUBLIC	??1ChannelMixer@@QEAA@XZ			; ChannelMixer::~ChannelMixer
PUBLIC	??0ChannelMixer@@QEAA@HH@Z			; ChannelMixer::ChannelMixer
PUBLIC	?processAudio@ChannelSplitter@@QEAAXPEAM0@Z	; ChannelSplitter::processAudio
PUBLIC	?setNumberOfChannelsOut@ChannelSplitter@@QEAAXH@Z ; ChannelSplitter::setNumberOfChannelsOut
PUBLIC	?setNumberOfChannelsIn@ChannelSplitter@@QEAAXH@Z ; ChannelSplitter::setNumberOfChannelsIn
PUBLIC	??1ChannelSplitter@@QEAA@XZ			; ChannelSplitter::~ChannelSplitter
PUBLIC	??0ChannelSplitter@@QEAA@HH@Z			; ChannelSplitter::ChannelSplitter
PUBLIC	?setRandomInRangeDelayLines@ModMultiChannelFeedback@@AEAAXXZ ; ModMultiChannelFeedback::setRandomInRangeDelayLines
PUBLIC	?setDelayExponential@ModMultiChannelFeedback@@AEAAXXZ ; ModMultiChannelFeedback::setDelayExponential
PUBLIC	?allocateDelayLines@ModMultiChannelFeedback@@AEAAXXZ ; ModMultiChannelFeedback::allocateDelayLines
PUBLIC	?deleteDelayLines@ModMultiChannelFeedback@@AEAAXXZ ; ModMultiChannelFeedback::deleteDelayLines
PUBLIC	?constructMCF@ModMultiChannelFeedback@@AEAAXH@Z	; ModMultiChannelFeedback::constructMCF
PUBLIC	?processAudio@ModMultiChannelFeedback@@QEAAXPEAM0@Z ; ModMultiChannelFeedback::processAudio
PUBLIC	?setOscillatorIsUnipolar@ModMultiChannelFeedback@@QEAAX_N@Z ; ModMultiChannelFeedback::setOscillatorIsUnipolar
PUBLIC	?setOscillatorType@ModMultiChannelFeedback@@QEAAXW4OscillatorType@@@Z ; ModMultiChannelFeedback::setOscillatorType
PUBLIC	?setModRate@ModMultiChannelFeedback@@QEAAXM@Z	; ModMultiChannelFeedback::setModRate
PUBLIC	?setModDepth@ModMultiChannelFeedback@@QEAAXM@Z	; ModMultiChannelFeedback::setModDepth
PUBLIC	?setModValue@ModMultiChannelFeedback@@QEAAXM@Z	; ModMultiChannelFeedback::setModValue
PUBLIC	?setFilterType@ModMultiChannelFeedback@@QEAAXW4LPFilterType@@@Z ; ModMultiChannelFeedback::setFilterType
PUBLIC	?setDampingFrequency@ModMultiChannelFeedback@@QEAAXM@Z ; ModMultiChannelFeedback::setDampingFrequency
PUBLIC	?setDelayLengths@ModMultiChannelFeedback@@QEAAXMMW4DelayDistribution@@@Z ; ModMultiChannelFeedback::setDelayLengths
PUBLIC	?setSampleRate@ModMultiChannelFeedback@@QEAAXH@Z ; ModMultiChannelFeedback::setSampleRate
PUBLIC	?init@ModMultiChannelFeedback@@QEAAXMH@Z	; ModMultiChannelFeedback::init
PUBLIC	?setDecayInSeconds@ModMultiChannelFeedback@@QEAAXM@Z ; ModMultiChannelFeedback::setDecayInSeconds
PUBLIC	??1ModMultiChannelFeedback@@QEAA@XZ		; ModMultiChannelFeedback::~ModMultiChannelFeedback
PUBLIC	??0ModMultiChannelFeedback@@QEAA@H@Z		; ModMultiChannelFeedback::ModMultiChannelFeedback
PUBLIC	??_GModMultiChannelDelay@@QEAAPEAXI@Z		; ModMultiChannelDelay::`scalar deleting destructor'
PUBLIC	?constructBlocks@ModMultiChannelDiffuser@@AEAAXXZ ; ModMultiChannelDiffuser::constructBlocks
PUBLIC	?deleteBlocks@ModMultiChannelDiffuser@@AEAAXXZ	; ModMultiChannelDiffuser::deleteBlocks
PUBLIC	?initPointers@ModMultiChannelDiffuser@@AEAAXXZ	; ModMultiChannelDiffuser::initPointers
PUBLIC	?deleteInternalArrays@ModMultiChannelDiffuser@@AEAAXXZ ; ModMultiChannelDiffuser::deleteInternalArrays
PUBLIC	?initInternalArrays@ModMultiChannelDiffuser@@AEAAXXZ ; ModMultiChannelDiffuser::initInternalArrays
PUBLIC	?constructMCDF@ModMultiChannelDiffuser@@AEAAXH@Z ; ModMultiChannelDiffuser::constructMCDF
PUBLIC	?processAudio@ModMultiChannelDiffuser@@QEAAXPEAM0@Z ; ModMultiChannelDiffuser::processAudio
PUBLIC	?setSampleRate@ModMultiChannelDiffuser@@QEAAXH@Z ; ModMultiChannelDiffuser::setSampleRate
PUBLIC	?setOscillatorIsUnipolar@ModMultiChannelDiffuser@@QEAAX_N@Z ; ModMultiChannelDiffuser::setOscillatorIsUnipolar
PUBLIC	?setOscillatorType@ModMultiChannelDiffuser@@QEAAXW4OscillatorType@@@Z ; ModMultiChannelDiffuser::setOscillatorType
PUBLIC	?setModValue@ModMultiChannelDiffuser@@QEAAXM@Z	; ModMultiChannelDiffuser::setModValue
PUBLIC	?setModRate@ModMultiChannelDiffuser@@QEAAXM@Z	; ModMultiChannelDiffuser::setModRate
PUBLIC	?setModDepth@ModMultiChannelDiffuser@@QEAAXM@Z	; ModMultiChannelDiffuser::setModDepth
PUBLIC	?setMakeUpGainDB@ModMultiChannelDiffuser@@QEAAXM@Z ; ModMultiChannelDiffuser::setMakeUpGainDB
PUBLIC	?setDelayLinesLength@ModMultiChannelDiffuser@@QEAAXMMW4DelayDistribution@@@Z ; ModMultiChannelDiffuser::setDelayLinesLength
PUBLIC	?init@ModMultiChannelDiffuser@@QEAAXMH@Z	; ModMultiChannelDiffuser::init
PUBLIC	??1ModMultiChannelDiffuser@@QEAA@XZ		; ModMultiChannelDiffuser::~ModMultiChannelDiffuser
PUBLIC	??0ModMultiChannelDiffuser@@QEAA@H@Z		; ModMultiChannelDiffuser::ModMultiChannelDiffuser
PUBLIC	??_GModDelay@@QEAAPEAXI@Z			; ModDelay::`scalar deleting destructor'
PUBLIC	?constructMCDL@ModMultiChannelDelay@@AEAAXH@Z	; ModMultiChannelDelay::constructMCDL
PUBLIC	?constructDelayObjects@ModMultiChannelDelay@@AEAAXXZ ; ModMultiChannelDelay::constructDelayObjects
PUBLIC	?deleteDelayLines@ModMultiChannelDelay@@AEAAXXZ	; ModMultiChannelDelay::deleteDelayLines
PUBLIC	?setExponentialDelayLengths@ModMultiChannelDelay@@AEAAXXZ ; ModMultiChannelDelay::setExponentialDelayLengths
PUBLIC	?setRandomInRangeDelayLines@ModMultiChannelDelay@@AEAAXXZ ; ModMultiChannelDelay::setRandomInRangeDelayLines
PUBLIC	?setEqualDelayLines@ModMultiChannelDelay@@AEAAXXZ ; ModMultiChannelDelay::setEqualDelayLines
PUBLIC	?processAudio@ModMultiChannelDelay@@QEAAXPEAM0@Z ; ModMultiChannelDelay::processAudio
PUBLIC	?setSampleRate@ModMultiChannelDelay@@QEAAXH@Z	; ModMultiChannelDelay::setSampleRate
PUBLIC	?setOscillatorIsUnipolar@ModMultiChannelDelay@@QEAAX_N@Z ; ModMultiChannelDelay::setOscillatorIsUnipolar
PUBLIC	?setOscillatorType@ModMultiChannelDelay@@QEAAXW4OscillatorType@@@Z ; ModMultiChannelDelay::setOscillatorType
PUBLIC	?setModValueInMsec@ModMultiChannelDelay@@QEAAXM@Z ; ModMultiChannelDelay::setModValueInMsec
PUBLIC	?setModRate@ModMultiChannelDelay@@QEAAXM@Z	; ModMultiChannelDelay::setModRate
PUBLIC	?setModDepth@ModMultiChannelDelay@@QEAAXM@Z	; ModMultiChannelDelay::setModDepth
PUBLIC	?setMakeUpGaindB@ModMultiChannelDelay@@QEAAXM@Z	; ModMultiChannelDelay::setMakeUpGaindB
PUBLIC	?setDelayLinesLength@ModMultiChannelDelay@@QEAAXMMW4DelayDistribution@@@Z ; ModMultiChannelDelay::setDelayLinesLength
PUBLIC	?initDelayLines@ModMultiChannelDelay@@QEAAXMH@Z	; ModMultiChannelDelay::initDelayLines
PUBLIC	??1ModMultiChannelDelay@@QEAA@XZ		; ModMultiChannelDelay::~ModMultiChannelDelay
PUBLIC	??0ModMultiChannelDelay@@QEAA@H@Z		; ModMultiChannelDelay::ModMultiChannelDelay
PUBLIC	?processAudio@Householder@@QEAAXPEAM0@Z		; Householder::processAudio
PUBLIC	?setNumberOfChannels@Householder@@QEAAXH@Z	; Householder::setNumberOfChannels
PUBLIC	??0Householder@@QEAA@H@Z			; Householder::Householder
PUBLIC	??_GFlipPolarity@@QEAAPEAXI@Z			; FlipPolarity::`scalar deleting destructor'
PUBLIC	??_GHadamard@@QEAAPEAXI@Z			; Hadamard::`scalar deleting destructor'
PUBLIC	??_GMultiChannelDelay@@QEAAPEAXI@Z		; MultiChannelDelay::`scalar deleting destructor'
PUBLIC	?constructBlocks@MultiChannelDiffuser@@AEAAXXZ	; MultiChannelDiffuser::constructBlocks
PUBLIC	?deleteBlocks@MultiChannelDiffuser@@AEAAXXZ	; MultiChannelDiffuser::deleteBlocks
PUBLIC	?initPointers@MultiChannelDiffuser@@AEAAXXZ	; MultiChannelDiffuser::initPointers
PUBLIC	?deleteInternalArrays@MultiChannelDiffuser@@AEAAXXZ ; MultiChannelDiffuser::deleteInternalArrays
PUBLIC	?initInternalArrays@MultiChannelDiffuser@@AEAAXXZ ; MultiChannelDiffuser::initInternalArrays
PUBLIC	?constructMCDF@MultiChannelDiffuser@@AEAAXH@Z	; MultiChannelDiffuser::constructMCDF
PUBLIC	?processAudio@MultiChannelDiffuser@@QEAAXPEAM0@Z ; MultiChannelDiffuser::processAudio
PUBLIC	?setSampleRate@MultiChannelDiffuser@@QEAAXH@Z	; MultiChannelDiffuser::setSampleRate
PUBLIC	?setDelayLinesLength@MultiChannelDiffuser@@QEAAXMMW4DelayDistribution@@@Z ; MultiChannelDiffuser::setDelayLinesLength
PUBLIC	?init@MultiChannelDiffuser@@QEAAXMH@Z		; MultiChannelDiffuser::init
PUBLIC	??1MultiChannelDiffuser@@QEAA@XZ		; MultiChannelDiffuser::~MultiChannelDiffuser
PUBLIC	??0MultiChannelDiffuser@@QEAA@H@Z		; MultiChannelDiffuser::MultiChannelDiffuser
PUBLIC	?deleteFlipVector@FlipPolarity@@AEAAXXZ		; FlipPolarity::deleteFlipVector
PUBLIC	?processAudio@FlipPolarity@@QEAAXPEAM0@Z	; FlipPolarity::processAudio
PUBLIC	?setNumberOfChannels@FlipPolarity@@QEAAXH@Z	; FlipPolarity::setNumberOfChannels
PUBLIC	??1FlipPolarity@@QEAA@XZ			; FlipPolarity::~FlipPolarity
PUBLIC	??0FlipPolarity@@QEAA@H@Z			; FlipPolarity::FlipPolarity
PUBLIC	?processAudio@Hadamard@@QEAAXPEAM0@Z		; Hadamard::processAudio
PUBLIC	?hadamardScaled@Hadamard@@QEAAXPEAMH@Z		; Hadamard::hadamardScaled
PUBLIC	?hadamardUnscaled@Hadamard@@QEAAXPEAMH@Z	; Hadamard::hadamardUnscaled
PUBLIC	?setNumberOfChannels@Hadamard@@QEAAXH@Z		; Hadamard::setNumberOfChannels
PUBLIC	?deleteMatrix@Hadamard@@QEAAXXZ			; Hadamard::deleteMatrix
PUBLIC	??1Hadamard@@QEAA@XZ				; Hadamard::~Hadamard
PUBLIC	??0Hadamard@@QEAA@H@Z				; Hadamard::Hadamard
PUBLIC	??_GDelay@@QEAAPEAXI@Z				; Delay::`scalar deleting destructor'
PUBLIC	?constructMCDL@MultiChannelDelay@@AEAAXH@Z	; MultiChannelDelay::constructMCDL
PUBLIC	?constructDelayObjects@MultiChannelDelay@@AEAAXXZ ; MultiChannelDelay::constructDelayObjects
PUBLIC	?deleteDelayLines@MultiChannelDelay@@AEAAXXZ	; MultiChannelDelay::deleteDelayLines
PUBLIC	?setExponentialDelayLengths@MultiChannelDelay@@AEAAXXZ ; MultiChannelDelay::setExponentialDelayLengths
PUBLIC	?setRandomInRangeDelayLines@MultiChannelDelay@@AEAAXXZ ; MultiChannelDelay::setRandomInRangeDelayLines
PUBLIC	?setEqualDelayLines@MultiChannelDelay@@AEAAXXZ	; MultiChannelDelay::setEqualDelayLines
PUBLIC	?processAudio@MultiChannelDelay@@QEAAXPEAM0@Z	; MultiChannelDelay::processAudio
PUBLIC	?setSampleRate@MultiChannelDelay@@QEAAXH@Z	; MultiChannelDelay::setSampleRate
PUBLIC	?setDelayLinesLength@MultiChannelDelay@@QEAAXMMW4DelayDistribution@@@Z ; MultiChannelDelay::setDelayLinesLength
PUBLIC	?initDelayLines@MultiChannelDelay@@QEAAXMH@Z	; MultiChannelDelay::initDelayLines
PUBLIC	??1MultiChannelDelay@@QEAA@XZ			; MultiChannelDelay::~MultiChannelDelay
PUBLIC	??0MultiChannelDelay@@QEAA@H@Z			; MultiChannelDelay::MultiChannelDelay
PUBLIC	??_GLFO@@QEAAPEAXI@Z				; LFO::`scalar deleting destructor'
PUBLIC	?processAudio@ModDelay@@UEAAMM@Z		; ModDelay::processAudio
PUBLIC	?setSampleRate@ModDelay@@UEAAXH@Z		; ModDelay::setSampleRate
PUBLIC	?setLFOUnipolar@ModDelay@@QEAAX_N@Z		; ModDelay::setLFOUnipolar
PUBLIC	?setLFOWaveform@ModDelay@@QEAAXW4OscillatorType@@@Z ; ModDelay::setLFOWaveform
PUBLIC	?setModRate@ModDelay@@QEAAXM@Z			; ModDelay::setModRate
PUBLIC	?setDelayInmsec@ModDelay@@QEAAXM@Z		; ModDelay::setDelayInmsec
PUBLIC	?setDeltaDelayValue@ModDelay@@QEAAXM@Z		; ModDelay::setDeltaDelayValue
PUBLIC	?init@ModDelay@@QEAAXMHW4OscillatorType@@@Z	; ModDelay::init
PUBLIC	??1ModDelay@@QEAA@XZ				; ModDelay::~ModDelay
PUBLIC	??0ModDelay@@QEAA@XZ				; ModDelay::ModDelay
PUBLIC	?createTable@LFO@@AEAAXXZ			; LFO::createTable
PUBLIC	?clearTable@LFO@@AEAAXXZ			; LFO::clearTable
PUBLIC	?increaseLFOCounter@LFO@@AEAAXXZ		; LFO::increaseLFOCounter
PUBLIC	?computeIncrement@LFO@@AEAAXXZ			; LFO::computeIncrement
PUBLIC	?processAudio@LFO@@QEAAMXZ			; LFO::processAudio
PUBLIC	?setSampleRate@LFO@@QEAAXH@Z			; LFO::setSampleRate
PUBLIC	?setLFOunipolar@LFO@@QEAAX_N@Z			; LFO::setLFOunipolar
PUBLIC	?setLFOWaveform@LFO@@QEAAXW4OscillatorType@@@Z	; LFO::setLFOWaveform
PUBLIC	?setLFOfrequency@LFO@@QEAAXM@Z			; LFO::setLFOfrequency
PUBLIC	?init@LFO@@QEAAXW4OscillatorType@@H@Z		; LFO::init
PUBLIC	??1LFO@@QEAA@XZ					; LFO::~LFO
PUBLIC	??0LFO@@QEAA@W4OscillatorType@@@Z		; LFO::LFO
PUBLIC	?setSampleRate@LowPassFilter@@QEAAXH@Z		; LowPassFilter::setSampleRate
PUBLIC	?randomInRange@@YAMMM@Z				; randomInRange
PUBLIC	?exponentialVector@@YA?AV?$vector@MV?$allocator@M@std@@@std@@MMH@Z ; exponentialVector
PUBLIC	?mapValueOutsideRange@@YAMMMM@Z			; mapValueOutsideRange
PUBLIC	?mapValueIntoRange@@YAMMMM@Z			; mapValueIntoRange
PUBLIC	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ	; std::_Fake_proxy_ptr_impl::_Release
PUBLIC	??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
PUBLIC	?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z ; std::_Container_base0::_Swap_proxy_and_iterators
PUBLIC	?abs@@YANN@Z					; abs
PUBLIC	?createEffectInstance@@YAPEAVAudioEffect@@P6A_JPEAUAEffect@@HH_JPEAXM@Z@Z ; createEffectInstance
EXTRN	??_EShimmer@@UEAAPEAXI@Z:PROC			; Shimmer::`vector deleting destructor'
?MAX_LPF_FREQUENCY_LOG@@3MB DD 01H DUP (?)		; MAX_LPF_FREQUENCY_LOG
?MIN_LPF_FREQUENCY_LOG@@3MB DD 01H DUP (?)		; MIN_LPF_FREQUENCY_LOG
?MAX_DAMPING_FREQUENCY_LOG@@3MB DD 01H DUP (?)		; MAX_DAMPING_FREQUENCY_LOG
?LPF_FILTER_MIN_FREQ_LOG@@3MB DD 01H DUP (?)		; LPF_FILTER_MIN_FREQ_LOG
?kCTCorrFactorAntiLog@@3NB DQ 01H DUP (?)		; kCTCorrFactorAntiLog
?LPF_FILTER_MAX_FREQ_LOG@@3MB DD 01H DUP (?)		; LPF_FILTER_MAX_FREQ_LOG
	ALIGN	8

?kCTCorrFactorZero@@3NB DQ 01H DUP (?)			; kCTCorrFactorZero
?MIN_DAMPING_FREQUENCY_LOG@@3MB DD 01H DUP (?)		; MIN_DAMPING_FREQUENCY_LOG
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Zero_range@PEAM@std@@YAPEAMQEAM0@Z DD imagerel $LN4
	DD	imagerel $LN4+32
	DD	imagerel $unwind$??$_Zero_range@PEAM@std@@YAPEAMQEAM0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_memmove@PEAPEAVDelay@@PEAPEAV1@@std@@YAPEAPEAVDelay@@PEAPEAV1@00@Z DD imagerel $LN4
	DD	imagerel $LN4+49
	DD	imagerel $unwind$??$_Copy_memmove@PEAPEAVDelay@@PEAPEAV1@@std@@YAPEAPEAVDelay@@PEAPEAV1@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_memmove@PEAHPEAH@std@@YAPEAHPEAH00@Z DD imagerel $LN4
	DD	imagerel $LN4+49
	DD	imagerel $unwind$??$_Copy_memmove@PEAHPEAH@std@@YAPEAHPEAH00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_memmove@PEAPEAVModDelay@@PEAPEAV1@@std@@YAPEAPEAVModDelay@@PEAPEAV1@00@Z DD imagerel $LN4
	DD	imagerel $LN4+49
	DD	imagerel $unwind$??$_Copy_memmove@PEAPEAVModDelay@@PEAPEAV1@@std@@YAPEAPEAVModDelay@@PEAPEAV1@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_memmove@PEAPEAVMultiChannelDiffuser@@PEAPEAV1@@std@@YAPEAPEAVMultiChannelDiffuser@@PEAPEAV1@00@Z DD imagerel $LN4
	DD	imagerel $LN4+49
	DD	imagerel $unwind$??$_Copy_memmove@PEAPEAVMultiChannelDiffuser@@PEAPEAV1@@std@@YAPEAPEAVMultiChannelDiffuser@@PEAPEAV1@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_memmove@PEAPEAVModMultiChannelDiffuser@@PEAPEAV1@@std@@YAPEAPEAVModMultiChannelDiffuser@@PEAPEAV1@00@Z DD imagerel $LN4
	DD	imagerel $LN4+49
	DD	imagerel $unwind$??$_Copy_memmove@PEAPEAVModMultiChannelDiffuser@@PEAPEAV1@@std@@YAPEAPEAVModMultiChannelDiffuser@@PEAPEAV1@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_memmove@PEAPEAVLowPassFilter@@PEAPEAV1@@std@@YAPEAPEAVLowPassFilter@@PEAPEAV1@00@Z DD imagerel $LN4
	DD	imagerel $LN4+49
	DD	imagerel $unwind$??$_Copy_memmove@PEAPEAVLowPassFilter@@PEAPEAV1@@std@@YAPEAPEAVLowPassFilter@@PEAPEAV1@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_memmove@PEAPEAVModulation@@PEAPEAV1@@std@@YAPEAPEAVModulation@@PEAPEAV1@00@Z DD imagerel $LN4
	DD	imagerel $LN4+49
	DD	imagerel $unwind$??$_Copy_memmove@PEAPEAVModulation@@PEAPEAV1@@std@@YAPEAPEAVModulation@@PEAPEAV1@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_memmove@PEAPEAVHighPassFilter@@PEAPEAV1@@std@@YAPEAPEAVHighPassFilter@@PEAPEAV1@00@Z DD imagerel $LN4
	DD	imagerel $LN4+49
	DD	imagerel $unwind$??$_Copy_memmove@PEAPEAVHighPassFilter@@PEAPEAV1@@std@@YAPEAPEAVHighPassFilter@@PEAPEAV1@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_value_construct_n@V?$allocator@M@std@@@std@@YAPEAMPEAM_KAEAV?$allocator@M@0@@Z DD imagerel $LN18
	DD	imagerel $LN18+47
	DD	imagerel $unwind$??$_Uninitialized_value_construct_n@V?$allocator@M@std@@@std@@YAPEAMPEAM_KAEAV?$allocator@M@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAPEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@YAPEAPEAVDelay@@QEAPEAV1@0PEAPEAV1@AEAV?$allocator@PEAVDelay@@@0@@Z DD imagerel $LN16
	DD	imagerel $LN16+53
	DD	imagerel $unwind$??$_Uninitialized_move@PEAPEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@YAPEAPEAVDelay@@QEAPEAV1@0PEAPEAV1@AEAV?$allocator@PEAVDelay@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAHV?$allocator@H@std@@@std@@YAPEAHQEAH0PEAHAEAV?$allocator@H@0@@Z DD imagerel $LN16
	DD	imagerel $LN16+53
	DD	imagerel $unwind$??$_Uninitialized_move@PEAHV?$allocator@H@std@@@std@@YAPEAHQEAH0PEAHAEAV?$allocator@H@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAPEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@YAPEAPEAVModDelay@@QEAPEAV1@0PEAPEAV1@AEAV?$allocator@PEAVModDelay@@@0@@Z DD imagerel $LN16
	DD	imagerel $LN16+53
	DD	imagerel $unwind$??$_Uninitialized_move@PEAPEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@YAPEAPEAVModDelay@@QEAPEAV1@0PEAPEAV1@AEAV?$allocator@PEAVModDelay@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAPEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@YAPEAPEAVMultiChannelDiffuser@@QEAPEAV1@0PEAPEAV1@AEAV?$allocator@PEAVMultiChannelDiffuser@@@0@@Z DD imagerel $LN16
	DD	imagerel $LN16+53
	DD	imagerel $unwind$??$_Uninitialized_move@PEAPEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@YAPEAPEAVMultiChannelDiffuser@@QEAPEAV1@0PEAPEAV1@AEAV?$allocator@PEAVMultiChannelDiffuser@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAPEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@YAPEAPEAVModMultiChannelDiffuser@@QEAPEAV1@0PEAPEAV1@AEAV?$allocator@PEAVModMultiChannelDiffuser@@@0@@Z DD imagerel $LN16
	DD	imagerel $LN16+53
	DD	imagerel $unwind$??$_Uninitialized_move@PEAPEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@YAPEAPEAVModMultiChannelDiffuser@@QEAPEAV1@0PEAPEAV1@AEAV?$allocator@PEAVModMultiChannelDiffuser@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAPEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@YAPEAPEAVLowPassFilter@@QEAPEAV1@0PEAPEAV1@AEAV?$allocator@PEAVLowPassFilter@@@0@@Z DD imagerel $LN16
	DD	imagerel $LN16+53
	DD	imagerel $unwind$??$_Uninitialized_move@PEAPEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@YAPEAPEAVLowPassFilter@@QEAPEAV1@0PEAPEAV1@AEAV?$allocator@PEAVLowPassFilter@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAPEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@YAPEAPEAVModulation@@QEAPEAV1@0PEAPEAV1@AEAV?$allocator@PEAVModulation@@@0@@Z DD imagerel $LN16
	DD	imagerel $LN16+53
	DD	imagerel $unwind$??$_Uninitialized_move@PEAPEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@YAPEAPEAVModulation@@QEAPEAV1@0PEAPEAV1@AEAV?$allocator@PEAVModulation@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$07@std@@YA_K_K@Z DD imagerel $LN7
	DD	imagerel $LN7+38
	DD	imagerel $unwind$??$_Get_size_of_n@$07@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAPEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@YAPEAPEAVHighPassFilter@@QEAPEAV1@0PEAPEAV1@AEAV?$allocator@PEAVHighPassFilter@@@0@@Z DD imagerel $LN16
	DD	imagerel $LN16+53
	DD	imagerel $unwind$??$_Uninitialized_move@PEAPEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@YAPEAPEAVHighPassFilter@@QEAPEAV1@0PEAPEAV1@AEAV?$allocator@PEAVHighPassFilter@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy_raw@?$vector@MV?$allocator@M@std@@@std@@AEAAX_K@Z DD imagerel $LN33
	DD	imagerel $LN33+134
	DD	imagerel $unwind$?_Buy_raw@?$vector@MV?$allocator@M@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Ufill@?$vector@MV?$allocator@M@std@@@std@@AEAAPEAMPEAM_KU_Value_init_tag@2@@Z DD imagerel $LN20
	DD	imagerel $LN20+50
	DD	imagerel $unwind$?_Ufill@?$vector@MV?$allocator@M@std@@@std@@AEAAPEAMPEAM_KU_Value_init_tag@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy_nonzero@?$vector@MV?$allocator@M@std@@@std@@AEAAX_K@Z DD imagerel $LN38
	DD	imagerel $LN38+140
	DD	imagerel $unwind$?_Buy_nonzero@?$vector@MV?$allocator@M@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@PEAVDelay@@@std@@QEAAPEAPEAVDelay@@_K@Z DD imagerel $LN30
	DD	imagerel $LN30+107
	DD	imagerel $unwind$?allocate@?$allocator@PEAVDelay@@@std@@QEAAPEAPEAVDelay@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Umove@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@AEAAPEAPEAVDelay@@PEAPEAV3@00@Z DD imagerel $LN18
	DD	imagerel $LN18+50
	DD	imagerel $unwind$?_Umove@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@AEAAPEAPEAVDelay@@PEAPEAV3@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@AEAAXQEAPEAVDelay@@_K1@Z DD imagerel $LN25
	DD	imagerel $LN25+136
	DD	imagerel $unwind$?_Change_array@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@AEAAXQEAPEAVDelay@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@CAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlength@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@H@std@@QEAAPEAH_K@Z DD imagerel $LN30
	DD	imagerel $LN30+107
	DD	imagerel $unwind$?allocate@?$allocator@H@std@@QEAAPEAH_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Umove@?$vector@HV?$allocator@H@std@@@std@@AEAAPEAHPEAH00@Z DD imagerel $LN18
	DD	imagerel $LN18+50
	DD	imagerel $unwind$?_Umove@?$vector@HV?$allocator@H@std@@@std@@AEAAPEAHPEAH00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@HV?$allocator@H@std@@@std@@AEAAXQEAH_K1@Z DD imagerel $LN25
	DD	imagerel $LN25+136
	DD	imagerel $unwind$?_Change_array@?$vector@HV?$allocator@H@std@@@std@@AEAAXQEAH_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@PEAVModDelay@@@std@@QEAAPEAPEAVModDelay@@_K@Z DD imagerel $LN30
	DD	imagerel $LN30+107
	DD	imagerel $unwind$?allocate@?$allocator@PEAVModDelay@@@std@@QEAAPEAPEAVModDelay@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Umove@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@AEAAPEAPEAVModDelay@@PEAPEAV3@00@Z DD imagerel $LN18
	DD	imagerel $LN18+50
	DD	imagerel $unwind$?_Umove@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@AEAAPEAPEAVModDelay@@PEAPEAV3@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@AEAAXQEAPEAVModDelay@@_K1@Z DD imagerel $LN25
	DD	imagerel $LN25+136
	DD	imagerel $unwind$?_Change_array@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@AEAAXQEAPEAVModDelay@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@CAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlength@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@PEAVMultiChannelDiffuser@@@std@@QEAAPEAPEAVMultiChannelDiffuser@@_K@Z DD imagerel $LN30
	DD	imagerel $LN30+107
	DD	imagerel $unwind$?allocate@?$allocator@PEAVMultiChannelDiffuser@@@std@@QEAAPEAPEAVMultiChannelDiffuser@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Umove@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@AEAAPEAPEAVMultiChannelDiffuser@@PEAPEAV3@00@Z DD imagerel $LN18
	DD	imagerel $LN18+50
	DD	imagerel $unwind$?_Umove@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@AEAAPEAPEAVMultiChannelDiffuser@@PEAPEAV3@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@AEAAXQEAPEAVMultiChannelDiffuser@@_K1@Z DD imagerel $LN25
	DD	imagerel $LN25+136
	DD	imagerel $unwind$?_Change_array@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@AEAAXQEAPEAVMultiChannelDiffuser@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@CAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlength@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@PEAVModMultiChannelDiffuser@@@std@@QEAAPEAPEAVModMultiChannelDiffuser@@_K@Z DD imagerel $LN30
	DD	imagerel $LN30+107
	DD	imagerel $unwind$?allocate@?$allocator@PEAVModMultiChannelDiffuser@@@std@@QEAAPEAPEAVModMultiChannelDiffuser@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Umove@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@AEAAPEAPEAVModMultiChannelDiffuser@@PEAPEAV3@00@Z DD imagerel $LN18
	DD	imagerel $LN18+50
	DD	imagerel $unwind$?_Umove@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@AEAAPEAPEAVModMultiChannelDiffuser@@PEAPEAV3@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@AEAAXQEAPEAVModMultiChannelDiffuser@@_K1@Z DD imagerel $LN25
	DD	imagerel $LN25+136
	DD	imagerel $unwind$?_Change_array@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@AEAAXQEAPEAVModMultiChannelDiffuser@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@CAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlength@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@PEAVLowPassFilter@@@std@@QEAAPEAPEAVLowPassFilter@@_K@Z DD imagerel $LN30
	DD	imagerel $LN30+107
	DD	imagerel $unwind$?allocate@?$allocator@PEAVLowPassFilter@@@std@@QEAAPEAPEAVLowPassFilter@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Umove@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@AEAAPEAPEAVLowPassFilter@@PEAPEAV3@00@Z DD imagerel $LN18
	DD	imagerel $LN18+50
	DD	imagerel $unwind$?_Umove@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@AEAAPEAPEAVLowPassFilter@@PEAPEAV3@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@AEAAXQEAPEAVLowPassFilter@@_K1@Z DD imagerel $LN25
	DD	imagerel $LN25+136
	DD	imagerel $unwind$?_Change_array@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@AEAAXQEAPEAVLowPassFilter@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@CAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlength@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@PEAVModulation@@@std@@QEAAPEAPEAVModulation@@_K@Z DD imagerel $LN30
	DD	imagerel $LN30+107
	DD	imagerel $unwind$?allocate@?$allocator@PEAVModulation@@@std@@QEAAPEAPEAVModulation@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Umove@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@AEAAPEAPEAVModulation@@PEAPEAV3@00@Z DD imagerel $LN18
	DD	imagerel $LN18+50
	DD	imagerel $unwind$?_Umove@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@AEAAPEAPEAVModulation@@PEAPEAV3@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@AEAAXQEAPEAVModulation@@_K1@Z DD imagerel $LN25
	DD	imagerel $LN25+136
	DD	imagerel $unwind$?_Change_array@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@AEAAXQEAPEAVModulation@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@CAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlength@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@PEAVHighPassFilter@@@std@@QEAAPEAPEAVHighPassFilter@@_K@Z DD imagerel $LN30
	DD	imagerel $LN30+107
	DD	imagerel $unwind$?allocate@?$allocator@PEAVHighPassFilter@@@std@@QEAAPEAPEAVHighPassFilter@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Umove@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@AEAAPEAPEAVHighPassFilter@@PEAPEAV3@00@Z DD imagerel $LN18
	DD	imagerel $LN18+50
	DD	imagerel $unwind$?_Umove@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@AEAAPEAPEAVHighPassFilter@@PEAPEAV3@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@AEAAXQEAPEAVHighPassFilter@@_K1@Z DD imagerel $LN25
	DD	imagerel $LN25+136
	DD	imagerel $unwind$?_Change_array@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@AEAAXQEAPEAVHighPassFilter@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@CAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlength@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Tidy_guard@V?$vector@MV?$allocator@M@std@@@std@@@std@@QEAA@XZ DD imagerel $LN29
	DD	imagerel $LN29+98
	DD	imagerel $unwind$??1?$_Tidy_guard@V?$vector@MV?$allocator@M@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_n_copies_of_ty@U_Value_init_tag@std@@@?$vector@MV?$allocator@M@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN62
	DD	imagerel $LN62+209
	DD	imagerel $unwind$??$_Construct_n_copies_of_ty@U_Value_init_tag@std@@@?$vector@MV?$allocator@M@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_reallocate@PEAVDelay@@@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@QEAAPEAPEAVDelay@@QEAPEAV2@$$QEAPEAV2@@Z DD imagerel $LN120
	DD	imagerel $LN120+400
	DD	imagerel $unwind$??$_Emplace_reallocate@PEAVDelay@@@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@QEAAPEAPEAVDelay@@QEAPEAV2@$$QEAPEAV2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_reallocate@H@?$vector@HV?$allocator@H@std@@@std@@QEAAPEAHQEAH$$QEAH@Z DD imagerel $LN120
	DD	imagerel $LN120+400
	DD	imagerel $unwind$??$_Emplace_reallocate@H@?$vector@HV?$allocator@H@std@@@std@@QEAAPEAHQEAH$$QEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_reallocate@PEAVModDelay@@@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEAAPEAPEAVModDelay@@QEAPEAV2@$$QEAPEAV2@@Z DD imagerel $LN120
	DD	imagerel $LN120+400
	DD	imagerel $unwind$??$_Emplace_reallocate@PEAVModDelay@@@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEAAPEAPEAVModDelay@@QEAPEAV2@$$QEAPEAV2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_reallocate@PEAVMultiChannelDiffuser@@@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEAAPEAPEAVMultiChannelDiffuser@@QEAPEAV2@$$QEAPEAV2@@Z DD imagerel $LN120
	DD	imagerel $LN120+400
	DD	imagerel $unwind$??$_Emplace_reallocate@PEAVMultiChannelDiffuser@@@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEAAPEAPEAVMultiChannelDiffuser@@QEAPEAV2@$$QEAPEAV2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_reallocate@PEAVModMultiChannelDiffuser@@@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEAAPEAPEAVModMultiChannelDiffuser@@QEAPEAV2@$$QEAPEAV2@@Z DD imagerel $LN120
	DD	imagerel $LN120+400
	DD	imagerel $unwind$??$_Emplace_reallocate@PEAVModMultiChannelDiffuser@@@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEAAPEAPEAVModMultiChannelDiffuser@@QEAPEAV2@$$QEAPEAV2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_reallocate@PEAVLowPassFilter@@@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEAAPEAPEAVLowPassFilter@@QEAPEAV2@$$QEAPEAV2@@Z DD imagerel $LN120
	DD	imagerel $LN120+400
	DD	imagerel $unwind$??$_Emplace_reallocate@PEAVLowPassFilter@@@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEAAPEAPEAVLowPassFilter@@QEAPEAV2@$$QEAPEAV2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_reallocate@PEAVModulation@@@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@QEAAPEAPEAVModulation@@QEAPEAV2@$$QEAPEAV2@@Z DD imagerel $LN120
	DD	imagerel $LN120+400
	DD	imagerel $unwind$??$_Emplace_reallocate@PEAVModulation@@@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@QEAAPEAPEAVModulation@@QEAPEAV2@$$QEAPEAV2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_reallocate@PEAVHighPassFilter@@@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEAAPEAPEAVHighPassFilter@@QEAPEAV2@$$QEAPEAV2@@Z DD imagerel $LN120
	DD	imagerel $LN120+400
	DD	imagerel $unwind$??$_Emplace_reallocate@PEAVHighPassFilter@@@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEAAPEAPEAVHighPassFilter@@QEAPEAV2@$$QEAPEAV2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@PEAVDelay@@@std@@QEAAXQEAPEAVDelay@@_K@Z DD imagerel $LN21
	DD	imagerel $LN21+67
	DD	imagerel $unwind$?deallocate@?$allocator@PEAVDelay@@@std@@QEAAXQEAPEAVDelay@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@H@std@@QEAAXQEAH_K@Z DD imagerel $LN21
	DD	imagerel $LN21+67
	DD	imagerel $unwind$?deallocate@?$allocator@H@std@@QEAAXQEAH_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@PEAVModDelay@@@std@@QEAAXQEAPEAVModDelay@@_K@Z DD imagerel $LN21
	DD	imagerel $LN21+67
	DD	imagerel $unwind$?deallocate@?$allocator@PEAVModDelay@@@std@@QEAAXQEAPEAVModDelay@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@PEAVMultiChannelDiffuser@@@std@@QEAAXQEAPEAVMultiChannelDiffuser@@_K@Z DD imagerel $LN21
	DD	imagerel $LN21+67
	DD	imagerel $unwind$?deallocate@?$allocator@PEAVMultiChannelDiffuser@@@std@@QEAAXQEAPEAVMultiChannelDiffuser@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@PEAVModMultiChannelDiffuser@@@std@@QEAAXQEAPEAVModMultiChannelDiffuser@@_K@Z DD imagerel $LN21
	DD	imagerel $LN21+67
	DD	imagerel $unwind$?deallocate@?$allocator@PEAVModMultiChannelDiffuser@@@std@@QEAAXQEAPEAVModMultiChannelDiffuser@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@PEAVLowPassFilter@@@std@@QEAAXQEAPEAVLowPassFilter@@_K@Z DD imagerel $LN21
	DD	imagerel $LN21+67
	DD	imagerel $unwind$?deallocate@?$allocator@PEAVLowPassFilter@@@std@@QEAAXQEAPEAVLowPassFilter@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@PEAVModulation@@@std@@QEAAXQEAPEAVModulation@@_K@Z DD imagerel $LN21
	DD	imagerel $LN21+67
	DD	imagerel $unwind$?deallocate@?$allocator@PEAVModulation@@@std@@QEAAXQEAPEAVModulation@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@PEAVHighPassFilter@@@std@@QEAAXQEAPEAVHighPassFilter@@_K@Z DD imagerel $LN21
	DD	imagerel $LN21+67
	DD	imagerel $unwind$?deallocate@?$allocator@PEAVHighPassFilter@@@std@@QEAAXQEAPEAVHighPassFilter@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Move_assign@?$vector@MV?$allocator@M@std@@@std@@AEAAXAEAV12@U_Equal_allocators@2@@Z DD imagerel $LN30
	DD	imagerel $LN30+141
	DD	imagerel $unwind$?_Move_assign@?$vector@MV?$allocator@M@std@@@std@@AEAAXAEAV12@U_Equal_allocators@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Reallocate_exactly@?$vector@MV?$allocator@M@std@@@std@@AEAAX_K@Z DD imagerel $LN78
	DD	imagerel $LN78+177
	DD	imagerel $unwind$?_Reallocate_exactly@?$vector@MV?$allocator@M@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@AEAAXXZ DD imagerel $LN25
	DD	imagerel $LN25+93
	DD	imagerel $unwind$?_Tidy@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AEAAXXZ DD imagerel $LN25
	DD	imagerel $LN25+93
	DD	imagerel $unwind$?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@AEAAXXZ DD imagerel $LN25
	DD	imagerel $LN25+93
	DD	imagerel $unwind$?_Tidy@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@AEAAXXZ DD imagerel $LN25
	DD	imagerel $LN25+93
	DD	imagerel $unwind$?_Tidy@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@AEAAXXZ DD imagerel $LN25
	DD	imagerel $LN25+93
	DD	imagerel $unwind$?_Tidy@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@AEAAXXZ DD imagerel $LN25
	DD	imagerel $LN25+93
	DD	imagerel $unwind$?_Tidy@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@AEAAXXZ DD imagerel $LN25
	DD	imagerel $LN25+93
	DD	imagerel $unwind$?_Tidy@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@AEAAXXZ DD imagerel $LN25
	DD	imagerel $LN25+93
	DD	imagerel $unwind$?_Tidy@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@MV?$allocator@M@std@@@std@@QEAA@_KAEBV?$allocator@M@1@@Z DD imagerel $LN68
	DD	imagerel $LN68+226
	DD	imagerel $unwind$??0?$vector@MV?$allocator@M@std@@@std@@QEAA@_KAEBV?$allocator@M@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$vector@MV?$allocator@M@std@@@std@@QEAAAEAV01@$$QEAV01@@Z DD imagerel $LN34
	DD	imagerel $LN34+149
	DD	imagerel $unwind$??4?$vector@MV?$allocator@M@std@@@std@@QEAAAEAV01@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$vector@MV?$allocator@M@std@@@std@@QEAAX_K@Z DD imagerel $LN9
	DD	imagerel $LN9+33
	DD	imagerel $unwind$?reserve@?$vector@MV?$allocator@M@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@QEAA@XZ DD imagerel $LN28
	DD	imagerel $LN28+93
	DD	imagerel $unwind$??1?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@HV?$allocator@H@std@@@std@@QEAA@XZ DD imagerel $LN28
	DD	imagerel $LN28+93
	DD	imagerel $unwind$??1?$vector@HV?$allocator@H@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEAA@XZ DD imagerel $LN28
	DD	imagerel $LN28+93
	DD	imagerel $unwind$??1?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEAA@XZ DD imagerel $LN28
	DD	imagerel $LN28+93
	DD	imagerel $unwind$??1?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEAA@XZ DD imagerel $LN28
	DD	imagerel $LN28+93
	DD	imagerel $unwind$??1?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEAA@XZ DD imagerel $LN28
	DD	imagerel $LN28+93
	DD	imagerel $unwind$??1?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@QEAA@XZ DD imagerel $LN28
	DD	imagerel $LN28+93
	DD	imagerel $unwind$??1?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEAA@XZ DD imagerel $LN28
	DD	imagerel $LN28+93
	DD	imagerel $unwind$??1?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GPSMVocoder@@QEAAPEAXI@Z DD imagerel $LN6
	DD	imagerel $LN6+36
	DD	imagerel $unwind$??_GPSMVocoder@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GFDN@@QEAAPEAXI@Z DD imagerel $LN6
	DD	imagerel $LN6+36
	DD	imagerel $unwind$??_GFDN@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1Shimmer@@UEAA@XZ DD imagerel $LN23
	DD	imagerel $LN23+140
	DD	imagerel $unwind$??1Shimmer@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getVendorString@Shimmer@@UEAA_NPEAD@Z DD imagerel $LN6
	DD	imagerel $LN6+43
	DD	imagerel $unwind$?getVendorString@Shimmer@@UEAA_NPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getEffectName@Shimmer@@UEAA_NPEAD@Z DD imagerel $LN6
	DD	imagerel $LN6+43
	DD	imagerel $unwind$?getEffectName@Shimmer@@UEAA_NPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setChunk@Shimmer@@UEAAHPEAXH_N@Z DD imagerel $LN4
	DD	imagerel $LN4+231
	DD	imagerel $unwind$?setChunk@Shimmer@@UEAAHPEAXH_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getChunk@Shimmer@@UEAAHPEAPEAX_N@Z DD imagerel $LN4
	DD	imagerel $LN4+21
	DD	imagerel $unwind$?getChunk@Shimmer@@UEAAHPEAPEAX_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getProgramNameIndexed@Shimmer@@UEAA_NHHPEAD@Z DD imagerel $LN5
	DD	imagerel $LN5+51
	DD	imagerel $unwind$?getProgramNameIndexed@Shimmer@@UEAA_NHHPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setProgram@Shimmer@@UEAAXH@Z DD imagerel $LN4
	DD	imagerel $LN4+243
	DD	imagerel $unwind$?setProgram@Shimmer@@UEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?InitPresets@Shimmer@@AEAAXXZ DD imagerel $LN10
	DD	imagerel $LN10+1186
	DD	imagerel $unwind$?InitPresets@Shimmer@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getParameterName@Shimmer@@UEAAXHPEAD@Z DD imagerel $LN42
	DD	imagerel $LN42+191
	DD	imagerel $unwind$?getParameterName@Shimmer@@UEAAXHPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getParameterDisplay@Shimmer@@UEAAXHPEAD@Z DD imagerel $LN28
	DD	imagerel $LN28+382
	DD	imagerel $unwind$?getParameterDisplay@Shimmer@@UEAAXHPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getParameterLabel@Shimmer@@UEAAXHPEAD@Z DD imagerel $LN42
	DD	imagerel $LN42+115
	DD	imagerel $unwind$?getParameterLabel@Shimmer@@UEAAXHPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setParameter@Shimmer@@UEAAXHM@Z DD imagerel $LN150
	DD	imagerel $LN150+1225
	DD	imagerel $unwind$?setParameter@Shimmer@@UEAAXHM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?processReplacing@Shimmer@@UEAAXPEAPEAM0H@Z DD imagerel $LN12
	DD	imagerel $LN12+394
	DD	imagerel $unwind$?processReplacing@Shimmer@@UEAAXPEAPEAM0H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setSampleRate@Shimmer@@UEAAXM@Z DD imagerel $LN4
	DD	imagerel $LN4+108
	DD	imagerel $unwind$?setSampleRate@Shimmer@@UEAAXM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?InitPlugin@Shimmer@@AEAAXXZ DD imagerel $LN206
	DD	imagerel $LN206+1141
	DD	imagerel $unwind$?InitPlugin@Shimmer@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??InitPlugin@Shimmer@@AEAAXXZ@4HA DD imagerel ?dtor$0@?0??InitPlugin@Shimmer@@AEAAXXZ@4HA
	DD	imagerel ?dtor$0@?0??InitPlugin@Shimmer@@AEAAXXZ@4HA+32
	DD	imagerel $unwind$?dtor$0@?0??InitPlugin@Shimmer@@AEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0??InitPlugin@Shimmer@@AEAAXXZ@4HA DD imagerel ?dtor$1@?0??InitPlugin@Shimmer@@AEAAXXZ@4HA
	DD	imagerel ?dtor$1@?0??InitPlugin@Shimmer@@AEAAXXZ@4HA+32
	DD	imagerel $unwind$?dtor$1@?0??InitPlugin@Shimmer@@AEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0??InitPlugin@Shimmer@@AEAAXXZ@4HA DD imagerel ?dtor$2@?0??InitPlugin@Shimmer@@AEAAXXZ@4HA
	DD	imagerel ?dtor$2@?0??InitPlugin@Shimmer@@AEAAXXZ@4HA+32
	DD	imagerel $unwind$?dtor$2@?0??InitPlugin@Shimmer@@AEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$3@?0??InitPlugin@Shimmer@@AEAAXXZ@4HA DD imagerel ?dtor$3@?0??InitPlugin@Shimmer@@AEAAXXZ@4HA
	DD	imagerel ?dtor$3@?0??InitPlugin@Shimmer@@AEAAXXZ@4HA+32
	DD	imagerel $unwind$?dtor$3@?0??InitPlugin@Shimmer@@AEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GShimmer@@UEAAPEAXI@Z DD imagerel $LN6
	DD	imagerel $LN6+52
	DD	imagerel $unwind$??_GShimmer@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0Shimmer@@QEAA@P6A_JPEAUAEffect@@HH_JPEAXM@Z@Z DD imagerel $LN14
	DD	imagerel $LN14+265
	DD	imagerel $unwind$??0Shimmer@@QEAA@P6A_JPEAUAEffect@@HH_JPEAXM@Z@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?updateMix@Shimmer@@AEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+95
	DD	imagerel $unwind$?updateMix@Shimmer@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__ELPF_FILTER_MIN_FREQ_LOG@@YAXXZ DD imagerel ??__ELPF_FILTER_MIN_FREQ_LOG@@YAXXZ
	DD	imagerel ??__ELPF_FILTER_MIN_FREQ_LOG@@YAXXZ+38
	DD	imagerel $unwind$??__ELPF_FILTER_MIN_FREQ_LOG@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__ELPF_FILTER_MAX_FREQ_LOG@@YAXXZ DD imagerel ??__ELPF_FILTER_MAX_FREQ_LOG@@YAXXZ
	DD	imagerel ??__ELPF_FILTER_MAX_FREQ_LOG@@YAXXZ+38
	DD	imagerel $unwind$??__ELPF_FILTER_MAX_FREQ_LOG@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__EMAX_DAMPING_FREQUENCY_LOG@@YAXXZ DD imagerel ??__EMAX_DAMPING_FREQUENCY_LOG@@YAXXZ
	DD	imagerel ??__EMAX_DAMPING_FREQUENCY_LOG@@YAXXZ+38
	DD	imagerel $unwind$??__EMAX_DAMPING_FREQUENCY_LOG@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__EMIN_DAMPING_FREQUENCY_LOG@@YAXXZ DD imagerel ??__EMIN_DAMPING_FREQUENCY_LOG@@YAXXZ
	DD	imagerel ??__EMIN_DAMPING_FREQUENCY_LOG@@YAXXZ+38
	DD	imagerel $unwind$??__EMIN_DAMPING_FREQUENCY_LOG@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setParameters@PSMVocoder@@QEAAXAEBUPSMVocoderParameters@@@Z DD imagerel $LN8
	DD	imagerel $LN8+66
	DD	imagerel $unwind$?setParameters@PSMVocoder@@QEAAXAEBUPSMVocoderParameters@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?processAudioSample@PSMVocoder@@UEAANN@Z DD imagerel $LN161
	DD	imagerel $LN161+1733
	DD	imagerel $unwind$?processAudioSample@PSMVocoder@@UEAANN@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?findPeaksAndRegionsOfInfluence@PSMVocoder@@QEAAXXZ DD imagerel $LN88
	DD	imagerel $LN88+758
	DD	imagerel $unwind$?findPeaksAndRegionsOfInfluence@PSMVocoder@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?findPreviousNearestPeak@PSMVocoder@@QEAAHH@Z DD imagerel $LN20
	DD	imagerel $LN20+132
	DD	imagerel $unwind$?findPreviousNearestPeak@PSMVocoder@@QEAAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setPitchShift@PSMVocoder@@QEAAXN@Z DD imagerel $LN14
	DD	imagerel $LN14+459
	DD	imagerel $unwind$?setPitchShift@PSMVocoder@@QEAAXN@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reset@PSMVocoder@@UEAA_NN@Z DD imagerel $LN16
	DD	imagerel $LN16+222
	DD	imagerel $unwind$?reset@PSMVocoder@@UEAA_NN@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1PSMVocoder@@QEAA@XZ DD imagerel $LN12
	DD	imagerel $LN12+109
	DD	imagerel $unwind$??1PSMVocoder@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0PSMVocoder@@QEAA@XZ DD imagerel $LN34
	DD	imagerel $LN34+429
	DD	imagerel $unwind$??0PSMVocoder@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1PhaseVocoder@@QEAA@XZ DD imagerel $LN8
	DD	imagerel $LN8+64
	DD	imagerel $unwind$??1PhaseVocoder@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resample@@YA_NPEAN0IIW4interpolation@@N0@Z DD imagerel $LN94
	DD	imagerel $LN94+315
	DD	imagerel $unwind$?resample@@YA_NPEAN0IIW4interpolation@@N0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?principalArg@@YANN@Z DD imagerel $LN6
	DD	imagerel $LN6+79
	DD	imagerel $unwind$?principalArg@@YANN@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__EkCTCorrFactorAntiLog@@YAXXZ DD imagerel ??__EkCTCorrFactorAntiLog@@YAXXZ
	DD	imagerel ??__EkCTCorrFactorAntiLog@@YAXXZ+47
	DD	imagerel $unwind$??__EkCTCorrFactorAntiLog@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__EkCTCorrFactorZero@@YAXXZ DD imagerel ??__EkCTCorrFactorZero@@YAXXZ
	DD	imagerel ??__EkCTCorrFactorZero@@YAXXZ+39
	DD	imagerel $unwind$??__EkCTCorrFactorZero@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GModulation@@QEAAPEAXI@Z DD imagerel $LN17
	DD	imagerel $LN17+88
	DD	imagerel $unwind$??_GModulation@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GHighPassFilter@@QEAAPEAXI@Z DD imagerel $LN6
	DD	imagerel $LN6+28
	DD	imagerel $unwind$??_GHighPassFilter@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GModMultiChannelFeedback@@QEAAPEAXI@Z DD imagerel $LN6
	DD	imagerel $LN6+36
	DD	imagerel $unwind$??_GModMultiChannelFeedback@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GModMultiChannelDiffuser@@QEAAPEAXI@Z DD imagerel $LN6
	DD	imagerel $LN6+36
	DD	imagerel $unwind$??_GModMultiChannelDiffuser@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GMultiChannelDiffuser@@QEAAPEAXI@Z DD imagerel $LN6
	DD	imagerel $LN6+36
	DD	imagerel $unwind$??_GMultiChannelDiffuser@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GChannelMixer@@QEAAPEAXI@Z DD imagerel $LN6
	DD	imagerel $LN6+28
	DD	imagerel $unwind$??_GChannelMixer@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GChannelSplitter@@QEAAPEAXI@Z DD imagerel $LN6
	DD	imagerel $LN6+28
	DD	imagerel $unwind$??_GChannelSplitter@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?initInternalArrays@FDN@@AEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+102
	DD	imagerel $unwind$?initInternalArrays@FDN@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deleteChorus@FDN@@AEAAXXZ DD imagerel $LN35
	DD	imagerel $LN35+188
	DD	imagerel $unwind$?deleteChorus@FDN@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deleteFilters@FDN@@AEAAXXZ DD imagerel $LN43
	DD	imagerel $LN43+211
	DD	imagerel $unwind$?deleteFilters@FDN@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deleteFeedbackBlock@FDN@@AEAAXXZ DD imagerel $LN10
	DD	imagerel $LN10+42
	DD	imagerel $unwind$?deleteFeedbackBlock@FDN@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deleteDiffusionBlocks@FDN@@AEAAXXZ DD imagerel $LN48
	DD	imagerel $LN48+272
	DD	imagerel $unwind$?deleteDiffusionBlocks@FDN@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deleteInterfaceBlocks@FDN@@AEAAXXZ DD imagerel $LN15
	DD	imagerel $LN15+52
	DD	imagerel $unwind$?deleteInterfaceBlocks@FDN@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?constructModulation@FDN@@AEAAXXZ DD imagerel $LN25
	DD	imagerel $LN25+125
	DD	imagerel $unwind$?constructModulation@FDN@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??constructModulation@FDN@@AEAAXXZ@4HA DD imagerel ?dtor$0@?0??constructModulation@FDN@@AEAAXXZ@4HA
	DD	imagerel ?dtor$0@?0??constructModulation@FDN@@AEAAXXZ@4HA+29
	DD	imagerel $unwind$?dtor$0@?0??constructModulation@FDN@@AEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?constructFilters@FDN@@AEAAXXZ DD imagerel $LN36
	DD	imagerel $LN36+298
	DD	imagerel $unwind$?constructFilters@FDN@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?constructDiffusionBlocks@FDN@@AEAAXXZ DD imagerel $LN102
	DD	imagerel $LN102+571
	DD	imagerel $unwind$?constructDiffusionBlocks@FDN@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA DD imagerel ?dtor$0@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA
	DD	imagerel ?dtor$0@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA+32
	DD	imagerel $unwind$?dtor$0@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA DD imagerel ?dtor$1@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA
	DD	imagerel ?dtor$1@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA+32
	DD	imagerel $unwind$?dtor$1@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$3@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA DD imagerel ?dtor$3@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA
	DD	imagerel ?dtor$3@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA+32
	DD	imagerel $unwind$?dtor$3@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$7@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA DD imagerel ?dtor$7@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA
	DD	imagerel ?dtor$7@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA+32
	DD	imagerel $unwind$?dtor$7@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$4@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA DD imagerel ?dtor$4@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA
	DD	imagerel ?dtor$4@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA+29
	DD	imagerel $unwind$?dtor$4@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$5@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA DD imagerel ?dtor$5@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA
	DD	imagerel ?dtor$5@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA+29
	DD	imagerel $unwind$?dtor$5@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA DD imagerel ?dtor$2@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA
	DD	imagerel ?dtor$2@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA+32
	DD	imagerel $unwind$?dtor$2@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?constructFDN@FDN@@AEAAXHHHHH@Z DD imagerel $LN120
	DD	imagerel $LN120+843
	DD	imagerel $unwind$?constructFDN@FDN@@AEAAXHHHHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0??constructFDN@FDN@@AEAAXHHHHH@Z@4HA DD imagerel ?dtor$2@?0??constructFDN@FDN@@AEAAXHHHHH@Z@4HA
	DD	imagerel ?dtor$2@?0??constructFDN@FDN@@AEAAXHHHHH@Z@4HA+29
	DD	imagerel $unwind$?dtor$2@?0??constructFDN@FDN@@AEAAXHHHHH@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$7@?0??constructFDN@FDN@@AEAAXHHHHH@Z@4HA DD imagerel ?dtor$7@?0??constructFDN@FDN@@AEAAXHHHHH@Z@4HA
	DD	imagerel ?dtor$7@?0??constructFDN@FDN@@AEAAXHHHHH@Z@4HA+29
	DD	imagerel $unwind$?dtor$7@?0??constructFDN@FDN@@AEAAXHHHHH@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$3@?0??constructFDN@FDN@@AEAAXHHHHH@Z@4HA DD imagerel ?dtor$3@?0??constructFDN@FDN@@AEAAXHHHHH@Z@4HA
	DD	imagerel ?dtor$3@?0??constructFDN@FDN@@AEAAXHHHHH@Z@4HA+29
	DD	imagerel $unwind$?dtor$3@?0??constructFDN@FDN@@AEAAXHHHHH@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$10@?0??constructFDN@FDN@@AEAAXHHHHH@Z@4HA DD imagerel ?dtor$10@?0??constructFDN@FDN@@AEAAXHHHHH@Z@4HA
	DD	imagerel ?dtor$10@?0??constructFDN@FDN@@AEAAXHHHHH@Z@4HA+29
	DD	imagerel $unwind$?dtor$10@?0??constructFDN@FDN@@AEAAXHHHHH@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$4@?0??constructFDN@FDN@@AEAAXHHHHH@Z@4HA DD imagerel ?dtor$4@?0??constructFDN@FDN@@AEAAXHHHHH@Z@4HA
	DD	imagerel ?dtor$4@?0??constructFDN@FDN@@AEAAXHHHHH@Z@4HA+29
	DD	imagerel $unwind$?dtor$4@?0??constructFDN@FDN@@AEAAXHHHHH@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setEqualDiffuserDelayLengths@FDN@@AEAAXMMW4DelayDistribution@@@Z DD imagerel $LN29
	DD	imagerel $LN29+209
	DD	imagerel $unwind$?setEqualDiffuserDelayLengths@FDN@@AEAAXMMW4DelayDistribution@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setDoubledDiffuserDelayLengths@FDN@@AEAAXMMW4DelayDistribution@@@Z DD imagerel $LN29
	DD	imagerel $LN29+187
	DD	imagerel $unwind$?setDoubledDiffuserDelayLengths@FDN@@AEAAXMMW4DelayDistribution@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?processAudio@FDN@@QEAAXPEAM0@Z DD imagerel $LN178
	DD	imagerel $LN178+1217
	DD	imagerel $unwind$?processAudio@FDN@@QEAAXPEAM0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setSampleRate@FDN@@QEAAXH@Z DD imagerel $LN112
	DD	imagerel $LN112+509
	DD	imagerel $unwind$?setSampleRate@FDN@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setFeedbackDelayLengths@FDN@@QEAAXMMW4DelayDistribution@@@Z DD imagerel $LN11
	DD	imagerel $LN11+87
	DD	imagerel $unwind$?setFeedbackDelayLengths@FDN@@QEAAXMMW4DelayDistribution@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setDiffuserDelayLengths@FDN@@QEAAXMW4DiffuserDelayLogic@@W4DelayDistribution@@M@Z DD imagerel $LN61
	DD	imagerel $LN61+365
	DD	imagerel $unwind$?setDiffuserDelayLengths@FDN@@QEAAXMW4DiffuserDelayLogic@@W4DelayDistribution@@M@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setStereoSpread@FDN@@QEAAXM@Z DD imagerel $LN29
	DD	imagerel $LN29+108
	DD	imagerel $unwind$?setStereoSpread@FDN@@QEAAXM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setHighPassType@FDN@@QEAAXW4HPFilterType@@@Z DD imagerel $LN16
	DD	imagerel $LN16+82
	DD	imagerel $unwind$?setHighPassType@FDN@@QEAAXW4HPFilterType@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setLowPassType@FDN@@QEAAXW4LPFilterType@@@Z DD imagerel $LN16
	DD	imagerel $LN16+87
	DD	imagerel $unwind$?setLowPassType@FDN@@QEAAXW4LPFilterType@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setHighPassFrequency@FDN@@QEAAXM@Z DD imagerel $LN16
	DD	imagerel $LN16+94
	DD	imagerel $unwind$?setHighPassFrequency@FDN@@QEAAXM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setLowPassFrequency@FDN@@QEAAXM@Z DD imagerel $LN16
	DD	imagerel $LN16+91
	DD	imagerel $unwind$?setLowPassFrequency@FDN@@QEAAXM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setDampingType@FDN@@QEAAXW4LPFilterType@@@Z DD imagerel $LN20
	DD	imagerel $LN20+76
	DD	imagerel $unwind$?setDampingType@FDN@@QEAAXW4LPFilterType@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setDampingFrequency@FDN@@QEAAXM@Z DD imagerel $LN20
	DD	imagerel $LN20+93
	DD	imagerel $unwind$?setDampingFrequency@FDN@@QEAAXM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setModMix@FDN@@QEAAXM@Z DD imagerel $LN4
	DD	imagerel $LN4+73
	DD	imagerel $unwind$?setModMix@FDN@@QEAAXM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setRoomSize@FDN@@QEAAXMW4DiffuserDelayLogic@@W4DelayDistribution@@1@Z DD imagerel $LN113
	DD	imagerel $LN113+745
	DD	imagerel $unwind$?setRoomSize@FDN@@QEAAXMW4DiffuserDelayLogic@@W4DelayDistribution@@1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setDecayInSeconds@FDN@@QEAAXM@Z DD imagerel $LN20
	DD	imagerel $LN20+187
	DD	imagerel $unwind$?setDecayInSeconds@FDN@@QEAAXM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?initialize@FDN@@QEAAXMMHM@Z DD imagerel $LN436
	DD	imagerel $LN436+1904
	DD	imagerel $unwind$?initialize@FDN@@QEAAXMMHM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1FDN@@QEAA@XZ DD imagerel $LN368
	DD	imagerel $LN368+1471
	DD	imagerel $unwind$??1FDN@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0FDN@@QEAA@HHHHH@Z DD imagerel $LN61
	DD	imagerel $LN61+162
	DD	imagerel $unwind$??0FDN@@QEAA@HHHHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?processAudio@Modulation@@UEAAMM@Z DD imagerel $LN11
	DD	imagerel $LN11+112
	DD	imagerel $unwind$?processAudio@Modulation@@UEAAMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setModType@Modulation@@QEAAXW4ModulationType@@@Z DD imagerel $LN29
	DD	imagerel $LN29+151
	DD	imagerel $unwind$?setModType@Modulation@@QEAAXW4ModulationType@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?init@Modulation@@QEAAXW4ModulationType@@H@Z DD imagerel $LN31
	DD	imagerel $LN31+164
	DD	imagerel $unwind$?init@Modulation@@QEAAXW4ModulationType@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1Modulation@@QEAA@XZ DD imagerel $LN13
	DD	imagerel $LN13+71
	DD	imagerel $unwind$??1Modulation@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0Modulation@@QEAA@XZ DD imagerel $LN6
	DD	imagerel $LN6+33
	DD	imagerel $unwind$??0Modulation@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?processAudio@HighPassFilter@@QEAAMM@Z DD imagerel $LN6
	DD	imagerel $LN6+118
	DD	imagerel $unwind$?processAudio@HighPassFilter@@QEAAMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?updateGains@HighPassFilter@@QEAAXXZ DD imagerel $LN13
	DD	imagerel $LN13+828
	DD	imagerel $unwind$?updateGains@HighPassFilter@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0HighPassFilter@@QEAA@HMW4HPFilterType@@@Z DD imagerel $LN4
	DD	imagerel $LN4+63
	DD	imagerel $unwind$??0HighPassFilter@@QEAA@HMW4HPFilterType@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setRandomInRangeDelayLines@ModMultiChannelFeedback@@AEAAXXZ DD imagerel $LN23
	DD	imagerel $LN23+227
	DD	imagerel $unwind$?setRandomInRangeDelayLines@ModMultiChannelFeedback@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setDelayExponential@ModMultiChannelFeedback@@AEAAXXZ DD imagerel $LN75
	DD	imagerel $LN75+316
	DD	imagerel $unwind$?setDelayExponential@ModMultiChannelFeedback@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocateDelayLines@ModMultiChannelFeedback@@AEAAXXZ DD imagerel $LN22
	DD	imagerel $LN22+109
	DD	imagerel $unwind$?allocateDelayLines@ModMultiChannelFeedback@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??allocateDelayLines@ModMultiChannelFeedback@@AEAAXXZ@4HA DD imagerel ?dtor$0@?0??allocateDelayLines@ModMultiChannelFeedback@@AEAAXXZ@4HA
	DD	imagerel ?dtor$0@?0??allocateDelayLines@ModMultiChannelFeedback@@AEAAXXZ@4HA+29
	DD	imagerel $unwind$?dtor$0@?0??allocateDelayLines@ModMultiChannelFeedback@@AEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deleteDelayLines@ModMultiChannelFeedback@@AEAAXXZ DD imagerel $LN32
	DD	imagerel $LN32+194
	DD	imagerel $unwind$?deleteDelayLines@ModMultiChannelFeedback@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?constructMCF@ModMultiChannelFeedback@@AEAAXH@Z DD imagerel $LN33
	DD	imagerel $LN33+171
	DD	imagerel $unwind$?constructMCF@ModMultiChannelFeedback@@AEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0??constructMCF@ModMultiChannelFeedback@@AEAAXH@Z@4HA DD imagerel ?dtor$1@?0??constructMCF@ModMultiChannelFeedback@@AEAAXH@Z@4HA
	DD	imagerel ?dtor$1@?0??constructMCF@ModMultiChannelFeedback@@AEAAXH@Z@4HA+29
	DD	imagerel $unwind$?dtor$1@?0??constructMCF@ModMultiChannelFeedback@@AEAAXH@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?processAudio@ModMultiChannelFeedback@@QEAAXPEAM0@Z DD imagerel $LN146
	DD	imagerel $LN146+715
	DD	imagerel $unwind$?processAudio@ModMultiChannelFeedback@@QEAAXPEAM0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setOscillatorType@ModMultiChannelFeedback@@QEAAXW4OscillatorType@@@Z DD imagerel $LN20
	DD	imagerel $LN20+91
	DD	imagerel $unwind$?setOscillatorType@ModMultiChannelFeedback@@QEAAXW4OscillatorType@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setFilterType@ModMultiChannelFeedback@@QEAAXW4LPFilterType@@@Z DD imagerel $LN18
	DD	imagerel $LN18+75
	DD	imagerel $unwind$?setFilterType@ModMultiChannelFeedback@@QEAAXW4LPFilterType@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setDampingFrequency@ModMultiChannelFeedback@@QEAAXM@Z DD imagerel $LN18
	DD	imagerel $LN18+92
	DD	imagerel $unwind$?setDampingFrequency@ModMultiChannelFeedback@@QEAAXM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setDelayLengths@ModMultiChannelFeedback@@QEAAXMMW4DelayDistribution@@@Z DD imagerel $LN9
	DD	imagerel $LN9+57
	DD	imagerel $unwind$?setDelayLengths@ModMultiChannelFeedback@@QEAAXMMW4DelayDistribution@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setSampleRate@ModMultiChannelFeedback@@QEAAXH@Z DD imagerel $LN14
	DD	imagerel $LN14+80
	DD	imagerel $unwind$?setSampleRate@ModMultiChannelFeedback@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?init@ModMultiChannelFeedback@@QEAAXMH@Z DD imagerel $LN18
	DD	imagerel $LN18+120
	DD	imagerel $unwind$?init@ModMultiChannelFeedback@@QEAAXMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setDecayInSeconds@ModMultiChannelFeedback@@QEAAXM@Z DD imagerel $LN18
	DD	imagerel $LN18+170
	DD	imagerel $unwind$?setDecayInSeconds@ModMultiChannelFeedback@@QEAAXM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1ModMultiChannelFeedback@@QEAA@XZ DD imagerel $LN31
	DD	imagerel $LN31+114
	DD	imagerel $unwind$??1ModMultiChannelFeedback@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ModMultiChannelFeedback@@QEAA@H@Z DD imagerel $LN42
	DD	imagerel $LN42+188
	DD	imagerel $unwind$??0ModMultiChannelFeedback@@QEAA@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0???0ModMultiChannelFeedback@@QEAA@H@Z@4HA DD imagerel ?dtor$2@?0???0ModMultiChannelFeedback@@QEAA@H@Z@4HA
	DD	imagerel ?dtor$2@?0???0ModMultiChannelFeedback@@QEAA@H@Z@4HA+29
	DD	imagerel $unwind$?dtor$2@?0???0ModMultiChannelFeedback@@QEAA@H@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GModMultiChannelDelay@@QEAAPEAXI@Z DD imagerel $LN6
	DD	imagerel $LN6+36
	DD	imagerel $unwind$??_GModMultiChannelDelay@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?constructBlocks@ModMultiChannelDiffuser@@AEAAXXZ DD imagerel $LN55
	DD	imagerel $LN55+244
	DD	imagerel $unwind$?constructBlocks@ModMultiChannelDiffuser@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??constructBlocks@ModMultiChannelDiffuser@@AEAAXXZ@4HA DD imagerel ?dtor$0@?0??constructBlocks@ModMultiChannelDiffuser@@AEAAXXZ@4HA
	DD	imagerel ?dtor$0@?0??constructBlocks@ModMultiChannelDiffuser@@AEAAXXZ@4HA+29
	DD	imagerel $unwind$?dtor$0@?0??constructBlocks@ModMultiChannelDiffuser@@AEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$4@?0??constructBlocks@ModMultiChannelDiffuser@@AEAAXXZ@4HA DD imagerel ?dtor$4@?0??constructBlocks@ModMultiChannelDiffuser@@AEAAXXZ@4HA
	DD	imagerel ?dtor$4@?0??constructBlocks@ModMultiChannelDiffuser@@AEAAXXZ@4HA+29
	DD	imagerel $unwind$?dtor$4@?0??constructBlocks@ModMultiChannelDiffuser@@AEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0??constructBlocks@ModMultiChannelDiffuser@@AEAAXXZ@4HA DD imagerel ?dtor$1@?0??constructBlocks@ModMultiChannelDiffuser@@AEAAXXZ@4HA
	DD	imagerel ?dtor$1@?0??constructBlocks@ModMultiChannelDiffuser@@AEAAXXZ@4HA+29
	DD	imagerel $unwind$?dtor$1@?0??constructBlocks@ModMultiChannelDiffuser@@AEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0??constructBlocks@ModMultiChannelDiffuser@@AEAAXXZ@4HA DD imagerel ?dtor$2@?0??constructBlocks@ModMultiChannelDiffuser@@AEAAXXZ@4HA
	DD	imagerel ?dtor$2@?0??constructBlocks@ModMultiChannelDiffuser@@AEAAXXZ@4HA+29
	DD	imagerel $unwind$?dtor$2@?0??constructBlocks@ModMultiChannelDiffuser@@AEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deleteBlocks@ModMultiChannelDiffuser@@AEAAXXZ DD imagerel $LN32
	DD	imagerel $LN32+180
	DD	imagerel $unwind$?deleteBlocks@ModMultiChannelDiffuser@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deleteInternalArrays@ModMultiChannelDiffuser@@AEAAXXZ DD imagerel $LN8
	DD	imagerel $LN8+55
	DD	imagerel $unwind$?deleteInternalArrays@ModMultiChannelDiffuser@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?initInternalArrays@ModMultiChannelDiffuser@@AEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+88
	DD	imagerel $unwind$?initInternalArrays@ModMultiChannelDiffuser@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?constructMCDF@ModMultiChannelDiffuser@@AEAAXH@Z DD imagerel $LN61
	DD	imagerel $LN61+317
	DD	imagerel $unwind$?constructMCDF@ModMultiChannelDiffuser@@AEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??constructMCDF@ModMultiChannelDiffuser@@AEAAXH@Z@4HA DD imagerel ?dtor$0@?0??constructMCDF@ModMultiChannelDiffuser@@AEAAXH@Z@4HA
	DD	imagerel ?dtor$0@?0??constructMCDF@ModMultiChannelDiffuser@@AEAAXH@Z@4HA+29
	DD	imagerel $unwind$?dtor$0@?0??constructMCDF@ModMultiChannelDiffuser@@AEAAXH@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$4@?0??constructMCDF@ModMultiChannelDiffuser@@AEAAXH@Z@4HA DD imagerel ?dtor$4@?0??constructMCDF@ModMultiChannelDiffuser@@AEAAXH@Z@4HA
	DD	imagerel ?dtor$4@?0??constructMCDF@ModMultiChannelDiffuser@@AEAAXH@Z@4HA+29
	DD	imagerel $unwind$?dtor$4@?0??constructMCDF@ModMultiChannelDiffuser@@AEAAXH@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0??constructMCDF@ModMultiChannelDiffuser@@AEAAXH@Z@4HA DD imagerel ?dtor$1@?0??constructMCDF@ModMultiChannelDiffuser@@AEAAXH@Z@4HA
	DD	imagerel ?dtor$1@?0??constructMCDF@ModMultiChannelDiffuser@@AEAAXH@Z@4HA+29
	DD	imagerel $unwind$?dtor$1@?0??constructMCDF@ModMultiChannelDiffuser@@AEAAXH@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0??constructMCDF@ModMultiChannelDiffuser@@AEAAXH@Z@4HA DD imagerel ?dtor$2@?0??constructMCDF@ModMultiChannelDiffuser@@AEAAXH@Z@4HA
	DD	imagerel ?dtor$2@?0??constructMCDF@ModMultiChannelDiffuser@@AEAAXH@Z@4HA+29
	DD	imagerel $unwind$?dtor$2@?0??constructMCDF@ModMultiChannelDiffuser@@AEAAXH@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?processAudio@ModMultiChannelDiffuser@@QEAAXPEAM0@Z DD imagerel $LN27
	DD	imagerel $LN27+193
	DD	imagerel $unwind$?processAudio@ModMultiChannelDiffuser@@QEAAXPEAM0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setSampleRate@ModMultiChannelDiffuser@@QEAAXH@Z DD imagerel $LN16
	DD	imagerel $LN16+90
	DD	imagerel $unwind$?setSampleRate@ModMultiChannelDiffuser@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setOscillatorType@ModMultiChannelDiffuser@@QEAAXW4OscillatorType@@@Z DD imagerel $LN22
	DD	imagerel $LN22+92
	DD	imagerel $unwind$?setOscillatorType@ModMultiChannelDiffuser@@QEAAXW4OscillatorType@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setMakeUpGainDB@ModMultiChannelDiffuser@@QEAAXM@Z DD imagerel $LN18
	DD	imagerel $LN18+73
	DD	imagerel $unwind$?setMakeUpGainDB@ModMultiChannelDiffuser@@QEAAXM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?init@ModMultiChannelDiffuser@@QEAAXMH@Z DD imagerel $LN34
	DD	imagerel $LN34+163
	DD	imagerel $unwind$?init@ModMultiChannelDiffuser@@QEAAXMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1ModMultiChannelDiffuser@@QEAA@XZ DD imagerel $LN40
	DD	imagerel $LN40+220
	DD	imagerel $unwind$??1ModMultiChannelDiffuser@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ModMultiChannelDiffuser@@QEAA@H@Z DD imagerel $LN63
	DD	imagerel $LN63+320
	DD	imagerel $unwind$??0ModMultiChannelDiffuser@@QEAA@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0ModMultiChannelDiffuser@@QEAA@H@Z@4HA DD imagerel ?dtor$0@?0???0ModMultiChannelDiffuser@@QEAA@H@Z@4HA
	DD	imagerel ?dtor$0@?0???0ModMultiChannelDiffuser@@QEAA@H@Z@4HA+29
	DD	imagerel $unwind$?dtor$0@?0???0ModMultiChannelDiffuser@@QEAA@H@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$4@?0???0ModMultiChannelDiffuser@@QEAA@H@Z@4HA DD imagerel ?dtor$4@?0???0ModMultiChannelDiffuser@@QEAA@H@Z@4HA
	DD	imagerel ?dtor$4@?0???0ModMultiChannelDiffuser@@QEAA@H@Z@4HA+29
	DD	imagerel $unwind$?dtor$4@?0???0ModMultiChannelDiffuser@@QEAA@H@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???0ModMultiChannelDiffuser@@QEAA@H@Z@4HA DD imagerel ?dtor$1@?0???0ModMultiChannelDiffuser@@QEAA@H@Z@4HA
	DD	imagerel ?dtor$1@?0???0ModMultiChannelDiffuser@@QEAA@H@Z@4HA+29
	DD	imagerel $unwind$?dtor$1@?0???0ModMultiChannelDiffuser@@QEAA@H@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0???0ModMultiChannelDiffuser@@QEAA@H@Z@4HA DD imagerel ?dtor$2@?0???0ModMultiChannelDiffuser@@QEAA@H@Z@4HA
	DD	imagerel ?dtor$2@?0???0ModMultiChannelDiffuser@@QEAA@H@Z@4HA+29
	DD	imagerel $unwind$?dtor$2@?0???0ModMultiChannelDiffuser@@QEAA@H@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GModDelay@@QEAAPEAXI@Z DD imagerel $LN14
	DD	imagerel $LN14+88
	DD	imagerel $unwind$??_GModDelay@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?constructMCDL@ModMultiChannelDelay@@AEAAXH@Z DD imagerel $LN35
	DD	imagerel $LN35+152
	DD	imagerel $unwind$?constructMCDL@ModMultiChannelDelay@@AEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??constructMCDL@ModMultiChannelDelay@@AEAAXH@Z@4HA DD imagerel ?dtor$0@?0??constructMCDL@ModMultiChannelDelay@@AEAAXH@Z@4HA
	DD	imagerel ?dtor$0@?0??constructMCDL@ModMultiChannelDelay@@AEAAXH@Z@4HA+29
	DD	imagerel $unwind$?dtor$0@?0??constructMCDL@ModMultiChannelDelay@@AEAAXH@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?constructDelayObjects@ModMultiChannelDelay@@AEAAXXZ DD imagerel $LN22
	DD	imagerel $LN22+109
	DD	imagerel $unwind$?constructDelayObjects@ModMultiChannelDelay@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??constructDelayObjects@ModMultiChannelDelay@@AEAAXXZ@4HA DD imagerel ?dtor$0@?0??constructDelayObjects@ModMultiChannelDelay@@AEAAXXZ@4HA
	DD	imagerel ?dtor$0@?0??constructDelayObjects@ModMultiChannelDelay@@AEAAXXZ@4HA+29
	DD	imagerel $unwind$?dtor$0@?0??constructDelayObjects@ModMultiChannelDelay@@AEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deleteDelayLines@ModMultiChannelDelay@@AEAAXXZ DD imagerel $LN32
	DD	imagerel $LN32+188
	DD	imagerel $unwind$?deleteDelayLines@ModMultiChannelDelay@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setExponentialDelayLengths@ModMultiChannelDelay@@AEAAXXZ DD imagerel $LN75
	DD	imagerel $LN75+319
	DD	imagerel $unwind$?setExponentialDelayLengths@ModMultiChannelDelay@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setRandomInRangeDelayLines@ModMultiChannelDelay@@AEAAXXZ DD imagerel $LN23
	DD	imagerel $LN23+248
	DD	imagerel $unwind$?setRandomInRangeDelayLines@ModMultiChannelDelay@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setEqualDelayLines@ModMultiChannelDelay@@AEAAXXZ DD imagerel $LN21
	DD	imagerel $LN21+101
	DD	imagerel $unwind$?setEqualDelayLines@ModMultiChannelDelay@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?processAudio@ModMultiChannelDelay@@QEAAXPEAM0@Z DD imagerel $LN14
	DD	imagerel $LN14+111
	DD	imagerel $unwind$?processAudio@ModMultiChannelDelay@@QEAAXPEAM0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setSampleRate@ModMultiChannelDelay@@QEAAXH@Z DD imagerel $LN14
	DD	imagerel $LN14+83
	DD	imagerel $unwind$?setSampleRate@ModMultiChannelDelay@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setOscillatorType@ModMultiChannelDelay@@QEAAXW4OscillatorType@@@Z DD imagerel $LN20
	DD	imagerel $LN20+91
	DD	imagerel $unwind$?setOscillatorType@ModMultiChannelDelay@@QEAAXW4OscillatorType@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setMakeUpGaindB@ModMultiChannelDelay@@QEAAXM@Z DD imagerel $LN16
	DD	imagerel $LN16+72
	DD	imagerel $unwind$?setMakeUpGaindB@ModMultiChannelDelay@@QEAAXM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setDelayLinesLength@ModMultiChannelDelay@@QEAAXMMW4DelayDistribution@@@Z DD imagerel $LN121
	DD	imagerel $LN121+659
	DD	imagerel $unwind$?setDelayLinesLength@ModMultiChannelDelay@@QEAAXMMW4DelayDistribution@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?initDelayLines@ModMultiChannelDelay@@QEAAXMH@Z DD imagerel $LN17
	DD	imagerel $LN17+103
	DD	imagerel $unwind$?initDelayLines@ModMultiChannelDelay@@QEAAXMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1ModMultiChannelDelay@@QEAA@XZ DD imagerel $LN60
	DD	imagerel $LN60+280
	DD	imagerel $unwind$??1ModMultiChannelDelay@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ModMultiChannelDelay@@QEAA@H@Z DD imagerel $LN44
	DD	imagerel $LN44+168
	DD	imagerel $unwind$??0ModMultiChannelDelay@@QEAA@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???0ModMultiChannelDelay@@QEAA@H@Z@4HA DD imagerel ?dtor$1@?0???0ModMultiChannelDelay@@QEAA@H@Z@4HA
	DD	imagerel ?dtor$1@?0???0ModMultiChannelDelay@@QEAA@H@Z@4HA+29
	DD	imagerel $unwind$?dtor$1@?0???0ModMultiChannelDelay@@QEAA@H@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GFlipPolarity@@QEAAPEAXI@Z DD imagerel $LN6
	DD	imagerel $LN6+36
	DD	imagerel $unwind$??_GFlipPolarity@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GHadamard@@QEAAPEAXI@Z DD imagerel $LN18
	DD	imagerel $LN18+104
	DD	imagerel $unwind$??_GHadamard@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GMultiChannelDelay@@QEAAPEAXI@Z DD imagerel $LN6
	DD	imagerel $LN6+36
	DD	imagerel $unwind$??_GMultiChannelDelay@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?constructBlocks@MultiChannelDiffuser@@AEAAXXZ DD imagerel $LN14
	DD	imagerel $LN14+105
	DD	imagerel $unwind$?constructBlocks@MultiChannelDiffuser@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??constructBlocks@MultiChannelDiffuser@@AEAAXXZ@4HA DD imagerel ?dtor$0@?0??constructBlocks@MultiChannelDiffuser@@AEAAXXZ@4HA
	DD	imagerel ?dtor$0@?0??constructBlocks@MultiChannelDiffuser@@AEAAXXZ@4HA+29
	DD	imagerel $unwind$?dtor$0@?0??constructBlocks@MultiChannelDiffuser@@AEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0??constructBlocks@MultiChannelDiffuser@@AEAAXXZ@4HA DD imagerel ?dtor$1@?0??constructBlocks@MultiChannelDiffuser@@AEAAXXZ@4HA
	DD	imagerel ?dtor$1@?0??constructBlocks@MultiChannelDiffuser@@AEAAXXZ@4HA+29
	DD	imagerel $unwind$?dtor$1@?0??constructBlocks@MultiChannelDiffuser@@AEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0??constructBlocks@MultiChannelDiffuser@@AEAAXXZ@4HA DD imagerel ?dtor$2@?0??constructBlocks@MultiChannelDiffuser@@AEAAXXZ@4HA
	DD	imagerel ?dtor$2@?0??constructBlocks@MultiChannelDiffuser@@AEAAXXZ@4HA+29
	DD	imagerel $unwind$?dtor$2@?0??constructBlocks@MultiChannelDiffuser@@AEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deleteBlocks@MultiChannelDiffuser@@AEAAXXZ DD imagerel $LN32
	DD	imagerel $LN32+180
	DD	imagerel $unwind$?deleteBlocks@MultiChannelDiffuser@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deleteInternalArrays@MultiChannelDiffuser@@AEAAXXZ DD imagerel $LN8
	DD	imagerel $LN8+55
	DD	imagerel $unwind$?deleteInternalArrays@MultiChannelDiffuser@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?initInternalArrays@MultiChannelDiffuser@@AEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+88
	DD	imagerel $unwind$?initInternalArrays@MultiChannelDiffuser@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?constructMCDF@MultiChannelDiffuser@@AEAAXH@Z DD imagerel $LN20
	DD	imagerel $LN20+190
	DD	imagerel $unwind$?constructMCDF@MultiChannelDiffuser@@AEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??constructMCDF@MultiChannelDiffuser@@AEAAXH@Z@4HA DD imagerel ?dtor$0@?0??constructMCDF@MultiChannelDiffuser@@AEAAXH@Z@4HA
	DD	imagerel ?dtor$0@?0??constructMCDF@MultiChannelDiffuser@@AEAAXH@Z@4HA+29
	DD	imagerel $unwind$?dtor$0@?0??constructMCDF@MultiChannelDiffuser@@AEAAXH@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0??constructMCDF@MultiChannelDiffuser@@AEAAXH@Z@4HA DD imagerel ?dtor$1@?0??constructMCDF@MultiChannelDiffuser@@AEAAXH@Z@4HA
	DD	imagerel ?dtor$1@?0??constructMCDF@MultiChannelDiffuser@@AEAAXH@Z@4HA+29
	DD	imagerel $unwind$?dtor$1@?0??constructMCDF@MultiChannelDiffuser@@AEAAXH@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0??constructMCDF@MultiChannelDiffuser@@AEAAXH@Z@4HA DD imagerel ?dtor$2@?0??constructMCDF@MultiChannelDiffuser@@AEAAXH@Z@4HA
	DD	imagerel ?dtor$2@?0??constructMCDF@MultiChannelDiffuser@@AEAAXH@Z@4HA+29
	DD	imagerel $unwind$?dtor$2@?0??constructMCDF@MultiChannelDiffuser@@AEAAXH@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?processAudio@MultiChannelDiffuser@@QEAAXPEAM0@Z DD imagerel $LN27
	DD	imagerel $LN27+193
	DD	imagerel $unwind$?processAudio@MultiChannelDiffuser@@QEAAXPEAM0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setSampleRate@MultiChannelDiffuser@@QEAAXH@Z DD imagerel $LN16
	DD	imagerel $LN16+90
	DD	imagerel $unwind$?setSampleRate@MultiChannelDiffuser@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?init@MultiChannelDiffuser@@QEAAXMH@Z DD imagerel $LN19
	DD	imagerel $LN19+111
	DD	imagerel $unwind$?init@MultiChannelDiffuser@@QEAAXMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1MultiChannelDiffuser@@QEAA@XZ DD imagerel $LN40
	DD	imagerel $LN40+220
	DD	imagerel $unwind$??1MultiChannelDiffuser@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0MultiChannelDiffuser@@QEAA@H@Z DD imagerel $LN22
	DD	imagerel $LN22+193
	DD	imagerel $unwind$??0MultiChannelDiffuser@@QEAA@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0MultiChannelDiffuser@@QEAA@H@Z@4HA DD imagerel ?dtor$0@?0???0MultiChannelDiffuser@@QEAA@H@Z@4HA
	DD	imagerel ?dtor$0@?0???0MultiChannelDiffuser@@QEAA@H@Z@4HA+29
	DD	imagerel $unwind$?dtor$0@?0???0MultiChannelDiffuser@@QEAA@H@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???0MultiChannelDiffuser@@QEAA@H@Z@4HA DD imagerel ?dtor$1@?0???0MultiChannelDiffuser@@QEAA@H@Z@4HA
	DD	imagerel ?dtor$1@?0???0MultiChannelDiffuser@@QEAA@H@Z@4HA+29
	DD	imagerel $unwind$?dtor$1@?0???0MultiChannelDiffuser@@QEAA@H@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0???0MultiChannelDiffuser@@QEAA@H@Z@4HA DD imagerel ?dtor$2@?0???0MultiChannelDiffuser@@QEAA@H@Z@4HA
	DD	imagerel ?dtor$2@?0???0MultiChannelDiffuser@@QEAA@H@Z@4HA+29
	DD	imagerel $unwind$?dtor$2@?0???0MultiChannelDiffuser@@QEAA@H@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setNumberOfChannels@FlipPolarity@@QEAAXH@Z DD imagerel $LN35
	DD	imagerel $LN35+137
	DD	imagerel $unwind$?setNumberOfChannels@FlipPolarity@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1FlipPolarity@@QEAA@XZ DD imagerel $LN36
	DD	imagerel $LN36+103
	DD	imagerel $unwind$??1FlipPolarity@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0FlipPolarity@@QEAA@H@Z DD imagerel $LN44
	DD	imagerel $LN44+158
	DD	imagerel $unwind$??0FlipPolarity@@QEAA@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?processAudio@Hadamard@@QEAAXPEAM0@Z DD imagerel $LN22
	DD	imagerel $LN22+141
	DD	imagerel $unwind$?processAudio@Hadamard@@QEAAXPEAM0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?hadamardScaled@Hadamard@@QEAAXPEAMH@Z DD imagerel $LN13
	DD	imagerel $LN13+95
	DD	imagerel $unwind$?hadamardScaled@Hadamard@@QEAAXPEAMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?hadamardUnscaled@Hadamard@@QEAAXPEAMH@Z DD imagerel $LN15
	DD	imagerel $LN15+149
	DD	imagerel $unwind$?hadamardUnscaled@Hadamard@@QEAAXPEAMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setNumberOfChannels@Hadamard@@QEAAXH@Z DD imagerel $LN42
	DD	imagerel $LN42+376
	DD	imagerel $unwind$?setNumberOfChannels@Hadamard@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deleteMatrix@Hadamard@@QEAAXXZ DD imagerel $LN12
	DD	imagerel $LN12+88
	DD	imagerel $unwind$?deleteMatrix@Hadamard@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1Hadamard@@QEAA@XZ DD imagerel $LN15
	DD	imagerel $LN15+88
	DD	imagerel $unwind$??1Hadamard@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0Hadamard@@QEAA@H@Z DD imagerel $LN44
	DD	imagerel $LN44+328
	DD	imagerel $unwind$??0Hadamard@@QEAA@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GDelay@@QEAAPEAXI@Z DD imagerel $LN6
	DD	imagerel $LN6+36
	DD	imagerel $unwind$??_GDelay@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?constructMCDL@MultiChannelDelay@@AEAAXH@Z DD imagerel $LN32
	DD	imagerel $LN32+169
	DD	imagerel $unwind$?constructMCDL@MultiChannelDelay@@AEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?constructDelayObjects@MultiChannelDelay@@AEAAXXZ DD imagerel $LN30
	DD	imagerel $LN30+167
	DD	imagerel $unwind$?constructDelayObjects@MultiChannelDelay@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deleteDelayLines@MultiChannelDelay@@AEAAXXZ DD imagerel $LN24
	DD	imagerel $LN24+136
	DD	imagerel $unwind$?deleteDelayLines@MultiChannelDelay@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setExponentialDelayLengths@MultiChannelDelay@@AEAAXXZ DD imagerel $LN73
	DD	imagerel $LN73+314
	DD	imagerel $unwind$?setExponentialDelayLengths@MultiChannelDelay@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setRandomInRangeDelayLines@MultiChannelDelay@@AEAAXXZ DD imagerel $LN21
	DD	imagerel $LN21+243
	DD	imagerel $unwind$?setRandomInRangeDelayLines@MultiChannelDelay@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setEqualDelayLines@MultiChannelDelay@@AEAAXXZ DD imagerel $LN19
	DD	imagerel $LN19+96
	DD	imagerel $unwind$?setEqualDelayLines@MultiChannelDelay@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?processAudio@MultiChannelDelay@@QEAAXPEAM0@Z DD imagerel $LN14
	DD	imagerel $LN14+111
	DD	imagerel $unwind$?processAudio@MultiChannelDelay@@QEAAXPEAM0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setSampleRate@MultiChannelDelay@@QEAAXH@Z DD imagerel $LN14
	DD	imagerel $LN14+83
	DD	imagerel $unwind$?setSampleRate@MultiChannelDelay@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setDelayLinesLength@MultiChannelDelay@@QEAAXMMW4DelayDistribution@@@Z DD imagerel $LN116
	DD	imagerel $LN116+690
	DD	imagerel $unwind$?setDelayLinesLength@MultiChannelDelay@@QEAAXMMW4DelayDistribution@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?initDelayLines@MultiChannelDelay@@QEAAXMH@Z DD imagerel $LN17
	DD	imagerel $LN17+110
	DD	imagerel $unwind$?initDelayLines@MultiChannelDelay@@QEAAXMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1MultiChannelDelay@@QEAA@XZ DD imagerel $LN52
	DD	imagerel $LN52+224
	DD	imagerel $unwind$??1MultiChannelDelay@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0MultiChannelDelay@@QEAA@H@Z DD imagerel $LN41
	DD	imagerel $LN41+173
	DD	imagerel $unwind$??0MultiChannelDelay@@QEAA@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GLFO@@QEAAPEAXI@Z DD imagerel $LN6
	DD	imagerel $LN6+36
	DD	imagerel $unwind$??_GLFO@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?processAudio@ModDelay@@UEAAMM@Z DD imagerel $LN9
	DD	imagerel $LN9+91
	DD	imagerel $unwind$?processAudio@ModDelay@@UEAAMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?init@ModDelay@@QEAAXMHW4OscillatorType@@@Z DD imagerel $LN19
	DD	imagerel $LN19+145
	DD	imagerel $unwind$?init@ModDelay@@QEAAXMHW4OscillatorType@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1ModDelay@@QEAA@XZ DD imagerel $LN10
	DD	imagerel $LN10+71
	DD	imagerel $unwind$??1ModDelay@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ModDelay@@QEAA@XZ DD imagerel $LN36
	DD	imagerel $LN36+288
	DD	imagerel $unwind$??0ModDelay@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???0ModDelay@@QEAA@XZ@4HA DD imagerel ?dtor$1@?0???0ModDelay@@QEAA@XZ@4HA
	DD	imagerel ?dtor$1@?0???0ModDelay@@QEAA@XZ@4HA+29
	DD	imagerel $unwind$?dtor$1@?0???0ModDelay@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?createTable@LFO@@AEAAXXZ DD imagerel $LN68
	DD	imagerel $LN68+433
	DD	imagerel $unwind$?createTable@LFO@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1LFO@@QEAA@XZ DD imagerel $LN33
	DD	imagerel $LN33+99
	DD	imagerel $unwind$??1LFO@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0LFO@@QEAA@W4OscillatorType@@@Z DD imagerel $LN12
	DD	imagerel $LN12+72
	DD	imagerel $unwind$??0LFO@@QEAA@W4OscillatorType@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?randomInRange@@YAMMM@Z DD imagerel $LN4
	DD	imagerel $LN4+68
	DD	imagerel $unwind$?randomInRange@@YAMMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?exponentialVector@@YA?AV?$vector@MV?$allocator@M@std@@@std@@MMH@Z DD imagerel $LN16
	DD	imagerel $LN16+242
	DD	imagerel $unwind$?exponentialVector@@YA?AV?$vector@MV?$allocator@M@std@@@std@@MMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__EMIN_LPF_FREQUENCY_LOG@@YAXXZ DD imagerel ??__EMIN_LPF_FREQUENCY_LOG@@YAXXZ
	DD	imagerel ??__EMIN_LPF_FREQUENCY_LOG@@YAXXZ+38
	DD	imagerel $unwind$??__EMIN_LPF_FREQUENCY_LOG@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__EMAX_LPF_FREQUENCY_LOG@@YAXXZ DD imagerel ??__EMAX_LPF_FREQUENCY_LOG@@YAXXZ
	DD	imagerel ??__EMAX_LPF_FREQUENCY_LOG@@YAXXZ+38
	DD	imagerel $unwind$??__EMAX_LPF_FREQUENCY_LOG@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?createEffectInstance@@YAPEAVAudioEffect@@P6A_JPEAUAEffect@@HH_JPEAXM@Z@Z DD imagerel $LN8
	DD	imagerel $LN8+42
	DD	imagerel $unwind$?createEffectInstance@@YAPEAVAudioEffect@@P6A_JPEAUAEffect@@HH_JPEAXM@Z@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??createEffectInstance@@YAPEAVAudioEffect@@P6A_JPEAUAEffect@@HH_JPEAXM@Z@Z@4HA DD imagerel ?dtor$0@?0??createEffectInstance@@YAPEAVAudioEffect@@P6A_JPEAUAEffect@@HH_JPEAXM@Z@Z@4HA
	DD	imagerel ?dtor$0@?0??createEffectInstance@@YAPEAVAudioEffect@@P6A_JPEAUAEffect@@HH_JPEAXM@Z@Z@4HA+29
	DD	imagerel $unwind$?dtor$0@?0??createEffectInstance@@YAPEAVAudioEffect@@P6A_JPEAUAEffect@@HH_JPEAXM@Z@Z@4HA
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??createEffectInstance@@YAPEAVAudioEffect@@P6A_JPEAUAEffect@@HH_JPEAXM@Z@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?createEffectInstance@@YAPEAVAudioEffect@@P6A_JPEAUAEffect@@HH_JPEAXM@Z@Z DB 04H
	DB	01cH
	DB	00H
	DB	' '
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?createEffectInstance@@YAPEAVAudioEffect@@P6A_JPEAUAEffect@@HH_JPEAXM@Z@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??createEffectInstance@@YAPEAVAudioEffect@@P6A_JPEAUAEffect@@HH_JPEAXM@Z@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?createEffectInstance@@YAPEAVAudioEffect@@P6A_JPEAUAEffect@@HH_JPEAXM@Z@Z DB 028H
	DD	imagerel $stateUnwindMap$?createEffectInstance@@YAPEAVAudioEffect@@P6A_JPEAUAEffect@@HH_JPEAXM@Z@Z
	DD	imagerel $ip2state$?createEffectInstance@@YAPEAVAudioEffect@@P6A_JPEAUAEffect@@HH_JPEAXM@Z@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?createEffectInstance@@YAPEAVAudioEffect@@P6A_JPEAUAEffect@@HH_JPEAXM@Z@Z DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?createEffectInstance@@YAPEAVAudioEffect@@P6A_JPEAUAEffect@@HH_JPEAXM@Z@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__EMAX_LPF_FREQUENCY_LOG@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__EMIN_LPF_FREQUENCY_LOG@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?exponentialVector@@YA?AV?$vector@MV?$allocator@M@std@@@std@@MMH@Z DD 0103201H
	DD	028832H
	DD	03782aH
	DD	04681dH
	DD	0f7419H
	DD	0e6419H
	DD	0d5419H
	DD	0c3419H
	DD	0e0159219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?randomInRange@@YAMMM@Z DD 051101H
	DD	027811H
	DD	036809H
	DD	08204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0LFO@@QEAA@W4OscillatorType@@@Z DB 02H
	DB	'r'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0LFO@@QEAA@W4OscillatorType@@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0LFO@@QEAA@W4OscillatorType@@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0LFO@@QEAA@W4OscillatorType@@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0LFO@@QEAA@W4OscillatorType@@@Z
	DD	imagerel $ip2state$??0LFO@@QEAA@W4OscillatorType@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0LFO@@QEAA@W4OscillatorType@@@Z DD 020a11H
	DD	03006320aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0LFO@@QEAA@W4OscillatorType@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1LFO@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?createTable@LFO@@AEAAXXZ DD 0102f01H
	DD	02882fH
	DD	037824H
	DD	04681cH
	DD	0106418H
	DD	0f5418H
	DD	0e3418H
	DD	0f0149218H
	DD	07010e012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???0ModDelay@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0ModDelay@@QEAA@XZ DB 06H
	DB	0beH
	DB	02H
	DB	09cH
	DB	04H
	DB	'x'
	DB	08H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0ModDelay@@QEAA@XZ DB 08H
	DB	0cH
	DD	imagerel ??1CombFilter@@QEAA@XZ
	DB	060H
	DB	03cH
	DD	imagerel ??1LPCombFilter@@QEAA@XZ
	DB	060H
	DB	036H
	DD	imagerel ?dtor$1@?0???0ModDelay@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$4@?0???0ModDelay@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0ModDelay@@QEAA@XZ DB 028H
	DD	imagerel $stateUnwindMap$??0ModDelay@@QEAA@XZ
	DD	imagerel $ip2state$??0ModDelay@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ModDelay@@QEAA@XZ DD 061511H
	DD	097415H
	DD	083415H
	DD	0f0113215H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0ModDelay@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1ModDelay@@QEAA@XZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?init@ModDelay@@QEAAXMHW4OscillatorType@@@Z DD 060f01H
	DD	02680fH
	DD	08340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?processAudio@ModDelay@@UEAAMM@Z DD 040e01H
	DD	02680eH
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GLFO@@QEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0MultiChannelDelay@@QEAA@H@Z DB 04H
	DB	'f'
	DB	02H
	DB	0d4H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0MultiChannelDelay@@QEAA@H@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0MultiChannelDelay@@QEAA@H@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0MultiChannelDelay@@QEAA@H@Z DB 028H
	DD	imagerel $stateUnwindMap$??0MultiChannelDelay@@QEAA@H@Z
	DD	imagerel $ip2state$??0MultiChannelDelay@@QEAA@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0MultiChannelDelay@@QEAA@H@Z DD 061111H
	DD	093411H
	DD	0700d3211H
	DD	0500b600cH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0MultiChannelDelay@@QEAA@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1MultiChannelDelay@@QEAA@XZ DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?initDelayLines@MultiChannelDelay@@QEAAXMH@Z DD 0a1801H
	DD	026818H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?setDelayLinesLength@MultiChannelDelay@@QEAAXMMW4DelayDistribution@@@Z DB 04H
	DB	01dH, 06H
	DB	00H
	DB	','
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?setDelayLinesLength@MultiChannelDelay@@QEAAXMMW4DelayDistribution@@@Z DB 02H
	DB	0aH
	DD	imagerel ??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?setDelayLinesLength@MultiChannelDelay@@QEAAXMMW4DelayDistribution@@@Z DB 028H
	DD	imagerel $stateUnwindMap$?setDelayLinesLength@MultiChannelDelay@@QEAAXMMW4DelayDistribution@@@Z
	DD	imagerel $ip2state$?setDelayLinesLength@MultiChannelDelay@@QEAAXMMW4DelayDistribution@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setDelayLinesLength@MultiChannelDelay@@QEAAXMMW4DelayDistribution@@@Z DD 0e2211H
	DD	058822H
	DD	06681dH
	DD	0137419H
	DD	0126419H
	DD	0115419H
	DD	0103419H
	DD	0e015d219H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?setDelayLinesLength@MultiChannelDelay@@QEAAXMMW4DelayDistribution@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setSampleRate@MultiChannelDelay@@QEAAXH@Z DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?processAudio@MultiChannelDelay@@QEAAXPEAM0@Z DD 0a1901H
	DD	097419H
	DD	086419H
	DD	075419H
	DD	063419H
	DD	0e0153219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setEqualDelayLines@MultiChannelDelay@@AEAAXXZ DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setRandomInRangeDelayLines@MultiChannelDelay@@AEAAXXZ DD 0a3401H
	DD	028834H
	DD	03682fH
	DD	0b6410H
	DD	0a3410H
	DD	0700c7210H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?setExponentialDelayLengths@MultiChannelDelay@@AEAAXXZ DB 04H
	DB	'>'
	DB	00H
	DB	','
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?setExponentialDelayLengths@MultiChannelDelay@@AEAAXXZ DB 02H
	DB	0aH
	DD	imagerel ??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?setExponentialDelayLengths@MultiChannelDelay@@AEAAXXZ DB 028H
	DD	imagerel $stateUnwindMap$?setExponentialDelayLengths@MultiChannelDelay@@AEAAXXZ
	DD	imagerel $ip2state$?setExponentialDelayLengths@MultiChannelDelay@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setExponentialDelayLengths@MultiChannelDelay@@AEAAXXZ DD 081511H
	DD	0e7415H
	DD	0d6415H
	DD	0c3415H
	DD	0e0119215H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?setExponentialDelayLengths@MultiChannelDelay@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deleteDelayLines@MultiChannelDelay@@AEAAXXZ DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?constructDelayObjects@MultiChannelDelay@@AEAAXXZ DD 060f01H
	DD	08640fH
	DD	07340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?constructMCDL@MultiChannelDelay@@AEAAXH@Z DD 081401H
	DD	096414H
	DD	085414H
	DD	073414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GDelay@@QEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0Hadamard@@QEAA@H@Z DD 0a1901H
	DD	097419H
	DD	086419H
	DD	075419H
	DD	063419H
	DD	0e0153219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1Hadamard@@QEAA@XZ DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deleteMatrix@Hadamard@@QEAAXXZ DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setNumberOfChannels@Hadamard@@QEAAXH@Z DD 0a1901H
	DD	097419H
	DD	086419H
	DD	075419H
	DD	063419H
	DD	0e0153219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?hadamardUnscaled@Hadamard@@QEAAXPEAMH@Z DD 081e01H
	DD	08641eH
	DD	07541eH
	DD	06341eH
	DD	0701a321eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?hadamardScaled@Hadamard@@QEAAXPEAMH@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?processAudio@Hadamard@@QEAAXPEAM0@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0FlipPolarity@@QEAA@H@Z DB 02H
	DB	011H, 02H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0FlipPolarity@@QEAA@H@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$vector@HV?$allocator@H@std@@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0FlipPolarity@@QEAA@H@Z DB 028H
	DD	imagerel $stateUnwindMap$??0FlipPolarity@@QEAA@H@Z
	DD	imagerel $ip2state$??0FlipPolarity@@QEAA@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0FlipPolarity@@QEAA@H@Z DD 040f11H
	DD	08340fH
	DD	0700b320fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0FlipPolarity@@QEAA@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1FlipPolarity@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setNumberOfChannels@FlipPolarity@@QEAAXH@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0???0MultiChannelDiffuser@@QEAA@H@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???0MultiChannelDiffuser@@QEAA@H@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0MultiChannelDiffuser@@QEAA@H@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0MultiChannelDiffuser@@QEAA@H@Z DB 0cH
	DB	'<'
	DB	00H
	DB	01eH
	DB	02H
	DB	01eH
	DB	00H
	DB	01eH
	DB	04H
	DB	01eH
	DB	00H
	DB	01eH
	DB	06H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0MultiChannelDiffuser@@QEAA@H@Z DB 06H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0MultiChannelDiffuser@@QEAA@H@Z@4HA
	DB	036H
	DD	imagerel ?dtor$1@?0???0MultiChannelDiffuser@@QEAA@H@Z@4HA
	DB	05eH
	DD	imagerel ?dtor$2@?0???0MultiChannelDiffuser@@QEAA@H@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0MultiChannelDiffuser@@QEAA@H@Z DB 028H
	DD	imagerel $stateUnwindMap$??0MultiChannelDiffuser@@QEAA@H@Z
	DD	imagerel $ip2state$??0MultiChannelDiffuser@@QEAA@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0MultiChannelDiffuser@@QEAA@H@Z DD 040a11H
	DD	07340aH
	DD	07006320aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0MultiChannelDiffuser@@QEAA@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1MultiChannelDiffuser@@QEAA@XZ DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?init@MultiChannelDiffuser@@QEAAXMH@Z DD 081501H
	DD	087415H
	DD	076415H
	DD	063415H
	DD	0e0113215H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setSampleRate@MultiChannelDiffuser@@QEAAXH@Z DD 081501H
	DD	087415H
	DD	076415H
	DD	063415H
	DD	0e0113215H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?processAudio@MultiChannelDiffuser@@QEAAXPEAM0@Z DD 0c1c01H
	DD	0c641cH
	DD	0b541cH
	DD	0a341cH
	DD	0f018321cH
	DD	0d014e016H
	DD	07010c012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0??constructMCDF@MultiChannelDiffuser@@AEAAXH@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0??constructMCDF@MultiChannelDiffuser@@AEAAXH@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??constructMCDF@MultiChannelDiffuser@@AEAAXH@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?constructMCDF@MultiChannelDiffuser@@AEAAXH@Z DB 0cH
	DB	'<'
	DB	00H
	DB	01eH
	DB	02H
	DB	01eH
	DB	00H
	DB	01eH
	DB	04H
	DB	01eH
	DB	00H
	DB	01eH
	DB	06H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?constructMCDF@MultiChannelDiffuser@@AEAAXH@Z DB 06H
	DB	0eH
	DD	imagerel ?dtor$0@?0??constructMCDF@MultiChannelDiffuser@@AEAAXH@Z@4HA
	DB	036H
	DD	imagerel ?dtor$1@?0??constructMCDF@MultiChannelDiffuser@@AEAAXH@Z@4HA
	DB	05eH
	DD	imagerel ?dtor$2@?0??constructMCDF@MultiChannelDiffuser@@AEAAXH@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?constructMCDF@MultiChannelDiffuser@@AEAAXH@Z DB 028H
	DD	imagerel $stateUnwindMap$?constructMCDF@MultiChannelDiffuser@@AEAAXH@Z
	DD	imagerel $ip2state$?constructMCDF@MultiChannelDiffuser@@AEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?constructMCDF@MultiChannelDiffuser@@AEAAXH@Z DD 040a11H
	DD	07340aH
	DD	07006320aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?constructMCDF@MultiChannelDiffuser@@AEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?initInternalArrays@MultiChannelDiffuser@@AEAAXXZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deleteInternalArrays@MultiChannelDiffuser@@AEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deleteBlocks@MultiChannelDiffuser@@AEAAXXZ DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0??constructBlocks@MultiChannelDiffuser@@AEAAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0??constructBlocks@MultiChannelDiffuser@@AEAAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??constructBlocks@MultiChannelDiffuser@@AEAAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?constructBlocks@MultiChannelDiffuser@@AEAAXXZ DB 0cH
	DB	01cH
	DB	00H
	DB	01eH
	DB	02H
	DB	01eH
	DB	00H
	DB	01eH
	DB	04H
	DB	01eH
	DB	00H
	DB	01eH
	DB	06H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?constructBlocks@MultiChannelDiffuser@@AEAAXXZ DB 06H
	DB	0eH
	DD	imagerel ?dtor$0@?0??constructBlocks@MultiChannelDiffuser@@AEAAXXZ@4HA
	DB	036H
	DD	imagerel ?dtor$1@?0??constructBlocks@MultiChannelDiffuser@@AEAAXXZ@4HA
	DB	05eH
	DD	imagerel ?dtor$2@?0??constructBlocks@MultiChannelDiffuser@@AEAAXXZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?constructBlocks@MultiChannelDiffuser@@AEAAXXZ DB 028H
	DD	imagerel $stateUnwindMap$?constructBlocks@MultiChannelDiffuser@@AEAAXXZ
	DD	imagerel $ip2state$?constructBlocks@MultiChannelDiffuser@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?constructBlocks@MultiChannelDiffuser@@AEAAXXZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?constructBlocks@MultiChannelDiffuser@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GMultiChannelDelay@@QEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GHadamard@@QEAAPEAXI@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GFlipPolarity@@QEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???0ModMultiChannelDelay@@QEAA@H@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0ModMultiChannelDelay@@QEAA@H@Z DB 06H
	DB	'l'
	DB	02H
	DB	01aH
	DB	04H
	DB	'N'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0ModMultiChannelDelay@@QEAA@H@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0ModMultiChannelDelay@@QEAA@H@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???0ModMultiChannelDelay@@QEAA@H@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0ModMultiChannelDelay@@QEAA@H@Z DB 028H
	DD	imagerel $stateUnwindMap$??0ModMultiChannelDelay@@QEAA@H@Z
	DD	imagerel $ip2state$??0ModMultiChannelDelay@@QEAA@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ModMultiChannelDelay@@QEAA@H@Z DD 061111H
	DD	093411H
	DD	0700d3211H
	DD	0500b600cH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0ModMultiChannelDelay@@QEAA@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1ModMultiChannelDelay@@QEAA@XZ DD 0a1901H
	DD	097419H
	DD	086419H
	DD	075419H
	DD	063419H
	DD	0e0153219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?initDelayLines@ModMultiChannelDelay@@QEAAXMH@Z DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?setDelayLinesLength@ModMultiChannelDelay@@QEAAXMMW4DelayDistribution@@@Z DB 04H
	DB	08dH, 05H
	DB	00H
	DB	','
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?setDelayLinesLength@ModMultiChannelDelay@@QEAAXMMW4DelayDistribution@@@Z DB 02H
	DB	0aH
	DD	imagerel ??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?setDelayLinesLength@ModMultiChannelDelay@@QEAAXMMW4DelayDistribution@@@Z DB 028H
	DD	imagerel $stateUnwindMap$?setDelayLinesLength@ModMultiChannelDelay@@QEAAXMMW4DelayDistribution@@@Z
	DD	imagerel $ip2state$?setDelayLinesLength@ModMultiChannelDelay@@QEAAXMMW4DelayDistribution@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setDelayLinesLength@ModMultiChannelDelay@@QEAAXMMW4DelayDistribution@@@Z DD 0e2211H
	DD	058822H
	DD	06681dH
	DD	0137419H
	DD	0126419H
	DD	0115419H
	DD	0103419H
	DD	0e015d219H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?setDelayLinesLength@ModMultiChannelDelay@@QEAAXMMW4DelayDistribution@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setMakeUpGaindB@ModMultiChannelDelay@@QEAAXM@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setOscillatorType@ModMultiChannelDelay@@QEAAXW4OscillatorType@@@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setSampleRate@ModMultiChannelDelay@@QEAAXH@Z DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?processAudio@ModMultiChannelDelay@@QEAAXPEAM0@Z DD 0a1901H
	DD	097419H
	DD	086419H
	DD	075419H
	DD	063419H
	DD	0e0153219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setEqualDelayLines@ModMultiChannelDelay@@AEAAXXZ DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setRandomInRangeDelayLines@ModMultiChannelDelay@@AEAAXXZ DD 0a3401H
	DD	028834H
	DD	03682fH
	DD	0b6410H
	DD	0a3410H
	DD	0700c7210H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?setExponentialDelayLengths@ModMultiChannelDelay@@AEAAXXZ DB 04H
	DB	'>'
	DB	00H
	DB	','
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?setExponentialDelayLengths@ModMultiChannelDelay@@AEAAXXZ DB 02H
	DB	0aH
	DD	imagerel ??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?setExponentialDelayLengths@ModMultiChannelDelay@@AEAAXXZ DB 028H
	DD	imagerel $stateUnwindMap$?setExponentialDelayLengths@ModMultiChannelDelay@@AEAAXXZ
	DD	imagerel $ip2state$?setExponentialDelayLengths@ModMultiChannelDelay@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setExponentialDelayLengths@ModMultiChannelDelay@@AEAAXXZ DD 081511H
	DD	0e7415H
	DD	0d6415H
	DD	0c3415H
	DD	0e0119215H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?setExponentialDelayLengths@ModMultiChannelDelay@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deleteDelayLines@ModMultiChannelDelay@@AEAAXXZ DD 0a1901H
	DD	097419H
	DD	086419H
	DD	075419H
	DD	063419H
	DD	0e0153219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??constructDelayObjects@ModMultiChannelDelay@@AEAAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?constructDelayObjects@ModMultiChannelDelay@@AEAAXXZ DB 06H
	DB	':'
	DB	00H
	DB	01aH
	DB	02H
	DB	'P'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?constructDelayObjects@ModMultiChannelDelay@@AEAAXXZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??constructDelayObjects@ModMultiChannelDelay@@AEAAXXZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?constructDelayObjects@ModMultiChannelDelay@@AEAAXXZ DB 028H
	DD	imagerel $stateUnwindMap$?constructDelayObjects@ModMultiChannelDelay@@AEAAXXZ
	DD	imagerel $ip2state$?constructDelayObjects@ModMultiChannelDelay@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?constructDelayObjects@ModMultiChannelDelay@@AEAAXXZ DD 060f11H
	DD	09640fH
	DD	08340fH
	DD	0700b320fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?constructDelayObjects@ModMultiChannelDelay@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??constructMCDL@ModMultiChannelDelay@@AEAAXH@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?constructMCDL@ModMultiChannelDelay@@AEAAXH@Z DB 06H
	DB	'D'
	DB	00H
	DB	01aH
	DB	02H
	DB	'P'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?constructMCDL@ModMultiChannelDelay@@AEAAXH@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??constructMCDL@ModMultiChannelDelay@@AEAAXH@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?constructMCDL@ModMultiChannelDelay@@AEAAXH@Z DB 028H
	DD	imagerel $stateUnwindMap$?constructMCDL@ModMultiChannelDelay@@AEAAXH@Z
	DD	imagerel $ip2state$?constructMCDL@ModMultiChannelDelay@@AEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?constructMCDL@ModMultiChannelDelay@@AEAAXH@Z DD 060c11H
	DD	09340cH
	DD	07008320cH
	DD	050066007H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?constructMCDL@ModMultiChannelDelay@@AEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GModDelay@@QEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0???0ModMultiChannelDiffuser@@QEAA@H@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???0ModMultiChannelDiffuser@@QEAA@H@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$4@?0???0ModMultiChannelDiffuser@@QEAA@H@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0ModMultiChannelDiffuser@@QEAA@H@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0ModMultiChannelDiffuser@@QEAA@H@Z DB 010H
	DB	':'
	DB	00H
	DB	'`'
	DB	04H
	DB	01aH
	DB	06H
	DB	'N'
	DB	04H
	DB	'n'
	DB	00H
	DB	' '
	DB	08H
	DB	01eH
	DB	00H
	DB	' '
	DB	0aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0ModMultiChannelDiffuser@@QEAA@H@Z DB 0aH
	DB	0eH
	DD	imagerel ?dtor$0@?0???0ModMultiChannelDiffuser@@QEAA@H@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$3@?0???0ModMultiChannelDiffuser@@QEAA@H@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$4@?0???0ModMultiChannelDiffuser@@QEAA@H@Z@4HA
	DB	086H
	DD	imagerel ?dtor$1@?0???0ModMultiChannelDiffuser@@QEAA@H@Z@4HA
	DB	0aeH
	DD	imagerel ?dtor$2@?0???0ModMultiChannelDiffuser@@QEAA@H@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0ModMultiChannelDiffuser@@QEAA@H@Z DB 028H
	DD	imagerel $stateUnwindMap$??0ModMultiChannelDiffuser@@QEAA@H@Z
	DD	imagerel $ip2state$??0ModMultiChannelDiffuser@@QEAA@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ModMultiChannelDiffuser@@QEAA@H@Z DD 060b11H
	DD	0e007320bH
	DD	060047005H
	DD	030025003H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0ModMultiChannelDiffuser@@QEAA@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1ModMultiChannelDiffuser@@QEAA@XZ DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?init@ModMultiChannelDiffuser@@QEAAXMH@Z DD 0a1801H
	DD	0a6418H
	DD	095418H
	DD	083418H
	DD	0f0143218H
	DD	07010e012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setMakeUpGainDB@ModMultiChannelDiffuser@@QEAAXM@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setOscillatorType@ModMultiChannelDiffuser@@QEAAXW4OscillatorType@@@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setSampleRate@ModMultiChannelDiffuser@@QEAAXH@Z DD 081501H
	DD	087415H
	DD	076415H
	DD	063415H
	DD	0e0113215H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?processAudio@ModMultiChannelDiffuser@@QEAAXPEAM0@Z DD 0c1c01H
	DD	0c641cH
	DD	0b541cH
	DD	0a341cH
	DD	0f018321cH
	DD	0d014e016H
	DD	07010c012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0??constructMCDF@ModMultiChannelDiffuser@@AEAAXH@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0??constructMCDF@ModMultiChannelDiffuser@@AEAAXH@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$4@?0??constructMCDF@ModMultiChannelDiffuser@@AEAAXH@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??constructMCDF@ModMultiChannelDiffuser@@AEAAXH@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?constructMCDF@ModMultiChannelDiffuser@@AEAAXH@Z DB 010H
	DB	':'
	DB	00H
	DB	'`'
	DB	04H
	DB	01aH
	DB	06H
	DB	'N'
	DB	04H
	DB	'n'
	DB	00H
	DB	' '
	DB	08H
	DB	01eH
	DB	00H
	DB	' '
	DB	0aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?constructMCDF@ModMultiChannelDiffuser@@AEAAXH@Z DB 0aH
	DB	0eH
	DD	imagerel ?dtor$0@?0??constructMCDF@ModMultiChannelDiffuser@@AEAAXH@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$3@?0??constructMCDF@ModMultiChannelDiffuser@@AEAAXH@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$4@?0??constructMCDF@ModMultiChannelDiffuser@@AEAAXH@Z@4HA
	DB	086H
	DD	imagerel ?dtor$1@?0??constructMCDF@ModMultiChannelDiffuser@@AEAAXH@Z@4HA
	DB	0aeH
	DD	imagerel ?dtor$2@?0??constructMCDF@ModMultiChannelDiffuser@@AEAAXH@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?constructMCDF@ModMultiChannelDiffuser@@AEAAXH@Z DB 028H
	DD	imagerel $stateUnwindMap$?constructMCDF@ModMultiChannelDiffuser@@AEAAXH@Z
	DD	imagerel $ip2state$?constructMCDF@ModMultiChannelDiffuser@@AEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?constructMCDF@ModMultiChannelDiffuser@@AEAAXH@Z DD 060b11H
	DD	0e007320bH
	DD	060047005H
	DD	030025003H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?constructMCDF@ModMultiChannelDiffuser@@AEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?initInternalArrays@ModMultiChannelDiffuser@@AEAAXXZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deleteInternalArrays@ModMultiChannelDiffuser@@AEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deleteBlocks@ModMultiChannelDiffuser@@AEAAXXZ DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0??constructBlocks@ModMultiChannelDiffuser@@AEAAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0??constructBlocks@ModMultiChannelDiffuser@@AEAAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$4@?0??constructBlocks@ModMultiChannelDiffuser@@AEAAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??constructBlocks@ModMultiChannelDiffuser@@AEAAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?constructBlocks@ModMultiChannelDiffuser@@AEAAXXZ DB 010H
	DB	'&'
	DB	00H
	DB	'd'
	DB	04H
	DB	01aH
	DB	06H
	DB	'N'
	DB	04H
	DB	'n'
	DB	00H
	DB	' '
	DB	08H
	DB	01eH
	DB	00H
	DB	' '
	DB	0aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?constructBlocks@ModMultiChannelDiffuser@@AEAAXXZ DB 0aH
	DB	0eH
	DD	imagerel ?dtor$0@?0??constructBlocks@ModMultiChannelDiffuser@@AEAAXXZ@4HA
	DB	02eH
	DD	imagerel ?dtor$3@?0??constructBlocks@ModMultiChannelDiffuser@@AEAAXXZ@4HA
	DB	02eH
	DD	imagerel ?dtor$4@?0??constructBlocks@ModMultiChannelDiffuser@@AEAAXXZ@4HA
	DB	086H
	DD	imagerel ?dtor$1@?0??constructBlocks@ModMultiChannelDiffuser@@AEAAXXZ@4HA
	DB	0aeH
	DD	imagerel ?dtor$2@?0??constructBlocks@ModMultiChannelDiffuser@@AEAAXXZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?constructBlocks@ModMultiChannelDiffuser@@AEAAXXZ DB 028H
	DD	imagerel $stateUnwindMap$?constructBlocks@ModMultiChannelDiffuser@@AEAAXXZ
	DD	imagerel $ip2state$?constructBlocks@ModMultiChannelDiffuser@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?constructBlocks@ModMultiChannelDiffuser@@AEAAXXZ DD 060b11H
	DD	0e007320bH
	DD	060047005H
	DD	030025003H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?constructBlocks@ModMultiChannelDiffuser@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GModMultiChannelDelay@@QEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0???0ModMultiChannelFeedback@@QEAA@H@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0ModMultiChannelFeedback@@QEAA@H@Z DB 08H
	DB	'P'
	DB	02H
	DB	098H
	DB	04H
	DB	012H
	DB	02H
	DB	'\'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0ModMultiChannelFeedback@@QEAA@H@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0ModMultiChannelFeedback@@QEAA@H@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0???0ModMultiChannelFeedback@@QEAA@H@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0ModMultiChannelFeedback@@QEAA@H@Z DB 028H
	DD	imagerel $stateUnwindMap$??0ModMultiChannelFeedback@@QEAA@H@Z
	DD	imagerel $ip2state$??0ModMultiChannelFeedback@@QEAA@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ModMultiChannelFeedback@@QEAA@H@Z DD 061211H
	DD	093412H
	DD	0e00e3212H
	DD	0600b700cH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0ModMultiChannelFeedback@@QEAA@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1ModMultiChannelFeedback@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setDecayInSeconds@ModMultiChannelFeedback@@QEAAXM@Z DD 0a1901H
	DD	026819H
	DD	0a7415H
	DD	096415H
	DD	083415H
	DD	0e0115215H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?init@ModMultiChannelFeedback@@QEAAXMH@Z DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setSampleRate@ModMultiChannelFeedback@@QEAAXH@Z DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setDelayLengths@ModMultiChannelFeedback@@QEAAXMMW4DelayDistribution@@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setDampingFrequency@ModMultiChannelFeedback@@QEAAXM@Z DD 081601H
	DD	026816H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setFilterType@ModMultiChannelFeedback@@QEAAXW4LPFilterType@@@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setOscillatorType@ModMultiChannelFeedback@@QEAAXW4OscillatorType@@@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?processAudio@ModMultiChannelFeedback@@QEAAXPEAM0@Z DB 04H
	DB	'f'
	DB	00H
	DB	01aH
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?processAudio@ModMultiChannelFeedback@@QEAAXPEAM0@Z DB 02H
	DB	0aH
	DD	imagerel ??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ
	DB	070H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?processAudio@ModMultiChannelFeedback@@QEAAXPEAM0@Z DB 028H
	DD	imagerel $stateUnwindMap$?processAudio@ModMultiChannelFeedback@@QEAAXPEAM0@Z
	DD	imagerel $ip2state$?processAudio@ModMultiChannelFeedback@@QEAAXPEAM0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?processAudio@ModMultiChannelFeedback@@QEAAXPEAM0@Z DD 0e2311H
	DD	056823H
	DD	014741fH
	DD	013641fH
	DD	012341fH
	DD	0f018b21fH
	DD	0d014e016H
	DD	05010c012H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?processAudio@ModMultiChannelFeedback@@QEAAXPEAM0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0??constructMCF@ModMultiChannelFeedback@@AEAAXH@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?constructMCF@ModMultiChannelFeedback@@AEAAXH@Z DB 06H
	DB	'2'
	DB	00H
	DB	098H
	DB	02H
	DB	012H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?constructMCF@ModMultiChannelFeedback@@AEAAXH@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$1@?0??constructMCF@ModMultiChannelFeedback@@AEAAXH@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?constructMCF@ModMultiChannelFeedback@@AEAAXH@Z DB 028H
	DD	imagerel $stateUnwindMap$?constructMCF@ModMultiChannelFeedback@@AEAAXH@Z
	DD	imagerel $ip2state$?constructMCF@ModMultiChannelFeedback@@AEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?constructMCF@ModMultiChannelFeedback@@AEAAXH@Z DD 060f11H
	DD	09640fH
	DD	07340fH
	DD	0700b320fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?constructMCF@ModMultiChannelFeedback@@AEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deleteDelayLines@ModMultiChannelFeedback@@AEAAXXZ DD 0a1901H
	DD	097419H
	DD	086419H
	DD	075419H
	DD	063419H
	DD	0e0153219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??allocateDelayLines@ModMultiChannelFeedback@@AEAAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?allocateDelayLines@ModMultiChannelFeedback@@AEAAXXZ DB 06H
	DB	':'
	DB	00H
	DB	01aH
	DB	02H
	DB	'P'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?allocateDelayLines@ModMultiChannelFeedback@@AEAAXXZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??allocateDelayLines@ModMultiChannelFeedback@@AEAAXXZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?allocateDelayLines@ModMultiChannelFeedback@@AEAAXXZ DB 028H
	DD	imagerel $stateUnwindMap$?allocateDelayLines@ModMultiChannelFeedback@@AEAAXXZ
	DD	imagerel $ip2state$?allocateDelayLines@ModMultiChannelFeedback@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocateDelayLines@ModMultiChannelFeedback@@AEAAXXZ DD 060f11H
	DD	09640fH
	DD	08340fH
	DD	0700b320fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?allocateDelayLines@ModMultiChannelFeedback@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?setDelayExponential@ModMultiChannelFeedback@@AEAAXXZ DB 04H
	DB	'>'
	DB	00H
	DB	'0'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?setDelayExponential@ModMultiChannelFeedback@@AEAAXXZ DB 02H
	DB	0aH
	DD	imagerel ??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?setDelayExponential@ModMultiChannelFeedback@@AEAAXXZ DB 028H
	DD	imagerel $stateUnwindMap$?setDelayExponential@ModMultiChannelFeedback@@AEAAXXZ
	DD	imagerel $ip2state$?setDelayExponential@ModMultiChannelFeedback@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setDelayExponential@ModMultiChannelFeedback@@AEAAXXZ DD 081511H
	DD	0e7415H
	DD	0d6415H
	DD	0c3415H
	DD	0e0119215H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?setDelayExponential@ModMultiChannelFeedback@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setRandomInRangeDelayLines@ModMultiChannelFeedback@@AEAAXXZ DD 0c2401H
	DD	028824H
	DD	03781fH
	DD	04681bH
	DD	0d6410H
	DD	0c3410H
	DD	0700c9210H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0HighPassFilter@@QEAA@HMW4HPFilterType@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?updateGains@HighPassFilter@@QEAAXXZ DD 0c2401H
	DD	02a824H
	DD	03981fH
	DD	04881aH
	DD	057815H
	DD	06680cH
	DD	03004d208H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?processAudio@HighPassFilter@@QEAAMM@Z DD 032e01H
	DD	0682eH
	DD	02204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0Modulation@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1Modulation@@QEAA@XZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?init@Modulation@@QEAAXW4ModulationType@@H@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setModType@Modulation@@QEAAXW4ModulationType@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?processAudio@Modulation@@UEAAMM@Z DD 040e01H
	DD	02680eH
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0FDN@@QEAA@HHHHH@Z DB 02H
	DB	'M', 02H
	DB	010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0FDN@@QEAA@HHHHH@Z DB 010H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0FDN@@QEAA@HHHHH@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???0FDN@@QEAA@HHHHH@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0???0FDN@@QEAA@HHHHH@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$3@?0???0FDN@@QEAA@HHHHH@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$4@?0???0FDN@@QEAA@HHHHH@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$5@?0???0FDN@@QEAA@HHHHH@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$6@?0???0FDN@@QEAA@HHHHH@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$7@?0???0FDN@@QEAA@HHHHH@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0FDN@@QEAA@HHHHH@Z DB 028H
	DD	imagerel $stateUnwindMap$??0FDN@@QEAA@HHHHH@Z
	DD	imagerel $ip2state$??0FDN@@QEAA@HHHHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0FDN@@QEAA@HHHHH@Z DD 020a11H
	DD	03006520aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0FDN@@QEAA@HHHHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1FDN@@QEAA@XZ DD 0c1d01H
	DD	0b741dH
	DD	0a641dH
	DD	09541dH
	DD	08341dH
	DD	0f019321dH
	DD	0d015e017H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?initialize@FDN@@QEAAXMMHM@Z DD 0c2001H
	DD	0c6420H
	DD	0b5420H
	DD	0a3420H
	DD	0f01c3220H
	DD	0d018e01aH
	DD	07014c016H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setDecayInSeconds@FDN@@QEAAXM@Z DD 0a1f01H
	DD	02681fH
	DD	0a7415H
	DD	096415H
	DD	083415H
	DD	0e0115215H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setRoomSize@FDN@@QEAAXMW4DiffuserDelayLogic@@W4DelayDistribution@@1@Z DD 0125e01H
	DD	02a85eH
	DD	038850H
	DD	047836H
	DD	05681fH
	DD	0126418H
	DD	0115418H
	DD	0103418H
	DD	0f014b218H
	DD	07010e012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setModMix@FDN@@QEAAXM@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setDampingFrequency@FDN@@QEAAXM@Z DD 081a01H
	DD	02681aH
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setDampingType@FDN@@QEAAXW4LPFilterType@@@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setLowPassFrequency@FDN@@QEAAXM@Z DD 081601H
	DD	026816H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setHighPassFrequency@FDN@@QEAAXM@Z DD 081601H
	DD	026816H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setLowPassType@FDN@@QEAAXW4LPFilterType@@@Z DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setHighPassType@FDN@@QEAAXW4HPFilterType@@@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setStereoSpread@FDN@@QEAAXM@Z DD 020501H
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setDiffuserDelayLengths@FDN@@QEAAXMW4DiffuserDelayLogic@@W4DelayDistribution@@M@Z DD 0c1f01H
	DD	02681fH
	DD	0b7419H
	DD	0a6419H
	DD	095419H
	DD	083419H
	DD	0e0155219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setFeedbackDelayLengths@FDN@@QEAAXMMW4DelayDistribution@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setSampleRate@FDN@@QEAAXH@Z DD 0c1c01H
	DD	0c641cH
	DD	0b541cH
	DD	0a341cH
	DD	0f018321cH
	DD	0d014e016H
	DD	07010c012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?processAudio@FDN@@QEAAXPEAM0@Z DD 0c2501H
	DD	036825H
	DD	011341eH
	DD	0f01a721eH
	DD	0d016e018H
	DD	07012c014H
	DD	050106011H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setDoubledDiffuserDelayLengths@FDN@@AEAAXMMW4DelayDistribution@@@Z DD 081701H
	DD	026817H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setEqualDiffuserDelayLengths@FDN@@AEAAXMMW4DelayDistribution@@@Z DD 0c1d01H
	DD	02681dH
	DD	0b7419H
	DD	0a6419H
	DD	095419H
	DD	083419H
	DD	0e0155219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$4@?0??constructFDN@FDN@@AEAAXHHHHH@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$10@?0??constructFDN@FDN@@AEAAXHHHHH@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$3@?0??constructFDN@FDN@@AEAAXHHHHH@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$7@?0??constructFDN@FDN@@AEAAXHHHHH@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0??constructFDN@FDN@@AEAAXHHHHH@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?constructFDN@FDN@@AEAAXHHHHH@Z DB 018H
	DB	0beH
	DB	00H
	DB	0bcH
	DB	02H
	DB	'*'
	DB	04H
	DB	098H
	DB	06H
	DB	012H
	DB	04H
	DB	'X'
	DB	00H
	DB	'$'
	DB	08H
	DB	01eH
	DB	00H
	DB	')', 04H
	DB	0aH
	DB	'$'
	DB	00H
	DB	'z'
	DB	0cH
	DB	01eH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?constructFDN@FDN@@AEAAXHHHHH@Z DB 0cH
	DB	0eH
	DD	imagerel ?dtor$2@?0??constructFDN@FDN@@AEAAXHHHHH@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$5@?0??constructFDN@FDN@@AEAAXHHHHH@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$7@?0??constructFDN@FDN@@AEAAXHHHHH@Z@4HA
	DB	086H
	DD	imagerel ?dtor$3@?0??constructFDN@FDN@@AEAAXHHHHH@Z@4HA
	DB	0aeH
	DD	imagerel ?dtor$10@?0??constructFDN@FDN@@AEAAXHHHHH@Z@4HA
	DB	0d6H
	DD	imagerel ?dtor$4@?0??constructFDN@FDN@@AEAAXHHHHH@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?constructFDN@FDN@@AEAAXHHHHH@Z DB 028H
	DD	imagerel $stateUnwindMap$?constructFDN@FDN@@AEAAXHHHHH@Z
	DD	imagerel $ip2state$?constructFDN@FDN@@AEAAXHHHHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?constructFDN@FDN@@AEAAXHHHHH@Z DD 0a1e11H
	DD	0e641eH
	DD	0d341eH
	DD	0f017521eH
	DD	0c013e015H
	DD	050107011H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?constructFDN@FDN@@AEAAXHHHHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$5@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$4@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$7@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$3@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?constructDiffusionBlocks@FDN@@AEAAXXZ DB 01eH
	DB	'h'
	DB	00H
	DB	'$'
	DB	02H
	DB	'L'
	DB	00H
	DB	'j'
	DB	04H
	DB	'B'
	DB	06H
	DB	'D'
	DB	08H
	DB	018H
	DB	0aH
	DB	'J'
	DB	08H
	DB	086H
	DB	04H
	DB	01eH
	DB	0cH
	DB	01eH
	DB	04H
	DB	01eH
	DB	0eH
	DB	0d8H
	DB	00H
	DB	'F'
	DB	010H
	DB	01eH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?constructDiffusionBlocks@FDN@@AEAAXXZ DB 010H
	DB	0eH
	DD	imagerel ?dtor$0@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA
	DB	036H
	DD	imagerel ?dtor$1@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA
	DB	02eH
	DD	imagerel ?dtor$3@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA
	DB	02eH
	DD	imagerel ?dtor$6@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA
	DB	02eH
	DD	imagerel ?dtor$7@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA
	DB	0a6H
	DD	imagerel ?dtor$4@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA
	DB	0ceH
	DD	imagerel ?dtor$5@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA
	DB	04dH
	DB	02H
	DD	imagerel ?dtor$2@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?constructDiffusionBlocks@FDN@@AEAAXXZ DB 028H
	DD	imagerel $stateUnwindMap$?constructDiffusionBlocks@FDN@@AEAAXXZ
	DD	imagerel $ip2state$?constructDiffusionBlocks@FDN@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?constructDiffusionBlocks@FDN@@AEAAXXZ DD 091411H
	DD	0f00d6214H
	DD	0d009e00bH
	DD	07005c007H
	DD	030036004H
	DD	05002H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?constructDiffusionBlocks@FDN@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?constructFilters@FDN@@AEAAXXZ DD 081201H
	DD	0a5412H
	DD	093412H
	DD	0e00e3212H
	DD	0600b700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??constructModulation@FDN@@AEAAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?constructModulation@FDN@@AEAAXXZ DB 06H
	DB	'>'
	DB	00H
	DB	' '
	DB	02H
	DB	'b'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?constructModulation@FDN@@AEAAXXZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??constructModulation@FDN@@AEAAXXZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?constructModulation@FDN@@AEAAXXZ DB 028H
	DD	imagerel $stateUnwindMap$?constructModulation@FDN@@AEAAXXZ
	DD	imagerel $ip2state$?constructModulation@FDN@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?constructModulation@FDN@@AEAAXXZ DD 060d11H
	DD	0a340dH
	DD	0e009320dH
	DD	060067007H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?constructModulation@FDN@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deleteInterfaceBlocks@FDN@@AEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deleteDiffusionBlocks@FDN@@AEAAXXZ DD 0a1901H
	DD	097419H
	DD	086419H
	DD	075419H
	DD	063419H
	DD	0e0153219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deleteFeedbackBlock@FDN@@AEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deleteFilters@FDN@@AEAAXXZ DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deleteChorus@FDN@@AEAAXXZ DD 0a1901H
	DD	097419H
	DD	086419H
	DD	075419H
	DD	063419H
	DD	0e0153219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?initInternalArrays@FDN@@AEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GChannelSplitter@@QEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GChannelMixer@@QEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GMultiChannelDiffuser@@QEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GModMultiChannelDiffuser@@QEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GModMultiChannelFeedback@@QEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GHighPassFilter@@QEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GModulation@@QEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__EkCTCorrFactorZero@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__EkCTCorrFactorAntiLog@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?principalArg@@YANN@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resample@@YA_NPEAN0IIW4interpolation@@N0@Z DD 060f01H
	DD	03740fH
	DD	02640aH
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1PhaseVocoder@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0PSMVocoder@@QEAA@XZ DB 02H
	DB	'=', 06H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0PSMVocoder@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0PSMVocoder@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0PSMVocoder@@QEAA@XZ DB 028H
	DD	imagerel $stateUnwindMap$??0PSMVocoder@@QEAA@XZ
	DD	imagerel $ip2state$??0PSMVocoder@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0PSMVocoder@@QEAA@XZ DD 081811H
	DD	096418H
	DD	085418H
	DD	073418H
	DD	070143218H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0PSMVocoder@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1PSMVocoder@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reset@PSMVocoder@@UEAA_NN@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setPitchShift@PSMVocoder@@QEAAXN@Z DD 0c3001H
	DD	028830H
	DD	03782bH
	DD	046827H
	DD	0d5410H
	DD	0c3410H
	DD	0700c9210H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?findPreviousNearestPeak@PSMVocoder@@QEAAHH@Z DD 0a1901H
	DD	097419H
	DD	086419H
	DD	075419H
	DD	063419H
	DD	0e0153219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?findPeaksAndRegionsOfInfluence@PSMVocoder@@QEAAXXZ DD 0c1e01H
	DD	04681eH
	DD	0123417H
	DD	0f0109217H
	DD	0d00ce00eH
	DD	07008c00aH
	DD	050066007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?processAudioSample@PSMVocoder@@UEAANN@Z DD 01d7801H
	DD	0802d878H
	DD	0803c86fH
	DD	0804b866H
	DD	0805a85dH
	DD	08069854H
	DD	08078848H
	DD	08087839H
	DD	0809682dH
	DD	0101c6425H
	DD	0101b5425H
	DD	0101a3425H
	DD	010140125H
	DD	0e016f018H
	DD	0c012d014H
	DD	07010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setParameters@PSMVocoder@@QEAAXAEBUPSMVocoderParameters@@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__EMIN_DAMPING_FREQUENCY_LOG@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__EMAX_DAMPING_FREQUENCY_LOG@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__ELPF_FILTER_MAX_FREQ_LOG@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__ELPF_FILTER_MIN_FREQ_LOG@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?updateMix@Shimmer@@AEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0Shimmer@@QEAA@P6A_JPEAUAEffect@@HH_JPEAXM@Z@Z DB 02H
	DB	0d5H, 03H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0Shimmer@@QEAA@P6A_JPEAUAEffect@@HH_JPEAXM@Z@Z DB 02H
	DB	0cH
	DD	imagerel ??1AudioEffectX@@UEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0Shimmer@@QEAA@P6A_JPEAUAEffect@@HH_JPEAXM@Z@Z DB 028H
	DD	imagerel $stateUnwindMap$??0Shimmer@@QEAA@P6A_JPEAUAEffect@@HH_JPEAXM@Z@Z
	DD	imagerel $ip2state$??0Shimmer@@QEAA@P6A_JPEAUAEffect@@HH_JPEAXM@Z@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0Shimmer@@QEAA@P6A_JPEAUAEffect@@HH_JPEAXM@Z@Z DD 040f11H
	DD	07340fH
	DD	0700b320fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0Shimmer@@QEAA@P6A_JPEAUAEffect@@HH_JPEAXM@Z@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GShimmer@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$3@?0??InitPlugin@Shimmer@@AEAAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0??InitPlugin@Shimmer@@AEAAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0??InitPlugin@Shimmer@@AEAAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??InitPlugin@Shimmer@@AEAAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?InitPlugin@Shimmer@@AEAAXXZ DB 012H
	DB	'B'
	DB	00H
	DB	':'
	DB	02H
	DB	'$'
	DB	00H
	DB	08dH, 03H
	DB	04H
	DB	01cH
	DB	00H
	DB	089H, 03H
	DB	06H
	DB	012H
	DB	00H
	DB	','
	DB	08H
	DB	012H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?InitPlugin@Shimmer@@AEAAXXZ DB 08H
	DB	0eH
	DD	imagerel ?dtor$0@?0??InitPlugin@Shimmer@@AEAAXXZ@4HA
	DB	036H
	DD	imagerel ?dtor$1@?0??InitPlugin@Shimmer@@AEAAXXZ@4HA
	DB	05eH
	DD	imagerel ?dtor$2@?0??InitPlugin@Shimmer@@AEAAXXZ@4HA
	DB	086H
	DD	imagerel ?dtor$3@?0??InitPlugin@Shimmer@@AEAAXXZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?InitPlugin@Shimmer@@AEAAXXZ DB 028H
	DD	imagerel $stateUnwindMap$?InitPlugin@Shimmer@@AEAAXXZ
	DD	imagerel $ip2state$?InitPlugin@Shimmer@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?InitPlugin@Shimmer@@AEAAXXZ DD 0c1b11H
	DD	05681bH
	DD	0145416H
	DD	0133416H
	DD	0f012b216H
	DD	0c00ee010H
	DD	0600b700cH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?InitPlugin@Shimmer@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setSampleRate@Shimmer@@UEAAXM@Z DD 061201H
	DD	026812H
	DD	08340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?processReplacing@Shimmer@@UEAAXPEAPEAM0H@Z DD 0c3e01H
	DD	03783eH
	DD	046836H
	DD	0f013921aH
	DD	0d00fe011H
	DD	0600c700dH
	DD	0500a300bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setParameter@Shimmer@@UEAAXHM@Z DD 0c1d01H
	DD	03681dH
	DD	0d7419H
	DD	0c6419H
	DD	0b5419H
	DD	0a3419H
	DD	0e0157219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getParameterLabel@Shimmer@@UEAAXHPEAD@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getParameterDisplay@Shimmer@@UEAAXHPEAD@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getParameterName@Shimmer@@UEAAXHPEAD@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?InitPresets@Shimmer@@AEAAXXZ DD 0c1f01H
	DD	02781fH
	DD	036819H
	DD	0c7415H
	DD	0b6415H
	DD	0a3415H
	DD	0f0117215H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setProgram@Shimmer@@UEAAXH@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getProgramNameIndexed@Shimmer@@UEAA_NHHPEAD@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getChunk@Shimmer@@UEAAHPEAPEAX_N@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setChunk@Shimmer@@UEAAHPEAXH_N@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getEffectName@Shimmer@@UEAA_NPEAD@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getVendorString@Shimmer@@UEAA_NPEAD@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1Shimmer@@UEAA@XZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GFDN@@QEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GPSMVocoder@@QEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@HV?$allocator@H@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$vector@MV?$allocator@M@std@@@std@@QEAAX_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$vector@MV?$allocator@M@std@@@std@@QEAAAEAV01@$$QEAV01@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@MV?$allocator@M@std@@@std@@QEAA@_KAEBV?$allocator@M@1@@Z DD 061401H
	DD	076414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@AEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@AEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@AEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@AEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@AEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@AEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@AEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Reallocate_exactly@?$vector@MV?$allocator@M@std@@@std@@AEAAX_K@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Move_assign@?$vector@MV?$allocator@M@std@@@std@@AEAAXAEAV12@U_Equal_allocators@2@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@PEAVHighPassFilter@@@std@@QEAAXQEAPEAVHighPassFilter@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@PEAVModulation@@@std@@QEAAXQEAPEAVModulation@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@PEAVLowPassFilter@@@std@@QEAAXQEAPEAVLowPassFilter@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@PEAVModMultiChannelDiffuser@@@std@@QEAAXQEAPEAVModMultiChannelDiffuser@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@PEAVMultiChannelDiffuser@@@std@@QEAAXQEAPEAVMultiChannelDiffuser@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@PEAVModDelay@@@std@@QEAAXQEAPEAVModDelay@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@H@std@@QEAAXQEAH_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@PEAVDelay@@@std@@QEAAXQEAPEAVDelay@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_reallocate@PEAVHighPassFilter@@@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEAAPEAPEAVHighPassFilter@@QEAPEAV2@$$QEAPEAV2@@Z DD 0c1c01H
	DD	0c641cH
	DD	0b541cH
	DD	0a341cH
	DD	0f018321cH
	DD	0d014e016H
	DD	07010c012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_reallocate@PEAVModulation@@@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@QEAAPEAPEAVModulation@@QEAPEAV2@$$QEAPEAV2@@Z DD 0c1c01H
	DD	0c641cH
	DD	0b541cH
	DD	0a341cH
	DD	0f018321cH
	DD	0d014e016H
	DD	07010c012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_reallocate@PEAVLowPassFilter@@@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEAAPEAPEAVLowPassFilter@@QEAPEAV2@$$QEAPEAV2@@Z DD 0c1c01H
	DD	0c641cH
	DD	0b541cH
	DD	0a341cH
	DD	0f018321cH
	DD	0d014e016H
	DD	07010c012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_reallocate@PEAVModMultiChannelDiffuser@@@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEAAPEAPEAVModMultiChannelDiffuser@@QEAPEAV2@$$QEAPEAV2@@Z DD 0c1c01H
	DD	0c641cH
	DD	0b541cH
	DD	0a341cH
	DD	0f018321cH
	DD	0d014e016H
	DD	07010c012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_reallocate@PEAVMultiChannelDiffuser@@@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEAAPEAPEAVMultiChannelDiffuser@@QEAPEAV2@$$QEAPEAV2@@Z DD 0c1c01H
	DD	0c641cH
	DD	0b541cH
	DD	0a341cH
	DD	0f018321cH
	DD	0d014e016H
	DD	07010c012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_reallocate@PEAVModDelay@@@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEAAPEAPEAVModDelay@@QEAPEAV2@$$QEAPEAV2@@Z DD 0c1c01H
	DD	0c641cH
	DD	0b541cH
	DD	0a341cH
	DD	0f018321cH
	DD	0d014e016H
	DD	07010c012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_reallocate@H@?$vector@HV?$allocator@H@std@@@std@@QEAAPEAHQEAH$$QEAH@Z DD 0c1c01H
	DD	0c641cH
	DD	0b541cH
	DD	0a341cH
	DD	0f018321cH
	DD	0d014e016H
	DD	07010c012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_reallocate@PEAVDelay@@@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@QEAAPEAPEAVDelay@@QEAPEAV2@$$QEAPEAV2@@Z DD 0c1c01H
	DD	0c641cH
	DD	0b541cH
	DD	0a341cH
	DD	0f018321cH
	DD	0d014e016H
	DD	07010c012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_n_copies_of_ty@U_Value_init_tag@std@@@?$vector@MV?$allocator@M@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 061d01H
	DD	07641dH
	DD	06341dH
	DD	07019321dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Tidy_guard@V?$vector@MV?$allocator@M@std@@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@AEAAXQEAPEAVHighPassFilter@@_K1@Z DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Umove@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@AEAAPEAPEAVHighPassFilter@@PEAPEAV3@00@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@PEAVHighPassFilter@@@std@@QEAAPEAPEAVHighPassFilter@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@AEAAXQEAPEAVModulation@@_K1@Z DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Umove@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@AEAAPEAPEAVModulation@@PEAPEAV3@00@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@PEAVModulation@@@std@@QEAAPEAPEAVModulation@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@AEAAXQEAPEAVLowPassFilter@@_K1@Z DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Umove@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@AEAAPEAPEAVLowPassFilter@@PEAPEAV3@00@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@PEAVLowPassFilter@@@std@@QEAAPEAPEAVLowPassFilter@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@AEAAXQEAPEAVModMultiChannelDiffuser@@_K1@Z DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Umove@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@AEAAPEAPEAVModMultiChannelDiffuser@@PEAPEAV3@00@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@PEAVModMultiChannelDiffuser@@@std@@QEAAPEAPEAVModMultiChannelDiffuser@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@AEAAXQEAPEAVMultiChannelDiffuser@@_K1@Z DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Umove@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@AEAAPEAPEAVMultiChannelDiffuser@@PEAPEAV3@00@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@PEAVMultiChannelDiffuser@@@std@@QEAAPEAPEAVMultiChannelDiffuser@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@AEAAXQEAPEAVModDelay@@_K1@Z DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Umove@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@AEAAPEAPEAVModDelay@@PEAPEAV3@00@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@PEAVModDelay@@@std@@QEAAPEAPEAVModDelay@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@HV?$allocator@H@std@@@std@@AEAAXQEAH_K1@Z DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Umove@?$vector@HV?$allocator@H@std@@@std@@AEAAPEAHPEAH00@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@H@std@@QEAAPEAH_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@AEAAXQEAPEAVDelay@@_K1@Z DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Umove@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@AEAAPEAPEAVDelay@@PEAPEAV3@00@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@PEAVDelay@@@std@@QEAAPEAPEAVDelay@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy_nonzero@?$vector@MV?$allocator@M@std@@@std@@AEAAX_K@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Ufill@?$vector@MV?$allocator@M@std@@@std@@AEAAPEAMPEAM_KU_Value_init_tag@2@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy_raw@?$vector@MV?$allocator@M@std@@@std@@AEAAX_K@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAPEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@YAPEAPEAVHighPassFilter@@QEAPEAV1@0PEAPEAV1@AEAV?$allocator@PEAVHighPassFilter@@@0@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$07@std@@YA_K_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAPEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@YAPEAPEAVModulation@@QEAPEAV1@0PEAPEAV1@AEAV?$allocator@PEAVModulation@@@0@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAPEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@YAPEAPEAVLowPassFilter@@QEAPEAV1@0PEAPEAV1@AEAV?$allocator@PEAVLowPassFilter@@@0@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAPEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@YAPEAPEAVModMultiChannelDiffuser@@QEAPEAV1@0PEAPEAV1@AEAV?$allocator@PEAVModMultiChannelDiffuser@@@0@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAPEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@YAPEAPEAVMultiChannelDiffuser@@QEAPEAV1@0PEAPEAV1@AEAV?$allocator@PEAVMultiChannelDiffuser@@@0@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAPEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@YAPEAPEAVModDelay@@QEAPEAV1@0PEAPEAV1@AEAV?$allocator@PEAVModDelay@@@0@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAHV?$allocator@H@std@@@std@@YAPEAHQEAH0PEAHAEAV?$allocator@H@0@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAPEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@YAPEAPEAVDelay@@QEAPEAV1@0PEAPEAV1@AEAV?$allocator@PEAVDelay@@@0@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_value_construct_n@V?$allocator@M@std@@@std@@YAPEAMPEAM_KAEAV?$allocator@M@0@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_memmove@PEAPEAVHighPassFilter@@PEAPEAV1@@std@@YAPEAPEAVHighPassFilter@@PEAPEAV1@00@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_memmove@PEAPEAVModulation@@PEAPEAV1@@std@@YAPEAPEAVModulation@@PEAPEAV1@00@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_memmove@PEAPEAVLowPassFilter@@PEAPEAV1@@std@@YAPEAPEAVLowPassFilter@@PEAPEAV1@00@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_memmove@PEAPEAVModMultiChannelDiffuser@@PEAPEAV1@@std@@YAPEAPEAVModMultiChannelDiffuser@@PEAPEAV1@00@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_memmove@PEAPEAVMultiChannelDiffuser@@PEAPEAV1@@std@@YAPEAPEAVMultiChannelDiffuser@@PEAPEAV1@00@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_memmove@PEAPEAVModDelay@@PEAPEAV1@@std@@YAPEAPEAVModDelay@@PEAPEAV1@00@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_memmove@PEAHPEAH@std@@YAPEAHPEAH00@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_memmove@PEAPEAVDelay@@PEAPEAV1@@std@@YAPEAPEAVDelay@@PEAPEAV1@00@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Zero_range@PEAM@std@@YAPEAMQEAM0@Z DD 020601H
	DD	030023206H
?MAX_LPF_FREQUENCY_LOG$initializer$@@3P6AXXZEA DQ FLAT:??__EMAX_LPF_FREQUENCY_LOG@@YAXXZ ; MAX_LPF_FREQUENCY_LOG$initializer$
?MIN_LPF_FREQUENCY_LOG$initializer$@@3P6AXXZEA DQ FLAT:??__EMIN_LPF_FREQUENCY_LOG@@YAXXZ ; MIN_LPF_FREQUENCY_LOG$initializer$
?MAX_HPF_FREQUENCY_LOG$initializer$@@3P6AXXZEA DQ FLAT:??__EMAX_HPF_FREQUENCY_LOG@@YAXXZ ; MAX_HPF_FREQUENCY_LOG$initializer$
?MIN_HPF_FREQUENCY_LOG$initializer$@@3P6AXXZEA DQ FLAT:??__EMIN_HPF_FREQUENCY_LOG@@YAXXZ ; MIN_HPF_FREQUENCY_LOG$initializer$
?MAX_FREQUENCY_LOG$initializer$@@3P6AXXZEA DQ FLAT:??__EMAX_FREQUENCY_LOG@@YAXXZ ; MAX_FREQUENCY_LOG$initializer$
?MIN_FREQUENCY_LOG$initializer$@@3P6AXXZEA DQ FLAT:??__EMIN_FREQUENCY_LOG@@YAXXZ ; MIN_FREQUENCY_LOG$initializer$
?kCTCorrFactorZero$initializer$@@3P6AXXZEA DQ FLAT:??__EkCTCorrFactorZero@@YAXXZ ; kCTCorrFactorZero$initializer$
?kCTCorrFactorUnity$initializer$@@3P6AXXZEA DQ FLAT:??__EkCTCorrFactorUnity@@YAXXZ ; kCTCorrFactorUnity$initializer$
?kCTCorrFactorAntiUnity$initializer$@@3P6AXXZEA DQ FLAT:??__EkCTCorrFactorAntiUnity@@YAXXZ ; kCTCorrFactorAntiUnity$initializer$
?kCTCorrFactorAntiLog$initializer$@@3P6AXXZEA DQ FLAT:??__EkCTCorrFactorAntiLog@@YAXXZ ; kCTCorrFactorAntiLog$initializer$
?kCTCorrFactorAntiLogScale$initializer$@@3P6AXXZEA DQ FLAT:??__EkCTCorrFactorAntiLogScale@@YAXXZ ; kCTCorrFactorAntiLogScale$initializer$
?MIN_DAMPING_FREQUENCY_LOG$initializer$@@3P6AXXZEA DQ FLAT:??__EMIN_DAMPING_FREQUENCY_LOG@@YAXXZ ; MIN_DAMPING_FREQUENCY_LOG$initializer$
?MAX_DAMPING_FREQUENCY_LOG$initializer$@@3P6AXXZEA DQ FLAT:??__EMAX_DAMPING_FREQUENCY_LOG@@YAXXZ ; MAX_DAMPING_FREQUENCY_LOG$initializer$
?LPF_FILTER_MAX_FREQ_LOG$initializer$@@3P6AXXZEA DQ FLAT:??__ELPF_FILTER_MAX_FREQ_LOG@@YAXXZ ; LPF_FILTER_MAX_FREQ_LOG$initializer$
?LPF_FILTER_MIN_FREQ_LOG$initializer$@@3P6AXXZEA DQ FLAT:??__ELPF_FILTER_MIN_FREQ_LOG@@YAXXZ ; LPF_FILTER_MIN_FREQ_LOG$initializer$
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\Shimmer.cpp
;	COMDAT ?createEffectInstance@@YAPEAVAudioEffect@@P6A_JPEAUAEffect@@HH_JPEAXM@Z@Z
_TEXT	SEGMENT
audioMaster$ = 48
$T1 = 56
?createEffectInstance@@YAPEAVAudioEffect@@P6A_JPEAUAEffect@@HH_JPEAXM@Z@Z PROC ; createEffectInstance, COMDAT

; 89   : {

$LN8:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 90   :     return new Shimmer(audioMaster);

	mov	ecx, 344				; 00000158H
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rdx, rbx
	mov	rcx, rax
	call	??0Shimmer@@QEAA@P6A_JPEAUAEffect@@HH_JPEAXM@Z@Z ; Shimmer::Shimmer
	npad	1

; 91   : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?createEffectInstance@@YAPEAVAudioEffect@@P6A_JPEAUAEffect@@HH_JPEAXM@Z@Z ENDP ; createEffectInstance
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
audioMaster$ = 48
$T1 = 56
?dtor$0@?0??createEffectInstance@@YAPEAVAudioEffect@@P6A_JPEAUAEffect@@HH_JPEAXM@Z@Z@4HA PROC ; `createEffectInstance'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 344				; 00000158H
	mov	rcx, QWORD PTR $T1[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??createEffectInstance@@YAPEAVAudioEffect@@P6A_JPEAUAEffect@@HH_JPEAXM@Z@Z@4HA ENDP ; `createEffectInstance'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
audioMaster$ = 48
$T1 = 56
?dtor$0@?0??createEffectInstance@@YAPEAVAudioEffect@@P6A_JPEAUAEffect@@HH_JPEAXM@Z@Z@4HA PROC ; `createEffectInstance'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 344				; 00000158H
	mov	rcx, QWORD PTR $T1[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??createEffectInstance@@YAPEAVAudioEffect@@P6A_JPEAUAEffect@@HH_JPEAXM@Z@Z@4HA ENDP ; `createEffectInstance'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\cstdlib
;	COMDAT ?abs@@YANN@Z
_TEXT	SEGMENT
_Xx$ = 8
?abs@@YANN@Z PROC					; abs, COMDAT

; 24   :     return _CSTD fabs(_Xx);

	rex_jmp	QWORD PTR __imp_fabs
?abs@@YANN@Z ENDP					; abs
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z PROC ; std::_Container_base0::_Swap_proxy_and_iterators, COMDAT

; 1038 :     _CONSTEXPR20_CONTAINER void _Swap_proxy_and_iterators(_Container_base0&) noexcept {}

	ret	0
?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z ENDP ; std::_Container_base0::_Swap_proxy_and_iterators
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z PROC ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl, COMDAT

; 1288 :     _CONSTEXPR20_CONTAINER _Fake_proxy_ptr_impl(const _Fake_allocator&, const _Container_base0&) noexcept {}

	mov	rax, rcx
	ret	0
??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ENDP ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ
_TEXT	SEGMENT
this$dead$ = 8
?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ PROC	; std::_Fake_proxy_ptr_impl::_Release, COMDAT

; 1291 :     _CONSTEXPR20_CONTAINER void _Release() noexcept {}

	ret	0
?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ENDP	; std::_Fake_proxy_ptr_impl::_Release
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\constants.h
;	COMDAT ??__EMAX_LPF_FREQUENCY_LOG@@YAXXZ
text$di	SEGMENT
??__EMAX_LPF_FREQUENCY_LOG@@YAXXZ PROC			; `dynamic initializer for 'MAX_LPF_FREQUENCY_LOG'', COMDAT

; 15   : const float MAX_LPF_FREQUENCY_LOG = log(MAX_LPF_FREQUENCY);

	sub	rsp, 40					; 00000028H
	movsd	xmm0, QWORD PTR __real@40d3880000000000
	call	QWORD PTR __imp_log
	xorps	xmm1, xmm1
	cvtsd2ss xmm1, xmm0
	movss	DWORD PTR ?MAX_LPF_FREQUENCY_LOG@@3MB, xmm1
	add	rsp, 40					; 00000028H
	ret	0
??__EMAX_LPF_FREQUENCY_LOG@@YAXXZ ENDP			; `dynamic initializer for 'MAX_LPF_FREQUENCY_LOG''
text$di	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\constants.h
;	COMDAT ??__EMIN_LPF_FREQUENCY_LOG@@YAXXZ
text$di	SEGMENT
??__EMIN_LPF_FREQUENCY_LOG@@YAXXZ PROC			; `dynamic initializer for 'MIN_LPF_FREQUENCY_LOG'', COMDAT

; 16   : const float MIN_LPF_FREQUENCY_LOG = log(MIN_LPF_FREQUENCY);

	sub	rsp, 40					; 00000028H
	movsd	xmm0, QWORD PTR __real@4034000000000000
	call	QWORD PTR __imp_log
	xorps	xmm1, xmm1
	cvtsd2ss xmm1, xmm0
	movss	DWORD PTR ?MIN_LPF_FREQUENCY_LOG@@3MB, xmm1
	add	rsp, 40					; 00000028H
	ret	0
??__EMIN_LPF_FREQUENCY_LOG@@YAXXZ ENDP			; `dynamic initializer for 'MIN_LPF_FREQUENCY_LOG''
text$di	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\constants.h
;	COMDAT ??__EMAX_HPF_FREQUENCY_LOG@@YAXXZ
text$di	SEGMENT
??__EMAX_HPF_FREQUENCY_LOG@@YAXXZ PROC			; `dynamic initializer for 'MAX_HPF_FREQUENCY_LOG'', COMDAT

; 17   : const float MAX_HPF_FREQUENCY_LOG = log(MAX_HPF_FREQUENCY);

	movsd	xmm0, QWORD PTR __real@40d09a0000000000
	rex_jmp	QWORD PTR __imp_log
??__EMAX_HPF_FREQUENCY_LOG@@YAXXZ ENDP			; `dynamic initializer for 'MAX_HPF_FREQUENCY_LOG''
text$di	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\constants.h
;	COMDAT ??__EMIN_HPF_FREQUENCY_LOG@@YAXXZ
text$di	SEGMENT
??__EMIN_HPF_FREQUENCY_LOG@@YAXXZ PROC			; `dynamic initializer for 'MIN_HPF_FREQUENCY_LOG'', COMDAT

; 18   : const float MIN_HPF_FREQUENCY_LOG = log(MIN_HPF_FREQUENCY);

	movsd	xmm0, QWORD PTR __real@4034000000000000
	rex_jmp	QWORD PTR __imp_log
??__EMIN_HPF_FREQUENCY_LOG@@YAXXZ ENDP			; `dynamic initializer for 'MIN_HPF_FREQUENCY_LOG''
text$di	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\constants.h
;	COMDAT ??__EMAX_FREQUENCY_LOG@@YAXXZ
text$di	SEGMENT
??__EMAX_FREQUENCY_LOG@@YAXXZ PROC			; `dynamic initializer for 'MAX_FREQUENCY_LOG'', COMDAT

; 19   : const float MAX_FREQUENCY_LOG = log(MAX_FREQUENCY);

	movsd	xmm0, QWORD PTR __real@40d3880000000000
	rex_jmp	QWORD PTR __imp_log
??__EMAX_FREQUENCY_LOG@@YAXXZ ENDP			; `dynamic initializer for 'MAX_FREQUENCY_LOG''
text$di	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\constants.h
;	COMDAT ??__EMIN_FREQUENCY_LOG@@YAXXZ
text$di	SEGMENT
??__EMIN_FREQUENCY_LOG@@YAXXZ PROC			; `dynamic initializer for 'MIN_FREQUENCY_LOG'', COMDAT

; 20   : const float MIN_FREQUENCY_LOG = log(MIN_FREQUENCY);

	movsd	xmm0, QWORD PTR __real@4024000000000000
	rex_jmp	QWORD PTR __imp_log
??__EMIN_FREQUENCY_LOG@@YAXXZ ENDP			; `dynamic initializer for 'MIN_FREQUENCY_LOG''
text$di	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\utils.h
;	COMDAT ?mapValueIntoRange@@YAMMMM@Z
_TEXT	SEGMENT
value$ = 8
minvalue$ = 16
maxValue$ = 24
?mapValueIntoRange@@YAMMMM@Z PROC			; mapValueIntoRange, COMDAT

; 61   :     return minvalue + value * (maxValue - minvalue);

	subss	xmm2, xmm1
	mulss	xmm2, xmm0
	addss	xmm2, xmm1
	movaps	xmm0, xmm2

; 62   : }

	ret	0
?mapValueIntoRange@@YAMMMM@Z ENDP			; mapValueIntoRange
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\utils.h
;	COMDAT ?mapValueOutsideRange@@YAMMMM@Z
_TEXT	SEGMENT
value$ = 8
minValue$ = 16
maxValue$ = 24
?mapValueOutsideRange@@YAMMMM@Z PROC			; mapValueOutsideRange, COMDAT

; 69   :     return (value - minValue) / (maxValue - minValue);

	subss	xmm0, xmm1
	subss	xmm2, xmm1
	divss	xmm0, xmm2

; 70   : }

	ret	0
?mapValueOutsideRange@@YAMMMM@Z ENDP			; mapValueOutsideRange
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\utils.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\utils.h
;	COMDAT ?exponentialVector@@YA?AV?$vector@MV?$allocator@M@std@@@std@@MMH@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 96
min$ = 104
max$ = 112
n$ = 120
?exponentialVector@@YA?AV?$vector@MV?$allocator@M@std@@@std@@MMH@Z PROC ; exponentialVector, COMDAT

; 91   : inline std::vector<float> exponentialVector(float min, float max, int n) {

$LN16:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	push	r14
	sub	rsp, 80					; 00000050H
	movaps	XMMWORD PTR [rax-24], xmm6
	mov	rsi, rcx
	movsxd	rdi, r9d
	movaps	xmm6, xmm2
	movaps	XMMWORD PTR [rax-40], xmm7

; 92   :     std::vector<float> out(n);

	mov	rdx, rdi
	movaps	XMMWORD PTR [rax-56], xmm8
	movaps	xmm8, xmm1
	call	??0?$vector@MV?$allocator@M@std@@@std@@QEAA@_KAEBV?$allocator@M@1@@Z ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
	movd	xmm0, edi

; 93   :     float rate;
; 94   :     float step = (max - min) / n;

	subss	xmm6, xmm8
	cvtdq2ps xmm0, xmm0
	xor	ebp, ebp
	divss	xmm6, xmm0

; 95   :     for (int i = 0; i < n; i++) {

	test	edi, edi
	jle	SHORT $LN3@exponentia
	movsd	xmm7, QWORD PTR __real@3ff0000000000000
	mov	r14d, ebp
	movd	xmm0, edi
	cvtdq2pd xmm0, xmm0
	divsd	xmm7, xmm0
$LL4@exponentia:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

	mov	rbx, QWORD PTR [rsi]
	xorps	xmm0, xmm0
; File E:\FoxSuite\shimmer\include\utils.h

; 96   :         rate = ((float)i + 1.0) * 2.0 / n;

	cvtsi2ss xmm0, ebp
	addss	xmm0, xmm0
	addss	xmm0, DWORD PTR __real@40000000
	cvtps2pd xmm0, xmm0
	mulsd	xmm0, xmm7
	cvtpd2ps xmm0, xmm0

; 97   : 		out[i] = min + step * (exp(rate) - 0.5);

	cvtps2pd xmm0, xmm0
	call	QWORD PTR __imp_exp
	xorps	xmm1, xmm1
	xorps	xmm2, xmm2
	subsd	xmm0, QWORD PTR __real@3fe0000000000000
	cvtss2sd xmm1, xmm6
	inc	ebp
	cvtss2sd xmm2, xmm8
	mulsd	xmm0, xmm1
	addsd	xmm0, xmm2
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR [r14+rbx], xmm0
	add	r14, 4
	cmp	ebp, edi
	jl	SHORT $LL4@exponentia
$LN3@exponentia:

; 98   :     }
; 99   :     return out;
; 100  : }

	movaps	xmm6, XMMWORD PTR [rsp+64]
	lea	r11, QWORD PTR [rsp+80]
	mov	rbx, QWORD PTR [r11+16]
	mov	rax, rsi
	mov	rbp, QWORD PTR [r11+24]
	mov	rsi, QWORD PTR [r11+32]
	mov	rdi, QWORD PTR [r11+40]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm7, XMMWORD PTR [rsp+48]
	mov	rsp, r11
	pop	r14
	ret	0
?exponentialVector@@YA?AV?$vector@MV?$allocator@M@std@@@std@@MMH@Z ENDP ; exponentialVector
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\utils.h
;	COMDAT ?randomInRange@@YAMMM@Z
_TEXT	SEGMENT
min$ = 80
max$ = 88
?randomInRange@@YAMMM@Z PROC				; randomInRange, COMDAT

; 104  : inline float randomInRange(float min, float max) {

$LN4:
	sub	rsp, 72					; 00000048H
	movaps	XMMWORD PTR [rsp+48], xmm6
	movaps	xmm6, xmm1
	movaps	XMMWORD PTR [rsp+32], xmm7
	movaps	xmm7, xmm0

; 105  : 	float unitRand = rand() / float(RAND_MAX);

	call	QWORD PTR __imp_rand
	xorps	xmm0, xmm0

; 106  : 	return min + unitRand * (max - min);

	subss	xmm6, xmm7
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@38000100
	mulss	xmm0, xmm6

; 107  : }

	movaps	xmm6, XMMWORD PTR [rsp+48]
	addss	xmm0, xmm7
	movaps	xmm7, XMMWORD PTR [rsp+32]
	add	rsp, 72					; 00000048H
	ret	0
?randomInRange@@YAMMM@Z ENDP				; randomInRange
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\LowPassFilter.h
;	COMDAT ?setSampleRate@LowPassFilter@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 8
sampleRate$ = 16
?setSampleRate@LowPassFilter@@QEAAXH@Z PROC		; LowPassFilter::setSampleRate, COMDAT

; 59   : 		// allocate internal sample rate
; 60   : 		lpf_sampleRate = sampleRate;

	mov	DWORD PTR [rcx+8], edx

; 61   : 
; 62   : 		// update lpf gains
; 63   : 		updateGains();

	jmp	?updateGains@LowPassFilter@@QEAAXXZ	; LowPassFilter::updateGains
?setSampleRate@LowPassFilter@@QEAAXH@Z ENDP		; LowPassFilter::setSampleRate
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\LFO.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\LFO.h
;	COMDAT ??0LFO@@QEAA@W4OscillatorType@@@Z
_TEXT	SEGMENT
this$ = 48
type$dead$ = 56
??0LFO@@QEAA@W4OscillatorType@@@Z PROC			; LFO::LFO, COMDAT

; 42   : 	LFO(OscillatorType type = DEFAULT_OSC_TYPE)

$LN12:
	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx+24], rax
	mov	QWORD PTR [rcx+32], rax
	mov	QWORD PTR [rcx+40], rax
; File E:\FoxSuite\shimmer\include\LFO.h

; 44   : 		lfo_counter = 0.0;

	mov	QWORD PTR [rcx+16], rax

; 45   : 		lfo_sampleRate = _TEMPLATE_SAMPLERATE;

	mov	DWORD PTR [rcx+4], 44100		; 0000ac44H

; 46   : 		lfo_frequency = 0.0;

	mov	DWORD PTR [rcx], eax

; 47   : 		lfo_amplitude = 1.0;

	mov	DWORD PTR [rcx+8], 1065353216		; 3f800000H

; 48   : 		lfo_inc = 0.0;
; 49   : 		lfo_waveform = type;

	mov	DWORD PTR [rcx+12], 1

; 50   : 		lfo_unipolar = false;

	mov	BYTE PTR [rcx+48], al

; 51   : 		createTable();

	call	?createTable@LFO@@AEAAXXZ		; LFO::createTable
	npad	1

; 52   : 	}

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0LFO@@QEAA@W4OscillatorType@@@Z ENDP			; LFO::LFO
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
type$dead$ = 56
?dtor$0@?0???0LFO@@QEAA@W4OscillatorType@@@Z@4HA PROC	; `LFO::LFO'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 24
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0???0LFO@@QEAA@W4OscillatorType@@@Z@4HA ENDP	; `LFO::LFO'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
type$dead$ = 56
?dtor$0@?0???0LFO@@QEAA@W4OscillatorType@@@Z@4HA PROC	; `LFO::LFO'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 24
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0???0LFO@@QEAA@W4OscillatorType@@@Z@4HA ENDP	; `LFO::LFO'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\LFO.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\LFO.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File E:\FoxSuite\shimmer\include\LFO.h
;	COMDAT ??1LFO@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1LFO@@QEAA@XZ PROC					; LFO::~LFO, COMDAT

; 55   : 	{

$LN33:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 132  : 		lfo_table.clear();

	mov	rcx, QWORD PTR [rcx+24]
	mov	QWORD PTR [rbx+32], rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

	test	rcx, rcx
	je	SHORT $LN8@LFO

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+40]
	sub	rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -4

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN24@LFO

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN21@LFO

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN24@LFO:

; 264  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

	and	QWORD PTR [rbx+24], 0

; 1768 :             _Mylast  = nullptr;

	and	QWORD PTR [rbx+32], 0

; 1769 :             _Myend   = nullptr;

	and	QWORD PTR [rbx+40], 0
$LN8@LFO:
; File E:\FoxSuite\shimmer\include\LFO.h

; 57   : 	}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN21@LFO:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN30@LFO:
??1LFO@@QEAA@XZ ENDP					; LFO::~LFO
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\LFO.h
;	COMDAT ?init@LFO@@QEAAXW4OscillatorType@@H@Z
_TEXT	SEGMENT
this$ = 8
waveform$dead$ = 16
sampleRate$ = 24
?init@LFO@@QEAAXW4OscillatorType@@H@Z PROC		; LFO::init, COMDAT

; 60   : 		lfo_counter = 0.0;

	xor	eax, eax

; 62   : 		lfo_waveform = waveform;

	mov	QWORD PTR [rcx+12], 1

; 63   : 		lfo_frequency = 0.0;

	mov	DWORD PTR [rcx], eax

; 122  : 		lfo_inc = WAVETABLE_SIZE * lfo_frequency / (float)lfo_sampleRate;

	mov	DWORD PTR [rcx+20], eax

; 132  : 		lfo_table.clear();

	mov	rax, QWORD PTR [rcx+24]
	mov	QWORD PTR [rcx+32], rax

; 61   : 		lfo_amplitude = 1.0;

	mov	DWORD PTR [rcx+8], 1065353216		; 3f800000H

; 64   : 		lfo_sampleRate = sampleRate;		

	mov	DWORD PTR [rcx+4], r8d

; 65   : 		computeIncrement();
; 66   : 		clearTable();
; 67   : 		createTable();

	jmp	?createTable@LFO@@AEAAXXZ		; LFO::createTable
?init@LFO@@QEAAXW4OscillatorType@@H@Z ENDP		; LFO::init
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\LFO.h
;	COMDAT ?setLFOfrequency@LFO@@QEAAXM@Z
_TEXT	SEGMENT
this$ = 8
frequency$ = 16
?setLFOfrequency@LFO@@QEAAXM@Z PROC			; LFO::setLFOfrequency, COMDAT

; 70   : 	void setLFOfrequency(float frequency) {

	movd	xmm0, DWORD PTR [rcx+4]

; 71   : 		lfo_frequency = frequency;

	movss	DWORD PTR [rcx], xmm1

; 122  : 		lfo_inc = WAVETABLE_SIZE * lfo_frequency / (float)lfo_sampleRate;

	mulss	xmm1, DWORD PTR __real@45800000
	cvtdq2ps xmm0, xmm0
	divss	xmm1, xmm0
	movss	DWORD PTR [rcx+20], xmm1

; 72   : 		computeIncrement();
; 73   : 	}

	ret	0
?setLFOfrequency@LFO@@QEAAXM@Z ENDP			; LFO::setLFOfrequency
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\LFO.h
;	COMDAT ?setLFOWaveform@LFO@@QEAAXW4OscillatorType@@@Z
_TEXT	SEGMENT
this$ = 8
waveform$ = 16
?setLFOWaveform@LFO@@QEAAXW4OscillatorType@@@Z PROC	; LFO::setLFOWaveform, COMDAT

; 132  : 		lfo_table.clear();

	mov	rax, QWORD PTR [rcx+24]
	mov	QWORD PTR [rcx+32], rax

; 76   : 		lfo_waveform = waveform;

	mov	DWORD PTR [rcx+12], edx

; 77   : 		clearTable();
; 78   : 		createTable();

	jmp	?createTable@LFO@@AEAAXXZ		; LFO::createTable
?setLFOWaveform@LFO@@QEAAXW4OscillatorType@@@Z ENDP	; LFO::setLFOWaveform
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\LFO.h
;	COMDAT ?setLFOunipolar@LFO@@QEAAX_N@Z
_TEXT	SEGMENT
this$ = 8
isUnipolar$ = 16
?setLFOunipolar@LFO@@QEAAX_N@Z PROC			; LFO::setLFOunipolar, COMDAT

; 86   : 		lfo_unipolar = isUnipolar;

	mov	BYTE PTR [rcx+48], dl

; 87   : 	}

	ret	0
?setLFOunipolar@LFO@@QEAAX_N@Z ENDP			; LFO::setLFOunipolar
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\LFO.h
;	COMDAT ?setSampleRate@LFO@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 8
sampleRate$ = 16
?setSampleRate@LFO@@QEAAXH@Z PROC			; LFO::setSampleRate, COMDAT

; 122  : 		lfo_inc = WAVETABLE_SIZE * lfo_frequency / (float)lfo_sampleRate;

	movss	xmm1, DWORD PTR [rcx]
	mulss	xmm1, DWORD PTR __real@45800000

; 94   : 		lfo_sampleRate = sampleRate;

	mov	DWORD PTR [rcx+4], edx
	movd	xmm0, edx

; 122  : 		lfo_inc = WAVETABLE_SIZE * lfo_frequency / (float)lfo_sampleRate;

	cvtdq2ps xmm0, xmm0
	divss	xmm1, xmm0
	movss	DWORD PTR [rcx+20], xmm1

; 95   : 		computeIncrement();
; 96   : 	}

	ret	0
?setSampleRate@LFO@@QEAAXH@Z ENDP			; LFO::setSampleRate
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\LFO.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\LFO.h
; File E:\FoxSuite\shimmer\include\utils.h
; File E:\FoxSuite\shimmer\include\LFO.h
;	COMDAT ?processAudio@LFO@@QEAAMXZ
_TEXT	SEGMENT
this$ = 8
?processAudio@LFO@@QEAAMXZ PROC				; LFO::processAudio, COMDAT

; 126  : 		lfo_counter += lfo_inc;

	movss	xmm1, DWORD PTR [rcx+20]

; 99   : 	float processAudio() {

	mov	r8, rcx

; 126  : 		lfo_counter += lfo_inc;

	addss	xmm1, DWORD PTR [rcx+16]

; 127  : 		if (lfo_counter >= WAVETABLE_SIZE)

	movss	xmm0, DWORD PTR __real@45800000
	comiss	xmm1, xmm0
	movss	DWORD PTR [rcx+16], xmm1
	jb	SHORT $LN14@processAud

; 128  : 			lfo_counter -= WAVETABLE_SIZE;

	subss	xmm1, xmm0
	movss	DWORD PTR [rcx+16], xmm1
$LN14@processAud:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

	mov	rdx, QWORD PTR [r8+24]
; File E:\FoxSuite\shimmer\include\LFO.h

; 106  : 		int readIndexNext = (readIndex + 1 >= WAVETABLE_SIZE) ? 0 : readIndex + 1;

	xor	r9d, r9d
	cvttss2si ecx, xmm1

; 107  : 		float yn = linearInterp(0.0, 1.0, lfo_table[readIndex], lfo_table[readIndexNext], frac);

	movsxd	rax, ecx
	movd	xmm0, ecx
	inc	ecx
	cvtdq2ps xmm0, xmm0
	cmp	ecx, 4096				; 00001000H
	cmovge	ecx, r9d
	movsxd	rcx, ecx
	subss	xmm1, xmm0
; File E:\FoxSuite\shimmer\include\utils.h

; 84   : 	float result = dx * y2 + (1 - dx) * y1;

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, xmm1
	movaps	xmm2, xmm1
	mulss	xmm2, DWORD PTR [rdx+rcx*4]
	mulss	xmm0, DWORD PTR [rdx+rax*4]
	addss	xmm2, xmm0
; File E:\FoxSuite\shimmer\include\LFO.h

; 110  : 		if (lfo_unipolar) {

	cmp	BYTE PTR [r8+48], r9b
	je	SHORT $LN2@processAud

; 111  : 			yn /= 2.0;

	mulss	xmm2, DWORD PTR __real@3f000000

; 112  : 			yn += 0.5;

	addss	xmm2, DWORD PTR __real@3f000000
$LN2@processAud:

; 113  : 		}
; 114  : 		// Return LFO value
; 115  : 		return yn * lfo_amplitude;

	mulss	xmm2, DWORD PTR [r8+8]
	movaps	xmm0, xmm2

; 116  : 
; 117  : 	}

	ret	0
?processAudio@LFO@@QEAAMXZ ENDP				; LFO::processAudio
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\LFO.h
;	COMDAT ?computeIncrement@LFO@@AEAAXXZ
_TEXT	SEGMENT
this$ = 8
?computeIncrement@LFO@@AEAAXXZ PROC			; LFO::computeIncrement, COMDAT

; 121  : 	void computeIncrement() {

	movd	xmm0, DWORD PTR [rcx+4]

; 122  : 		lfo_inc = WAVETABLE_SIZE * lfo_frequency / (float)lfo_sampleRate;

	movss	xmm1, DWORD PTR [rcx]
	mulss	xmm1, DWORD PTR __real@45800000
	cvtdq2ps xmm0, xmm0
	divss	xmm1, xmm0
	movss	DWORD PTR [rcx+20], xmm1

; 123  : 	}

	ret	0
?computeIncrement@LFO@@AEAAXXZ ENDP			; LFO::computeIncrement
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\LFO.h
;	COMDAT ?increaseLFOCounter@LFO@@AEAAXXZ
_TEXT	SEGMENT
this$ = 8
?increaseLFOCounter@LFO@@AEAAXXZ PROC			; LFO::increaseLFOCounter, COMDAT

; 126  : 		lfo_counter += lfo_inc;

	movss	xmm0, DWORD PTR [rcx+20]
	addss	xmm0, DWORD PTR [rcx+16]

; 127  : 		if (lfo_counter >= WAVETABLE_SIZE)

	movss	xmm1, DWORD PTR __real@45800000
	comiss	xmm0, xmm1
	movss	DWORD PTR [rcx+16], xmm0
	jb	SHORT $LN2@increaseLF

; 128  : 			lfo_counter -= WAVETABLE_SIZE;

	subss	xmm0, xmm1
	movss	DWORD PTR [rcx+16], xmm0
$LN2@increaseLF:

; 129  : 	}

	ret	0
?increaseLFOCounter@LFO@@AEAAXXZ ENDP			; LFO::increaseLFOCounter
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\LFO.h
;	COMDAT ?clearTable@LFO@@AEAAXXZ
_TEXT	SEGMENT
this$ = 8
?clearTable@LFO@@AEAAXXZ PROC				; LFO::clearTable, COMDAT

; 132  : 		lfo_table.clear();

	mov	rax, QWORD PTR [rcx+24]
	mov	QWORD PTR [rcx+32], rax

; 133  : 	}

	ret	0
?clearTable@LFO@@AEAAXXZ ENDP				; LFO::clearTable
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\LFO.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\LFO.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\LFO.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\LFO.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\cstdlib
; File E:\FoxSuite\shimmer\include\LFO.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\LFO.h
;	COMDAT ?createTable@LFO@@AEAAXXZ
_TEXT	SEGMENT
this$ = 112
?createTable@LFO@@AEAAXXZ PROC				; LFO::createTable, COMDAT

; 135  : 	void createTable() {

$LN68:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 80					; 00000050H
	movaps	XMMWORD PTR [rax-40], xmm6

; 136  : 	
; 137  : 		lfo_table.reserve(WAVETABLE_SIZE);	

	lea	rdi, QWORD PTR [rcx+24]
	movaps	XMMWORD PTR [rax-56], xmm7
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1371 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

	mov	r15d, 4096				; 00001000H
	movaps	XMMWORD PTR [rax-72], xmm8
; File E:\FoxSuite\shimmer\include\LFO.h

; 135  : 	void createTable() {

	mov	rbx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rax, QWORD PTR [rdi+16]
	sub	rax, QWORD PTR [rdi]
	sar	rax, 2

; 1371 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

	cmp	rax, r15
	jae	SHORT $LN26@createTabl

; 1372 :             if (_Newcapacity > max_size()) {
; 1373 :                 _Xlength();
; 1374 :             }
; 1375 : 
; 1376 :             _Reallocate_exactly(_Newcapacity);

	mov	rcx, rdi
	call	?_Reallocate_exactly@?$vector@MV?$allocator@M@std@@@std@@AEAAX_K@Z ; std::vector<float,std::allocator<float> >::_Reallocate_exactly
$LN26@createTabl:
; File E:\FoxSuite\shimmer\include\LFO.h

; 142  : 		switch (lfo_waveform) {

	mov	ecx, DWORD PTR [rbx+12]
	xor	ebx, ebx
	test	ecx, ecx
	je	$LN19@createTabl
	sub	ecx, 1
	je	$LN16@createTabl
	sub	ecx, 1
	je	SHORT $LN20@createTabl
	cmp	ecx, 1
	jne	$LL54@createTabl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1563 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR [rdi]
	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR __real@3f800000
$LL15@createTabl:
; File E:\FoxSuite\shimmer\include\LFO.h

; 178  : 				if (i <= halfWave)

	cmp	rbx, 2048				; 00000800H
	ja	SHORT $LN22@createTabl

; 179  : 					lfo_table[i] = 1.0;

	movaps	xmm0, xmm1
	jmp	SHORT $LN13@createTabl
$LN22@createTabl:

; 180  : 				else
; 181  : 					lfo_table[i] = 0.0;

	movaps	xmm0, xmm2
$LN13@createTabl:

; 172  : 		}
; 173  : 
; 174  : 		// Create Pulse oscillator wave
; 175  : 		case OscillatorType::Pulse: {
; 176  : 			for (int i = 0; i < WAVETABLE_SIZE; i++) {

	movss	DWORD PTR [rax], xmm0
	inc	rbx
	add	rax, 4
	cmp	rbx, r15
	jl	SHORT $LL15@createTabl
	jmp	$LL54@createTabl
$LN20@createTabl:

; 161  : 			}
; 162  : 			break;
; 163  : 		}
; 164  : 
; 165  : 		// Create Triangular oscillator wave
; 166  : 		case OscillatorType::Triangular: {
; 167  : 			for (int i = 0; i < WAVETABLE_SIZE; i++) {

	movsd	xmm6, QWORD PTR __real@3ff0000000000000
	mov	rsi, rbx
$LL12@createTabl:

; 168  : 				step = (float)i / (float)WAVETABLE_SIZE;	

	xorps	xmm0, xmm0
	cvtsi2ss xmm0, ebx
	mulss	xmm0, DWORD PTR __real@39800000

; 169  : 				lfo_table[i] = 2.0 * abs(2.0 * step - 1.0) - 1.0;				

	cvtps2pd xmm0, xmm0
	addsd	xmm0, xmm0
	subsd	xmm0, xmm6
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\cstdlib

; 24   :     return _CSTD fabs(_Xx);

	call	QWORD PTR __imp_fabs
; File E:\FoxSuite\shimmer\include\LFO.h

; 169  : 				lfo_table[i] = 2.0 * abs(2.0 * step - 1.0) - 1.0;				

	mov	rax, QWORD PTR [rdi]
	inc	ebx
	mulsd	xmm0, QWORD PTR __real@4000000000000000
	subsd	xmm0, xmm6
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR [rsi+rax], xmm0
	add	rsi, 4
	cmp	ebx, r15d
	jl	SHORT $LL12@createTabl

; 170  : 			}
; 171  : 			break;

	jmp	$LL54@createTabl
$LN16@createTabl:

; 143  : 
; 144  : 		// Create Sine oscillator wave
; 145  : 		case OscillatorType::Sine: {
; 146  : 			for (int i = 0; i < WAVETABLE_SIZE; i++) {

	movss	xmm7, DWORD PTR __real@3a000000
	mov	esi, ebx
	movsd	xmm8, QWORD PTR __real@400921fb54442d18
	mov	rbp, rbx
	xorps	xmm6, xmm6
$LL6@createTabl:

; 148  : 				if (i != 0)

	mov	r14, QWORD PTR [rdi]
	test	esi, esi
	je	SHORT $LN17@createTabl

; 147  : 				step = (float)i / (float)WAVETABLE_SIZE;

	movd	xmm0, esi
	cvtdq2ps xmm0, xmm0

; 149  : 					lfo_table[i] = sin(step * 2.0 * M_PI);

	mulss	xmm0, xmm7
	cvtps2pd xmm0, xmm0
	mulsd	xmm0, xmm8
	call	QWORD PTR __imp_sin
	xorps	xmm1, xmm1
	cvtsd2ss xmm1, xmm0
	jmp	SHORT $LN4@createTabl
$LN17@createTabl:

; 150  : 				else
; 151  : 					lfo_table[i] = 0.0;

	movaps	xmm1, xmm6
$LN4@createTabl:

; 143  : 
; 144  : 		// Create Sine oscillator wave
; 145  : 		case OscillatorType::Sine: {
; 146  : 			for (int i = 0; i < WAVETABLE_SIZE; i++) {

	movss	DWORD PTR [r14+rbp], xmm1
	inc	esi
	add	rbp, 4
	cmp	esi, r15d
	jl	SHORT $LL6@createTabl

; 152  : 			}
; 153  : 			break;

	jmp	SHORT $LL54@createTabl
$LN19@createTabl:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

	mov	rcx, QWORD PTR [rdi]
; File E:\FoxSuite\shimmer\include\LFO.h

; 158  : 			for (int i = 0; i < WAVETABLE_SIZE; i++) {

	mov	rax, rbx
$LL9@createTabl:

; 159  : 				step = (float)i / (float)WAVETABLE_SIZE;

	movd	xmm0, ebx
	add	ebx, 4
	pshufd	xmm0, xmm0, 0
	paddd	xmm0, XMMWORD PTR __xmm@00000003000000020000000100000000
	cvtdq2ps xmm1, xmm0

; 160  : 				lfo_table[i] = 2.0 * step - 1.0;

	addps	xmm1, xmm1
	mulps	xmm1, XMMWORD PTR __xmm@39800000398000003980000039800000
	subps	xmm1, XMMWORD PTR __xmm@3f8000003f8000003f8000003f800000
	movups	XMMWORD PTR [rax+rcx], xmm1
	add	rax, 16
	cmp	ebx, r15d
	jl	SHORT $LL9@createTabl
$LL54@createTabl:

; 182  : 			}
; 183  : 			break;
; 184  : 		}
; 185  : 		}
; 186  : 	}

	movaps	xmm6, XMMWORD PTR [rsp+64]
	lea	r11, QWORD PTR [rsp+80]
	mov	rbx, QWORD PTR [r11+32]
	mov	rbp, QWORD PTR [r11+40]
	mov	rsi, QWORD PTR [r11+48]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm7, XMMWORD PTR [rsp+48]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	rdi
	ret	0
?createTable@LFO@@AEAAXXZ ENDP				; LFO::createTable
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\src\Delay.cpp
; File E:\FoxSuite\shimmer\include\src\CombFilter.cpp
; File E:\FoxSuite\shimmer\include\src\LPCombFilter.cpp
; File E:\FoxSuite\shimmer\include\LowPassFilter.h
; File E:\FoxSuite\shimmer\include\src\LPCombFilter.cpp
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\LFO.h
; File E:\FoxSuite\shimmer\include\ModDelay.h
;	COMDAT ??0ModDelay@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
$T1 = 56
$T3 = 56
??0ModDelay@@QEAA@XZ PROC				; ModDelay::ModDelay, COMDAT

; 40   : 	ModDelay() : LPCombFilter() {

$LN36:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rdi
	mov	QWORD PTR [rsp+8], rcx
	push	r15
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	r15d, r15d
	mov	QWORD PTR [rcx+40], r15
	mov	QWORD PTR [rcx+48], r15
	mov	QWORD PTR [rcx+56], r15
; File E:\FoxSuite\shimmer\include\src\Delay.cpp

; 9    : 	dly_makeUpGaindB		= 0.0;

	mov	DWORD PTR [rcx+64], r15d

; 10   : 	dly_makeUpGain			= 1.0;

	mov	QWORD PTR [rcx+68], 1065353216		; 3f800000H

; 11   : 	dly_delayInmsec			= 0.0;
; 12   : 	dly_delayInSamples		= 0.0;

	mov	QWORD PTR [rcx+20], r15

; 13   : 	dly_readIndex			= 0;

	mov	QWORD PTR [rcx+28], r15

; 14   : 	dly_writeIndex			= 0;
; 15   : 	dly_lineLengthInSamples = 0;

	mov	QWORD PTR [rcx+12], r15

; 16   : 	dly_lineLengthInmsec	= 0.0;
; 17   : 	dly_sampleRate			= _TEMPLATE_SAMPLERATE;

	mov	DWORD PTR [rcx+8], 44100		; 0000ac44H
; File E:\FoxSuite\shimmer\include\src\CombFilter.cpp

; 8    : 	cf_decayInSeconds   = 0.0;

	mov	DWORD PTR [rcx+76], r15d

; 9    : 	cf_feedbackGainSign = 1;

	mov	DWORD PTR [rcx+80], 1
; File E:\FoxSuite\shimmer\include\src\LPCombFilter.cpp

; 6    : LPCombFilter::LPCombFilter() : CombFilter() {

	lea	rax, OFFSET FLAT:??_7LPCombFilter@@6B@
	mov	QWORD PTR [rcx], rax

; 7    : 	lpcf_feedbackLPF = new LowPassFilter();	

	lea	ecx, QWORD PTR [r15+60]
	call	??2@YAPEAX_K@Z				; operator new
	mov	rbx, rax
	mov	QWORD PTR $T1[rsp], rax
; File E:\FoxSuite\shimmer\include\LowPassFilter.h

; 39   : 			lpf_cutoffFreq = freq;

	mov	DWORD PTR [rax+4], 1184645120		; 469c4000H

; 40   : 			lpf_sampleRate = sampleRate;

	mov	DWORD PTR [rax+8], 44100		; 0000ac44H

; 41   : 			lpf_type = type;

	mov	DWORD PTR [rax], r15d

; 42   : 			lpf_shelvingGaindB = DEFAULT_SHELVING_GAIN;

	mov	DWORD PTR [rax+12], -1061158912		; c0c00000H

; 43   : 			lpf_Q = DEFAULT_RESONANCE;

	mov	DWORD PTR [rax+16], 1060437492		; 3f34fdf4H

; 44   : 			lpf_xn_1 = 0.0;

	mov	QWORD PTR [rax+44], r15

; 45   : 			lpf_xn_2 = 0.0;
; 46   : 			lpf_yn_1 = 0.0;

	mov	QWORD PTR [rax+52], r15

; 47   : 			lpf_yn_2 = 0.0;
; 48   : 			updateGains();

	mov	rcx, rax
	call	?updateGains@LowPassFilter@@QEAAXXZ	; LowPassFilter::updateGains
; File E:\FoxSuite\shimmer\include\src\LPCombFilter.cpp

; 7    : 	lpcf_feedbackLPF = new LowPassFilter();	

	mov	QWORD PTR [rdi+88], rbx
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 40   : 	ModDelay() : LPCombFilter() {

	lea	rax, OFFSET FLAT:??_7ModDelay@@6B@
	mov	QWORD PTR [rdi], rax

; 41   : 		mdly_LFO = new LFO();

	lea	ecx, QWORD PTR [r15+56]
	call	??2@YAPEAX_K@Z				; operator new
	mov	rbx, rax
	mov	QWORD PTR $T3[rsp], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rax+24], r15
	mov	QWORD PTR [rax+32], r15
	mov	QWORD PTR [rax+40], r15
; File E:\FoxSuite\shimmer\include\LFO.h

; 44   : 		lfo_counter = 0.0;

	mov	QWORD PTR [rax+16], r15

; 45   : 		lfo_sampleRate = _TEMPLATE_SAMPLERATE;

	mov	DWORD PTR [rax+4], 44100		; 0000ac44H

; 46   : 		lfo_frequency = 0.0;

	mov	DWORD PTR [rax], r15d

; 47   : 		lfo_amplitude = 1.0;

	mov	DWORD PTR [rax+8], 1065353216		; 3f800000H

; 48   : 		lfo_inc = 0.0;
; 49   : 		lfo_waveform = type;

	mov	DWORD PTR [rax+12], 1

; 50   : 		lfo_unipolar = false;

	mov	BYTE PTR [rax+48], r15b

; 51   : 		createTable();

	mov	rcx, rax
	call	?createTable@LFO@@AEAAXXZ		; LFO::createTable
	npad	1
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 41   : 		mdly_LFO = new LFO();

	mov	QWORD PTR [rdi+104], rbx

; 42   : 		mdly_minDelayValue = 0.0;

	mov	QWORD PTR [rdi+128], r15

; 43   : 		mdly_maxDelayValue = 0.0;
; 44   : 		mdly_rate = 0.0;

	mov	DWORD PTR [rdi+136], r15d

; 45   : 		mdly_deltaDelayValue = 0.0;
; 46   : 		mdly_meanDelayValue = 0.0;

	mov	QWORD PTR [rdi+120], r15

; 47   : 		mdly_lfoWaveform = DEFAULT_OSC_TYPE;

	mov	DWORD PTR [rdi+116], 1

; 48   : 	}

	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r15
	ret	0
??0ModDelay@@QEAA@XZ ENDP				; ModDelay::ModDelay
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
$T1 = 56
$T3 = 56
?dtor$2@?0???0ModDelay@@QEAA@XZ@4HA PROC		; `ModDelay::ModDelay'::`1'::dtor$2
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1CombFilter@@QEAA@XZ			; CombFilter::~CombFilter
?dtor$2@?0???0ModDelay@@QEAA@XZ@4HA ENDP		; `ModDelay::ModDelay'::`1'::dtor$2
this$ = 48
$T1 = 56
$T3 = 56
?dtor$0@?0???0ModDelay@@QEAA@XZ@4HA PROC		; `ModDelay::ModDelay'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1LPCombFilter@@QEAA@XZ		; LPCombFilter::~LPCombFilter
?dtor$0@?0???0ModDelay@@QEAA@XZ@4HA ENDP		; `ModDelay::ModDelay'::`1'::dtor$0
this$ = 48
$T1 = 56
$T3 = 56
?dtor$1@?0???0ModDelay@@QEAA@XZ@4HA PROC		; `ModDelay::ModDelay'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 56					; 00000038H
	mov	rcx, QWORD PTR $T3[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???0ModDelay@@QEAA@XZ@4HA ENDP		; `ModDelay::ModDelay'::`1'::dtor$1
this$ = 48
$T1 = 56
$T3 = 56
?dtor$4@?0???0ModDelay@@QEAA@XZ@4HA PROC		; `ModDelay::ModDelay'::`1'::dtor$4
	mov	rcx, QWORD PTR $T3[rdx]
	add	rcx, 24
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$4@?0???0ModDelay@@QEAA@XZ@4HA ENDP		; `ModDelay::ModDelay'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
$T1 = 56
$T3 = 56
?dtor$2@?0???0ModDelay@@QEAA@XZ@4HA PROC		; `ModDelay::ModDelay'::`1'::dtor$2
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1CombFilter@@QEAA@XZ			; CombFilter::~CombFilter
?dtor$2@?0???0ModDelay@@QEAA@XZ@4HA ENDP		; `ModDelay::ModDelay'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
$T1 = 56
$T3 = 56
?dtor$0@?0???0ModDelay@@QEAA@XZ@4HA PROC		; `ModDelay::ModDelay'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1LPCombFilter@@QEAA@XZ		; LPCombFilter::~LPCombFilter
?dtor$0@?0???0ModDelay@@QEAA@XZ@4HA ENDP		; `ModDelay::ModDelay'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
$T1 = 56
$T3 = 56
?dtor$1@?0???0ModDelay@@QEAA@XZ@4HA PROC		; `ModDelay::ModDelay'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 56					; 00000038H
	mov	rcx, QWORD PTR $T3[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???0ModDelay@@QEAA@XZ@4HA ENDP		; `ModDelay::ModDelay'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
$T1 = 56
$T3 = 56
?dtor$4@?0???0ModDelay@@QEAA@XZ@4HA PROC		; `ModDelay::ModDelay'::`1'::dtor$4
	mov	rcx, QWORD PTR $T3[rdx]
	add	rcx, 24
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$4@?0???0ModDelay@@QEAA@XZ@4HA ENDP		; `ModDelay::ModDelay'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ModDelay.h
;	COMDAT ??1ModDelay@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1ModDelay@@QEAA@XZ PROC				; ModDelay::~ModDelay, COMDAT

; 50   : 	~ModDelay() {

$LN10:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 51   : 		delete mdly_LFO;

	mov	rdi, QWORD PTR [rcx+104]
	lea	rax, OFFSET FLAT:??_7ModDelay@@6B@
	mov	QWORD PTR [rcx], rax
	mov	rbx, rcx
	test	rdi, rdi
	je	SHORT $LN6@ModDelay
	mov	rcx, rdi
	call	??1LFO@@QEAA@XZ				; LFO::~LFO
	mov	edx, 56					; 00000038H
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN6@ModDelay:

; 52   : 	}

	mov	rcx, rbx
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	jmp	??1LPCombFilter@@QEAA@XZ		; LPCombFilter::~LPCombFilter
??1ModDelay@@QEAA@XZ ENDP				; ModDelay::~ModDelay
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File E:\FoxSuite\shimmer\include\src\Delay.cpp
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File E:\FoxSuite\shimmer\include\src\Delay.cpp
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File E:\FoxSuite\shimmer\include\LFO.h
; File E:\FoxSuite\shimmer\include\ModDelay.h
;	COMDAT ?init@ModDelay@@QEAAXMHW4OscillatorType@@@Z
_TEXT	SEGMENT
this$ = 64
bufferLengthMs$ = 72
sampleRate$ = 80
type$dead$ = 88
?init@ModDelay@@QEAAXMHW4OscillatorType@@@Z PROC	; ModDelay::init, COMDAT

; 54   : 	void init(float bufferLengthMs, int sampleRate, OscillatorType type = DEFAULT_OSC_TYPE) {

$LN19:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 48					; 00000030H
	movaps	XMMWORD PTR [rsp+32], xmm6
	mov	edi, r8d
	movaps	xmm6, xmm1
	mov	rbx, rcx

; 55   : 		bool isunipolar = false;
; 56   : 		
; 57   : 		// initialize delay line
; 58   : 		LPCombFilter::init(bufferLengthMs, sampleRate);

	call	?init@LPCombFilter@@UEAAXMH@Z		; LPCombFilter::init
; File E:\FoxSuite\shimmer\include\src\Delay.cpp

; 118  : 	if (delayInmsec > dly_lineLengthInmsec)

	movss	xmm0, DWORD PTR [rbx+16]
	comiss	xmm6, xmm0
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 84   : 		mdly_meanDelayValue = delay;

	movss	DWORD PTR [rbx+120], xmm6
; File E:\FoxSuite\shimmer\include\src\Delay.cpp

; 118  : 	if (delayInmsec > dly_lineLengthInmsec)

	ja	SHORT $LN8@init

; 119  : 		delayInmsec = dly_lineLengthInmsec;
; 120  : 	else if (delayInmsec < 0.0)

	movaps	xmm0, xmm6
	maxss	xmm0, DWORD PTR __real@00000000
$LN8@init:

; 121  : 		delayInmsec = 0.0;
; 122  : 
; 123  : 	// Set delay line length in milliseconds
; 124  : 	dly_delayInmsec = delayInmsec;
; 125  : 
; 126  : 	// Update parameters based on new delay length
; 127  : 	updateParameters();

	mov	rcx, rbx
	movss	DWORD PTR [rbx+24], xmm0
	call	?updateParameters@Delay@@AEAAXXZ	; Delay::updateParameters
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 65   : 		mdly_LFO->init(type, sampleRate);

	mov	rcx, QWORD PTR [rbx+104]
	mov	eax, 1
	mov	DWORD PTR [rbx+116], eax
; File E:\FoxSuite\shimmer\include\LFO.h

; 60   : 		lfo_counter = 0.0;

	and	DWORD PTR [rcx+16], 0

; 63   : 		lfo_frequency = 0.0;

	and	DWORD PTR [rcx], 0

; 122  : 		lfo_inc = WAVETABLE_SIZE * lfo_frequency / (float)lfo_sampleRate;

	and	DWORD PTR [rcx+20], 0

; 62   : 		lfo_waveform = waveform;

	mov	DWORD PTR [rcx+12], eax

; 132  : 		lfo_table.clear();

	mov	rax, QWORD PTR [rcx+24]
	mov	QWORD PTR [rcx+32], rax

; 61   : 		lfo_amplitude = 1.0;

	mov	DWORD PTR [rcx+8], 1065353216		; 3f800000H

; 64   : 		lfo_sampleRate = sampleRate;		

	mov	DWORD PTR [rcx+4], edi

; 65   : 		computeIncrement();
; 66   : 		clearTable();
; 67   : 		createTable();

	call	?createTable@LFO@@AEAAXXZ		; LFO::createTable
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 100  : 		mdly_LFO->setLFOunipolar(isUnipolar);

	mov	rax, QWORD PTR [rbx+104]

; 66   : 		setLFOUnipolar(isunipolar);
; 67   : 	}

	movaps	xmm6, XMMWORD PTR [rsp+32]

; 99   : 		mdly_isUnipolar = isUnipolar;

	mov	BYTE PTR [rbx+112], 0

; 66   : 		setLFOUnipolar(isunipolar);
; 67   : 	}

	mov	rbx, QWORD PTR [rsp+64]

; 100  : 		mdly_LFO->setLFOunipolar(isUnipolar);

	mov	BYTE PTR [rax+48], 0

; 66   : 		setLFOUnipolar(isunipolar);
; 67   : 	}

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
?init@ModDelay@@QEAAXMHW4OscillatorType@@@Z ENDP	; ModDelay::init
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ModDelay.h
;	COMDAT ?setDeltaDelayValue@ModDelay@@QEAAXM@Z
_TEXT	SEGMENT
this$ = 8
delta$ = 16
?setDeltaDelayValue@ModDelay@@QEAAXM@Z PROC		; ModDelay::setDeltaDelayValue, COMDAT

; 80   : 		mdly_deltaDelayValue = delta;

	movss	DWORD PTR [rcx+124], xmm1

; 81   : 	}

	ret	0
?setDeltaDelayValue@ModDelay@@QEAAXM@Z ENDP		; ModDelay::setDeltaDelayValue
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File E:\FoxSuite\shimmer\include\src\Delay.cpp
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File E:\FoxSuite\shimmer\include\src\Delay.cpp
; File E:\FoxSuite\shimmer\include\ModDelay.h
;	COMDAT ?setDelayInmsec@ModDelay@@QEAAXM@Z
_TEXT	SEGMENT
this$ = 8
delay$ = 16
?setDelayInmsec@ModDelay@@QEAAXM@Z PROC			; ModDelay::setDelayInmsec, COMDAT
; File E:\FoxSuite\shimmer\include\src\Delay.cpp

; 118  : 	if (delayInmsec > dly_lineLengthInmsec)

	movss	xmm0, DWORD PTR [rcx+16]
	comiss	xmm1, xmm0
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 84   : 		mdly_meanDelayValue = delay;

	movss	DWORD PTR [rcx+120], xmm1
; File E:\FoxSuite\shimmer\include\src\Delay.cpp

; 118  : 	if (delayInmsec > dly_lineLengthInmsec)

	ja	SHORT $LN6@setDelayIn

; 119  : 		delayInmsec = dly_lineLengthInmsec;
; 120  : 	else if (delayInmsec < 0.0)

	movaps	xmm0, xmm1
	maxss	xmm0, DWORD PTR __real@00000000
$LN6@setDelayIn:

; 121  : 		delayInmsec = 0.0;
; 122  : 
; 123  : 	// Set delay line length in milliseconds
; 124  : 	dly_delayInmsec = delayInmsec;

	movss	DWORD PTR [rcx+24], xmm0

; 125  : 
; 126  : 	// Update parameters based on new delay length
; 127  : 	updateParameters();

	jmp	?updateParameters@Delay@@AEAAXXZ	; Delay::updateParameters
?setDelayInmsec@ModDelay@@QEAAXM@Z ENDP			; ModDelay::setDelayInmsec
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File E:\FoxSuite\shimmer\include\LFO.h
; File E:\FoxSuite\shimmer\include\ModDelay.h
;	COMDAT ?setModRate@ModDelay@@QEAAXM@Z
_TEXT	SEGMENT
this$ = 8
modRate$ = 16
?setModRate@ModDelay@@QEAAXM@Z PROC			; ModDelay::setModRate, COMDAT

; 89   : 		mdly_rate = modRate;
; 90   : 		mdly_LFO->setLFOfrequency(mdly_rate);

	mov	rax, QWORD PTR [rcx+104]
	movss	DWORD PTR [rcx+136], xmm1
	movd	xmm0, DWORD PTR [rax+4]
; File E:\FoxSuite\shimmer\include\LFO.h

; 71   : 		lfo_frequency = frequency;

	movss	DWORD PTR [rax], xmm1

; 122  : 		lfo_inc = WAVETABLE_SIZE * lfo_frequency / (float)lfo_sampleRate;

	mulss	xmm1, DWORD PTR __real@45800000
	cvtdq2ps xmm0, xmm0
	divss	xmm1, xmm0
	movss	DWORD PTR [rax+20], xmm1
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 91   : 	}		

	ret	0
?setModRate@ModDelay@@QEAAXM@Z ENDP			; ModDelay::setModRate
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File E:\FoxSuite\shimmer\include\LFO.h
; File E:\FoxSuite\shimmer\include\ModDelay.h
;	COMDAT ?setLFOWaveform@ModDelay@@QEAAXW4OscillatorType@@@Z
_TEXT	SEGMENT
this$ = 8
wave$ = 16
?setLFOWaveform@ModDelay@@QEAAXW4OscillatorType@@@Z PROC ; ModDelay::setLFOWaveform, COMDAT

; 94   : 		mdly_lfoWaveform = wave;

	mov	DWORD PTR [rcx+116], edx

; 95   : 		mdly_LFO->setLFOWaveform(wave);

	mov	rcx, QWORD PTR [rcx+104]
; File E:\FoxSuite\shimmer\include\LFO.h

; 132  : 		lfo_table.clear();

	mov	rax, QWORD PTR [rcx+24]
	mov	QWORD PTR [rcx+32], rax

; 76   : 		lfo_waveform = waveform;

	mov	DWORD PTR [rcx+12], edx

; 77   : 		clearTable();
; 78   : 		createTable();

	jmp	?createTable@LFO@@AEAAXXZ		; LFO::createTable
?setLFOWaveform@ModDelay@@QEAAXW4OscillatorType@@@Z ENDP ; ModDelay::setLFOWaveform
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ModDelay.h
;	COMDAT ?setLFOUnipolar@ModDelay@@QEAAX_N@Z
_TEXT	SEGMENT
this$ = 8
isUnipolar$ = 16
?setLFOUnipolar@ModDelay@@QEAAX_N@Z PROC		; ModDelay::setLFOUnipolar, COMDAT

; 99   : 		mdly_isUnipolar = isUnipolar;
; 100  : 		mdly_LFO->setLFOunipolar(isUnipolar);

	mov	rax, QWORD PTR [rcx+104]
	mov	BYTE PTR [rcx+112], dl
	mov	BYTE PTR [rax+48], dl

; 101  : 	}	

	ret	0
?setLFOUnipolar@ModDelay@@QEAAX_N@Z ENDP		; ModDelay::setLFOUnipolar
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File E:\FoxSuite\shimmer\include\LFO.h
; File E:\FoxSuite\shimmer\include\ModDelay.h
;	COMDAT ?setSampleRate@ModDelay@@UEAAXH@Z
_TEXT	SEGMENT
this$ = 8
sampleRate$ = 16
?setSampleRate@ModDelay@@UEAAXH@Z PROC			; ModDelay::setSampleRate, COMDAT

; 104  : 		mdly_LFO->setSampleRate(sampleRate);

	mov	rax, QWORD PTR [rcx+104]
	movd	xmm0, edx
; File E:\FoxSuite\shimmer\include\LFO.h

; 122  : 		lfo_inc = WAVETABLE_SIZE * lfo_frequency / (float)lfo_sampleRate;

	cvtdq2ps xmm0, xmm0

; 94   : 		lfo_sampleRate = sampleRate;

	mov	DWORD PTR [rax+4], edx

; 122  : 		lfo_inc = WAVETABLE_SIZE * lfo_frequency / (float)lfo_sampleRate;

	movss	xmm1, DWORD PTR [rax]
	mulss	xmm1, DWORD PTR __real@45800000
	divss	xmm1, xmm0
	movss	DWORD PTR [rax+20], xmm1
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 105  : 		LPCombFilter::setSampleRate(sampleRate);

	jmp	?setSampleRate@Delay@@UEAAXH@Z		; Delay::setSampleRate
?setSampleRate@ModDelay@@UEAAXH@Z ENDP			; ModDelay::setSampleRate
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File E:\FoxSuite\shimmer\include\src\Delay.cpp
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File E:\FoxSuite\shimmer\include\src\Delay.cpp
; File E:\FoxSuite\shimmer\include\ModDelay.h
;	COMDAT ?processAudio@ModDelay@@UEAAMM@Z
_TEXT	SEGMENT
this$ = 64
xn$ = 72
?processAudio@ModDelay@@UEAAMM@Z PROC			; ModDelay::processAudio, COMDAT

; 108  : 	float processAudio(float xn) {

$LN9:
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	rbx, rcx
	movaps	XMMWORD PTR [rsp+32], xmm6

; 110  : 		float newDelayInmsec = mdly_meanDelayValue + mdly_deltaDelayValue * mdly_LFO->processAudio();

	mov	rcx, QWORD PTR [rcx+104]
	movaps	xmm6, xmm1
	call	?processAudio@LFO@@QEAAMXZ		; LFO::processAudio
	mulss	xmm0, DWORD PTR [rbx+124]
; File E:\FoxSuite\shimmer\include\src\Delay.cpp

; 118  : 	if (delayInmsec > dly_lineLengthInmsec)

	movss	xmm2, DWORD PTR [rbx+16]
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 110  : 		float newDelayInmsec = mdly_meanDelayValue + mdly_deltaDelayValue * mdly_LFO->processAudio();

	addss	xmm0, DWORD PTR [rbx+120]
; File E:\FoxSuite\shimmer\include\src\Delay.cpp

; 118  : 	if (delayInmsec > dly_lineLengthInmsec)

	comiss	xmm0, xmm2
	ja	SHORT $LN6@processAud

; 119  : 		delayInmsec = dly_lineLengthInmsec;
; 120  : 	else if (delayInmsec < 0.0)

	movaps	xmm2, xmm0
	maxss	xmm2, DWORD PTR __real@00000000
$LN6@processAud:

; 121  : 		delayInmsec = 0.0;
; 122  : 
; 123  : 	// Set delay line length in milliseconds
; 124  : 	dly_delayInmsec = delayInmsec;
; 125  : 
; 126  : 	// Update parameters based on new delay length
; 127  : 	updateParameters();

	mov	rcx, rbx
	movss	DWORD PTR [rbx+24], xmm2
	call	?updateParameters@Delay@@AEAAXXZ	; Delay::updateParameters
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 116  : 		float yn = LPCombFilter::processAudio(xn);

	movaps	xmm1, xmm6
	mov	rcx, rbx

; 117  : 
; 118  : 		return yn;
; 119  : 	}

	movaps	xmm6, XMMWORD PTR [rsp+32]
	add	rsp, 48					; 00000030H
	pop	rbx

; 116  : 		float yn = LPCombFilter::processAudio(xn);

	jmp	?processAudio@LPCombFilter@@UEAAMM@Z	; LPCombFilter::processAudio
?processAudio@ModDelay@@UEAAMM@Z ENDP			; ModDelay::processAudio
_TEXT	ENDS
; Function compile flags: /Ogspy
;	COMDAT ??_GLFO@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$dead$ = 56
??_GLFO@@QEAAPEAXI@Z PROC				; LFO::`scalar deleting destructor', COMDAT
$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	call	??1LFO@@QEAA@XZ				; LFO::~LFO
	mov	edx, 56					; 00000038H
	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??_GLFO@@QEAAPEAXI@Z ENDP				; LFO::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\src\Delay.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\src\Delay.cpp
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
;	COMDAT ??0MultiChannelDelay@@QEAA@H@Z
_TEXT	SEGMENT
this$ = 64
numCh$ = 72
$T1 = 80
$T3 = 80
??0MultiChannelDelay@@QEAA@H@Z PROC			; MultiChannelDelay::MultiChannelDelay, COMDAT

; 29   : 	MultiChannelDelay(int numCh) { 

$LN41:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	ebp, ebp
	mov	QWORD PTR [rcx+8], rbp
	mov	QWORD PTR [rcx+16], rbp
	mov	QWORD PTR [rcx+24], rbp
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h

; 135  : 		mdel_numberOfChannels = numCh;

	mov	DWORD PTR [rcx], edx

; 136  : 		mdel_minDelayMs = 0.0;

	mov	QWORD PTR [rcx+32], rbp

; 130  : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	mov	esi, ebp
	test	edx, edx
	jle	SHORT $LN14@MultiChann
$LL15@MultiChann:

; 131  : 			mdel_DelayLines.push_back(new Delay);

	mov	ecx, 72					; 00000048H
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T1[rsp], rax
; File E:\FoxSuite\shimmer\include\src\Delay.cpp

; 8    : Delay::Delay() {

	lea	rcx, OFFSET FLAT:??_7Delay@@6B@
	mov	QWORD PTR [rax], rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rax+40], rbp
	mov	QWORD PTR [rax+48], rbp
	mov	QWORD PTR [rax+56], rbp
; File E:\FoxSuite\shimmer\include\src\Delay.cpp

; 9    : 	dly_makeUpGaindB		= 0.0;

	mov	DWORD PTR [rax+64], ebp

; 10   : 	dly_makeUpGain			= 1.0;

	mov	DWORD PTR [rax+68], 1065353216		; 3f800000H

; 11   : 	dly_delayInmsec			= 0.0;
; 12   : 	dly_delayInSamples		= 0.0;

	mov	QWORD PTR [rax+20], rbp

; 13   : 	dly_readIndex			= 0;

	mov	QWORD PTR [rax+28], rbp

; 14   : 	dly_writeIndex			= 0;
; 15   : 	dly_lineLengthInSamples = 0;

	mov	QWORD PTR [rax+12], rbp

; 16   : 	dly_lineLengthInmsec	= 0.0;
; 17   : 	dly_sampleRate			= _TEMPLATE_SAMPLERATE;

	mov	DWORD PTR [rax+8], 44100		; 0000ac44H
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h

; 131  : 			mdel_DelayLines.push_back(new Delay);

	mov	QWORD PTR $T3[rsp], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 743  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rbx+16]
	cmp	rdx, QWORD PTR [rbx+24]
	je	SHORT $LN31@MultiChann

; 726  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	QWORD PTR [rdx], rax

; 727  :         _Orphan_range(_Mylast, _Mylast);
; 728  :         _Ty& _Result = *_Mylast;
; 729  :         ++_Mylast;

	add	QWORD PTR [rbx+16], 8

; 744  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN13@MultiChann
$LN31@MultiChann:

; 745  :         }
; 746  : 
; 747  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T3[rsp]
	lea	rcx, QWORD PTR [rbx+8]
	call	??$_Emplace_reallocate@PEAVDelay@@@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@QEAAPEAPEAVDelay@@QEAPEAV2@$$QEAPEAV2@@Z ; std::vector<Delay *,std::allocator<Delay *> >::_Emplace_reallocate<Delay *>
$LN13@MultiChann:
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h

; 130  : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	inc	esi
	cmp	esi, DWORD PTR [rbx]
	jl	SHORT $LL15@MultiChann
$LN14@MultiChann:

; 30   : 		constructMCDL(numCh);
; 31   : 	}

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
??0MultiChannelDelay@@QEAA@H@Z ENDP			; MultiChannelDelay::MultiChannelDelay
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
this$ = 64
numCh$ = 72
$T1 = 80
$T3 = 80
?dtor$0@?0???0MultiChannelDelay@@QEAA@H@Z@4HA PROC	; `MultiChannelDelay::MultiChannelDelay'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 8
	jmp	??1?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@QEAA@XZ ; std::vector<Delay *,std::allocator<Delay *> >::~vector<Delay *,std::allocator<Delay *> >
?dtor$0@?0???0MultiChannelDelay@@QEAA@H@Z@4HA ENDP	; `MultiChannelDelay::MultiChannelDelay'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
this$ = 64
numCh$ = 72
$T1 = 80
$T3 = 80
?dtor$0@?0???0MultiChannelDelay@@QEAA@H@Z@4HA PROC	; `MultiChannelDelay::MultiChannelDelay'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 8
	jmp	??1?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@QEAA@XZ ; std::vector<Delay *,std::allocator<Delay *> >::~vector<Delay *,std::allocator<Delay *> >
?dtor$0@?0???0MultiChannelDelay@@QEAA@H@Z@4HA ENDP	; `MultiChannelDelay::MultiChannelDelay'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
;	COMDAT ??1MultiChannelDelay@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1MultiChannelDelay@@QEAA@XZ PROC			; MultiChannelDelay::~MultiChannelDelay, COMDAT

; 33   : 	~MultiChannelDelay() { deleteDelayLines(); }

$LN52:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1544 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	r8, QWORD PTR [rcx+8]
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h

; 33   : 	~MultiChannelDelay() { deleteDelayLines(); }

	mov	rbx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1544 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	rax, QWORD PTR [rcx+16]
	cmp	r8, rax
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h

; 122  : 		if (!mdel_DelayLines.empty()) {

	je	SHORT $LN7@MultiChann
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	rax, r8
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h

; 123  : 			for (int i = 0; i < mdel_DelayLines.size(); i++) 

	xor	ebp, ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	rax, 3
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h

; 123  : 			for (int i = 0; i < mdel_DelayLines.size(); i++) 

	mov	rdx, r8
	test	rax, rax
	je	SHORT $LN5@MultiChann
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1548 :         auto& _My_data = _Mypair._Myval2;

	xor	esi, esi
$LL6@MultiChann:
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h

; 124  : 				delete mdel_DelayLines[i];

	mov	rdi, QWORD PTR [rsi+r8]
	test	rdi, rdi
	je	SHORT $LN4@MultiChann
	mov	rcx, rdi
	call	??1Delay@@QEAA@XZ			; Delay::~Delay
	mov	edx, 72					; 00000048H
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN4@MultiChann:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	r8, QWORD PTR [rbx+8]
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h

; 123  : 			for (int i = 0; i < mdel_DelayLines.size(); i++) 

	inc	ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rbx+16]
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h

; 123  : 			for (int i = 0; i < mdel_DelayLines.size(); i++) 

	add	rsi, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	rcx, r8
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h

; 123  : 			for (int i = 0; i < mdel_DelayLines.size(); i++) 

	movsxd	rax, ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	rcx, 3
	mov	rdx, r8
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h

; 123  : 			for (int i = 0; i < mdel_DelayLines.size(); i++) 

	cmp	rax, rcx
	jb	SHORT $LL6@MultiChann
$LN5@MultiChann:

; 125  : 			mdel_DelayLines.clear();

	mov	QWORD PTR [rbx+16], r8
	mov	r8, rdx
$LN7@MultiChann:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

	test	r8, r8
	je	SHORT $LN23@MultiChann

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+24]
	sub	rdx, r8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN39@MultiChann

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [r8-8]
	add	rdx, 39					; 00000027H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	r8, rcx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [r8-8]
	cmp	rax, 31
	ja	SHORT $LN36@MultiChann

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	r8, rcx
$LN39@MultiChann:

; 264  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, r8
	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

	and	QWORD PTR [rbx+8], 0

; 1768 :             _Mylast  = nullptr;

	and	QWORD PTR [rbx+16], 0

; 1769 :             _Myend   = nullptr;

	and	QWORD PTR [rbx+24], 0
$LN23@MultiChann:
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h

; 33   : 	~MultiChannelDelay() { deleteDelayLines(); }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN36@MultiChann:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN49@MultiChann:
??1MultiChannelDelay@@QEAA@XZ ENDP			; MultiChannelDelay::~MultiChannelDelay
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
;	COMDAT ?initDelayLines@MultiChannelDelay@@QEAAXMH@Z
_TEXT	SEGMENT
this$ = 64
bufferLengthMs$ = 72
sampleRate$ = 80
?initDelayLines@MultiChannelDelay@@QEAAXMH@Z PROC	; MultiChannelDelay::initDelayLines, COMDAT

; 35   : 	void initDelayLines(float bufferLengthMs, int sampleRate) {

$LN17:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	movaps	XMMWORD PTR [rax-24], xmm6
	mov	ebp, r8d

; 36   : 		mdel_sampleRate = sampleRate;

	mov	DWORD PTR [rcx+40], r8d
	movaps	xmm6, xmm1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1544 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	rax, QWORD PTR [rcx+16]
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h

; 35   : 	void initDelayLines(float bufferLengthMs, int sampleRate) {

	mov	rbx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1544 :         return _My_data._Myfirst == _My_data._Mylast;

	cmp	QWORD PTR [rcx+8], rax
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h

; 37   : 		if (!mdel_DelayLines.empty()) {

	je	SHORT $LN3@initDelayL

; 38   : 			for (int i = 0; i < mdel_numberOfChannels; i++)

	xor	edi, edi
	cmp	DWORD PTR [rcx], edi
	jle	SHORT $LN3@initDelayL
	mov	esi, edi
$LL4@initDelayL:

; 39   : 				mdel_DelayLines[i]->init(bufferLengthMs, sampleRate);

	mov	rax, QWORD PTR [rbx+8]
	mov	r8d, ebp
	movaps	xmm1, xmm6
	mov	rcx, QWORD PTR [rsi+rax]
	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax]
	inc	edi
	lea	rsi, QWORD PTR [rsi+8]
	cmp	edi, DWORD PTR [rbx]
	jl	SHORT $LL4@initDelayL
$LN3@initDelayL:

; 40   : 		}
; 41   : 	}

	mov	rbx, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	movaps	xmm6, XMMWORD PTR [rsp+32]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
?initDelayLines@MultiChannelDelay@@QEAAXMH@Z ENDP	; MultiChannelDelay::initDelayLines
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\src\Delay.cpp
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\utils.h
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\utils.h
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\src\Delay.cpp
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\src\Delay.cpp
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
;	COMDAT ?setDelayLinesLength@MultiChannelDelay@@QEAAXMMW4DelayDistribution@@@Z
_TEXT	SEGMENT
dly$7 = 32
$T3 = 56
this$ = 128
dlyMinLengthMs$dead$ = 136
dlyMaxLengthMs$ = 144
distr$ = 152
?setDelayLinesLength@MultiChannelDelay@@QEAAXMMW4DelayDistribution@@@Z PROC ; MultiChannelDelay::setDelayLinesLength, COMDAT

; 53   : 	void setDelayLinesLength(float dlyMinLengthMs, float dlyMaxLengthMs, DelayDistribution distr = DelayDistribution::RandomInRange) {

$LN116:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	push	r14
	sub	rsp, 112				; 00000070H
	movaps	XMMWORD PTR [rax-24], xmm6
	movaps	XMMWORD PTR [rax-40], xmm8
	mov	rdi, rcx

; 54   : 		mdel_minDelayMs = dlyMinLengthMs;

	mov	DWORD PTR [rcx+32], 1106247680		; 41f00000H

; 55   : 		mdel_maxDelayMs = dlyMaxLengthMs;

	movss	DWORD PTR [rcx+36], xmm2
	movd	xmm0, DWORD PTR [rcx]

; 56   : 		if (mdel_maxDelayMs / mdel_numberOfChannels < MINIMUM_DELAY_LENGTH_MCD)

	cvtdq2ps xmm0, xmm0
	movaps	xmm1, xmm2
	divss	xmm1, xmm0
	xorps	xmm3, xmm3
	cvtss2sd xmm3, xmm1
	comisd	xmm3, QWORD PTR __real@3fb999999999999a
	jae	SHORT $LN4@setDelayLi

; 57   : 			mdel_maxDelayMs = 2 * MINIMUM_DELAY_LENGTH_MCD;

	mov	DWORD PTR [rcx+36], 1045220557		; 3e4ccccdH
	movss	xmm2, DWORD PTR __real@3e4ccccd
$LN4@setDelayLi:

; 58   : 		mdel_delayDistr = distr;

	mov	DWORD PTR [rcx+44], r9d

; 59   : 		switch (distr) {

	xor	ebx, ebx
	test	r9d, r9d
	je	$LN6@setDelayLi
	sub	r9d, 1
	je	SHORT $LN5@setDelayLi
	cmp	r9d, 1
	jne	$LN67@setDelayLi

; 100  : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	cmp	DWORD PTR [rcx], ebx
	jle	$LN67@setDelayLi
	mov	esi, ebx
$LL92@setDelayLi:

; 101  : 			mdel_DelayLines[i]->setDelayInmsec(mdel_maxDelayMs);		

	movss	xmm1, DWORD PTR [rdi+36]
	mov	rax, QWORD PTR [rdi+8]
	mov	rcx, QWORD PTR [rsi+rax]
; File E:\FoxSuite\shimmer\include\src\Delay.cpp

; 118  : 	if (delayInmsec > dly_lineLengthInmsec)

	movss	xmm0, DWORD PTR [rcx+16]
	comiss	xmm1, xmm0
	ja	SHORT $LN99@setDelayLi

; 119  : 		delayInmsec = dly_lineLengthInmsec;
; 120  : 	else if (delayInmsec < 0.0)

	movaps	xmm0, xmm1
	maxss	xmm0, DWORD PTR __real@00000000
$LN99@setDelayLi:

; 121  : 		delayInmsec = 0.0;
; 122  : 
; 123  : 	// Set delay line length in milliseconds
; 124  : 	dly_delayInmsec = delayInmsec;

	movss	DWORD PTR [rcx+24], xmm0

; 125  : 
; 126  : 	// Update parameters based on new delay length
; 127  : 	updateParameters();

	call	?updateParameters@Delay@@AEAAXXZ	; Delay::updateParameters
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h

; 100  : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	inc	ebx
	add	rsi, 8
	cmp	ebx, DWORD PTR [rdi]
	jl	SHORT $LL92@setDelayLi
	jmp	$LN67@setDelayLi
$LN5@setDelayLi:

; 105  : 		float step = (mdel_maxDelayMs - MINIMUM_DELAY_LENGTH_MCD) / mdel_numberOfChannels;

	xorps	xmm1, xmm1
	cvtss2sd xmm1, xmm2
	subsd	xmm1, QWORD PTR __real@3fb999999999999a
	movd	xmm0, DWORD PTR [rcx]
	cvtdq2pd xmm0, xmm0
	divsd	xmm1, xmm0
	cvtpd2ps xmm8, xmm1

; 107  : 		for (int i = 0; i < mdel_numberOfChannels; i++) {

	cmp	DWORD PTR [rcx], ebx
	jle	$LN67@setDelayLi
	mov	rsi, rbx
$LL12@setDelayLi:
	xorps	xmm0, xmm0

; 108  : 			dlyLength = randomInRange(MINIMUM_DELAY_LENGTH_MCD + step * i, MINIMUM_DELAY_LENGTH_MCD + step * (i + 1));

	cvtsi2ss xmm0, ebx
	mulss	xmm0, xmm8
	cvtps2pd xmm1, xmm0
	addsd	xmm1, QWORD PTR __real@3fb999999999999a
	cvtpd2ps xmm6, xmm1
	inc	ebx
; File E:\FoxSuite\shimmer\include\utils.h

; 105  : 	float unitRand = rand() / float(RAND_MAX);

	call	QWORD PTR __imp_rand
	xorps	xmm3, xmm3
	cvtsi2ss xmm3, eax
	xorps	xmm0, xmm0
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h

; 108  : 			dlyLength = randomInRange(MINIMUM_DELAY_LENGTH_MCD + step * i, MINIMUM_DELAY_LENGTH_MCD + step * (i + 1));

	cvtsi2ss xmm0, ebx
	mulss	xmm0, xmm8
	cvtps2pd xmm1, xmm0
	addsd	xmm1, QWORD PTR __real@3fb999999999999a
	cvtpd2ps xmm2, xmm1
; File E:\FoxSuite\shimmer\include\utils.h

; 106  : 	return min + unitRand * (max - min);

	subss	xmm2, xmm6
	mulss	xmm3, xmm2
	mulss	xmm3, DWORD PTR __real@38000100
	addss	xmm3, xmm6
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h

; 109  : 			mdel_DelayLines[i]->setDelayInmsec(dlyLength);

	mov	rax, QWORD PTR [rdi+8]
	mov	rcx, QWORD PTR [rsi+rax]
; File E:\FoxSuite\shimmer\include\src\Delay.cpp

; 118  : 	if (delayInmsec > dly_lineLengthInmsec)

	movss	xmm0, DWORD PTR [rcx+16]
	comiss	xmm3, xmm0
	ja	SHORT $LN21@setDelayLi

; 119  : 		delayInmsec = dly_lineLengthInmsec;
; 120  : 	else if (delayInmsec < 0.0)

	movaps	xmm0, xmm3
	maxss	xmm0, DWORD PTR __real@00000000
$LN21@setDelayLi:

; 121  : 		delayInmsec = 0.0;
; 122  : 
; 123  : 	// Set delay line length in milliseconds
; 124  : 	dly_delayInmsec = delayInmsec;

	movss	DWORD PTR [rcx+24], xmm0

; 125  : 
; 126  : 	// Update parameters based on new delay length
; 127  : 	updateParameters();

	call	?updateParameters@Delay@@AEAAXXZ	; Delay::updateParameters
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h

; 107  : 		for (int i = 0; i < mdel_numberOfChannels; i++) {

	add	rsi, 8
	cmp	ebx, DWORD PTR [rdi]
	jl	$LL12@setDelayLi

; 60   : 		case DelayDistribution::RandomInRange: {
; 61   : 			setRandomInRangeDelayLines();
; 62   : 			break;

	jmp	$LN67@setDelayLi
$LN6@setDelayLi:

; 114  : 		vector<float> dly(mdel_numberOfChannels);

	movsxd	rdx, DWORD PTR [rcx]
	lea	rcx, QWORD PTR dly$7[rsp]
	call	??0?$vector@MV?$allocator@M@std@@@std@@QEAA@_KAEBV?$allocator@M@1@@Z ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
	npad	1

; 115  : 		dly = exponentialVector(0.0, mdel_maxDelayMs, mdel_numberOfChannels);

	mov	r9d, DWORD PTR [rdi]
	movss	xmm2, DWORD PTR [rdi+36]
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T3[rsp]
	call	?exponentialVector@@YA?AV?$vector@MV?$allocator@M@std@@@std@@MMH@Z ; exponentialVector
	mov	rdx, rax
	lea	rcx, QWORD PTR dly$7[rsp]
	call	??4?$vector@MV?$allocator@M@std@@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::vector<float,std::allocator<float> >::operator=
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR $T3[rsp]
	test	rcx, rcx
	je	SHORT $LN33@setDelayLi

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR $T3[rsp+16]
	sub	rax, rcx
	sar	rax, 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax*4]
	mov	rax, rcx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN49@setDelayLi

; 155  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 156  : 
; 157  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN49@setDelayLi
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN49@setDelayLi:

; 264  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN33@setDelayLi:
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h

; 116  : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	mov	esi, ebx
	cmp	DWORD PTR [rdi], ebx
	jle	SHORT $LN25@setDelayLi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1563 :         auto& _My_data = _Mypair._Myval2;

	mov	rbp, rbx
	mov	r14, rbx
$LL26@setDelayLi:

; 1564 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1565 :         _STL_VERIFY(
; 1566 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1567 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1568 : 
; 1569 :         return _My_data._Myfirst[_Pos];

	mov	rcx, QWORD PTR [rdi+8]
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h

; 117  : 			mdel_DelayLines[i]->setDelayInmsec(dly[i]);		

	mov	rax, QWORD PTR dly$7[rsp]
	movss	xmm1, DWORD PTR [rax+rbp]
	mov	rcx, QWORD PTR [r14+rcx]
; File E:\FoxSuite\shimmer\include\src\Delay.cpp

; 118  : 	if (delayInmsec > dly_lineLengthInmsec)

	movss	xmm0, DWORD PTR [rcx+16]
	comiss	xmm1, xmm0
	ja	SHORT $LN62@setDelayLi

; 119  : 		delayInmsec = dly_lineLengthInmsec;
; 120  : 	else if (delayInmsec < 0.0)

	movaps	xmm0, xmm1
	maxss	xmm0, DWORD PTR __real@00000000
$LN62@setDelayLi:

; 121  : 		delayInmsec = 0.0;
; 122  : 
; 123  : 	// Set delay line length in milliseconds
; 124  : 	dly_delayInmsec = delayInmsec;

	movss	DWORD PTR [rcx+24], xmm0

; 125  : 
; 126  : 	// Update parameters based on new delay length
; 127  : 	updateParameters();

	call	?updateParameters@Delay@@AEAAXXZ	; Delay::updateParameters
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h

; 116  : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	inc	esi
	add	r14, 8
	add	rbp, 4
	cmp	esi, DWORD PTR [rdi]
	jl	SHORT $LL26@setDelayLi
$LN25@setDelayLi:

; 118  : 		dly.clear();

	mov	rcx, QWORD PTR dly$7[rsp]
	mov	QWORD PTR dly$7[rsp+8], rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

	test	rcx, rcx
	je	SHORT $LN67@setDelayLi

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR dly$7[rsp+16]
	sub	rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -4
	mov	rax, rcx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN83@setDelayLi

; 155  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 156  : 
; 157  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN83@setDelayLi
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN83@setDelayLi:

; 264  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN67@setDelayLi:
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h

; 73   : 	}

	lea	r11, QWORD PTR [rsp+112]
	mov	rbx, QWORD PTR [r11+16]
	mov	rbp, QWORD PTR [r11+24]
	mov	rsi, QWORD PTR [r11+32]
	mov	rdi, QWORD PTR [r11+40]
	movaps	xmm6, XMMWORD PTR [rsp+96]
	movaps	xmm8, XMMWORD PTR [r11-32]
	mov	rsp, r11
	pop	r14
	ret	0
$LN113@setDelayLi:
?setDelayLinesLength@MultiChannelDelay@@QEAAXMMW4DelayDistribution@@@Z ENDP ; MultiChannelDelay::setDelayLinesLength
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
dly$7 = 32
$T3 = 56
this$ = 128
dlyMinLengthMs$dead$ = 136
dlyMaxLengthMs$ = 144
distr$ = 152
?dtor$0@?0??setDelayLinesLength@MultiChannelDelay@@QEAAXMMW4DelayDistribution@@@Z@4HA PROC ; `MultiChannelDelay::setDelayLinesLength'::`1'::dtor$0
	lea	rcx, QWORD PTR dly$7[rdx]
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0??setDelayLinesLength@MultiChannelDelay@@QEAAXMMW4DelayDistribution@@@Z@4HA ENDP ; `MultiChannelDelay::setDelayLinesLength'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
dly$7 = 32
$T3 = 56
this$ = 128
dlyMinLengthMs$dead$ = 136
dlyMaxLengthMs$ = 144
distr$ = 152
?dtor$0@?0??setDelayLinesLength@MultiChannelDelay@@QEAAXMMW4DelayDistribution@@@Z@4HA PROC ; `MultiChannelDelay::setDelayLinesLength'::`1'::dtor$0
	lea	rcx, QWORD PTR dly$7[rdx]
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0??setDelayLinesLength@MultiChannelDelay@@QEAAXMMW4DelayDistribution@@@Z@4HA ENDP ; `MultiChannelDelay::setDelayLinesLength'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
;	COMDAT ?setSampleRate@MultiChannelDelay@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
sampleRate$ = 56
?setSampleRate@MultiChannelDelay@@QEAAXH@Z PROC		; MultiChannelDelay::setSampleRate, COMDAT

; 85   : 	void setSampleRate(int sampleRate) {

$LN14:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 86   : 		for (int i = 0; i < mdel_numberOfChannels; i++) {

	xor	ebx, ebx
	mov	ebp, edx
	mov	rdi, rcx
	cmp	DWORD PTR [rcx], ebx
	jle	SHORT $LN3@setSampleR
	mov	esi, ebx
$LL4@setSampleR:

; 87   : 			mdel_sampleRate = sampleRate;

	mov	DWORD PTR [rdi+40], ebp

; 88   : 			mdel_DelayLines[i]->setSampleRate(sampleRate);

	mov	edx, ebp
	mov	rax, QWORD PTR [rdi+8]
	mov	rcx, QWORD PTR [rsi+rax]
	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+8]
	inc	ebx
	lea	rsi, QWORD PTR [rsi+8]
	cmp	ebx, DWORD PTR [rdi]
	jl	SHORT $LL4@setSampleR
$LN3@setSampleR:

; 89   : 		}
; 90   : 	}

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?setSampleRate@MultiChannelDelay@@QEAAXH@Z ENDP		; MultiChannelDelay::setSampleRate
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
;	COMDAT ?processAudio@MultiChannelDelay@@QEAAXPEAM0@Z
_TEXT	SEGMENT
this$ = 48
in$ = 56
out$ = 64
?processAudio@MultiChannelDelay@@QEAAXPEAM0@Z PROC	; MultiChannelDelay::processAudio, COMDAT

; 92   : 	void processAudio(float* in, float* out) {

$LN14:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 93   : 		for (int i = 0; i < mdel_numberOfChannels; i++) 

	xor	ebx, ebx
	mov	rdi, r8
	mov	rsi, rdx
	mov	rbp, rcx
	cmp	DWORD PTR [rcx], ebx
	jle	SHORT $LN3@processAud
	mov	r14d, ebx
	sub	rsi, r8
$LL4@processAud:

; 94   : 			out[i] = mdel_DelayLines[i]->processAudio(in[i]);

	mov	rax, QWORD PTR [rbp+8]
	movss	xmm1, DWORD PTR [rsi+rdi]
	mov	rcx, QWORD PTR [r14+rax]
	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+16]
	movss	DWORD PTR [rdi], xmm0
	inc	ebx
	lea	r14, QWORD PTR [r14+8]
	lea	rdi, QWORD PTR [rdi+4]
	cmp	ebx, DWORD PTR [rbp]
	jl	SHORT $LL4@processAud
$LN3@processAud:

; 95   : 	}

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
?processAudio@MultiChannelDelay@@QEAAXPEAM0@Z ENDP	; MultiChannelDelay::processAudio
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\src\Delay.cpp
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
;	COMDAT ?setEqualDelayLines@MultiChannelDelay@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?setEqualDelayLines@MultiChannelDelay@@AEAAXXZ PROC	; MultiChannelDelay::setEqualDelayLines, COMDAT

; 99   : 	void setEqualDelayLines() {

$LN19:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 100  : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	xor	ebx, ebx
	mov	rdi, rcx
	cmp	DWORD PTR [rcx], ebx
	jle	SHORT $LN3@setEqualDe
	mov	esi, ebx
$LL4@setEqualDe:

; 101  : 			mdel_DelayLines[i]->setDelayInmsec(mdel_maxDelayMs);		

	mov	rax, QWORD PTR [rdi+8]
	movss	xmm1, DWORD PTR [rdi+36]
	mov	rcx, QWORD PTR [rsi+rax]
; File E:\FoxSuite\shimmer\include\src\Delay.cpp

; 118  : 	if (delayInmsec > dly_lineLengthInmsec)

	movss	xmm0, DWORD PTR [rcx+16]
	comiss	xmm1, xmm0
	ja	SHORT $LN11@setEqualDe

; 119  : 		delayInmsec = dly_lineLengthInmsec;
; 120  : 	else if (delayInmsec < 0.0)

	movaps	xmm0, xmm1
	maxss	xmm0, DWORD PTR __real@00000000
$LN11@setEqualDe:

; 121  : 		delayInmsec = 0.0;
; 122  : 
; 123  : 	// Set delay line length in milliseconds
; 124  : 	dly_delayInmsec = delayInmsec;

	movss	DWORD PTR [rcx+24], xmm0

; 125  : 
; 126  : 	// Update parameters based on new delay length
; 127  : 	updateParameters();

	call	?updateParameters@Delay@@AEAAXXZ	; Delay::updateParameters
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h

; 100  : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	inc	ebx
	add	rsi, 8
	cmp	ebx, DWORD PTR [rdi]
	jl	SHORT $LL4@setEqualDe
$LN3@setEqualDe:

; 102  : 	}

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?setEqualDelayLines@MultiChannelDelay@@AEAAXXZ ENDP	; MultiChannelDelay::setEqualDelayLines
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\utils.h
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\utils.h
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\src\Delay.cpp
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\utils.h
; File E:\FoxSuite\shimmer\include\src\Delay.cpp
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
;	COMDAT ?setRandomInRangeDelayLines@MultiChannelDelay@@AEAAXXZ
_TEXT	SEGMENT
this$ = 80
?setRandomInRangeDelayLines@MultiChannelDelay@@AEAAXXZ PROC ; MultiChannelDelay::setRandomInRangeDelayLines, COMDAT

; 104  : 	void setRandomInRangeDelayLines() {

$LN21:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rsi
	push	rdi
	sub	rsp, 64					; 00000040H
	movss	xmm1, DWORD PTR [rcx+36]
	mov	rbx, rcx
	movd	xmm0, DWORD PTR [rcx]

; 105  : 		float step = (mdel_maxDelayMs - MINIMUM_DELAY_LENGTH_MCD) / mdel_numberOfChannels;

	cvtps2pd xmm1, xmm1
	cvtdq2pd xmm0, xmm0
	subsd	xmm1, QWORD PTR __real@3fb999999999999a
	movaps	XMMWORD PTR [rax-24], xmm6
	movaps	XMMWORD PTR [rax-40], xmm8

; 107  : 		for (int i = 0; i < mdel_numberOfChannels; i++) {

	xor	eax, eax
	divsd	xmm1, xmm0
	cvtpd2ps xmm8, xmm1
	cmp	DWORD PTR [rcx], eax
	jle	$LN3@setRandomI
	mov	edi, eax
$LL4@setRandomI:
	xorps	xmm0, xmm0

; 108  : 			dlyLength = randomInRange(MINIMUM_DELAY_LENGTH_MCD + step * i, MINIMUM_DELAY_LENGTH_MCD + step * (i + 1));

	lea	esi, DWORD PTR [rax+1]
	cvtsi2ss xmm0, eax
	mulss	xmm0, xmm8
	cvtps2pd xmm1, xmm0
	addsd	xmm1, QWORD PTR __real@3fb999999999999a
	cvtpd2ps xmm6, xmm1
; File E:\FoxSuite\shimmer\include\utils.h

; 105  : 	float unitRand = rand() / float(RAND_MAX);

	call	QWORD PTR __imp_rand
	xorps	xmm0, xmm0
	xorps	xmm3, xmm3
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h

; 108  : 			dlyLength = randomInRange(MINIMUM_DELAY_LENGTH_MCD + step * i, MINIMUM_DELAY_LENGTH_MCD + step * (i + 1));

	cvtsi2ss xmm0, esi
; File E:\FoxSuite\shimmer\include\utils.h

; 105  : 	float unitRand = rand() / float(RAND_MAX);

	cvtsi2ss xmm3, eax
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h

; 109  : 			mdel_DelayLines[i]->setDelayInmsec(dlyLength);

	mov	rax, QWORD PTR [rbx+8]
	mov	rcx, QWORD PTR [rdi+rax]
	mulss	xmm0, xmm8
	cvtps2pd xmm1, xmm0
; File E:\FoxSuite\shimmer\include\src\Delay.cpp

; 118  : 	if (delayInmsec > dly_lineLengthInmsec)

	movss	xmm0, DWORD PTR [rcx+16]
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h

; 108  : 			dlyLength = randomInRange(MINIMUM_DELAY_LENGTH_MCD + step * i, MINIMUM_DELAY_LENGTH_MCD + step * (i + 1));

	addsd	xmm1, QWORD PTR __real@3fb999999999999a
	cvtpd2ps xmm2, xmm1
; File E:\FoxSuite\shimmer\include\utils.h

; 106  : 	return min + unitRand * (max - min);

	subss	xmm2, xmm6
	mulss	xmm3, xmm2
	mulss	xmm3, DWORD PTR __real@38000100
	addss	xmm3, xmm6
; File E:\FoxSuite\shimmer\include\src\Delay.cpp

; 118  : 	if (delayInmsec > dly_lineLengthInmsec)

	comiss	xmm3, xmm0
	ja	SHORT $LN13@setRandomI

; 119  : 		delayInmsec = dly_lineLengthInmsec;
; 120  : 	else if (delayInmsec < 0.0)

	movaps	xmm0, xmm3
	maxss	xmm0, DWORD PTR __real@00000000
$LN13@setRandomI:

; 121  : 		delayInmsec = 0.0;
; 122  : 
; 123  : 	// Set delay line length in milliseconds
; 124  : 	dly_delayInmsec = delayInmsec;

	movss	DWORD PTR [rcx+24], xmm0

; 125  : 
; 126  : 	// Update parameters based on new delay length
; 127  : 	updateParameters();

	call	?updateParameters@Delay@@AEAAXXZ	; Delay::updateParameters
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h

; 107  : 		for (int i = 0; i < mdel_numberOfChannels; i++) {

	add	rdi, 8
	mov	eax, esi
	cmp	esi, DWORD PTR [rbx]
	jl	$LL4@setRandomI
$LN3@setRandomI:

; 110  : 		}
; 111  : 	}

	mov	rbx, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+88]
	movaps	xmm6, XMMWORD PTR [rsp+48]
	movaps	xmm8, XMMWORD PTR [rsp+32]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
?setRandomInRangeDelayLines@MultiChannelDelay@@AEAAXXZ ENDP ; MultiChannelDelay::setRandomInRangeDelayLines
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\src\Delay.cpp
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
;	COMDAT ?setExponentialDelayLengths@MultiChannelDelay@@AEAAXXZ
_TEXT	SEGMENT
dly$ = 32
$T2 = 56
this$ = 96
?setExponentialDelayLengths@MultiChannelDelay@@AEAAXXZ PROC ; MultiChannelDelay::setExponentialDelayLengths, COMDAT

; 113  : 	void setExponentialDelayLengths() {

$LN73:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rsi
	mov	QWORD PTR [rax+24], rdi
	push	r14
	sub	rsp, 80					; 00000050H
	mov	rbx, rcx

; 114  : 		vector<float> dly(mdel_numberOfChannels);

	movsxd	rdx, DWORD PTR [rcx]
	lea	rcx, QWORD PTR [rax-56]
	call	??0?$vector@MV?$allocator@M@std@@@std@@QEAA@_KAEBV?$allocator@M@1@@Z ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
	npad	1

; 115  : 		dly = exponentialVector(0.0, mdel_maxDelayMs, mdel_numberOfChannels);

	mov	r9d, DWORD PTR [rbx]
	movss	xmm2, DWORD PTR [rbx+36]
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T2[rsp]
	call	?exponentialVector@@YA?AV?$vector@MV?$allocator@M@std@@@std@@MMH@Z ; exponentialVector
	mov	rdx, rax
	lea	rcx, QWORD PTR dly$[rsp]
	call	??4?$vector@MV?$allocator@M@std@@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::vector<float,std::allocator<float> >::operator=
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR $T2[rsp]
	test	rcx, rcx
	je	SHORT $LN11@setExponen

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR $T2[rsp+16]
	sub	rax, rcx
	sar	rax, 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax*4]
	mov	rax, rcx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN27@setExponen

; 155  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 156  : 
; 157  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN27@setExponen
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN27@setExponen:

; 264  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN11@setExponen:
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h

; 116  : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	xor	edi, edi
	cmp	DWORD PTR [rbx], edi
	jle	SHORT $LN3@setExponen
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1563 :         auto& _My_data = _Mypair._Myval2;

	xor	esi, esi
	xor	r14d, r14d
$LL4@setExponen:

; 1564 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1565 :         _STL_VERIFY(
; 1566 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1567 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1568 : 
; 1569 :         return _My_data._Myfirst[_Pos];

	mov	rcx, QWORD PTR [rbx+8]
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h

; 117  : 			mdel_DelayLines[i]->setDelayInmsec(dly[i]);		

	mov	rax, QWORD PTR dly$[rsp]
	movss	xmm1, DWORD PTR [rsi+rax]
	mov	rcx, QWORD PTR [r14+rcx]
; File E:\FoxSuite\shimmer\include\src\Delay.cpp

; 118  : 	if (delayInmsec > dly_lineLengthInmsec)

	movss	xmm0, DWORD PTR [rcx+16]
	comiss	xmm1, xmm0
	ja	SHORT $LN40@setExponen

; 119  : 		delayInmsec = dly_lineLengthInmsec;
; 120  : 	else if (delayInmsec < 0.0)

	movaps	xmm0, xmm1
	maxss	xmm0, DWORD PTR __real@00000000
$LN40@setExponen:

; 121  : 		delayInmsec = 0.0;
; 122  : 
; 123  : 	// Set delay line length in milliseconds
; 124  : 	dly_delayInmsec = delayInmsec;

	movss	DWORD PTR [rcx+24], xmm0

; 125  : 
; 126  : 	// Update parameters based on new delay length
; 127  : 	updateParameters();

	call	?updateParameters@Delay@@AEAAXXZ	; Delay::updateParameters
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h

; 116  : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	inc	edi
	add	r14, 8
	add	rsi, 4
	cmp	edi, DWORD PTR [rbx]
	jl	SHORT $LL4@setExponen
$LN3@setExponen:

; 118  : 		dly.clear();

	mov	rcx, QWORD PTR dly$[rsp]
	mov	QWORD PTR dly$[rsp+8], rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

	test	rcx, rcx
	je	SHORT $LN45@setExponen

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR dly$[rsp+16]
	sub	rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -4
	mov	rax, rcx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN61@setExponen

; 155  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 156  : 
; 157  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN61@setExponen
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN61@setExponen:

; 264  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN45@setExponen:
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h

; 119  : 	}

	mov	rbx, QWORD PTR [rsp+96]
	mov	rsi, QWORD PTR [rsp+104]
	mov	rdi, QWORD PTR [rsp+112]
	add	rsp, 80					; 00000050H
	pop	r14
	ret	0
$LN70@setExponen:
?setExponentialDelayLengths@MultiChannelDelay@@AEAAXXZ ENDP ; MultiChannelDelay::setExponentialDelayLengths
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
dly$ = 32
$T2 = 56
this$ = 96
?dtor$0@?0??setExponentialDelayLengths@MultiChannelDelay@@AEAAXXZ@4HA PROC ; `MultiChannelDelay::setExponentialDelayLengths'::`1'::dtor$0
	lea	rcx, QWORD PTR dly$[rdx]
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0??setExponentialDelayLengths@MultiChannelDelay@@AEAAXXZ@4HA ENDP ; `MultiChannelDelay::setExponentialDelayLengths'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
dly$ = 32
$T2 = 56
this$ = 96
?dtor$0@?0??setExponentialDelayLengths@MultiChannelDelay@@AEAAXXZ@4HA PROC ; `MultiChannelDelay::setExponentialDelayLengths'::`1'::dtor$0
	lea	rcx, QWORD PTR dly$[rdx]
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0??setExponentialDelayLengths@MultiChannelDelay@@AEAAXXZ@4HA ENDP ; `MultiChannelDelay::setExponentialDelayLengths'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
;	COMDAT ?deleteDelayLines@MultiChannelDelay@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?deleteDelayLines@MultiChannelDelay@@AEAAXXZ PROC	; MultiChannelDelay::deleteDelayLines, COMDAT

; 121  : 	void deleteDelayLines() {

$LN24:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1544 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	rdx, QWORD PTR [rcx+8]
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h

; 121  : 	void deleteDelayLines() {

	mov	rbx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1544 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	rax, QWORD PTR [rcx+16]
	cmp	rdx, rax
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h

; 122  : 		if (!mdel_DelayLines.empty()) {

	je	SHORT $LN5@deleteDela
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	rax, rdx
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h

; 123  : 			for (int i = 0; i < mdel_DelayLines.size(); i++) 

	xor	ebp, ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	rax, 3
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h

; 123  : 			for (int i = 0; i < mdel_DelayLines.size(); i++) 

	test	rax, rax
	je	SHORT $LN3@deleteDela
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1548 :         auto& _My_data = _Mypair._Myval2;

	xor	esi, esi
$LL4@deleteDela:
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h

; 124  : 				delete mdel_DelayLines[i];

	mov	rdi, QWORD PTR [rsi+rdx]
	test	rdi, rdi
	je	SHORT $LN2@deleteDela
	mov	rcx, rdi
	call	??1Delay@@QEAA@XZ			; Delay::~Delay
	mov	edx, 72					; 00000048H
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN2@deleteDela:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR [rbx+8]
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h

; 123  : 			for (int i = 0; i < mdel_DelayLines.size(); i++) 

	inc	ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rbx+16]
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h

; 123  : 			for (int i = 0; i < mdel_DelayLines.size(); i++) 

	add	rsi, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	rcx, rdx
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h

; 123  : 			for (int i = 0; i < mdel_DelayLines.size(); i++) 

	movsxd	rax, ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	rcx, 3
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h

; 123  : 			for (int i = 0; i < mdel_DelayLines.size(); i++) 

	cmp	rax, rcx
	jb	SHORT $LL4@deleteDela
$LN3@deleteDela:

; 125  : 			mdel_DelayLines.clear();

	mov	QWORD PTR [rbx+16], rdx
$LN5@deleteDela:

; 126  : 		}
; 127  : 	}

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?deleteDelayLines@MultiChannelDelay@@AEAAXXZ ENDP	; MultiChannelDelay::deleteDelayLines
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\src\Delay.cpp
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\src\Delay.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\src\Delay.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
;	COMDAT ?constructDelayObjects@MultiChannelDelay@@AEAAXXZ
_TEXT	SEGMENT
$T1 = 48
$T3 = 48
this$ = 48
?constructDelayObjects@MultiChannelDelay@@AEAAXXZ PROC	; MultiChannelDelay::constructDelayObjects, COMDAT

; 129  : 	void constructDelayObjects() {

$LN30:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 130  : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	xor	esi, esi
	mov	rbx, rcx
	cmp	DWORD PTR [rcx], esi
	jle	SHORT $LN3@constructD
$LL4@constructD:

; 131  : 			mdel_DelayLines.push_back(new Delay);

	mov	ecx, 72					; 00000048H
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T1[rsp], rax
; File E:\FoxSuite\shimmer\include\src\Delay.cpp

; 8    : Delay::Delay() {

	lea	rcx, OFFSET FLAT:??_7Delay@@6B@
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h

; 131  : 			mdel_DelayLines.push_back(new Delay);

	mov	QWORD PTR $T3[rsp], rax
; File E:\FoxSuite\shimmer\include\src\Delay.cpp

; 8    : Delay::Delay() {

	mov	QWORD PTR [rax], rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	and	QWORD PTR [rax+40], 0
	and	QWORD PTR [rax+48], 0
	and	QWORD PTR [rax+56], 0
; File E:\FoxSuite\shimmer\include\src\Delay.cpp

; 9    : 	dly_makeUpGaindB		= 0.0;

	and	DWORD PTR [rax+64], 0

; 10   : 	dly_makeUpGain			= 1.0;
; 11   : 	dly_delayInmsec			= 0.0;

	and	DWORD PTR [rax+24], 0

; 12   : 	dly_delayInSamples		= 0.0;

	and	DWORD PTR [rax+20], 0

; 13   : 	dly_readIndex			= 0;

	and	DWORD PTR [rax+28], 0

; 14   : 	dly_writeIndex			= 0;

	and	DWORD PTR [rax+32], 0

; 15   : 	dly_lineLengthInSamples = 0;

	and	DWORD PTR [rax+12], 0

; 16   : 	dly_lineLengthInmsec	= 0.0;

	and	DWORD PTR [rax+16], 0
	mov	DWORD PTR [rax+68], 1065353216		; 3f800000H

; 17   : 	dly_sampleRate			= _TEMPLATE_SAMPLERATE;

	mov	DWORD PTR [rax+8], 44100		; 0000ac44H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 743  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rbx+16]
	cmp	rdx, QWORD PTR [rbx+24]
	je	SHORT $LN20@constructD

; 726  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	QWORD PTR [rdx], rax

; 727  :         _Orphan_range(_Mylast, _Mylast);
; 728  :         _Ty& _Result = *_Mylast;
; 729  :         ++_Mylast;

	add	QWORD PTR [rbx+16], 8

; 744  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN2@constructD
$LN20@constructD:

; 745  :         }
; 746  : 
; 747  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T3[rsp]
	lea	rcx, QWORD PTR [rbx+8]
	call	??$_Emplace_reallocate@PEAVDelay@@@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@QEAAPEAPEAVDelay@@QEAPEAV2@$$QEAPEAV2@@Z ; std::vector<Delay *,std::allocator<Delay *> >::_Emplace_reallocate<Delay *>
$LN2@constructD:
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h

; 130  : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	inc	esi
	cmp	esi, DWORD PTR [rbx]
	jl	SHORT $LL4@constructD
$LN3@constructD:

; 132  : 	}

	mov	rbx, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?constructDelayObjects@MultiChannelDelay@@AEAAXXZ ENDP	; MultiChannelDelay::constructDelayObjects
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\src\Delay.cpp
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\src\Delay.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\src\Delay.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
;	COMDAT ?constructMCDL@MultiChannelDelay@@AEAAXH@Z
_TEXT	SEGMENT
$T1 = 48
$T3 = 48
this$ = 48
numCh$ = 56
?constructMCDL@MultiChannelDelay@@AEAAXH@Z PROC		; MultiChannelDelay::constructMCDL, COMDAT

; 134  : 	void constructMCDL(int numCh) {

$LN32:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 135  : 		mdel_numberOfChannels = numCh;
; 136  : 		mdel_minDelayMs = 0.0;

	xor	ebp, ebp
	mov	DWORD PTR [rcx], edx
	mov	QWORD PTR [rcx+32], rbp
	mov	rbx, rcx

; 130  : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	mov	esi, ebp
	test	edx, edx
	jle	SHORT $LN5@constructM
$LL6@constructM:

; 131  : 			mdel_DelayLines.push_back(new Delay);

	mov	ecx, 72					; 00000048H
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T1[rsp], rax
; File E:\FoxSuite\shimmer\include\src\Delay.cpp

; 8    : Delay::Delay() {

	lea	rcx, OFFSET FLAT:??_7Delay@@6B@
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h

; 131  : 			mdel_DelayLines.push_back(new Delay);

	mov	QWORD PTR $T3[rsp], rax
; File E:\FoxSuite\shimmer\include\src\Delay.cpp

; 8    : Delay::Delay() {

	mov	QWORD PTR [rax], rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rax+40], rbp
	mov	QWORD PTR [rax+48], rbp
	mov	QWORD PTR [rax+56], rbp
; File E:\FoxSuite\shimmer\include\src\Delay.cpp

; 9    : 	dly_makeUpGaindB		= 0.0;

	mov	DWORD PTR [rax+64], ebp

; 10   : 	dly_makeUpGain			= 1.0;

	mov	DWORD PTR [rax+68], 1065353216		; 3f800000H

; 11   : 	dly_delayInmsec			= 0.0;
; 12   : 	dly_delayInSamples		= 0.0;

	mov	QWORD PTR [rax+20], rbp

; 13   : 	dly_readIndex			= 0;

	mov	QWORD PTR [rax+28], rbp

; 14   : 	dly_writeIndex			= 0;
; 15   : 	dly_lineLengthInSamples = 0;

	mov	QWORD PTR [rax+12], rbp

; 16   : 	dly_lineLengthInmsec	= 0.0;
; 17   : 	dly_sampleRate			= _TEMPLATE_SAMPLERATE;

	mov	DWORD PTR [rax+8], 44100		; 0000ac44H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 743  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rbx+16]
	cmp	rdx, QWORD PTR [rbx+24]
	je	SHORT $LN22@constructM

; 726  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	QWORD PTR [rdx], rax

; 727  :         _Orphan_range(_Mylast, _Mylast);
; 728  :         _Ty& _Result = *_Mylast;
; 729  :         ++_Mylast;

	add	QWORD PTR [rbx+16], 8

; 744  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN4@constructM
$LN22@constructM:

; 745  :         }
; 746  : 
; 747  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T3[rsp]
	lea	rcx, QWORD PTR [rbx+8]
	call	??$_Emplace_reallocate@PEAVDelay@@@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@QEAAPEAPEAVDelay@@QEAPEAV2@$$QEAPEAV2@@Z ; std::vector<Delay *,std::allocator<Delay *> >::_Emplace_reallocate<Delay *>
$LN4@constructM:
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h

; 130  : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	inc	esi
	cmp	esi, DWORD PTR [rbx]
	jl	SHORT $LL6@constructM
$LN5@constructM:

; 137  : 		mdel_maxDelayMs = 0.0;
; 138  : 		constructDelayObjects();		
; 139  : 	}

	mov	rbx, QWORD PTR [rsp+56]
	mov	rbp, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?constructMCDL@MultiChannelDelay@@AEAAXH@Z ENDP		; MultiChannelDelay::constructMCDL
_TEXT	ENDS
; Function compile flags: /Ogspy
;	COMDAT ??_GDelay@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$dead$ = 56
??_GDelay@@QEAAPEAXI@Z PROC				; Delay::`scalar deleting destructor', COMDAT
$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	call	??1Delay@@QEAA@XZ			; Delay::~Delay
	mov	edx, 72					; 00000048H
	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??_GDelay@@QEAAPEAXI@Z ENDP				; Delay::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\Hadamard.h
;	COMDAT ??0Hadamard@@QEAA@H@Z
_TEXT	SEGMENT
this$ = 48
numCh$ = 56
??0Hadamard@@QEAA@H@Z PROC				; Hadamard::Hadamard, COMDAT

; 21   : 	Hadamard(int numCh) { 

$LN44:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 41   : 		had_scalingFactor = sqrt(1.0 / had_numberOfChannels);

	movsd	xmm0, QWORD PTR __real@3ff0000000000000

; 21   : 	Hadamard(int numCh) { 

	mov	rbx, rcx

; 35   : 		had_matrix = nullptr;

	and	QWORD PTR [rcx+8], 0
	movd	xmm1, edx

; 41   : 		had_scalingFactor = sqrt(1.0 / had_numberOfChannels);

	cvtdq2pd xmm1, xmm1
	mov	DWORD PTR [rcx], edx
	divsd	xmm0, xmm1
	call	QWORD PTR __imp_sqrt

; 42   : 		had_matrix = new int* [had_numberOfChannels];

	movsxd	rcx, DWORD PTR [rbx]
	xorps	xmm1, xmm1
	cvtsd2ss xmm1, xmm0
	mov	eax, 8
	mov	rbp, -1
	mul	rcx
	movss	DWORD PTR [rbx+4], xmm1
	cmovo	rax, rbp
	mov	rcx, rax
	call	??_U@YAPEAX_K@Z				; operator new[]

; 43   : 		for (int i = 0; i < had_numberOfChannels; i++) had_matrix[i] = new int[had_numberOfChannels];

	xor	esi, esi
	mov	QWORD PTR [rbx+8], rax
	cmp	DWORD PTR [rbx], esi
	jle	SHORT $LN5@Hadamard
	xor	edi, edi
$LL6@Hadamard:
	movsxd	rcx, DWORD PTR [rbx]
	mov	eax, 4
	mul	rcx
	cmovo	rax, rbp
	mov	rcx, rax
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	rcx, QWORD PTR [rbx+8]
	inc	esi
	mov	QWORD PTR [rdi+rcx], rax
	lea	rdi, QWORD PTR [rdi+8]
	cmp	esi, DWORD PTR [rbx]
	jl	SHORT $LL6@Hadamard
	mov	rax, QWORD PTR [rbx+8]
$LN5@Hadamard:

; 44   : 		had_matrix[0][0] = 1;

	mov	rax, QWORD PTR [rax]

; 45   : 		for (int x = 1;x < had_numberOfChannels;x += x) {

	mov	edi, 1
	mov	DWORD PTR [rax], 1
	cmp	DWORD PTR [rbx], edi
	jle	SHORT $LN8@Hadamard
	mov	r10d, edi
$LL9@Hadamard:

; 46   : 			for (int i = 0;i < x;i++) {

	xor	r11d, r11d
	test	r10, r10
	jle	SHORT $LN7@Hadamard
$LL12@Hadamard:
	lea	rsi, QWORD PTR [r11*8]

; 47   : 				for (int j = 0;j < x;j++) {

	xor	ebp, ebp
	lea	r14, QWORD PTR [rsi+r10*8]
$LL15@Hadamard:

; 48   : 					had_matrix[i + x][j] = had_matrix[i][j];

	mov	rcx, QWORD PTR [rbx+8]
	lea	r9, QWORD PTR [rbp*4]

; 49   : 					had_matrix[i][j + x] = had_matrix[i][j];

	lea	r8, QWORD PTR [r9+r10*4]
	inc	rbp
	mov	rax, QWORD PTR [rsi+rcx]
	mov	rcx, QWORD PTR [r14+rcx]
	mov	eax, DWORD PTR [r9+rax]
	mov	DWORD PTR [r9+rcx], eax
	mov	rax, QWORD PTR [rbx+8]
	mov	rcx, QWORD PTR [rsi+rax]
	mov	eax, DWORD PTR [rcx+r9]
	mov	DWORD PTR [r8+rcx], eax

; 50   : 					had_matrix[i + x][j + x] = -had_matrix[i][j];

	mov	rdx, QWORD PTR [rbx+8]
	mov	rax, QWORD PTR [rsi+rdx]
	mov	ecx, DWORD PTR [rax+r9]
	mov	rax, QWORD PTR [r14+rdx]
	neg	ecx
	mov	DWORD PTR [r8+rax], ecx
	cmp	rbp, r10
	jl	SHORT $LL15@Hadamard

; 46   : 			for (int i = 0;i < x;i++) {

	inc	r11
	cmp	r11, r10
	jl	SHORT $LL12@Hadamard
$LN7@Hadamard:

; 45   : 		for (int x = 1;x < had_numberOfChannels;x += x) {

	add	edi, edi
	add	r10, r10
	cmp	edi, DWORD PTR [rbx]
	jl	SHORT $LL9@Hadamard
$LN8@Hadamard:

; 22   : 		had_matrix = nullptr;
; 23   : 		setNumberOfChannels(numCh); 
; 24   : 	}

	mov	rbp, QWORD PTR [rsp+56]
	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
??0Hadamard@@QEAA@H@Z ENDP				; Hadamard::Hadamard
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\Hadamard.h
;	COMDAT ??1Hadamard@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1Hadamard@@QEAA@XZ PROC				; Hadamard::~Hadamard, COMDAT

; 26   : 	~Hadamard() { deleteMatrix(); }

$LN15:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 29   : 		if (had_matrix) {

	mov	rcx, QWORD PTR [rcx+8]
	test	rcx, rcx
	je	SHORT $LN7@Hadamard

; 30   : 			for (int i = 0; i < had_numberOfChannels; i++) {

	xor	esi, esi
	cmp	DWORD PTR [rbx], esi
	jle	SHORT $LN5@Hadamard
	xor	edi, edi
$LL6@Hadamard:

; 31   : 				delete[] had_matrix[i];

	mov	rcx, QWORD PTR [rbx+8]
	mov	rcx, QWORD PTR [rdi+rcx]
	call	??_V@YAXPEAX@Z				; operator delete[]
	inc	esi
	lea	rdi, QWORD PTR [rdi+8]
	cmp	esi, DWORD PTR [rbx]
	jl	SHORT $LL6@Hadamard
	mov	rcx, QWORD PTR [rbx+8]
$LN5@Hadamard:

; 32   : 			}
; 33   : 			delete[] had_matrix;

	call	??_V@YAXPEAX@Z				; operator delete[]
$LN7@Hadamard:

; 34   : 		}
; 35   : 		had_matrix = nullptr;

	and	QWORD PTR [rbx+8], 0

; 26   : 	~Hadamard() { deleteMatrix(); }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??1Hadamard@@QEAA@XZ ENDP				; Hadamard::~Hadamard
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\Hadamard.h
;	COMDAT ?deleteMatrix@Hadamard@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?deleteMatrix@Hadamard@@QEAAXXZ PROC			; Hadamard::deleteMatrix, COMDAT

; 28   : 	void deleteMatrix() {

$LN12:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 29   : 		if (had_matrix) {

	mov	rcx, QWORD PTR [rcx+8]
	test	rcx, rcx
	je	SHORT $LN5@deleteMatr

; 30   : 			for (int i = 0; i < had_numberOfChannels; i++) {

	xor	esi, esi
	cmp	DWORD PTR [rbx], esi
	jle	SHORT $LN3@deleteMatr
	xor	edi, edi
$LL4@deleteMatr:

; 31   : 				delete[] had_matrix[i];

	mov	rcx, QWORD PTR [rbx+8]
	mov	rcx, QWORD PTR [rdi+rcx]
	call	??_V@YAXPEAX@Z				; operator delete[]
	inc	esi
	lea	rdi, QWORD PTR [rdi+8]
	cmp	esi, DWORD PTR [rbx]
	jl	SHORT $LL4@deleteMatr
	mov	rcx, QWORD PTR [rbx+8]
$LN3@deleteMatr:

; 32   : 			}
; 33   : 			delete[] had_matrix;

	call	??_V@YAXPEAX@Z				; operator delete[]
$LN5@deleteMatr:

; 34   : 		}
; 35   : 		had_matrix = nullptr;

	and	QWORD PTR [rbx+8], 0

; 36   : 	}

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?deleteMatrix@Hadamard@@QEAAXXZ ENDP			; Hadamard::deleteMatrix
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\Hadamard.h
;	COMDAT ?setNumberOfChannels@Hadamard@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
numCh$ = 56
?setNumberOfChannels@Hadamard@@QEAAXH@Z PROC		; Hadamard::setNumberOfChannels, COMDAT

; 38   : 	void setNumberOfChannels(int numCh) {

$LN42:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	push	r14
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	ebp, edx

; 29   : 		if (had_matrix) {

	mov	rcx, QWORD PTR [rcx+8]
	test	rcx, rcx
	je	SHORT $LN19@setNumberO

; 30   : 			for (int i = 0; i < had_numberOfChannels; i++) {

	xor	esi, esi
	cmp	DWORD PTR [rbx], esi
	jle	SHORT $LN17@setNumberO
	xor	edi, edi
$LL18@setNumberO:

; 31   : 				delete[] had_matrix[i];

	mov	rax, QWORD PTR [rbx+8]
	mov	rcx, QWORD PTR [rdi+rax]
	call	??_V@YAXPEAX@Z				; operator delete[]
	inc	esi
	lea	rdi, QWORD PTR [rdi+8]
	cmp	esi, DWORD PTR [rbx]
	jl	SHORT $LL18@setNumberO
	mov	rcx, QWORD PTR [rbx+8]
$LN17@setNumberO:

; 32   : 			}
; 33   : 			delete[] had_matrix;

	call	??_V@YAXPEAX@Z				; operator delete[]
$LN19@setNumberO:

; 39   : 		deleteMatrix();
; 40   : 		had_numberOfChannels = numCh;	
; 41   : 		had_scalingFactor = sqrt(1.0 / had_numberOfChannels);

	movsd	xmm0, QWORD PTR __real@3ff0000000000000

; 35   : 		had_matrix = nullptr;

	and	QWORD PTR [rbx+8], 0
	movd	xmm1, ebp

; 39   : 		deleteMatrix();
; 40   : 		had_numberOfChannels = numCh;	
; 41   : 		had_scalingFactor = sqrt(1.0 / had_numberOfChannels);

	cvtdq2pd xmm1, xmm1
	mov	DWORD PTR [rbx], ebp
	divsd	xmm0, xmm1
	call	QWORD PTR __imp_sqrt

; 42   : 		had_matrix = new int* [had_numberOfChannels];

	movsxd	rcx, DWORD PTR [rbx]
	xorps	xmm1, xmm1
	cvtsd2ss xmm1, xmm0
	mov	eax, 8
	mov	rbp, -1
	mul	rcx
	movss	DWORD PTR [rbx+4], xmm1
	cmovo	rax, rbp
	mov	rcx, rax
	call	??_U@YAPEAX_K@Z				; operator new[]

; 43   : 		for (int i = 0; i < had_numberOfChannels; i++) had_matrix[i] = new int[had_numberOfChannels];

	xor	esi, esi
	mov	QWORD PTR [rbx+8], rax
	cmp	DWORD PTR [rbx], esi
	jle	SHORT $LN3@setNumberO
	xor	edi, edi
$LL4@setNumberO:
	movsxd	rcx, DWORD PTR [rbx]
	mov	eax, 4
	mul	rcx
	cmovo	rax, rbp
	mov	rcx, rax
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	rcx, QWORD PTR [rbx+8]
	inc	esi
	mov	QWORD PTR [rdi+rcx], rax
	lea	rdi, QWORD PTR [rdi+8]
	cmp	esi, DWORD PTR [rbx]
	jl	SHORT $LL4@setNumberO
	mov	rax, QWORD PTR [rbx+8]
$LN3@setNumberO:

; 44   : 		had_matrix[0][0] = 1;

	mov	rax, QWORD PTR [rax]

; 45   : 		for (int x = 1;x < had_numberOfChannels;x += x) {

	mov	edi, 1
	mov	DWORD PTR [rax], 1
	cmp	DWORD PTR [rbx], edi
	jle	SHORT $LN6@setNumberO
	mov	r10d, edi
$LL7@setNumberO:

; 46   : 			for (int i = 0;i < x;i++) {

	xor	r11d, r11d
	test	r10, r10
	jle	SHORT $LN5@setNumberO
$LL10@setNumberO:
	lea	rsi, QWORD PTR [r11*8]

; 47   : 				for (int j = 0;j < x;j++) {

	xor	ebp, ebp
	lea	r14, QWORD PTR [rsi+r10*8]
$LL13@setNumberO:

; 48   : 					had_matrix[i + x][j] = had_matrix[i][j];

	mov	rcx, QWORD PTR [rbx+8]
	lea	r9, QWORD PTR [rbp*4]

; 49   : 					had_matrix[i][j + x] = had_matrix[i][j];

	lea	r8, QWORD PTR [r9+r10*4]
	inc	rbp
	mov	rax, QWORD PTR [rsi+rcx]
	mov	rcx, QWORD PTR [r14+rcx]
	mov	eax, DWORD PTR [r9+rax]
	mov	DWORD PTR [r9+rcx], eax
	mov	rax, QWORD PTR [rbx+8]
	mov	rcx, QWORD PTR [rsi+rax]
	mov	eax, DWORD PTR [rcx+r9]
	mov	DWORD PTR [r8+rcx], eax

; 50   : 					had_matrix[i + x][j + x] = -had_matrix[i][j];

	mov	rdx, QWORD PTR [rbx+8]
	mov	rax, QWORD PTR [rsi+rdx]
	mov	ecx, DWORD PTR [rax+r9]
	mov	rax, QWORD PTR [r14+rdx]
	neg	ecx
	mov	DWORD PTR [r8+rax], ecx
	cmp	rbp, r10
	jl	SHORT $LL13@setNumberO

; 46   : 			for (int i = 0;i < x;i++) {

	inc	r11
	cmp	r11, r10
	jl	SHORT $LL10@setNumberO
$LN5@setNumberO:

; 45   : 		for (int x = 1;x < had_numberOfChannels;x += x) {

	add	edi, edi
	add	r10, r10
	cmp	edi, DWORD PTR [rbx]
	jl	SHORT $LL7@setNumberO
$LN6@setNumberO:

; 51   : 				}
; 52   : 			}
; 53   : 		}		
; 54   : 	}

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
?setNumberOfChannels@Hadamard@@QEAAXH@Z ENDP		; Hadamard::setNumberOfChannels
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\Hadamard.h
;	COMDAT ?hadamardUnscaled@Hadamard@@QEAAXPEAMH@Z
_TEXT	SEGMENT
this$ = 48
data$ = 56
size$ = 64
?hadamardUnscaled@Hadamard@@QEAAXPEAMH@Z PROC		; Hadamard::hadamardUnscaled, COMDAT

; 56   : 	void hadamardUnscaled(float* data, int size) {

$LN15:

; 57   : 		if (size <= 1) return;

	cmp	r8d, 1
	jle	$LN13@hadamardUn
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 58   : 		int hSize = size / 2;

	shr	r8d, 1
	mov	rbx, rdx
	mov	edi, r8d
	mov	rbp, rcx

; 59   : 
; 60   : 		// Two (unscaled) Hadamards of half the size
; 61   : 		hadamardUnscaled(data, hSize);

	call	?hadamardUnscaled@Hadamard@@QEAAXPEAMH@Z ; Hadamard::hadamardUnscaled

; 62   : 		hadamardUnscaled(data + hSize, hSize);

	lea	rsi, QWORD PTR [rdi*4]
	mov	r8d, edi
	lea	rdx, QWORD PTR [rsi+rbx]
	mov	rcx, rbp
	call	?hadamardUnscaled@Hadamard@@QEAAXPEAMH@Z ; Hadamard::hadamardUnscaled

; 63   : 
; 64   : 		// Combine the two halves using sum/difference
; 65   : 		for (int i = 0; i < hSize; ++i) {

	test	rdi, rdi
	je	SHORT $LN3@hadamardUn
$LL9@hadamardUn:
	movss	xmm1, DWORD PTR [rbx+rsi]
	movss	xmm2, DWORD PTR [rbx]

; 66   : 			double a = data[i];

	cvtps2pd xmm2, xmm2

; 67   : 			double b = data[i + hSize];

	cvtps2pd xmm1, xmm1

; 68   : 			data[i] = (a + b);

	movaps	xmm0, xmm1
	addsd	xmm0, xmm2

; 69   : 			data[i + hSize] = (a - b);

	subsd	xmm2, xmm1
	cvtpd2ps xmm0, xmm0
	movss	DWORD PTR [rbx], xmm0
	cvtpd2ps xmm0, xmm2
	movss	DWORD PTR [rbx+rsi], xmm0
	add	rbx, 4
	sub	rdi, 1
	jne	SHORT $LL9@hadamardUn
$LN3@hadamardUn:

; 70   : 		}
; 71   : 	}

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
$LN13@hadamardUn:
	ret	0
?hadamardUnscaled@Hadamard@@QEAAXPEAMH@Z ENDP		; Hadamard::hadamardUnscaled
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\Hadamard.h
;	COMDAT ?hadamardScaled@Hadamard@@QEAAXPEAMH@Z
_TEXT	SEGMENT
this$ = 48
data$ = 56
size$ = 64
?hadamardScaled@Hadamard@@QEAAXPEAMH@Z PROC		; Hadamard::hadamardScaled, COMDAT

; 73   : 	void hadamardScaled(float* data, int size) {

$LN13:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	movsxd	rbx, r8d
	mov	rdi, rdx

; 74   : 		hadamardUnscaled(data, size);

	mov	r8d, ebx
	call	?hadamardUnscaled@Hadamard@@QEAAXPEAMH@Z ; Hadamard::hadamardUnscaled

; 75   : 
; 76   : 		float scalingFactor = sqrt(1.0 / size);

	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	movd	xmm3, ebx
	cvtdq2pd xmm3, xmm3
	divsd	xmm0, xmm3
	call	QWORD PTR __imp_sqrt

; 77   : 		for (int c = 0; c < size; ++c) {

	xor	eax, eax
	xorps	xmm1, xmm1
	cvtsd2ss xmm1, xmm0
	test	ebx, ebx
	jle	SHORT $LN3@hadamardSc
$LL8@hadamardSc:

; 78   : 			data[c] *= scalingFactor;

	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR [rdi+rax*4]
	movss	DWORD PTR [rdi+rax*4], xmm0
	inc	rax
	cmp	rax, rbx
	jl	SHORT $LL8@hadamardSc
$LN3@hadamardSc:

; 79   : 		}
; 80   : 	}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?hadamardScaled@Hadamard@@QEAAXPEAMH@Z ENDP		; Hadamard::hadamardScaled
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\Hadamard.h
;	COMDAT ?processAudio@Hadamard@@QEAAXPEAM0@Z
_TEXT	SEGMENT
this$ = 48
in$ = 56
out$ = 64
?processAudio@Hadamard@@QEAAXPEAM0@Z PROC		; Hadamard::processAudio, COMDAT

; 92   : 	void processAudio(float* in, float* out) {

$LN22:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 93   : 		// Allocate the input into the output
; 94   : 		for (int i = 0; i < had_numberOfChannels; i++) out[i] = in[i];

	mov	esi, DWORD PTR [rcx]
	xor	ebx, ebx
	mov	rdi, r8
	mov	r9d, ebx
	test	esi, esi
	jle	SHORT $LN3@processAud
	sub	rdx, r8
$LL4@processAud:
	mov	eax, DWORD PTR [rdx+r8]
	inc	r9d
	mov	DWORD PTR [r8], eax
	lea	r8, QWORD PTR [r8+4]
	mov	esi, DWORD PTR [rcx]
	cmp	r9d, esi
	jl	SHORT $LL4@processAud
$LN3@processAud:

; 74   : 		hadamardUnscaled(data, size);

	mov	r8d, esi
	mov	rdx, rdi
	call	?hadamardUnscaled@Hadamard@@QEAAXPEAMH@Z ; Hadamard::hadamardUnscaled

; 75   : 
; 76   : 		float scalingFactor = sqrt(1.0 / size);

	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	movd	xmm3, esi
	cvtdq2pd xmm3, xmm3
	divsd	xmm0, xmm3
	call	QWORD PTR __imp_sqrt

; 77   : 		for (int c = 0; c < size; ++c) {

	movsxd	rax, esi
	xorps	xmm1, xmm1
	cvtsd2ss xmm1, xmm0
	test	esi, esi
	jle	SHORT $LN8@processAud
$LL15@processAud:

; 78   : 			data[c] *= scalingFactor;

	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR [rdi+rbx*4]
	movss	DWORD PTR [rdi+rbx*4], xmm0
	inc	rbx
	cmp	rbx, rax
	jl	SHORT $LL15@processAud
$LN8@processAud:

; 95   : 
; 96   : 		// Process output with hadamard
; 97   : 		hadamardScaled(out, had_numberOfChannels);
; 98   : 		//multiplyHadamard(in, out);
; 99   : 	}

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?processAudio@Hadamard@@QEAAXPEAM0@Z ENDP		; Hadamard::processAudio
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\FlipPolarity.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FlipPolarity.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FlipPolarity.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FlipPolarity.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FlipPolarity.h
;	COMDAT ??0FlipPolarity@@QEAA@H@Z
_TEXT	SEGMENT
this$ = 48
$T3 = 56
$T2 = 56
numCh$ = 56
??0FlipPolarity@@QEAA@H@Z PROC				; FlipPolarity::FlipPolarity, COMDAT

; 12   : 	FlipPolarity(int numCh) { 

$LN44:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	and	QWORD PTR [rcx], 0
	and	QWORD PTR [rcx+8], 0
	and	QWORD PTR [rcx+16], 0
; File E:\FoxSuite\shimmer\include\FlipPolarity.h

; 19   : 		fp_numofChannels = numCh; 

	mov	DWORD PTR [rcx+24], edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1544 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	rax, QWORD PTR [rcx]
; File E:\FoxSuite\shimmer\include\FlipPolarity.h

; 37   : 		if (!fp_flipPolarity.empty())

	test	rax, rax
	je	SHORT $LN18@FlipPolari

; 38   : 			fp_flipPolarity.clear();

	mov	QWORD PTR [rcx+8], rax
$LN18@FlipPolari:

; 21   : 		for (int i = 0; i < fp_numofChannels; i++)

	xor	edi, edi
	test	edx, edx
	jle	SHORT $LN12@FlipPolari
$LL13@FlipPolari:

; 22   : 			if (rand() % 2)

	call	QWORD PTR __imp_rand
	and	eax, -2147483647			; ffffffff80000001H
	jge	SHORT $LN40@FlipPolari
	dec	eax
	or	eax, -2
	inc	eax
$LN40@FlipPolari:
	mov	rdx, QWORD PTR [rbx+8]
	test	eax, eax
	je	SHORT $LN14@FlipPolari

; 23   : 				fp_flipPolarity.push_back(1);

	mov	DWORD PTR $T2[rsp], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 743  :         if (_Mylast != _My_data._Myend) {

	cmp	rdx, QWORD PTR [rbx+16]
	je	SHORT $LN32@FlipPolari

; 726  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR [rdx], 1
; File E:\FoxSuite\shimmer\include\FlipPolarity.h

; 23   : 				fp_flipPolarity.push_back(1);

	jmp	SHORT $LN41@FlipPolari
$LN14@FlipPolari:

; 24   : 			else
; 25   : 				fp_flipPolarity.push_back(-1);

	or	DWORD PTR $T3[rsp], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 743  :         if (_Mylast != _My_data._Myend) {

	cmp	rdx, QWORD PTR [rbx+16]
	je	SHORT $LN32@FlipPolari

; 726  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	or	DWORD PTR [rdx], -1
$LN41@FlipPolari:
; File E:\FoxSuite\shimmer\include\FlipPolarity.h

; 21   : 		for (int i = 0; i < fp_numofChannels; i++)

	add	QWORD PTR [rbx+8], 4
	jmp	SHORT $LN11@FlipPolari
$LN32@FlipPolari:
	lea	r8, QWORD PTR $T3[rsp]
	mov	rcx, rbx
	call	??$_Emplace_reallocate@H@?$vector@HV?$allocator@H@std@@@std@@QEAAPEAHQEAH$$QEAH@Z ; std::vector<int,std::allocator<int> >::_Emplace_reallocate<int>
$LN11@FlipPolari:
	inc	edi
	cmp	edi, DWORD PTR [rbx+24]
	jl	SHORT $LL13@FlipPolari
$LN12@FlipPolari:

; 13   : 		setNumberOfChannels(numCh); 
; 14   : 	}

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0FlipPolarity@@QEAA@H@Z ENDP				; FlipPolarity::FlipPolarity
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
$T3 = 56
$T2 = 56
numCh$ = 56
?dtor$0@?0???0FlipPolarity@@QEAA@H@Z@4HA PROC		; `FlipPolarity::FlipPolarity'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QEAA@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
?dtor$0@?0???0FlipPolarity@@QEAA@H@Z@4HA ENDP		; `FlipPolarity::FlipPolarity'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
$T3 = 56
$T2 = 56
numCh$ = 56
?dtor$0@?0???0FlipPolarity@@QEAA@H@Z@4HA PROC		; `FlipPolarity::FlipPolarity'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QEAA@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
?dtor$0@?0???0FlipPolarity@@QEAA@H@Z@4HA ENDP		; `FlipPolarity::FlipPolarity'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\FlipPolarity.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FlipPolarity.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FlipPolarity.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File E:\FoxSuite\shimmer\include\FlipPolarity.h
;	COMDAT ??1FlipPolarity@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1FlipPolarity@@QEAA@XZ PROC				; FlipPolarity::~FlipPolarity, COMDAT

; 16   : 	~FlipPolarity() { deleteFlipVector(); }

$LN36:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1544 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	rcx, QWORD PTR [rcx]
	cmp	rcx, QWORD PTR [rbx+8]
; File E:\FoxSuite\shimmer\include\FlipPolarity.h

; 37   : 		if (!fp_flipPolarity.empty())

	je	SHORT $LN4@FlipPolari

; 38   : 			fp_flipPolarity.clear();

	mov	QWORD PTR [rbx+8], rcx
$LN4@FlipPolari:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

	test	rcx, rcx
	je	SHORT $LN11@FlipPolari

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -4

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN27@FlipPolari

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN24@FlipPolari

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN27@FlipPolari:

; 264  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

	and	QWORD PTR [rbx], 0

; 1768 :             _Mylast  = nullptr;

	and	QWORD PTR [rbx+8], 0

; 1769 :             _Myend   = nullptr;

	and	QWORD PTR [rbx+16], 0
$LN11@FlipPolari:
; File E:\FoxSuite\shimmer\include\FlipPolarity.h

; 16   : 	~FlipPolarity() { deleteFlipVector(); }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN24@FlipPolari:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN33@FlipPolari:
??1FlipPolarity@@QEAA@XZ ENDP				; FlipPolarity::~FlipPolarity
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\FlipPolarity.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FlipPolarity.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FlipPolarity.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FlipPolarity.h
;	COMDAT ?setNumberOfChannels@FlipPolarity@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
$T3 = 56
$T2 = 56
numCh$ = 56
?setNumberOfChannels@FlipPolarity@@QEAAXH@Z PROC	; FlipPolarity::setNumberOfChannels, COMDAT

; 18   : 	void setNumberOfChannels(int numCh) { 

$LN35:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 19   : 		fp_numofChannels = numCh; 

	mov	DWORD PTR [rcx+24], edx
	mov	rbx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1544 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	rax, QWORD PTR [rcx]
	cmp	rax, QWORD PTR [rcx+8]
; File E:\FoxSuite\shimmer\include\FlipPolarity.h

; 37   : 		if (!fp_flipPolarity.empty())

	je	SHORT $LN9@setNumberO

; 38   : 			fp_flipPolarity.clear();

	mov	QWORD PTR [rcx+8], rax
$LN9@setNumberO:

; 21   : 		for (int i = 0; i < fp_numofChannels; i++)

	xor	edi, edi
	test	edx, edx
	jle	SHORT $LN3@setNumberO
$LL4@setNumberO:

; 22   : 			if (rand() % 2)

	call	QWORD PTR __imp_rand
	and	eax, -2147483647			; ffffffff80000001H
	jge	SHORT $LN31@setNumberO
	dec	eax
	or	eax, -2
	inc	eax
$LN31@setNumberO:
	mov	rdx, QWORD PTR [rbx+8]
	test	eax, eax
	je	SHORT $LN5@setNumberO

; 23   : 				fp_flipPolarity.push_back(1);

	mov	DWORD PTR $T2[rsp], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 743  :         if (_Mylast != _My_data._Myend) {

	cmp	rdx, QWORD PTR [rbx+16]
	je	SHORT $LN23@setNumberO

; 726  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR [rdx], 1
; File E:\FoxSuite\shimmer\include\FlipPolarity.h

; 23   : 				fp_flipPolarity.push_back(1);

	jmp	SHORT $LN32@setNumberO
$LN5@setNumberO:

; 24   : 			else
; 25   : 				fp_flipPolarity.push_back(-1);

	or	DWORD PTR $T3[rsp], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 743  :         if (_Mylast != _My_data._Myend) {

	cmp	rdx, QWORD PTR [rbx+16]
	je	SHORT $LN23@setNumberO

; 726  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	or	DWORD PTR [rdx], -1
$LN32@setNumberO:
; File E:\FoxSuite\shimmer\include\FlipPolarity.h

; 21   : 		for (int i = 0; i < fp_numofChannels; i++)

	add	QWORD PTR [rbx+8], 4
	jmp	SHORT $LN2@setNumberO
$LN23@setNumberO:
	lea	r8, QWORD PTR $T3[rsp]
	mov	rcx, rbx
	call	??$_Emplace_reallocate@H@?$vector@HV?$allocator@H@std@@@std@@QEAAPEAHQEAH$$QEAH@Z ; std::vector<int,std::allocator<int> >::_Emplace_reallocate<int>
$LN2@setNumberO:
	inc	edi
	cmp	edi, DWORD PTR [rbx+24]
	jl	SHORT $LL4@setNumberO
$LN3@setNumberO:

; 26   : 	}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?setNumberOfChannels@FlipPolarity@@QEAAXH@Z ENDP	; FlipPolarity::setNumberOfChannels
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\FlipPolarity.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FlipPolarity.h
;	COMDAT ?processAudio@FlipPolarity@@QEAAXPEAM0@Z
_TEXT	SEGMENT
this$ = 8
in$ = 16
out$ = 24
?processAudio@FlipPolarity@@QEAAXPEAM0@Z PROC		; FlipPolarity::processAudio, COMDAT

; 29   : 		for (int i = 0; i < fp_numofChannels; i++) {			

	xor	eax, eax
	cmp	DWORD PTR [rcx+24], eax
	jle	SHORT $LN3@processAud
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

	mov	r9, QWORD PTR [rcx]
	sub	r9, rdx
	sub	r8, rdx
$LL4@processAud:
	movd	xmm0, DWORD PTR [r9+rdx]
; File E:\FoxSuite\shimmer\include\FlipPolarity.h

; 29   : 		for (int i = 0; i < fp_numofChannels; i++) {			

	inc	eax

; 30   : 			out[i] = in[i] * fp_flipPolarity[i];

	cvtdq2ps xmm0, xmm0
	mulss	xmm0, DWORD PTR [rdx]
	movss	DWORD PTR [r8+rdx], xmm0
	lea	rdx, QWORD PTR [rdx+4]
	cmp	eax, DWORD PTR [rcx+24]
	jl	SHORT $LL4@processAud
$LN3@processAud:

; 31   : 		}
; 32   : 	}

	ret	0
?processAudio@FlipPolarity@@QEAAXPEAM0@Z ENDP		; FlipPolarity::processAudio
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\FlipPolarity.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FlipPolarity.h
;	COMDAT ?deleteFlipVector@FlipPolarity@@AEAAXXZ
_TEXT	SEGMENT
this$ = 8
?deleteFlipVector@FlipPolarity@@AEAAXXZ PROC		; FlipPolarity::deleteFlipVector, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1544 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	rax, QWORD PTR [rcx]
	cmp	rax, QWORD PTR [rcx+8]
; File E:\FoxSuite\shimmer\include\FlipPolarity.h

; 37   : 		if (!fp_flipPolarity.empty())

	je	SHORT $LN2@deleteFlip

; 38   : 			fp_flipPolarity.clear();

	mov	QWORD PTR [rcx+8], rax
$LN2@deleteFlip:

; 39   : 	}

	ret	0
?deleteFlipVector@FlipPolarity@@AEAAXXZ ENDP		; FlipPolarity::deleteFlipVector
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\MultiChannelDiffuser.h
;	COMDAT ??0MultiChannelDiffuser@@QEAA@H@Z
_TEXT	SEGMENT
$T5 = 48
$T3 = 48
$T1 = 48
this$ = 48
numChInt$ = 56
??0MultiChannelDiffuser@@QEAA@H@Z PROC			; MultiChannelDiffuser::MultiChannelDiffuser, COMDAT

; 27   : 	MultiChannelDiffuser(int numChInt) { 

$LN22:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx

; 71   : 		mdiff_numberOfChannels = numCh;

	mov	DWORD PTR [rcx], edx

; 99   : 		mdiff_outHadamard = nullptr;

	and	QWORD PTR [rcx+16], 0

; 100  : 		mdiff_outMultiChDel = nullptr;

	and	QWORD PTR [rcx+8], 0

; 110  : 		mdiff_MultiChDelay = new MultiChannelDelay(mdiff_numberOfChannels);

	mov	ecx, 48					; 00000030H
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	edx, DWORD PTR [rdi]
	mov	rcx, rax
	call	??0MultiChannelDelay@@QEAA@H@Z		; MultiChannelDelay::MultiChannelDelay
	npad	1
	mov	QWORD PTR [rdi+24], rax

; 111  : 		mdiff_Hadamard = new Hadamard(mdiff_numberOfChannels);

	mov	ecx, 16
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T3[rsp], rax
	mov	edx, DWORD PTR [rdi]
	mov	rcx, rax
	call	??0Hadamard@@QEAA@H@Z			; Hadamard::Hadamard
	npad	1
	mov	QWORD PTR [rdi+32], rax

; 112  : 		mdiff_Polarity = new FlipPolarity(mdiff_numberOfChannels);

	mov	ecx, 32					; 00000020H
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T5[rsp], rax
	mov	edx, DWORD PTR [rdi]
	mov	rcx, rax
	call	??0FlipPolarity@@QEAA@H@Z		; FlipPolarity::FlipPolarity
	npad	1
	mov	QWORD PTR [rdi+40], rax

; 78   : 		int lenghtInBytes = mdiff_numberOfChannels * sizeof(float);

	mov	eax, DWORD PTR [rdi]
	shl	eax, 2

; 79   : 		mdiff_outMultiChDel = (float*)malloc(lenghtInBytes);

	movsxd	rbx, eax
	mov	rcx, rbx
	call	QWORD PTR __imp_malloc
	mov	QWORD PTR [rdi+8], rax

; 80   : 		mdiff_outHadamard = (float*)malloc(lenghtInBytes);	

	mov	rcx, rbx
	call	QWORD PTR __imp_malloc
	mov	QWORD PTR [rdi+16], rax

; 81   : 		memset(mdiff_outMultiChDel, 0, lenghtInBytes);

	mov	r8, rbx
	xor	edx, edx
	mov	rcx, QWORD PTR [rdi+8]
	call	QWORD PTR __imp_memset

; 82   : 		memset(mdiff_outHadamard, 0, lenghtInBytes);

	mov	r8, rbx
	xor	edx, edx
	mov	rcx, QWORD PTR [rdi+16]
	call	QWORD PTR __imp_memset

; 28   : 		constructMCDF(numChInt);
; 29   : 	}

	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0MultiChannelDiffuser@@QEAA@H@Z ENDP			; MultiChannelDiffuser::MultiChannelDiffuser
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T5 = 48
$T3 = 48
$T1 = 48
this$ = 48
numChInt$ = 56
?dtor$0@?0???0MultiChannelDiffuser@@QEAA@H@Z@4HA PROC	; `MultiChannelDiffuser::MultiChannelDiffuser'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 48					; 00000030H
	mov	rcx, QWORD PTR $T1[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0MultiChannelDiffuser@@QEAA@H@Z@4HA ENDP	; `MultiChannelDiffuser::MultiChannelDiffuser'::`1'::dtor$0
$T5 = 48
$T3 = 48
$T1 = 48
this$ = 48
numChInt$ = 56
?dtor$1@?0???0MultiChannelDiffuser@@QEAA@H@Z@4HA PROC	; `MultiChannelDiffuser::MultiChannelDiffuser'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 16
	mov	rcx, QWORD PTR $T3[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???0MultiChannelDiffuser@@QEAA@H@Z@4HA ENDP	; `MultiChannelDiffuser::MultiChannelDiffuser'::`1'::dtor$1
$T5 = 48
$T3 = 48
$T1 = 48
this$ = 48
numChInt$ = 56
?dtor$2@?0???0MultiChannelDiffuser@@QEAA@H@Z@4HA PROC	; `MultiChannelDiffuser::MultiChannelDiffuser'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 32					; 00000020H
	mov	rcx, QWORD PTR $T5[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0???0MultiChannelDiffuser@@QEAA@H@Z@4HA ENDP	; `MultiChannelDiffuser::MultiChannelDiffuser'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
$T5 = 48
$T3 = 48
$T1 = 48
this$ = 48
numChInt$ = 56
?dtor$0@?0???0MultiChannelDiffuser@@QEAA@H@Z@4HA PROC	; `MultiChannelDiffuser::MultiChannelDiffuser'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 48					; 00000030H
	mov	rcx, QWORD PTR $T1[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0MultiChannelDiffuser@@QEAA@H@Z@4HA ENDP	; `MultiChannelDiffuser::MultiChannelDiffuser'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
$T5 = 48
$T3 = 48
$T1 = 48
this$ = 48
numChInt$ = 56
?dtor$1@?0???0MultiChannelDiffuser@@QEAA@H@Z@4HA PROC	; `MultiChannelDiffuser::MultiChannelDiffuser'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 16
	mov	rcx, QWORD PTR $T3[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???0MultiChannelDiffuser@@QEAA@H@Z@4HA ENDP	; `MultiChannelDiffuser::MultiChannelDiffuser'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
$T5 = 48
$T3 = 48
$T1 = 48
this$ = 48
numChInt$ = 56
?dtor$2@?0???0MultiChannelDiffuser@@QEAA@H@Z@4HA PROC	; `MultiChannelDiffuser::MultiChannelDiffuser'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 32					; 00000020H
	mov	rcx, QWORD PTR $T5[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0???0MultiChannelDiffuser@@QEAA@H@Z@4HA ENDP	; `MultiChannelDiffuser::MultiChannelDiffuser'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\MultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\Hadamard.h
; File E:\FoxSuite\shimmer\include\MultiChannelDiffuser.h
;	COMDAT ??1MultiChannelDiffuser@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1MultiChannelDiffuser@@QEAA@XZ PROC			; MultiChannelDiffuser::~MultiChannelDiffuser, COMDAT

; 31   : 	~MultiChannelDiffuser() { 

$LN40:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 104  : 		delete mdiff_MultiChDelay;			

	mov	rdi, QWORD PTR [rcx+24]

; 31   : 	~MultiChannelDiffuser() { 

	mov	rbx, rcx

; 104  : 		delete mdiff_MultiChDelay;			

	test	rdi, rdi
	je	SHORT $LN12@MultiChann
	mov	rcx, rdi
	call	??1MultiChannelDelay@@QEAA@XZ		; MultiChannelDelay::~MultiChannelDelay
	mov	edx, 48					; 00000030H
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN12@MultiChann:

; 105  : 		delete mdiff_Hadamard;

	mov	rdi, QWORD PTR [rbx+32]
	test	rdi, rdi
	je	SHORT $LN15@MultiChann
; File E:\FoxSuite\shimmer\include\Hadamard.h

; 29   : 		if (had_matrix) {

	mov	rcx, QWORD PTR [rdi+8]
	test	rcx, rcx
	je	SHORT $LN23@MultiChann

; 30   : 			for (int i = 0; i < had_numberOfChannels; i++) {

	xor	ebp, ebp
	cmp	DWORD PTR [rdi], ebp
	jle	SHORT $LN21@MultiChann
	xor	esi, esi
$LL22@MultiChann:

; 31   : 				delete[] had_matrix[i];

	mov	rcx, QWORD PTR [rdi+8]
	mov	rcx, QWORD PTR [rsi+rcx]
	call	??_V@YAXPEAX@Z				; operator delete[]
	inc	ebp
	lea	rsi, QWORD PTR [rsi+8]
	cmp	ebp, DWORD PTR [rdi]
	jl	SHORT $LL22@MultiChann
	mov	rcx, QWORD PTR [rdi+8]
$LN21@MultiChann:

; 32   : 			}
; 33   : 			delete[] had_matrix;

	call	??_V@YAXPEAX@Z				; operator delete[]
$LN23@MultiChann:

; 34   : 		}
; 35   : 		had_matrix = nullptr;

	and	QWORD PTR [rdi+8], 0
	mov	edx, 16
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN15@MultiChann:
; File E:\FoxSuite\shimmer\include\MultiChannelDiffuser.h

; 106  : 		delete mdiff_Polarity;

	mov	rdi, QWORD PTR [rbx+40]
	test	rdi, rdi
	je	SHORT $LN26@MultiChann
	mov	rcx, rdi
	call	??1FlipPolarity@@QEAA@XZ		; FlipPolarity::~FlipPolarity
	mov	edx, 32					; 00000020H
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN26@MultiChann:

; 91   : 		if (mdiff_outMultiChDel)

	mov	rcx, QWORD PTR [rbx+8]
	test	rcx, rcx
	je	SHORT $LN29@MultiChann

; 92   : 			free(mdiff_outMultiChDel);

	call	QWORD PTR __imp_free
$LN29@MultiChann:

; 93   : 		if (mdiff_outHadamard)

	mov	rcx, QWORD PTR [rbx+16]
	test	rcx, rcx
	je	SHORT $LN30@MultiChann

; 94   : 			free(mdiff_outHadamard);

	call	QWORD PTR __imp_free
$LN30@MultiChann:

; 99   : 		mdiff_outHadamard = nullptr;

	and	QWORD PTR [rbx+16], 0

; 100  : 		mdiff_outMultiChDel = nullptr;

	and	QWORD PTR [rbx+8], 0

; 32   : 		deleteBlocks();
; 33   : 		deleteInternalArrays();		
; 34   : 	}	

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??1MultiChannelDiffuser@@QEAA@XZ ENDP			; MultiChannelDiffuser::~MultiChannelDiffuser
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\MultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\MultiChannelDiffuser.h
;	COMDAT ?init@MultiChannelDiffuser@@QEAAXMH@Z
_TEXT	SEGMENT
this$ = 48
bufferLengthMs$dead$ = 56
sampleRate$ = 64
?init@MultiChannelDiffuser@@QEAAXMH@Z PROC		; MultiChannelDiffuser::init, COMDAT

; 36   : 	void init(float bufferLengthMs, int sampleRate) {

$LN19:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 37   : 		mdiff_sampleRate = sampleRate;
; 38   : 		mdiff_MultiChDelay->initDelayLines(bufferLengthMs, sampleRate);

	mov	rbx, QWORD PTR [rcx+24]
	mov	esi, r8d
	mov	DWORD PTR [rcx+4], r8d
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h

; 36   : 		mdel_sampleRate = sampleRate;

	mov	DWORD PTR [rbx+40], r8d
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1544 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	rax, QWORD PTR [rbx+16]
	cmp	QWORD PTR [rbx+8], rax
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h

; 37   : 		if (!mdel_DelayLines.empty()) {

	je	SHORT $LN5@init

; 38   : 			for (int i = 0; i < mdel_numberOfChannels; i++)

	xor	edi, edi
	cmp	DWORD PTR [rbx], edi
	jle	SHORT $LN5@init
	mov	r14d, edi
$LL6@init:

; 39   : 				mdel_DelayLines[i]->init(bufferLengthMs, sampleRate);

	mov	rax, QWORD PTR [rbx+8]
	mov	r8d, esi
	movss	xmm1, DWORD PTR __real@44fa0000
	mov	rcx, QWORD PTR [r14+rax]
	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax]
	inc	edi
	lea	r14, QWORD PTR [r14+8]
	cmp	edi, DWORD PTR [rbx]
	jl	SHORT $LL6@init
$LN5@init:
; File E:\FoxSuite\shimmer\include\MultiChannelDiffuser.h

; 39   : 	}

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
?init@MultiChannelDiffuser@@QEAAXMH@Z ENDP		; MultiChannelDiffuser::init
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\MultiChannelDiffuser.h
;	COMDAT ?setDelayLinesLength@MultiChannelDiffuser@@QEAAXMMW4DelayDistribution@@@Z
_TEXT	SEGMENT
this$ = 8
minDelayMs$dead$ = 16
maxDelayMs$ = 24
distr$ = 32
?setDelayLinesLength@MultiChannelDiffuser@@QEAAXMMW4DelayDistribution@@@Z PROC ; MultiChannelDiffuser::setDelayLinesLength, COMDAT

; 50   : 		mdiff_MultiChDelay->setDelayLinesLength(minDelayMs, maxDelayMs, distr);

	mov	rcx, QWORD PTR [rcx+24]
	jmp	?setDelayLinesLength@MultiChannelDelay@@QEAAXMMW4DelayDistribution@@@Z ; MultiChannelDelay::setDelayLinesLength
?setDelayLinesLength@MultiChannelDiffuser@@QEAAXMMW4DelayDistribution@@@Z ENDP ; MultiChannelDiffuser::setDelayLinesLength
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\MultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\MultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\MultiChannelDiffuser.h
;	COMDAT ?setSampleRate@MultiChannelDiffuser@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
sampleRate$ = 56
?setSampleRate@MultiChannelDiffuser@@QEAAXH@Z PROC	; MultiChannelDiffuser::setSampleRate, COMDAT

; 57   : 	void setSampleRate(int sampleRate) { 

$LN16:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 59   : 		mdiff_MultiChDelay->setSampleRate(sampleRate); 

	mov	rdi, QWORD PTR [rcx+24]
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h

; 86   : 		for (int i = 0; i < mdel_numberOfChannels; i++) {

	xor	ebx, ebx
; File E:\FoxSuite\shimmer\include\MultiChannelDiffuser.h

; 58   : 		mdiff_sampleRate = sampleRate;

	mov	DWORD PTR [rcx+4], edx
	mov	esi, edx
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h

; 86   : 		for (int i = 0; i < mdel_numberOfChannels; i++) {

	cmp	DWORD PTR [rdi], ebx
	jle	SHORT $LN5@setSampleR
	mov	r14d, ebx
$LL6@setSampleR:

; 87   : 			mdel_sampleRate = sampleRate;

	mov	DWORD PTR [rdi+40], esi

; 88   : 			mdel_DelayLines[i]->setSampleRate(sampleRate);

	mov	edx, esi
	mov	rax, QWORD PTR [rdi+8]
	mov	rcx, QWORD PTR [r14+rax]
	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+8]
	inc	ebx
	lea	r14, QWORD PTR [r14+8]
	cmp	ebx, DWORD PTR [rdi]
	jl	SHORT $LL6@setSampleR
$LN5@setSampleR:
; File E:\FoxSuite\shimmer\include\MultiChannelDiffuser.h

; 60   : 	}

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
?setSampleRate@MultiChannelDiffuser@@QEAAXH@Z ENDP	; MultiChannelDiffuser::setSampleRate
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\MultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\MultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\MultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\FlipPolarity.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FlipPolarity.h
; File E:\FoxSuite\shimmer\include\MultiChannelDiffuser.h
;	COMDAT ?processAudio@MultiChannelDiffuser@@QEAAXPEAM0@Z
_TEXT	SEGMENT
this$ = 80
in$ = 88
out$ = 96
?processAudio@MultiChannelDiffuser@@QEAAXPEAM0@Z PROC	; MultiChannelDiffuser::processAudio, COMDAT

; 62   : 	void processAudio(float* in, float* out) {

$LN27:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 63   : 		mdiff_MultiChDelay->processAudio(in, mdiff_outMultiChDel);

	mov	r14, QWORD PTR [rcx+24]
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h

; 93   : 		for (int i = 0; i < mdel_numberOfChannels; i++) 

	xor	esi, esi
; File E:\FoxSuite\shimmer\include\MultiChannelDiffuser.h

; 63   : 		mdiff_MultiChDelay->processAudio(in, mdiff_outMultiChDel);

	mov	rbx, QWORD PTR [rcx+8]
	mov	r13, r8
	mov	rbp, rdx
	mov	rdi, rcx
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h

; 93   : 		for (int i = 0; i < mdel_numberOfChannels; i++) 

	mov	r12d, esi
	cmp	DWORD PTR [r14], esi
	jle	SHORT $LN5@processAud
	mov	r15d, esi
	sub	rbp, rbx
$LL6@processAud:

; 94   : 			out[i] = mdel_DelayLines[i]->processAudio(in[i]);

	mov	rax, QWORD PTR [r14+8]
	movss	xmm1, DWORD PTR [rbx+rbp]
	mov	rcx, QWORD PTR [r15+rax]
	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+16]
	movss	DWORD PTR [rbx], xmm0
	inc	r12d
	lea	r15, QWORD PTR [r15+8]
	lea	rbx, QWORD PTR [rbx+4]
	cmp	r12d, DWORD PTR [r14]
	jl	SHORT $LL6@processAud
	mov	rbx, QWORD PTR [rdi+8]
$LN5@processAud:
; File E:\FoxSuite\shimmer\include\MultiChannelDiffuser.h

; 64   : 		mdiff_Polarity->processAudio(mdiff_outMultiChDel, mdiff_outMultiChDel);

	mov	rax, QWORD PTR [rdi+40]
; File E:\FoxSuite\shimmer\include\FlipPolarity.h

; 29   : 		for (int i = 0; i < fp_numofChannels; i++) {			

	cmp	DWORD PTR [rax+24], esi
	jle	SHORT $LN12@processAud
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

	mov	rcx, QWORD PTR [rax]
	sub	rcx, rbx
$LL13@processAud:
	movd	xmm0, DWORD PTR [rcx+rbx]
; File E:\FoxSuite\shimmer\include\FlipPolarity.h

; 29   : 		for (int i = 0; i < fp_numofChannels; i++) {			

	inc	esi

; 30   : 			out[i] = in[i] * fp_flipPolarity[i];

	cvtdq2ps xmm0, xmm0
	mulss	xmm0, DWORD PTR [rbx]
	movss	DWORD PTR [rbx], xmm0
	lea	rbx, QWORD PTR [rbx+4]
	cmp	esi, DWORD PTR [rax+24]
	jl	SHORT $LL13@processAud
	mov	rbx, QWORD PTR [rdi+8]
$LN12@processAud:
; File E:\FoxSuite\shimmer\include\MultiChannelDiffuser.h

; 65   : 		mdiff_Hadamard->processAudio(mdiff_outMultiChDel, out);

	mov	rcx, QWORD PTR [rdi+32]
	mov	r8, r13
	mov	rdx, rbx

; 66   : 	}

	mov	rbx, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi

; 65   : 		mdiff_Hadamard->processAudio(mdiff_outMultiChDel, out);

	jmp	?processAudio@Hadamard@@QEAAXPEAM0@Z	; Hadamard::processAudio
?processAudio@MultiChannelDiffuser@@QEAAXPEAM0@Z ENDP	; MultiChannelDiffuser::processAudio
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\MultiChannelDiffuser.h
;	COMDAT ?constructMCDF@MultiChannelDiffuser@@AEAAXH@Z
_TEXT	SEGMENT
$T5 = 48
$T3 = 48
$T1 = 48
this$ = 48
numCh$ = 56
?constructMCDF@MultiChannelDiffuser@@AEAAXH@Z PROC	; MultiChannelDiffuser::constructMCDF, COMDAT

; 70   : 	void constructMCDF(int numCh) {

$LN20:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx

; 71   : 		mdiff_numberOfChannels = numCh;

	mov	DWORD PTR [rcx], edx

; 99   : 		mdiff_outHadamard = nullptr;

	and	QWORD PTR [rcx+16], 0

; 100  : 		mdiff_outMultiChDel = nullptr;

	and	QWORD PTR [rcx+8], 0

; 110  : 		mdiff_MultiChDelay = new MultiChannelDelay(mdiff_numberOfChannels);

	mov	ecx, 48					; 00000030H
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	edx, DWORD PTR [rdi]
	mov	rcx, rax
	call	??0MultiChannelDelay@@QEAA@H@Z		; MultiChannelDelay::MultiChannelDelay
	npad	1
	mov	QWORD PTR [rdi+24], rax

; 111  : 		mdiff_Hadamard = new Hadamard(mdiff_numberOfChannels);

	mov	ecx, 16
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T3[rsp], rax
	mov	edx, DWORD PTR [rdi]
	mov	rcx, rax
	call	??0Hadamard@@QEAA@H@Z			; Hadamard::Hadamard
	npad	1
	mov	QWORD PTR [rdi+32], rax

; 112  : 		mdiff_Polarity = new FlipPolarity(mdiff_numberOfChannels);

	mov	ecx, 32					; 00000020H
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T5[rsp], rax
	mov	edx, DWORD PTR [rdi]
	mov	rcx, rax
	call	??0FlipPolarity@@QEAA@H@Z		; FlipPolarity::FlipPolarity
	npad	1
	mov	QWORD PTR [rdi+40], rax

; 78   : 		int lenghtInBytes = mdiff_numberOfChannels * sizeof(float);

	mov	eax, DWORD PTR [rdi]
	shl	eax, 2

; 79   : 		mdiff_outMultiChDel = (float*)malloc(lenghtInBytes);

	movsxd	rbx, eax
	mov	rcx, rbx
	call	QWORD PTR __imp_malloc
	mov	QWORD PTR [rdi+8], rax

; 80   : 		mdiff_outHadamard = (float*)malloc(lenghtInBytes);	

	mov	rcx, rbx
	call	QWORD PTR __imp_malloc
	mov	QWORD PTR [rdi+16], rax

; 81   : 		memset(mdiff_outMultiChDel, 0, lenghtInBytes);

	mov	r8, rbx
	xor	edx, edx
	mov	rcx, QWORD PTR [rdi+8]
	call	QWORD PTR __imp_memset

; 82   : 		memset(mdiff_outHadamard, 0, lenghtInBytes);

	mov	r8, rbx
	xor	edx, edx
	mov	rcx, QWORD PTR [rdi+16]

; 72   : 		initPointers();
; 73   : 		constructBlocks();
; 74   : 		initInternalArrays();
; 75   : 	}

	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi

; 82   : 		memset(mdiff_outHadamard, 0, lenghtInBytes);

	rex_jmp	QWORD PTR __imp_memset
?constructMCDF@MultiChannelDiffuser@@AEAAXH@Z ENDP	; MultiChannelDiffuser::constructMCDF
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T5 = 48
$T3 = 48
$T1 = 48
this$ = 48
numCh$ = 56
?dtor$0@?0??constructMCDF@MultiChannelDiffuser@@AEAAXH@Z@4HA PROC ; `MultiChannelDiffuser::constructMCDF'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 48					; 00000030H
	mov	rcx, QWORD PTR $T1[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??constructMCDF@MultiChannelDiffuser@@AEAAXH@Z@4HA ENDP ; `MultiChannelDiffuser::constructMCDF'::`1'::dtor$0
$T5 = 48
$T3 = 48
$T1 = 48
this$ = 48
numCh$ = 56
?dtor$1@?0??constructMCDF@MultiChannelDiffuser@@AEAAXH@Z@4HA PROC ; `MultiChannelDiffuser::constructMCDF'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 16
	mov	rcx, QWORD PTR $T3[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??constructMCDF@MultiChannelDiffuser@@AEAAXH@Z@4HA ENDP ; `MultiChannelDiffuser::constructMCDF'::`1'::dtor$1
$T5 = 48
$T3 = 48
$T1 = 48
this$ = 48
numCh$ = 56
?dtor$2@?0??constructMCDF@MultiChannelDiffuser@@AEAAXH@Z@4HA PROC ; `MultiChannelDiffuser::constructMCDF'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 32					; 00000020H
	mov	rcx, QWORD PTR $T5[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0??constructMCDF@MultiChannelDiffuser@@AEAAXH@Z@4HA ENDP ; `MultiChannelDiffuser::constructMCDF'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
$T5 = 48
$T3 = 48
$T1 = 48
this$ = 48
numCh$ = 56
?dtor$0@?0??constructMCDF@MultiChannelDiffuser@@AEAAXH@Z@4HA PROC ; `MultiChannelDiffuser::constructMCDF'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 48					; 00000030H
	mov	rcx, QWORD PTR $T1[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??constructMCDF@MultiChannelDiffuser@@AEAAXH@Z@4HA ENDP ; `MultiChannelDiffuser::constructMCDF'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
$T5 = 48
$T3 = 48
$T1 = 48
this$ = 48
numCh$ = 56
?dtor$1@?0??constructMCDF@MultiChannelDiffuser@@AEAAXH@Z@4HA PROC ; `MultiChannelDiffuser::constructMCDF'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 16
	mov	rcx, QWORD PTR $T3[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??constructMCDF@MultiChannelDiffuser@@AEAAXH@Z@4HA ENDP ; `MultiChannelDiffuser::constructMCDF'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
$T5 = 48
$T3 = 48
$T1 = 48
this$ = 48
numCh$ = 56
?dtor$2@?0??constructMCDF@MultiChannelDiffuser@@AEAAXH@Z@4HA PROC ; `MultiChannelDiffuser::constructMCDF'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 32					; 00000020H
	mov	rcx, QWORD PTR $T5[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0??constructMCDF@MultiChannelDiffuser@@AEAAXH@Z@4HA ENDP ; `MultiChannelDiffuser::constructMCDF'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\MultiChannelDiffuser.h
;	COMDAT ?initInternalArrays@MultiChannelDiffuser@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?initInternalArrays@MultiChannelDiffuser@@AEAAXXZ PROC	; MultiChannelDiffuser::initInternalArrays, COMDAT

; 77   : 	void initInternalArrays() {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 78   : 		int lenghtInBytes = mdiff_numberOfChannels * sizeof(float);

	mov	eax, DWORD PTR [rcx]
	mov	rdi, rcx
	shl	eax, 2

; 79   : 		mdiff_outMultiChDel = (float*)malloc(lenghtInBytes);

	movsxd	rbx, eax
	mov	rcx, rbx
	call	QWORD PTR __imp_malloc

; 80   : 		mdiff_outHadamard = (float*)malloc(lenghtInBytes);	

	mov	rcx, rbx
	mov	QWORD PTR [rdi+8], rax
	call	QWORD PTR __imp_malloc

; 81   : 		memset(mdiff_outMultiChDel, 0, lenghtInBytes);

	mov	rcx, QWORD PTR [rdi+8]
	mov	r8, rbx
	xor	edx, edx
	mov	QWORD PTR [rdi+16], rax
	call	QWORD PTR __imp_memset

; 82   : 		memset(mdiff_outHadamard, 0, lenghtInBytes);

	mov	rcx, QWORD PTR [rdi+16]
	mov	r8, rbx
	xor	edx, edx

; 83   : 	}	

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi

; 82   : 		memset(mdiff_outHadamard, 0, lenghtInBytes);

	rex_jmp	QWORD PTR __imp_memset
?initInternalArrays@MultiChannelDiffuser@@AEAAXXZ ENDP	; MultiChannelDiffuser::initInternalArrays
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\MultiChannelDiffuser.h
;	COMDAT ?deleteInternalArrays@MultiChannelDiffuser@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?deleteInternalArrays@MultiChannelDiffuser@@AEAAXXZ PROC ; MultiChannelDiffuser::deleteInternalArrays, COMDAT

; 90   : 	void deleteInternalArrays() {

$LN8:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 91   : 		if (mdiff_outMultiChDel)

	mov	rcx, QWORD PTR [rcx+8]
	test	rcx, rcx
	je	SHORT $LN2@deleteInte

; 92   : 			free(mdiff_outMultiChDel);

	call	QWORD PTR __imp_free
$LN2@deleteInte:

; 93   : 		if (mdiff_outHadamard)

	mov	rcx, QWORD PTR [rbx+16]
	test	rcx, rcx
	je	SHORT $LN3@deleteInte

; 94   : 			free(mdiff_outHadamard);

	call	QWORD PTR __imp_free
$LN3@deleteInte:

; 99   : 		mdiff_outHadamard = nullptr;

	and	QWORD PTR [rbx+16], 0

; 100  : 		mdiff_outMultiChDel = nullptr;

	and	QWORD PTR [rbx+8], 0

; 95   : 		initPointers();
; 96   : 	}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?deleteInternalArrays@MultiChannelDiffuser@@AEAAXXZ ENDP ; MultiChannelDiffuser::deleteInternalArrays
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\MultiChannelDiffuser.h
;	COMDAT ?initPointers@MultiChannelDiffuser@@AEAAXXZ
_TEXT	SEGMENT
this$ = 8
?initPointers@MultiChannelDiffuser@@AEAAXXZ PROC	; MultiChannelDiffuser::initPointers, COMDAT

; 99   : 		mdiff_outHadamard = nullptr;

	and	QWORD PTR [rcx+16], 0

; 100  : 		mdiff_outMultiChDel = nullptr;

	and	QWORD PTR [rcx+8], 0

; 101  : 	}

	ret	0
?initPointers@MultiChannelDiffuser@@AEAAXXZ ENDP	; MultiChannelDiffuser::initPointers
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\MultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\Hadamard.h
; File E:\FoxSuite\shimmer\include\MultiChannelDiffuser.h
;	COMDAT ?deleteBlocks@MultiChannelDiffuser@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?deleteBlocks@MultiChannelDiffuser@@AEAAXXZ PROC	; MultiChannelDiffuser::deleteBlocks, COMDAT

; 103  : 	void deleteBlocks() {

$LN32:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 104  : 		delete mdiff_MultiChDelay;			

	mov	rbx, QWORD PTR [rcx+24]
	mov	rdi, rcx
	test	rbx, rbx
	je	SHORT $LN10@deleteBloc
	mov	rcx, rbx
	call	??1MultiChannelDelay@@QEAA@XZ		; MultiChannelDelay::~MultiChannelDelay
	mov	edx, 48					; 00000030H
	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
$LN10@deleteBloc:

; 105  : 		delete mdiff_Hadamard;

	mov	rbx, QWORD PTR [rdi+32]
	test	rbx, rbx
	je	SHORT $LN13@deleteBloc
; File E:\FoxSuite\shimmer\include\Hadamard.h

; 29   : 		if (had_matrix) {

	mov	rcx, QWORD PTR [rbx+8]
	test	rcx, rcx
	je	SHORT $LN21@deleteBloc

; 30   : 			for (int i = 0; i < had_numberOfChannels; i++) {

	xor	ebp, ebp
	cmp	DWORD PTR [rbx], ebp
	jle	SHORT $LN19@deleteBloc
	xor	esi, esi
$LL20@deleteBloc:

; 31   : 				delete[] had_matrix[i];

	mov	rcx, QWORD PTR [rbx+8]
	mov	rcx, QWORD PTR [rcx+rsi]
	call	??_V@YAXPEAX@Z				; operator delete[]
	inc	ebp
	lea	rsi, QWORD PTR [rsi+8]
	cmp	ebp, DWORD PTR [rbx]
	jl	SHORT $LL20@deleteBloc
	mov	rcx, QWORD PTR [rbx+8]
$LN19@deleteBloc:

; 32   : 			}
; 33   : 			delete[] had_matrix;

	call	??_V@YAXPEAX@Z				; operator delete[]
$LN21@deleteBloc:

; 34   : 		}
; 35   : 		had_matrix = nullptr;

	and	QWORD PTR [rbx+8], 0
	mov	edx, 16
	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
$LN13@deleteBloc:
; File E:\FoxSuite\shimmer\include\MultiChannelDiffuser.h

; 106  : 		delete mdiff_Polarity;

	mov	rbx, QWORD PTR [rdi+40]
	test	rbx, rbx
	je	SHORT $LN24@deleteBloc
	mov	rcx, rbx
	call	??1FlipPolarity@@QEAA@XZ		; FlipPolarity::~FlipPolarity
	mov	edx, 32					; 00000020H
	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
$LN24@deleteBloc:

; 107  : 	}

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?deleteBlocks@MultiChannelDiffuser@@AEAAXXZ ENDP	; MultiChannelDiffuser::deleteBlocks
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\MultiChannelDiffuser.h
;	COMDAT ?constructBlocks@MultiChannelDiffuser@@AEAAXXZ
_TEXT	SEGMENT
$T5 = 48
$T3 = 48
$T1 = 48
this$ = 48
?constructBlocks@MultiChannelDiffuser@@AEAAXXZ PROC	; MultiChannelDiffuser::constructBlocks, COMDAT

; 109  : 	void constructBlocks() {

$LN14:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 110  : 		mdiff_MultiChDelay = new MultiChannelDelay(mdiff_numberOfChannels);

	mov	ecx, 48					; 00000030H
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	edx, DWORD PTR [rbx]
	mov	rcx, rax
	call	??0MultiChannelDelay@@QEAA@H@Z		; MultiChannelDelay::MultiChannelDelay
	npad	1
	mov	QWORD PTR [rbx+24], rax

; 111  : 		mdiff_Hadamard = new Hadamard(mdiff_numberOfChannels);

	mov	ecx, 16
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T3[rsp], rax
	mov	edx, DWORD PTR [rbx]
	mov	rcx, rax
	call	??0Hadamard@@QEAA@H@Z			; Hadamard::Hadamard
	npad	1
	mov	QWORD PTR [rbx+32], rax

; 112  : 		mdiff_Polarity = new FlipPolarity(mdiff_numberOfChannels);

	mov	ecx, 32					; 00000020H
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T5[rsp], rax
	mov	edx, DWORD PTR [rbx]
	mov	rcx, rax
	call	??0FlipPolarity@@QEAA@H@Z		; FlipPolarity::FlipPolarity
	npad	1
	mov	QWORD PTR [rbx+40], rax

; 113  : 	}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?constructBlocks@MultiChannelDiffuser@@AEAAXXZ ENDP	; MultiChannelDiffuser::constructBlocks
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T5 = 48
$T3 = 48
$T1 = 48
this$ = 48
?dtor$0@?0??constructBlocks@MultiChannelDiffuser@@AEAAXXZ@4HA PROC ; `MultiChannelDiffuser::constructBlocks'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 48					; 00000030H
	mov	rcx, QWORD PTR $T1[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??constructBlocks@MultiChannelDiffuser@@AEAAXXZ@4HA ENDP ; `MultiChannelDiffuser::constructBlocks'::`1'::dtor$0
$T5 = 48
$T3 = 48
$T1 = 48
this$ = 48
?dtor$1@?0??constructBlocks@MultiChannelDiffuser@@AEAAXXZ@4HA PROC ; `MultiChannelDiffuser::constructBlocks'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 16
	mov	rcx, QWORD PTR $T3[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??constructBlocks@MultiChannelDiffuser@@AEAAXXZ@4HA ENDP ; `MultiChannelDiffuser::constructBlocks'::`1'::dtor$1
$T5 = 48
$T3 = 48
$T1 = 48
this$ = 48
?dtor$2@?0??constructBlocks@MultiChannelDiffuser@@AEAAXXZ@4HA PROC ; `MultiChannelDiffuser::constructBlocks'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 32					; 00000020H
	mov	rcx, QWORD PTR $T5[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0??constructBlocks@MultiChannelDiffuser@@AEAAXXZ@4HA ENDP ; `MultiChannelDiffuser::constructBlocks'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
$T5 = 48
$T3 = 48
$T1 = 48
this$ = 48
?dtor$0@?0??constructBlocks@MultiChannelDiffuser@@AEAAXXZ@4HA PROC ; `MultiChannelDiffuser::constructBlocks'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 48					; 00000030H
	mov	rcx, QWORD PTR $T1[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??constructBlocks@MultiChannelDiffuser@@AEAAXXZ@4HA ENDP ; `MultiChannelDiffuser::constructBlocks'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
$T5 = 48
$T3 = 48
$T1 = 48
this$ = 48
?dtor$1@?0??constructBlocks@MultiChannelDiffuser@@AEAAXXZ@4HA PROC ; `MultiChannelDiffuser::constructBlocks'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 16
	mov	rcx, QWORD PTR $T3[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??constructBlocks@MultiChannelDiffuser@@AEAAXXZ@4HA ENDP ; `MultiChannelDiffuser::constructBlocks'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
$T5 = 48
$T3 = 48
$T1 = 48
this$ = 48
?dtor$2@?0??constructBlocks@MultiChannelDiffuser@@AEAAXXZ@4HA PROC ; `MultiChannelDiffuser::constructBlocks'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 32					; 00000020H
	mov	rcx, QWORD PTR $T5[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0??constructBlocks@MultiChannelDiffuser@@AEAAXXZ@4HA ENDP ; `MultiChannelDiffuser::constructBlocks'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT ??_GMultiChannelDelay@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$dead$ = 56
??_GMultiChannelDelay@@QEAAPEAXI@Z PROC			; MultiChannelDelay::`scalar deleting destructor', COMDAT
$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	call	??1MultiChannelDelay@@QEAA@XZ		; MultiChannelDelay::~MultiChannelDelay
	mov	edx, 48					; 00000030H
	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??_GMultiChannelDelay@@QEAAPEAXI@Z ENDP			; MultiChannelDelay::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\Hadamard.h
;	COMDAT ??_GHadamard@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$dead$ = 56
??_GHadamard@@QEAAPEAXI@Z PROC				; Hadamard::`scalar deleting destructor', COMDAT
$LN18:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 29   : 		if (had_matrix) {

	mov	rcx, QWORD PTR [rcx+8]
	test	rcx, rcx
	je	SHORT $LN10@scalar

; 30   : 			for (int i = 0; i < had_numberOfChannels; i++) {

	xor	esi, esi
	cmp	DWORD PTR [rbx], esi
	jle	SHORT $LN8@scalar
	xor	edi, edi
$LL9@scalar:

; 31   : 				delete[] had_matrix[i];

	mov	rcx, QWORD PTR [rbx+8]
	mov	rcx, QWORD PTR [rdi+rcx]
	call	??_V@YAXPEAX@Z				; operator delete[]
	inc	esi
	lea	rdi, QWORD PTR [rdi+8]
	cmp	esi, DWORD PTR [rbx]
	jl	SHORT $LL9@scalar
	mov	rcx, QWORD PTR [rbx+8]
$LN8@scalar:

; 32   : 			}
; 33   : 			delete[] had_matrix;

	call	??_V@YAXPEAX@Z				; operator delete[]
$LN10@scalar:

; 34   : 		}
; 35   : 		had_matrix = nullptr;

	and	QWORD PTR [rbx+8], 0
	mov	edx, 16
	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
	mov	rsi, QWORD PTR [rsp+56]
	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??_GHadamard@@QEAAPEAXI@Z ENDP				; Hadamard::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogspy
;	COMDAT ??_GFlipPolarity@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$dead$ = 56
??_GFlipPolarity@@QEAAPEAXI@Z PROC			; FlipPolarity::`scalar deleting destructor', COMDAT
$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	call	??1FlipPolarity@@QEAA@XZ		; FlipPolarity::~FlipPolarity
	mov	edx, 32					; 00000020H
	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??_GFlipPolarity@@QEAAPEAXI@Z ENDP			; FlipPolarity::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\Householder.h
;	COMDAT ??0Householder@@QEAA@H@Z
_TEXT	SEGMENT
this$ = 8
numCh$ = 16
??0Householder@@QEAA@H@Z PROC				; Householder::Householder, COMDAT

; 19   : 		hou_multiplier = -2.0 / hou_numberOfChannels;

	movsd	xmm1, QWORD PTR __real@c000000000000000

; 15   : 	Householder(int numCh) { setNumberOfChannels(numCh); }

	mov	rax, rcx
	movd	xmm0, edx

; 19   : 		hou_multiplier = -2.0 / hou_numberOfChannels;

	cvtdq2pd xmm0, xmm0
	mov	DWORD PTR [rcx], edx
	divsd	xmm1, xmm0
	cvtpd2ps xmm0, xmm1
	movss	DWORD PTR [rcx+4], xmm0

; 15   : 	Householder(int numCh) { setNumberOfChannels(numCh); }

	ret	0
??0Householder@@QEAA@H@Z ENDP				; Householder::Householder
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\Householder.h
;	COMDAT ?setNumberOfChannels@Householder@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 8
numCh$ = 16
?setNumberOfChannels@Householder@@QEAAXH@Z PROC		; Householder::setNumberOfChannels, COMDAT

; 18   : 		hou_numberOfChannels = numCh;
; 19   : 		hou_multiplier = -2.0 / hou_numberOfChannels;

	movsd	xmm1, QWORD PTR __real@c000000000000000
	movd	xmm0, edx
	cvtdq2pd xmm0, xmm0
	mov	DWORD PTR [rcx], edx
	divsd	xmm1, xmm0
	cvtpd2ps xmm0, xmm1
	movss	DWORD PTR [rcx+4], xmm0

; 20   : 	}

	ret	0
?setNumberOfChannels@Householder@@QEAAXH@Z ENDP		; Householder::setNumberOfChannels
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\Householder.h
;	COMDAT ?processAudio@Householder@@QEAAXPEAM0@Z
_TEXT	SEGMENT
this$ = 8
in$ = 16
out$ = 24
?processAudio@Householder@@QEAAXPEAM0@Z PROC		; Householder::processAudio, COMDAT

; 23   : 		float sum = 0.0;
; 24   : 		for (int i = 0; i < hou_numberOfChannels; i++)

	movsxd	r10, DWORD PTR [rcx]
	xor	eax, eax
	xorps	xmm1, xmm1
	test	r10, r10
	jle	SHORT $LN3@processAud
	mov	r9d, eax
$LL13@processAud:

; 25   : 			sum += in[i];

	addss	xmm1, DWORD PTR [rdx+r9*4]
	inc	r9
	cmp	r9, r10
	jl	SHORT $LL13@processAud
$LN3@processAud:

; 26   : 
; 27   : 		sum *= hou_multiplier;

	mulss	xmm1, DWORD PTR [rcx+4]

; 28   : 
; 29   : 		for (int i = 0; i < hou_numberOfChannels; i++)

	cmp	DWORD PTR [rcx], eax
	jle	SHORT $LN6@processAud
	sub	rdx, r8
$LL7@processAud:

; 30   : 			out[i] = in[i] + sum;

	movaps	xmm0, xmm1
	inc	eax
	addss	xmm0, DWORD PTR [rdx+r8]
	movss	DWORD PTR [r8], xmm0
	add	r8, 4
	cmp	eax, DWORD PTR [rcx]
	jl	SHORT $LL7@processAud
$LN6@processAud:

; 31   : 			//arr[i] += sum;
; 32   : 	}

	ret	0
?processAudio@Householder@@QEAAXPEAM0@Z ENDP		; Householder::processAudio
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
;	COMDAT ??0ModMultiChannelDelay@@QEAA@H@Z
_TEXT	SEGMENT
this$ = 64
numCh$ = 72
$T3 = 80
$T1 = 88
??0ModMultiChannelDelay@@QEAA@H@Z PROC			; ModMultiChannelDelay::ModMultiChannelDelay, COMDAT

; 31   : 	ModMultiChannelDelay(int numCh) {

$LN44:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx
	lea	rsi, QWORD PTR [rcx+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	ebx, ebx
	mov	QWORD PTR [rsi], rbx
	mov	QWORD PTR [rsi+8], rbx
	mov	QWORD PTR [rsi+16], rbx
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 163  : 		mdel_numberOfChannels = numCh;

	mov	DWORD PTR [rcx], edx

; 164  : 		mdel_minDelayMs = 0.0;

	mov	QWORD PTR [rcx+32], rbx

; 158  : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	mov	ebp, ebx
	test	edx, edx
	jle	SHORT $LN14@ModMultiCh
$LL15@ModMultiCh:

; 159  : 			mdel_DelayLines.push_back(new ModDelay);

	mov	ecx, 144				; 00000090H
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, rax
	call	??0ModDelay@@QEAA@XZ			; ModDelay::ModDelay
	npad	1
	mov	QWORD PTR $T3[rsp], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 743  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rsi+8]
	cmp	rdx, QWORD PTR [rsi+16]
	je	SHORT $LN23@ModMultiCh

; 726  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	QWORD PTR [rdx], rax

; 727  :         _Orphan_range(_Mylast, _Mylast);
; 728  :         _Ty& _Result = *_Mylast;
; 729  :         ++_Mylast;

	add	QWORD PTR [rsi+8], 8

; 744  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN13@ModMultiCh
$LN23@ModMultiCh:

; 745  :         }
; 746  : 
; 747  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T3[rsp]
	mov	rcx, rsi
	call	??$_Emplace_reallocate@PEAVModDelay@@@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEAAPEAPEAVModDelay@@QEAPEAV2@$$QEAPEAV2@@Z ; std::vector<ModDelay *,std::allocator<ModDelay *> >::_Emplace_reallocate<ModDelay *>
$LN13@ModMultiCh:
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 158  : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	inc	ebp
	cmp	ebp, DWORD PTR [rdi]
	jl	SHORT $LL15@ModMultiCh
$LN14@ModMultiCh:

; 98   : 		mdel_modValmsec = modVal;

	mov	edx, 1106247680				; 41f00000H
	mov	DWORD PTR [rdi+48], edx

; 99   : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	cmp	DWORD PTR [rdi], ebx
	jle	SHORT $LN29@ModMultiCh
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1563 :         auto& _My_data = _Mypair._Myval2;

	mov	rcx, rbx
$LL30@ModMultiCh:

; 1564 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1565 :         _STL_VERIFY(
; 1566 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1567 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1568 : 
; 1569 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rsi]
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 100  : 			mdel_DelayLines[i]->setDeltaDelayValue(modVal);

	mov	rax, QWORD PTR [rcx+rax]
	mov	DWORD PTR [rax+124], edx

; 99   : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	inc	ebx
	lea	rcx, QWORD PTR [rcx+8]
	cmp	ebx, DWORD PTR [rdi]
	jl	SHORT $LL30@ModMultiCh
$LN29@ModMultiCh:

; 32   : 		constructMCDL(numCh);
; 33   : 	}

	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
??0ModMultiChannelDelay@@QEAA@H@Z ENDP			; ModMultiChannelDelay::ModMultiChannelDelay
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
this$ = 64
numCh$ = 72
$T3 = 80
$T1 = 88
?dtor$0@?0???0ModMultiChannelDelay@@QEAA@H@Z@4HA PROC	; `ModMultiChannelDelay::ModMultiChannelDelay'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 8
	jmp	??1?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEAA@XZ ; std::vector<ModDelay *,std::allocator<ModDelay *> >::~vector<ModDelay *,std::allocator<ModDelay *> >
?dtor$0@?0???0ModMultiChannelDelay@@QEAA@H@Z@4HA ENDP	; `ModMultiChannelDelay::ModMultiChannelDelay'::`1'::dtor$0
this$ = 64
numCh$ = 72
$T3 = 80
$T1 = 88
?dtor$1@?0???0ModMultiChannelDelay@@QEAA@H@Z@4HA PROC	; `ModMultiChannelDelay::ModMultiChannelDelay'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 144				; 00000090H
	mov	rcx, QWORD PTR $T1[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???0ModMultiChannelDelay@@QEAA@H@Z@4HA ENDP	; `ModMultiChannelDelay::ModMultiChannelDelay'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
this$ = 64
numCh$ = 72
$T3 = 80
$T1 = 88
?dtor$0@?0???0ModMultiChannelDelay@@QEAA@H@Z@4HA PROC	; `ModMultiChannelDelay::ModMultiChannelDelay'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 8
	jmp	??1?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEAA@XZ ; std::vector<ModDelay *,std::allocator<ModDelay *> >::~vector<ModDelay *,std::allocator<ModDelay *> >
?dtor$0@?0???0ModMultiChannelDelay@@QEAA@H@Z@4HA ENDP	; `ModMultiChannelDelay::ModMultiChannelDelay'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
this$ = 64
numCh$ = 72
$T3 = 80
$T1 = 88
?dtor$1@?0???0ModMultiChannelDelay@@QEAA@H@Z@4HA PROC	; `ModMultiChannelDelay::ModMultiChannelDelay'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 144				; 00000090H
	mov	rcx, QWORD PTR $T1[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???0ModMultiChannelDelay@@QEAA@H@Z@4HA ENDP	; `ModMultiChannelDelay::ModMultiChannelDelay'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
;	COMDAT ??1ModMultiChannelDelay@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1ModMultiChannelDelay@@QEAA@XZ PROC			; ModMultiChannelDelay::~ModMultiChannelDelay, COMDAT

; 35   : 	~ModMultiChannelDelay() { deleteDelayLines(); }

$LN60:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	push	r14
	sub	rsp, 32					; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1544 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	r8, QWORD PTR [rcx+8]
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 35   : 	~ModMultiChannelDelay() { deleteDelayLines(); }

	mov	rbx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1544 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	rax, QWORD PTR [rcx+16]
	cmp	r8, rax
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 150  : 		if (!mdel_DelayLines.empty()) {

	je	$LN7@ModMultiCh
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	rax, r8
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 151  : 			for (int i = 0; i < mdel_DelayLines.size(); i++)

	xor	ebp, ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	rax, 3
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 151  : 			for (int i = 0; i < mdel_DelayLines.size(); i++)

	mov	rdx, r8
	test	rax, rax
	je	SHORT $LN5@ModMultiCh
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1548 :         auto& _My_data = _Mypair._Myval2;

	xor	r14d, r14d
$LL6@ModMultiCh:
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 152  : 				delete mdel_DelayLines[i];

	mov	rdi, QWORD PTR [r14+r8]
	test	rdi, rdi
	je	SHORT $LN4@ModMultiCh
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 51   : 		delete mdly_LFO;

	mov	rsi, QWORD PTR [rdi+104]
	lea	rax, OFFSET FLAT:??_7ModDelay@@6B@
	mov	QWORD PTR [rdi], rax
	test	rsi, rsi
	je	SHORT $LN26@ModMultiCh
	mov	rcx, rsi
	call	??1LFO@@QEAA@XZ				; LFO::~LFO
	mov	edx, 56					; 00000038H
	mov	rcx, rsi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN26@ModMultiCh:

; 52   : 	}

	mov	rcx, rdi
	call	??1LPCombFilter@@QEAA@XZ		; LPCombFilter::~LPCombFilter
	mov	edx, 144				; 00000090H
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN4@ModMultiCh:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	r8, QWORD PTR [rbx+8]
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 151  : 			for (int i = 0; i < mdel_DelayLines.size(); i++)

	inc	ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rbx+16]
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 151  : 			for (int i = 0; i < mdel_DelayLines.size(); i++)

	add	r14, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	rcx, r8
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 151  : 			for (int i = 0; i < mdel_DelayLines.size(); i++)

	movsxd	rax, ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	rcx, 3
	mov	rdx, r8
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 151  : 			for (int i = 0; i < mdel_DelayLines.size(); i++)

	cmp	rax, rcx
	jb	SHORT $LL6@ModMultiCh
$LN5@ModMultiCh:

; 153  : 			mdel_DelayLines.clear();

	mov	QWORD PTR [rbx+16], r8
	mov	r8, rdx
$LN7@ModMultiCh:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

	test	r8, r8
	je	SHORT $LN31@ModMultiCh

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+24]
	sub	rdx, r8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN47@ModMultiCh

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [r8-8]
	add	rdx, 39					; 00000027H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	r8, rcx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [r8-8]
	cmp	rax, 31
	ja	SHORT $LN44@ModMultiCh

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	r8, rcx
$LN47@ModMultiCh:

; 264  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, r8
	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

	and	QWORD PTR [rbx+8], 0

; 1768 :             _Mylast  = nullptr;

	and	QWORD PTR [rbx+16], 0

; 1769 :             _Myend   = nullptr;

	and	QWORD PTR [rbx+24], 0
$LN31@ModMultiCh:
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 35   : 	~ModMultiChannelDelay() { deleteDelayLines(); }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
$LN44@ModMultiCh:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN57@ModMultiCh:
??1ModMultiChannelDelay@@QEAA@XZ ENDP			; ModMultiChannelDelay::~ModMultiChannelDelay
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
;	COMDAT ?initDelayLines@ModMultiChannelDelay@@QEAAXMH@Z
_TEXT	SEGMENT
this$ = 48
bufferLengthMs$dead$ = 56
sampleRate$ = 64
?initDelayLines@ModMultiChannelDelay@@QEAAXMH@Z PROC	; ModMultiChannelDelay::initDelayLines, COMDAT

; 37   : 	void initDelayLines(float bufferLengthMs, int sampleRate) {

$LN17:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 38   : 		mdel_sampleRate = sampleRate;

	mov	DWORD PTR [rcx+40], r8d
	mov	ebp, r8d
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1544 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	rax, QWORD PTR [rcx+16]
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 37   : 	void initDelayLines(float bufferLengthMs, int sampleRate) {

	mov	rbx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1544 :         return _My_data._Myfirst == _My_data._Mylast;

	cmp	QWORD PTR [rcx+8], rax
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 39   : 		if (!mdel_DelayLines.empty()) {

	je	SHORT $LN3@initDelayL

; 40   : 			for (int i = 0; i < mdel_numberOfChannels; i++)

	xor	edi, edi
	cmp	DWORD PTR [rcx], edi
	jle	SHORT $LN3@initDelayL
	mov	esi, edi
$LL4@initDelayL:

; 41   : 				mdel_DelayLines[i]->init(bufferLengthMs, sampleRate);

	mov	rcx, QWORD PTR [rbx+8]
	mov	r8d, ebp
	movss	xmm1, DWORD PTR __real@44fa0000
	mov	rcx, QWORD PTR [rcx+rsi]
	call	?init@ModDelay@@QEAAXMHW4OscillatorType@@@Z ; ModDelay::init
	inc	edi
	lea	rsi, QWORD PTR [rsi+8]
	cmp	edi, DWORD PTR [rbx]
	jl	SHORT $LL4@initDelayL
$LN3@initDelayL:

; 42   : 		}
; 43   : 	}

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?initDelayLines@ModMultiChannelDelay@@QEAAXMH@Z ENDP	; ModMultiChannelDelay::initDelayLines
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File E:\FoxSuite\shimmer\include\src\Delay.cpp
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\utils.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\utils.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File E:\FoxSuite\shimmer\include\src\Delay.cpp
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File E:\FoxSuite\shimmer\include\src\Delay.cpp
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
;	COMDAT ?setDelayLinesLength@ModMultiChannelDelay@@QEAAXMMW4DelayDistribution@@@Z
_TEXT	SEGMENT
dly$7 = 32
$T3 = 56
this$ = 128
dlyMinLengthMs$dead$ = 136
dlyMaxLengthMs$ = 144
distr$ = 152
?setDelayLinesLength@ModMultiChannelDelay@@QEAAXMMW4DelayDistribution@@@Z PROC ; ModMultiChannelDelay::setDelayLinesLength, COMDAT

; 55   : 	void setDelayLinesLength(float dlyMinLengthMs, float dlyMaxLengthMs, DelayDistribution distr = DelayDistribution::RandomInRange) {

$LN121:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	push	r14
	sub	rsp, 112				; 00000070H
	movaps	XMMWORD PTR [rax-24], xmm6
	movaps	XMMWORD PTR [rax-40], xmm8
	mov	rdi, rcx

; 56   : 		mdel_minDelayMs = dlyMinLengthMs;

	mov	DWORD PTR [rcx+32], 1106247680		; 41f00000H

; 57   : 		mdel_maxDelayMs = dlyMaxLengthMs;

	movss	DWORD PTR [rcx+36], xmm2

; 58   : 		/*if (mdel_maxDelayMs / mdel_numberOfChannels < MINIMUM_DELAY_LENGTH_MCD)
; 59   : 			mdel_maxDelayMs = 2 * MINIMUM_DELAY_LENGTH_MCD;*/
; 60   : 		mdel_delayDistr = distr;

	mov	DWORD PTR [rcx+44], r9d

; 61   : 		switch (distr) {

	xor	ebx, ebx
	test	r9d, r9d
	je	$LN5@setDelayLi
	sub	r9d, 1
	je	SHORT $LN4@setDelayLi
	cmp	r9d, 1
	jne	$LN70@setDelayLi

; 128  : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	cmp	DWORD PTR [rcx], ebx
	jle	$LN70@setDelayLi
	mov	esi, ebx
$LL95@setDelayLi:

; 129  : 			mdel_DelayLines[i]->setDelayInmsec(mdel_maxDelayMs);

	movss	xmm1, DWORD PTR [rdi+36]
	mov	rax, QWORD PTR [rdi+8]
	mov	rcx, QWORD PTR [rsi+rax]
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 84   : 		mdly_meanDelayValue = delay;

	movss	DWORD PTR [rcx+120], xmm1
; File E:\FoxSuite\shimmer\include\src\Delay.cpp

; 118  : 	if (delayInmsec > dly_lineLengthInmsec)

	movss	xmm0, DWORD PTR [rcx+16]
	comiss	xmm1, xmm0
	ja	SHORT $LN104@setDelayLi

; 119  : 		delayInmsec = dly_lineLengthInmsec;
; 120  : 	else if (delayInmsec < 0.0)

	movaps	xmm0, xmm1
	maxss	xmm0, DWORD PTR __real@00000000
$LN104@setDelayLi:

; 121  : 		delayInmsec = 0.0;
; 122  : 
; 123  : 	// Set delay line length in milliseconds
; 124  : 	dly_delayInmsec = delayInmsec;

	movss	DWORD PTR [rcx+24], xmm0

; 125  : 
; 126  : 	// Update parameters based on new delay length
; 127  : 	updateParameters();

	call	?updateParameters@Delay@@AEAAXXZ	; Delay::updateParameters
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 128  : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	inc	ebx
	add	rsi, 8
	cmp	ebx, DWORD PTR [rdi]
	jl	SHORT $LL95@setDelayLi
	jmp	$LN70@setDelayLi
$LN4@setDelayLi:

; 133  : 		float step = (mdel_maxDelayMs - MINIMUM_DELAY_LENGTH_MCD) / mdel_numberOfChannels;

	xorps	xmm1, xmm1
	cvtss2sd xmm1, xmm2
	subsd	xmm1, QWORD PTR __real@3fb999999999999a
	movd	xmm0, DWORD PTR [rcx]
	cvtdq2pd xmm0, xmm0
	divsd	xmm1, xmm0
	cvtpd2ps xmm8, xmm1

; 135  : 		for (int i = 0; i < mdel_numberOfChannels; i++) {

	cmp	DWORD PTR [rcx], ebx
	jle	$LN70@setDelayLi
	mov	rsi, rbx
$LL11@setDelayLi:
	xorps	xmm0, xmm0

; 136  : 			dlyLength = randomInRange(MINIMUM_DELAY_LENGTH_MCD + step * i, MINIMUM_DELAY_LENGTH_MCD + step * (i + 1));

	cvtsi2ss xmm0, ebx
	mulss	xmm0, xmm8
	cvtps2pd xmm1, xmm0
	addsd	xmm1, QWORD PTR __real@3fb999999999999a
	cvtpd2ps xmm6, xmm1
	inc	ebx
; File E:\FoxSuite\shimmer\include\utils.h

; 105  : 	float unitRand = rand() / float(RAND_MAX);

	call	QWORD PTR __imp_rand
	xorps	xmm3, xmm3
	cvtsi2ss xmm3, eax
	mulss	xmm3, DWORD PTR __real@38000100
	xorps	xmm0, xmm0
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 136  : 			dlyLength = randomInRange(MINIMUM_DELAY_LENGTH_MCD + step * i, MINIMUM_DELAY_LENGTH_MCD + step * (i + 1));

	cvtsi2ss xmm0, ebx
	mulss	xmm0, xmm8
	cvtps2pd xmm1, xmm0
	addsd	xmm1, QWORD PTR __real@3fb999999999999a
	cvtpd2ps xmm2, xmm1
; File E:\FoxSuite\shimmer\include\utils.h

; 106  : 	return min + unitRand * (max - min);

	subss	xmm2, xmm6
	mulss	xmm3, xmm2
	addss	xmm3, xmm6
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 137  : 			mdel_DelayLines[i]->setDelayInmsec(dlyLength);

	mov	rax, QWORD PTR [rdi+8]
	mov	rcx, QWORD PTR [rsi+rax]
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 84   : 		mdly_meanDelayValue = delay;

	movss	DWORD PTR [rcx+120], xmm3
; File E:\FoxSuite\shimmer\include\src\Delay.cpp

; 118  : 	if (delayInmsec > dly_lineLengthInmsec)

	movss	xmm0, DWORD PTR [rcx+16]
	comiss	xmm3, xmm0
	ja	SHORT $LN22@setDelayLi

; 119  : 		delayInmsec = dly_lineLengthInmsec;
; 120  : 	else if (delayInmsec < 0.0)

	movaps	xmm0, xmm3
	maxss	xmm0, DWORD PTR __real@00000000
$LN22@setDelayLi:

; 121  : 		delayInmsec = 0.0;
; 122  : 
; 123  : 	// Set delay line length in milliseconds
; 124  : 	dly_delayInmsec = delayInmsec;

	movss	DWORD PTR [rcx+24], xmm0

; 125  : 
; 126  : 	// Update parameters based on new delay length
; 127  : 	updateParameters();

	call	?updateParameters@Delay@@AEAAXXZ	; Delay::updateParameters
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 135  : 		for (int i = 0; i < mdel_numberOfChannels; i++) {

	add	rsi, 8
	cmp	ebx, DWORD PTR [rdi]
	jl	$LL11@setDelayLi

; 62   : 		case DelayDistribution::RandomInRange: {
; 63   : 			setRandomInRangeDelayLines();
; 64   : 			break;

	jmp	$LN70@setDelayLi
$LN5@setDelayLi:

; 142  : 		vector<float> dly(mdel_numberOfChannels);

	movsxd	rdx, DWORD PTR [rcx]
	lea	rcx, QWORD PTR dly$7[rsp]
	call	??0?$vector@MV?$allocator@M@std@@@std@@QEAA@_KAEBV?$allocator@M@1@@Z ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
	npad	1

; 143  : 		dly = exponentialVector(0.0, mdel_maxDelayMs, mdel_numberOfChannels);

	mov	r9d, DWORD PTR [rdi]
	movss	xmm2, DWORD PTR [rdi+36]
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T3[rsp]
	call	?exponentialVector@@YA?AV?$vector@MV?$allocator@M@std@@@std@@MMH@Z ; exponentialVector
	mov	rdx, rax
	lea	rcx, QWORD PTR dly$7[rsp]
	call	??4?$vector@MV?$allocator@M@std@@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::vector<float,std::allocator<float> >::operator=
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR $T3[rsp]
	test	rcx, rcx
	je	SHORT $LN34@setDelayLi

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR $T3[rsp+16]
	sub	rax, rcx
	sar	rax, 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax*4]
	mov	rax, rcx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN50@setDelayLi

; 155  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 156  : 
; 157  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN50@setDelayLi
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN50@setDelayLi:

; 264  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN34@setDelayLi:
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 144  : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	mov	esi, ebx
	cmp	DWORD PTR [rdi], ebx
	jle	SHORT $LN26@setDelayLi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1563 :         auto& _My_data = _Mypair._Myval2;

	mov	rbp, rbx
	mov	r14, rbx
$LL27@setDelayLi:

; 1564 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1565 :         _STL_VERIFY(
; 1566 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1567 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1568 : 
; 1569 :         return _My_data._Myfirst[_Pos];

	mov	rcx, QWORD PTR [rdi+8]
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 145  : 			mdel_DelayLines[i]->setDelayInmsec(dly[i]);

	mov	rax, QWORD PTR dly$7[rsp]
	movss	xmm1, DWORD PTR [rax+rbp]
	mov	rcx, QWORD PTR [r14+rcx]
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 84   : 		mdly_meanDelayValue = delay;

	movss	DWORD PTR [rcx+120], xmm1
; File E:\FoxSuite\shimmer\include\src\Delay.cpp

; 118  : 	if (delayInmsec > dly_lineLengthInmsec)

	movss	xmm0, DWORD PTR [rcx+16]
	comiss	xmm1, xmm0
	ja	SHORT $LN65@setDelayLi

; 119  : 		delayInmsec = dly_lineLengthInmsec;
; 120  : 	else if (delayInmsec < 0.0)

	movaps	xmm0, xmm1
	maxss	xmm0, DWORD PTR __real@00000000
$LN65@setDelayLi:

; 121  : 		delayInmsec = 0.0;
; 122  : 
; 123  : 	// Set delay line length in milliseconds
; 124  : 	dly_delayInmsec = delayInmsec;

	movss	DWORD PTR [rcx+24], xmm0

; 125  : 
; 126  : 	// Update parameters based on new delay length
; 127  : 	updateParameters();

	call	?updateParameters@Delay@@AEAAXXZ	; Delay::updateParameters
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 144  : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	inc	esi
	add	r14, 8
	add	rbp, 4
	cmp	esi, DWORD PTR [rdi]
	jl	SHORT $LL27@setDelayLi
$LN26@setDelayLi:

; 146  : 		dly.clear();

	mov	rcx, QWORD PTR dly$7[rsp]
	mov	QWORD PTR dly$7[rsp+8], rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

	test	rcx, rcx
	je	SHORT $LN70@setDelayLi

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR dly$7[rsp+16]
	sub	rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -4
	mov	rax, rcx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN86@setDelayLi

; 155  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 156  : 
; 157  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN86@setDelayLi
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN86@setDelayLi:

; 264  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN70@setDelayLi:
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 75   : 	}

	lea	r11, QWORD PTR [rsp+112]
	mov	rbx, QWORD PTR [r11+16]
	mov	rbp, QWORD PTR [r11+24]
	mov	rsi, QWORD PTR [r11+32]
	mov	rdi, QWORD PTR [r11+40]
	movaps	xmm6, XMMWORD PTR [rsp+96]
	movaps	xmm8, XMMWORD PTR [r11-32]
	mov	rsp, r11
	pop	r14
	ret	0
$LN118@setDelayLi:
?setDelayLinesLength@ModMultiChannelDelay@@QEAAXMMW4DelayDistribution@@@Z ENDP ; ModMultiChannelDelay::setDelayLinesLength
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
dly$7 = 32
$T3 = 56
this$ = 128
dlyMinLengthMs$dead$ = 136
dlyMaxLengthMs$ = 144
distr$ = 152
?dtor$0@?0??setDelayLinesLength@ModMultiChannelDelay@@QEAAXMMW4DelayDistribution@@@Z@4HA PROC ; `ModMultiChannelDelay::setDelayLinesLength'::`1'::dtor$0
	lea	rcx, QWORD PTR dly$7[rdx]
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0??setDelayLinesLength@ModMultiChannelDelay@@QEAAXMMW4DelayDistribution@@@Z@4HA ENDP ; `ModMultiChannelDelay::setDelayLinesLength'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
dly$7 = 32
$T3 = 56
this$ = 128
dlyMinLengthMs$dead$ = 136
dlyMaxLengthMs$ = 144
distr$ = 152
?dtor$0@?0??setDelayLinesLength@ModMultiChannelDelay@@QEAAXMMW4DelayDistribution@@@Z@4HA PROC ; `ModMultiChannelDelay::setDelayLinesLength'::`1'::dtor$0
	lea	rcx, QWORD PTR dly$7[rdx]
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0??setDelayLinesLength@ModMultiChannelDelay@@QEAAXMMW4DelayDistribution@@@Z@4HA ENDP ; `ModMultiChannelDelay::setDelayLinesLength'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\src\Delay.cpp
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
;	COMDAT ?setMakeUpGaindB@ModMultiChannelDelay@@QEAAXM@Z
_TEXT	SEGMENT
this$ = 48
makeUpGain$dead$ = 56
?setMakeUpGaindB@ModMultiChannelDelay@@QEAAXM@Z PROC	; ModMultiChannelDelay::setMakeUpGaindB, COMDAT

; 82   : 	void setMakeUpGaindB(float makeUpGain) {

$LN16:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 83   : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	xor	ebx, ebx
	mov	rdi, rcx
	cmp	DWORD PTR [rcx], ebx
	jle	SHORT $LN3@setMakeUpG
	mov	esi, ebx
$LL4@setMakeUpG:

; 84   : 			mdel_DelayLines[i]->setMakeUpGaindB(makeUpGain);

	mov	rax, QWORD PTR [rdi+8]
	mov	rcx, QWORD PTR [rsi+rax]
; File E:\FoxSuite\shimmer\include\src\Delay.cpp

; 135  : 	dly_makeUpGaindB = gaindB;

	mov	DWORD PTR [rcx+64], 1069547520		; 3fc00000H

; 136  : 
; 137  : 	// update parameters
; 138  : 	updateParameters();

	call	?updateParameters@Delay@@AEAAXXZ	; Delay::updateParameters
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 83   : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	inc	ebx
	lea	rsi, QWORD PTR [rsi+8]
	cmp	ebx, DWORD PTR [rdi]
	jl	SHORT $LL4@setMakeUpG
$LN3@setMakeUpG:

; 85   : 	}

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?setMakeUpGaindB@ModMultiChannelDelay@@QEAAXM@Z ENDP	; ModMultiChannelDelay::setMakeUpGaindB
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
;	COMDAT ?setModDepth@ModMultiChannelDelay@@QEAAXM@Z
_TEXT	SEGMENT
this$ = 8
depth$ = 16
?setModDepth@ModMultiChannelDelay@@QEAAXM@Z PROC	; ModMultiChannelDelay::setModDepth, COMDAT

; 88   : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	xor	edx, edx
	mov	r8, rcx
	cmp	DWORD PTR [rcx], edx
	jle	SHORT $LN3@setModDept
	mov	r9d, edx
$LL4@setModDept:

; 89   : 			mdel_DelayLines[i]->setDeltaDelayValue(depth*mdel_modValmsec);

	mov	rax, QWORD PTR [r8+8]
	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR [r8+48]
	inc	edx
	mov	rcx, QWORD PTR [r9+rax]
	lea	r9, QWORD PTR [r9+8]
	movss	DWORD PTR [rcx+124], xmm0
	cmp	edx, DWORD PTR [r8]
	jl	SHORT $LL4@setModDept
$LN3@setModDept:

; 90   : 	}

	ret	0
?setModDepth@ModMultiChannelDelay@@QEAAXM@Z ENDP	; ModMultiChannelDelay::setModDepth
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\LFO.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File E:\FoxSuite\shimmer\include\LFO.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
;	COMDAT ?setModRate@ModMultiChannelDelay@@QEAAXM@Z
_TEXT	SEGMENT
this$ = 8
freq$dead$ = 16
?setModRate@ModMultiChannelDelay@@QEAAXM@Z PROC		; ModMultiChannelDelay::setModRate, COMDAT

; 93   : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	xor	edx, edx
	mov	r8, rcx
	cmp	DWORD PTR [rcx], edx
	jle	SHORT $LN3@setModRate
	mov	r9d, edx
	mov	r10d, 1065353216			; 3f800000H
$LL4@setModRate:

; 94   : 			mdel_DelayLines[i]->setModRate(freq);

	mov	rax, QWORD PTR [r8+8]
	inc	edx
; File E:\FoxSuite\shimmer\include\LFO.h

; 122  : 		lfo_inc = WAVETABLE_SIZE * lfo_frequency / (float)lfo_sampleRate;

	movss	xmm1, DWORD PTR __real@45800000
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 94   : 			mdel_DelayLines[i]->setModRate(freq);

	mov	rcx, QWORD PTR [r9+rax]
	lea	r9, QWORD PTR [r9+8]
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 90   : 		mdly_LFO->setLFOfrequency(mdly_rate);

	mov	rax, QWORD PTR [rcx+104]
	mov	DWORD PTR [rcx+136], r10d
	movd	xmm0, DWORD PTR [rax+4]
; File E:\FoxSuite\shimmer\include\LFO.h

; 122  : 		lfo_inc = WAVETABLE_SIZE * lfo_frequency / (float)lfo_sampleRate;

	cvtdq2ps xmm0, xmm0

; 71   : 		lfo_frequency = frequency;

	mov	DWORD PTR [rax], r10d

; 122  : 		lfo_inc = WAVETABLE_SIZE * lfo_frequency / (float)lfo_sampleRate;

	divss	xmm1, xmm0
	movss	DWORD PTR [rax+20], xmm1
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 93   : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	cmp	edx, DWORD PTR [r8]
	jl	SHORT $LL4@setModRate
$LN3@setModRate:

; 95   : 	}	

	ret	0
?setModRate@ModMultiChannelDelay@@QEAAXM@Z ENDP		; ModMultiChannelDelay::setModRate
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
;	COMDAT ?setModValueInMsec@ModMultiChannelDelay@@QEAAXM@Z
_TEXT	SEGMENT
this$ = 8
modVal$ = 16
?setModValueInMsec@ModMultiChannelDelay@@QEAAXM@Z PROC	; ModMultiChannelDelay::setModValueInMsec, COMDAT

; 98   : 		mdel_modValmsec = modVal;
; 99   : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	xor	r8d, r8d
	movss	DWORD PTR [rcx+48], xmm1
	cmp	DWORD PTR [rcx], r8d
	jle	SHORT $LN3@setModValu
	mov	r9d, r8d
$LL4@setModValu:

; 100  : 			mdel_DelayLines[i]->setDeltaDelayValue(modVal);

	mov	rax, QWORD PTR [rcx+8]
	inc	r8d
	mov	rdx, QWORD PTR [rax+r9]
	lea	r9, QWORD PTR [r9+8]
	movss	DWORD PTR [rdx+124], xmm1
	cmp	r8d, DWORD PTR [rcx]
	jl	SHORT $LL4@setModValu
$LN3@setModValu:

; 101  : 	}

	ret	0
?setModValueInMsec@ModMultiChannelDelay@@QEAAXM@Z ENDP	; ModMultiChannelDelay::setModValueInMsec
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File E:\FoxSuite\shimmer\include\LFO.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
;	COMDAT ?setOscillatorType@ModMultiChannelDelay@@QEAAXW4OscillatorType@@@Z
_TEXT	SEGMENT
this$ = 48
type$dead$ = 56
?setOscillatorType@ModMultiChannelDelay@@QEAAXW4OscillatorType@@@Z PROC ; ModMultiChannelDelay::setOscillatorType, COMDAT

; 103  : 	void setOscillatorType(OscillatorType type) {

$LN20:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 104  : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	xor	ebx, ebx
	mov	rdi, rcx
	cmp	DWORD PTR [rcx], ebx
	jle	SHORT $LN3@setOscilla
	mov	esi, ebx
$LL4@setOscilla:

; 105  : 			mdel_DelayLines[i]->setLFOWaveform(type);

	mov	rax, QWORD PTR [rdi+8]
	mov	rdx, QWORD PTR [rsi+rax]
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 95   : 		mdly_LFO->setLFOWaveform(wave);

	mov	rcx, QWORD PTR [rdx+104]
	mov	DWORD PTR [rdx+116], 1
; File E:\FoxSuite\shimmer\include\LFO.h

; 132  : 		lfo_table.clear();

	mov	rax, QWORD PTR [rcx+24]
	mov	QWORD PTR [rcx+32], rax

; 76   : 		lfo_waveform = waveform;

	mov	DWORD PTR [rcx+12], 1

; 77   : 		clearTable();
; 78   : 		createTable();

	call	?createTable@LFO@@AEAAXXZ		; LFO::createTable
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 104  : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	inc	ebx
	lea	rsi, QWORD PTR [rsi+8]
	cmp	ebx, DWORD PTR [rdi]
	jl	SHORT $LL4@setOscilla
$LN3@setOscilla:

; 106  : 	}

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?setOscillatorType@ModMultiChannelDelay@@QEAAXW4OscillatorType@@@Z ENDP ; ModMultiChannelDelay::setOscillatorType
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
;	COMDAT ?setOscillatorIsUnipolar@ModMultiChannelDelay@@QEAAX_N@Z
_TEXT	SEGMENT
this$ = 8
isUnipolar$dead$ = 16
?setOscillatorIsUnipolar@ModMultiChannelDelay@@QEAAX_N@Z PROC ; ModMultiChannelDelay::setOscillatorIsUnipolar, COMDAT

; 109  : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	xor	r9d, r9d
	mov	r8d, r9d
	cmp	DWORD PTR [rcx], r9d
	jle	SHORT $LN3@setOscilla
	mov	edx, r9d
$LL4@setOscilla:

; 110  : 			mdel_DelayLines[i]->setLFOUnipolar(isUnipolar);

	mov	rax, QWORD PTR [rcx+8]
	inc	r8d
	mov	rax, QWORD PTR [rdx+rax]
	lea	rdx, QWORD PTR [rdx+8]
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 99   : 		mdly_isUnipolar = isUnipolar;

	mov	BYTE PTR [rax+112], r9b

; 100  : 		mdly_LFO->setLFOunipolar(isUnipolar);

	mov	rax, QWORD PTR [rax+104]
	mov	BYTE PTR [rax+48], r9b
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 109  : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	cmp	r8d, DWORD PTR [rcx]
	jl	SHORT $LL4@setOscilla
$LN3@setOscilla:

; 111  : 	}

	ret	0
?setOscillatorIsUnipolar@ModMultiChannelDelay@@QEAAX_N@Z ENDP ; ModMultiChannelDelay::setOscillatorIsUnipolar
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
;	COMDAT ?setSampleRate@ModMultiChannelDelay@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
sampleRate$ = 56
?setSampleRate@ModMultiChannelDelay@@QEAAXH@Z PROC	; ModMultiChannelDelay::setSampleRate, COMDAT

; 113  : 	void setSampleRate(int sampleRate) {

$LN14:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 114  : 		for (int i = 0; i < mdel_numberOfChannels; i++) {

	xor	ebx, ebx
	mov	ebp, edx
	mov	rdi, rcx
	cmp	DWORD PTR [rcx], ebx
	jle	SHORT $LN3@setSampleR
	mov	esi, ebx
$LL4@setSampleR:

; 115  : 			mdel_sampleRate = sampleRate;

	mov	DWORD PTR [rdi+40], ebp

; 116  : 			mdel_DelayLines[i]->setSampleRate(sampleRate);

	mov	edx, ebp
	mov	rax, QWORD PTR [rdi+8]
	mov	rcx, QWORD PTR [rsi+rax]
	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+8]
	inc	ebx
	lea	rsi, QWORD PTR [rsi+8]
	cmp	ebx, DWORD PTR [rdi]
	jl	SHORT $LL4@setSampleR
$LN3@setSampleR:

; 117  : 		}
; 118  : 	}

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?setSampleRate@ModMultiChannelDelay@@QEAAXH@Z ENDP	; ModMultiChannelDelay::setSampleRate
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
;	COMDAT ?processAudio@ModMultiChannelDelay@@QEAAXPEAM0@Z
_TEXT	SEGMENT
this$ = 48
in$ = 56
out$ = 64
?processAudio@ModMultiChannelDelay@@QEAAXPEAM0@Z PROC	; ModMultiChannelDelay::processAudio, COMDAT

; 120  : 	void processAudio(float* in, float* out) {

$LN14:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 121  : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	xor	ebx, ebx
	mov	rdi, r8
	mov	rsi, rdx
	mov	rbp, rcx
	cmp	DWORD PTR [rcx], ebx
	jle	SHORT $LN3@processAud
	mov	r14d, ebx
	sub	rsi, r8
$LL4@processAud:

; 122  : 			out[i] = mdel_DelayLines[i]->processAudio(in[i]);

	mov	rax, QWORD PTR [rbp+8]
	movss	xmm1, DWORD PTR [rsi+rdi]
	mov	rcx, QWORD PTR [r14+rax]
	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+16]
	movss	DWORD PTR [rdi], xmm0
	inc	ebx
	lea	r14, QWORD PTR [r14+8]
	lea	rdi, QWORD PTR [rdi+4]
	cmp	ebx, DWORD PTR [rbp]
	jl	SHORT $LL4@processAud
$LN3@processAud:

; 123  : 	}

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
?processAudio@ModMultiChannelDelay@@QEAAXPEAM0@Z ENDP	; ModMultiChannelDelay::processAudio
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\src\Delay.cpp
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File E:\FoxSuite\shimmer\include\src\Delay.cpp
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
;	COMDAT ?setEqualDelayLines@ModMultiChannelDelay@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?setEqualDelayLines@ModMultiChannelDelay@@AEAAXXZ PROC	; ModMultiChannelDelay::setEqualDelayLines, COMDAT

; 127  : 	void setEqualDelayLines() {

$LN21:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 128  : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	xor	ebx, ebx
	mov	rdi, rcx
	cmp	DWORD PTR [rcx], ebx
	jle	SHORT $LN3@setEqualDe
	mov	esi, ebx
$LL4@setEqualDe:

; 129  : 			mdel_DelayLines[i]->setDelayInmsec(mdel_maxDelayMs);

	movss	xmm1, DWORD PTR [rdi+36]
	mov	rax, QWORD PTR [rdi+8]
	mov	rcx, QWORD PTR [rsi+rax]
; File E:\FoxSuite\shimmer\include\src\Delay.cpp

; 118  : 	if (delayInmsec > dly_lineLengthInmsec)

	movss	xmm0, DWORD PTR [rcx+16]
	comiss	xmm1, xmm0
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 84   : 		mdly_meanDelayValue = delay;

	movss	DWORD PTR [rcx+120], xmm1
; File E:\FoxSuite\shimmer\include\src\Delay.cpp

; 118  : 	if (delayInmsec > dly_lineLengthInmsec)

	ja	SHORT $LN13@setEqualDe

; 119  : 		delayInmsec = dly_lineLengthInmsec;
; 120  : 	else if (delayInmsec < 0.0)

	movaps	xmm0, xmm1
	maxss	xmm0, DWORD PTR __real@00000000
$LN13@setEqualDe:

; 121  : 		delayInmsec = 0.0;
; 122  : 
; 123  : 	// Set delay line length in milliseconds
; 124  : 	dly_delayInmsec = delayInmsec;

	movss	DWORD PTR [rcx+24], xmm0

; 125  : 
; 126  : 	// Update parameters based on new delay length
; 127  : 	updateParameters();

	call	?updateParameters@Delay@@AEAAXXZ	; Delay::updateParameters
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 128  : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	inc	ebx
	add	rsi, 8
	cmp	ebx, DWORD PTR [rdi]
	jl	SHORT $LL4@setEqualDe
$LN3@setEqualDe:

; 130  : 	}

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?setEqualDelayLines@ModMultiChannelDelay@@AEAAXXZ ENDP	; ModMultiChannelDelay::setEqualDelayLines
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\utils.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\utils.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\utils.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\src\Delay.cpp
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\utils.h
; File E:\FoxSuite\shimmer\include\src\Delay.cpp
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File E:\FoxSuite\shimmer\include\src\Delay.cpp
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
;	COMDAT ?setRandomInRangeDelayLines@ModMultiChannelDelay@@AEAAXXZ
_TEXT	SEGMENT
this$ = 80
?setRandomInRangeDelayLines@ModMultiChannelDelay@@AEAAXXZ PROC ; ModMultiChannelDelay::setRandomInRangeDelayLines, COMDAT

; 132  : 	void setRandomInRangeDelayLines() {

$LN23:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rsi
	push	rdi
	sub	rsp, 64					; 00000040H
	movss	xmm1, DWORD PTR [rcx+36]
	mov	rbx, rcx
	movd	xmm0, DWORD PTR [rcx]

; 133  : 		float step = (mdel_maxDelayMs - MINIMUM_DELAY_LENGTH_MCD) / mdel_numberOfChannels;

	cvtps2pd xmm1, xmm1
	cvtdq2pd xmm0, xmm0
	subsd	xmm1, QWORD PTR __real@3fb999999999999a
	movaps	XMMWORD PTR [rax-24], xmm6
	movaps	XMMWORD PTR [rax-40], xmm8

; 135  : 		for (int i = 0; i < mdel_numberOfChannels; i++) {

	xor	eax, eax
	divsd	xmm1, xmm0
	cvtpd2ps xmm8, xmm1
	cmp	DWORD PTR [rcx], eax
	jle	$LN3@setRandomI
	mov	edi, eax
$LL4@setRandomI:
	xorps	xmm0, xmm0

; 136  : 			dlyLength = randomInRange(MINIMUM_DELAY_LENGTH_MCD + step * i, MINIMUM_DELAY_LENGTH_MCD + step * (i + 1));

	lea	esi, DWORD PTR [rax+1]
	cvtsi2ss xmm0, eax
	mulss	xmm0, xmm8
	cvtps2pd xmm1, xmm0
	addsd	xmm1, QWORD PTR __real@3fb999999999999a
	cvtpd2ps xmm6, xmm1
; File E:\FoxSuite\shimmer\include\utils.h

; 105  : 	float unitRand = rand() / float(RAND_MAX);

	call	QWORD PTR __imp_rand
	xorps	xmm0, xmm0
	xorps	xmm3, xmm3
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 136  : 			dlyLength = randomInRange(MINIMUM_DELAY_LENGTH_MCD + step * i, MINIMUM_DELAY_LENGTH_MCD + step * (i + 1));

	cvtsi2ss xmm0, esi
; File E:\FoxSuite\shimmer\include\utils.h

; 105  : 	float unitRand = rand() / float(RAND_MAX);

	cvtsi2ss xmm3, eax
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 137  : 			mdel_DelayLines[i]->setDelayInmsec(dlyLength);

	mov	rax, QWORD PTR [rbx+8]
	mov	rcx, QWORD PTR [rdi+rax]
; File E:\FoxSuite\shimmer\include\utils.h

; 105  : 	float unitRand = rand() / float(RAND_MAX);

	mulss	xmm3, DWORD PTR __real@38000100
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 136  : 			dlyLength = randomInRange(MINIMUM_DELAY_LENGTH_MCD + step * i, MINIMUM_DELAY_LENGTH_MCD + step * (i + 1));

	mulss	xmm0, xmm8
	cvtps2pd xmm1, xmm0
; File E:\FoxSuite\shimmer\include\src\Delay.cpp

; 118  : 	if (delayInmsec > dly_lineLengthInmsec)

	movss	xmm0, DWORD PTR [rcx+16]
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 136  : 			dlyLength = randomInRange(MINIMUM_DELAY_LENGTH_MCD + step * i, MINIMUM_DELAY_LENGTH_MCD + step * (i + 1));

	addsd	xmm1, QWORD PTR __real@3fb999999999999a
	cvtpd2ps xmm2, xmm1
; File E:\FoxSuite\shimmer\include\utils.h

; 106  : 	return min + unitRand * (max - min);

	subss	xmm2, xmm6
	mulss	xmm3, xmm2
	addss	xmm3, xmm6
; File E:\FoxSuite\shimmer\include\src\Delay.cpp

; 118  : 	if (delayInmsec > dly_lineLengthInmsec)

	comiss	xmm3, xmm0
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 84   : 		mdly_meanDelayValue = delay;

	movss	DWORD PTR [rcx+120], xmm3
; File E:\FoxSuite\shimmer\include\src\Delay.cpp

; 118  : 	if (delayInmsec > dly_lineLengthInmsec)

	ja	SHORT $LN15@setRandomI

; 119  : 		delayInmsec = dly_lineLengthInmsec;
; 120  : 	else if (delayInmsec < 0.0)

	movaps	xmm0, xmm3
	maxss	xmm0, DWORD PTR __real@00000000
$LN15@setRandomI:

; 121  : 		delayInmsec = 0.0;
; 122  : 
; 123  : 	// Set delay line length in milliseconds
; 124  : 	dly_delayInmsec = delayInmsec;

	movss	DWORD PTR [rcx+24], xmm0

; 125  : 
; 126  : 	// Update parameters based on new delay length
; 127  : 	updateParameters();

	call	?updateParameters@Delay@@AEAAXXZ	; Delay::updateParameters
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 135  : 		for (int i = 0; i < mdel_numberOfChannels; i++) {

	add	rdi, 8
	mov	eax, esi
	cmp	esi, DWORD PTR [rbx]
	jl	$LL4@setRandomI
$LN3@setRandomI:

; 138  : 		}
; 139  : 	}

	mov	rbx, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+88]
	movaps	xmm6, XMMWORD PTR [rsp+48]
	movaps	xmm8, XMMWORD PTR [rsp+32]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
?setRandomInRangeDelayLines@ModMultiChannelDelay@@AEAAXXZ ENDP ; ModMultiChannelDelay::setRandomInRangeDelayLines
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File E:\FoxSuite\shimmer\include\src\Delay.cpp
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
;	COMDAT ?setExponentialDelayLengths@ModMultiChannelDelay@@AEAAXXZ
_TEXT	SEGMENT
dly$ = 32
$T2 = 56
this$ = 96
?setExponentialDelayLengths@ModMultiChannelDelay@@AEAAXXZ PROC ; ModMultiChannelDelay::setExponentialDelayLengths, COMDAT

; 141  : 	void setExponentialDelayLengths() {

$LN75:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rsi
	mov	QWORD PTR [rax+24], rdi
	push	r14
	sub	rsp, 80					; 00000050H
	mov	rbx, rcx

; 142  : 		vector<float> dly(mdel_numberOfChannels);

	movsxd	rdx, DWORD PTR [rcx]
	lea	rcx, QWORD PTR [rax-56]
	call	??0?$vector@MV?$allocator@M@std@@@std@@QEAA@_KAEBV?$allocator@M@1@@Z ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
	npad	1

; 143  : 		dly = exponentialVector(0.0, mdel_maxDelayMs, mdel_numberOfChannels);

	mov	r9d, DWORD PTR [rbx]
	movss	xmm2, DWORD PTR [rbx+36]
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T2[rsp]
	call	?exponentialVector@@YA?AV?$vector@MV?$allocator@M@std@@@std@@MMH@Z ; exponentialVector
	mov	rdx, rax
	lea	rcx, QWORD PTR dly$[rsp]
	call	??4?$vector@MV?$allocator@M@std@@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::vector<float,std::allocator<float> >::operator=
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR $T2[rsp]
	test	rcx, rcx
	je	SHORT $LN11@setExponen

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR $T2[rsp+16]
	sub	rax, rcx
	sar	rax, 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax*4]
	mov	rax, rcx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN27@setExponen

; 155  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 156  : 
; 157  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN27@setExponen
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN27@setExponen:

; 264  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN11@setExponen:
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 144  : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	xor	edi, edi
	cmp	DWORD PTR [rbx], edi
	jle	SHORT $LN3@setExponen
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1563 :         auto& _My_data = _Mypair._Myval2;

	xor	esi, esi
	xor	r14d, r14d
$LL4@setExponen:

; 1564 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1565 :         _STL_VERIFY(
; 1566 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1567 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1568 : 
; 1569 :         return _My_data._Myfirst[_Pos];

	mov	rcx, QWORD PTR [rbx+8]
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 145  : 			mdel_DelayLines[i]->setDelayInmsec(dly[i]);

	mov	rax, QWORD PTR dly$[rsp]
	movss	xmm1, DWORD PTR [rsi+rax]
	mov	rcx, QWORD PTR [r14+rcx]
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 84   : 		mdly_meanDelayValue = delay;

	movss	DWORD PTR [rcx+120], xmm1
; File E:\FoxSuite\shimmer\include\src\Delay.cpp

; 118  : 	if (delayInmsec > dly_lineLengthInmsec)

	movss	xmm0, DWORD PTR [rcx+16]
	comiss	xmm1, xmm0
	ja	SHORT $LN42@setExponen

; 119  : 		delayInmsec = dly_lineLengthInmsec;
; 120  : 	else if (delayInmsec < 0.0)

	movaps	xmm0, xmm1
	maxss	xmm0, DWORD PTR __real@00000000
$LN42@setExponen:

; 121  : 		delayInmsec = 0.0;
; 122  : 
; 123  : 	// Set delay line length in milliseconds
; 124  : 	dly_delayInmsec = delayInmsec;

	movss	DWORD PTR [rcx+24], xmm0

; 125  : 
; 126  : 	// Update parameters based on new delay length
; 127  : 	updateParameters();

	call	?updateParameters@Delay@@AEAAXXZ	; Delay::updateParameters
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 144  : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	inc	edi
	add	r14, 8
	add	rsi, 4
	cmp	edi, DWORD PTR [rbx]
	jl	SHORT $LL4@setExponen
$LN3@setExponen:

; 146  : 		dly.clear();

	mov	rcx, QWORD PTR dly$[rsp]
	mov	QWORD PTR dly$[rsp+8], rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

	test	rcx, rcx
	je	SHORT $LN47@setExponen

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR dly$[rsp+16]
	sub	rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -4
	mov	rax, rcx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN63@setExponen

; 155  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 156  : 
; 157  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN63@setExponen
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN63@setExponen:

; 264  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN47@setExponen:
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 147  : 	}

	mov	rbx, QWORD PTR [rsp+96]
	mov	rsi, QWORD PTR [rsp+104]
	mov	rdi, QWORD PTR [rsp+112]
	add	rsp, 80					; 00000050H
	pop	r14
	ret	0
$LN72@setExponen:
?setExponentialDelayLengths@ModMultiChannelDelay@@AEAAXXZ ENDP ; ModMultiChannelDelay::setExponentialDelayLengths
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
dly$ = 32
$T2 = 56
this$ = 96
?dtor$0@?0??setExponentialDelayLengths@ModMultiChannelDelay@@AEAAXXZ@4HA PROC ; `ModMultiChannelDelay::setExponentialDelayLengths'::`1'::dtor$0
	lea	rcx, QWORD PTR dly$[rdx]
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0??setExponentialDelayLengths@ModMultiChannelDelay@@AEAAXXZ@4HA ENDP ; `ModMultiChannelDelay::setExponentialDelayLengths'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
dly$ = 32
$T2 = 56
this$ = 96
?dtor$0@?0??setExponentialDelayLengths@ModMultiChannelDelay@@AEAAXXZ@4HA PROC ; `ModMultiChannelDelay::setExponentialDelayLengths'::`1'::dtor$0
	lea	rcx, QWORD PTR dly$[rdx]
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0??setExponentialDelayLengths@ModMultiChannelDelay@@AEAAXXZ@4HA ENDP ; `ModMultiChannelDelay::setExponentialDelayLengths'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
;	COMDAT ?deleteDelayLines@ModMultiChannelDelay@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?deleteDelayLines@ModMultiChannelDelay@@AEAAXXZ PROC	; ModMultiChannelDelay::deleteDelayLines, COMDAT

; 149  : 	void deleteDelayLines() {

$LN32:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	push	r14
	sub	rsp, 32					; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1544 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	rdx, QWORD PTR [rcx+8]
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 149  : 	void deleteDelayLines() {

	mov	rbx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1544 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	rax, QWORD PTR [rcx+16]
	cmp	rdx, rax
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 150  : 		if (!mdel_DelayLines.empty()) {

	je	SHORT $LN5@deleteDela
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	rax, rdx
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 151  : 			for (int i = 0; i < mdel_DelayLines.size(); i++)

	xor	ebp, ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	rax, 3
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 151  : 			for (int i = 0; i < mdel_DelayLines.size(); i++)

	test	rax, rax
	je	SHORT $LN3@deleteDela
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1548 :         auto& _My_data = _Mypair._Myval2;

	xor	r14d, r14d
$LL4@deleteDela:
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 152  : 				delete mdel_DelayLines[i];

	mov	rdi, QWORD PTR [r14+rdx]
	test	rdi, rdi
	je	SHORT $LN2@deleteDela
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 51   : 		delete mdly_LFO;

	mov	rsi, QWORD PTR [rdi+104]
	lea	rax, OFFSET FLAT:??_7ModDelay@@6B@
	mov	QWORD PTR [rdi], rax
	test	rsi, rsi
	je	SHORT $LN24@deleteDela
	mov	rcx, rsi
	call	??1LFO@@QEAA@XZ				; LFO::~LFO
	mov	edx, 56					; 00000038H
	mov	rcx, rsi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN24@deleteDela:

; 52   : 	}

	mov	rcx, rdi
	call	??1LPCombFilter@@QEAA@XZ		; LPCombFilter::~LPCombFilter
	mov	edx, 144				; 00000090H
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN2@deleteDela:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR [rbx+8]
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 151  : 			for (int i = 0; i < mdel_DelayLines.size(); i++)

	inc	ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rbx+16]
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 151  : 			for (int i = 0; i < mdel_DelayLines.size(); i++)

	add	r14, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	rcx, rdx
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 151  : 			for (int i = 0; i < mdel_DelayLines.size(); i++)

	movsxd	rax, ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	rcx, 3
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 151  : 			for (int i = 0; i < mdel_DelayLines.size(); i++)

	cmp	rax, rcx
	jb	SHORT $LL4@deleteDela
$LN3@deleteDela:

; 153  : 			mdel_DelayLines.clear();

	mov	QWORD PTR [rbx+16], rdx
$LN5@deleteDela:

; 154  : 		}
; 155  : 	}

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
?deleteDelayLines@ModMultiChannelDelay@@AEAAXXZ ENDP	; ModMultiChannelDelay::deleteDelayLines
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
;	COMDAT ?constructDelayObjects@ModMultiChannelDelay@@AEAAXXZ
_TEXT	SEGMENT
$T3 = 48
this$ = 48
$T1 = 56
?constructDelayObjects@ModMultiChannelDelay@@AEAAXXZ PROC ; ModMultiChannelDelay::constructDelayObjects, COMDAT

; 157  : 	void constructDelayObjects() {

$LN22:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx

; 158  : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	xor	ebx, ebx
	cmp	DWORD PTR [rcx], ebx
	jle	SHORT $LN3@constructD
$LL4@constructD:

; 159  : 			mdel_DelayLines.push_back(new ModDelay);

	mov	ecx, 144				; 00000090H
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, rax
	call	??0ModDelay@@QEAA@XZ			; ModDelay::ModDelay
	npad	1
	mov	QWORD PTR $T3[rsp], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 743  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rdi+16]
	cmp	rdx, QWORD PTR [rdi+24]
	je	SHORT $LN12@constructD

; 726  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	QWORD PTR [rdx], rax

; 727  :         _Orphan_range(_Mylast, _Mylast);
; 728  :         _Ty& _Result = *_Mylast;
; 729  :         ++_Mylast;

	add	QWORD PTR [rdi+16], 8

; 744  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN2@constructD
$LN12@constructD:

; 745  :         }
; 746  : 
; 747  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T3[rsp]
	lea	rcx, QWORD PTR [rdi+8]
	call	??$_Emplace_reallocate@PEAVModDelay@@@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEAAPEAPEAVModDelay@@QEAPEAV2@$$QEAPEAV2@@Z ; std::vector<ModDelay *,std::allocator<ModDelay *> >::_Emplace_reallocate<ModDelay *>
$LN2@constructD:
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 158  : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	inc	ebx
	cmp	ebx, DWORD PTR [rdi]
	jl	SHORT $LL4@constructD
$LN3@constructD:

; 160  : 	}

	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?constructDelayObjects@ModMultiChannelDelay@@AEAAXXZ ENDP ; ModMultiChannelDelay::constructDelayObjects
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T3 = 48
this$ = 48
$T1 = 56
?dtor$0@?0??constructDelayObjects@ModMultiChannelDelay@@AEAAXXZ@4HA PROC ; `ModMultiChannelDelay::constructDelayObjects'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 144				; 00000090H
	mov	rcx, QWORD PTR $T1[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??constructDelayObjects@ModMultiChannelDelay@@AEAAXXZ@4HA ENDP ; `ModMultiChannelDelay::constructDelayObjects'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
$T3 = 48
this$ = 48
$T1 = 56
?dtor$0@?0??constructDelayObjects@ModMultiChannelDelay@@AEAAXXZ@4HA PROC ; `ModMultiChannelDelay::constructDelayObjects'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 144				; 00000090H
	mov	rcx, QWORD PTR $T1[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??constructDelayObjects@ModMultiChannelDelay@@AEAAXXZ@4HA ENDP ; `ModMultiChannelDelay::constructDelayObjects'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
;	COMDAT ?constructMCDL@ModMultiChannelDelay@@AEAAXH@Z
_TEXT	SEGMENT
$T3 = 64
this$ = 64
numCh$ = 72
$T1 = 80
?constructMCDL@ModMultiChannelDelay@@AEAAXH@Z PROC	; ModMultiChannelDelay::constructMCDL, COMDAT

; 162  : 	void constructMCDL(int numCh) {

$LN35:
	mov	QWORD PTR [rsp+16], rbx
	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx

; 163  : 		mdel_numberOfChannels = numCh;

	mov	DWORD PTR [rcx], edx

; 164  : 		mdel_minDelayMs = 0.0;

	xor	ebx, ebx
	mov	QWORD PTR [rcx+32], rbx

; 158  : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	mov	ebp, ebx
	test	edx, edx
	jle	SHORT $LN5@constructM
$LL6@constructM:

; 159  : 			mdel_DelayLines.push_back(new ModDelay);

	mov	ecx, 144				; 00000090H
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, rax
	call	??0ModDelay@@QEAA@XZ			; ModDelay::ModDelay
	npad	1
	mov	QWORD PTR $T3[rsp], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 743  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rdi+16]
	cmp	rdx, QWORD PTR [rdi+24]
	je	SHORT $LN14@constructM

; 726  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	QWORD PTR [rdx], rax

; 727  :         _Orphan_range(_Mylast, _Mylast);
; 728  :         _Ty& _Result = *_Mylast;
; 729  :         ++_Mylast;

	add	QWORD PTR [rdi+16], 8

; 744  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN4@constructM
$LN14@constructM:

; 745  :         }
; 746  : 
; 747  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T3[rsp]
	lea	rcx, QWORD PTR [rdi+8]
	call	??$_Emplace_reallocate@PEAVModDelay@@@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEAAPEAPEAVModDelay@@QEAPEAV2@$$QEAPEAV2@@Z ; std::vector<ModDelay *,std::allocator<ModDelay *> >::_Emplace_reallocate<ModDelay *>
$LN4@constructM:
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 158  : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	inc	ebp
	mov	edx, DWORD PTR [rdi]
	cmp	ebp, edx
	jl	SHORT $LL6@constructM
$LN5@constructM:

; 98   : 		mdel_modValmsec = modVal;

	mov	r8d, 1106247680				; 41f00000H
	mov	DWORD PTR [rdi+48], r8d

; 99   : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	test	edx, edx
	jle	SHORT $LN20@constructM
	mov	rdx, rbx
$LL21@constructM:

; 100  : 			mdel_DelayLines[i]->setDeltaDelayValue(modVal);

	mov	rax, QWORD PTR [rdi+8]
	mov	rcx, QWORD PTR [rdx+rax]
	mov	DWORD PTR [rcx+124], r8d

; 99   : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	inc	ebx
	lea	rdx, QWORD PTR [rdx+8]
	cmp	ebx, DWORD PTR [rdi]
	jl	SHORT $LL21@constructM
$LN20@constructM:

; 165  : 		mdel_maxDelayMs = 0.0;
; 166  : 		constructDelayObjects();
; 167  : 		setModValueInMsec(DEFAULT_MOD_VALUE);
; 168  : 	}

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
?constructMCDL@ModMultiChannelDelay@@AEAAXH@Z ENDP	; ModMultiChannelDelay::constructMCDL
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T3 = 64
this$ = 64
numCh$ = 72
$T1 = 80
?dtor$0@?0??constructMCDL@ModMultiChannelDelay@@AEAAXH@Z@4HA PROC ; `ModMultiChannelDelay::constructMCDL'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 144				; 00000090H
	mov	rcx, QWORD PTR $T1[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??constructMCDL@ModMultiChannelDelay@@AEAAXH@Z@4HA ENDP ; `ModMultiChannelDelay::constructMCDL'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
$T3 = 64
this$ = 64
numCh$ = 72
$T1 = 80
?dtor$0@?0??constructMCDL@ModMultiChannelDelay@@AEAAXH@Z@4HA PROC ; `ModMultiChannelDelay::constructMCDL'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 144				; 00000090H
	mov	rcx, QWORD PTR $T1[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??constructMCDL@ModMultiChannelDelay@@AEAAXH@Z@4HA ENDP ; `ModMultiChannelDelay::constructMCDL'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ModDelay.h
;	COMDAT ??_GModDelay@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$dead$ = 56
??_GModDelay@@QEAAPEAXI@Z PROC				; ModDelay::`scalar deleting destructor', COMDAT
$LN14:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 51   : 		delete mdly_LFO;

	mov	rdi, QWORD PTR [rcx+104]
	lea	rax, OFFSET FLAT:??_7ModDelay@@6B@
	mov	QWORD PTR [rcx], rax
	mov	rbx, rcx
	test	rdi, rdi
	je	SHORT $LN10@scalar
	mov	rcx, rdi
	call	??1LFO@@QEAA@XZ				; LFO::~LFO
	mov	edx, 56					; 00000038H
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN10@scalar:

; 52   : 	}

	mov	rcx, rbx
	call	??1LPCombFilter@@QEAA@XZ		; LPCombFilter::~LPCombFilter
	mov	edx, 144				; 00000090H
	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??_GModDelay@@QEAAPEAXI@Z ENDP				; ModDelay::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h
;	COMDAT ??0ModMultiChannelDiffuser@@QEAA@H@Z
_TEXT	SEGMENT
$T4 = 80
$T9 = 80
$T7 = 80
this$ = 80
numChInt$ = 88
$T1 = 96
$T2 = 104
??0ModMultiChannelDiffuser@@QEAA@H@Z PROC		; ModMultiChannelDiffuser::ModMultiChannelDiffuser, COMDAT

; 28   : 	ModMultiChannelDiffuser(int numChInt) {

$LN63:
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 32					; 00000020H
	mov	r14, rcx

; 93   : 		mdiff_numberOfChannels = numCh;

	mov	DWORD PTR [rcx], edx

; 121  : 		mdiff_outHadamard = nullptr;

	xor	ebx, ebx
	mov	QWORD PTR [rcx+16], rbx

; 122  : 		mdiff_outMultiChDel = nullptr;

	mov	QWORD PTR [rcx+8], rbx

; 132  : 		mdiff_MultiChDelay = new ModMultiChannelDelay(mdiff_numberOfChannels);

	lea	ecx, QWORD PTR [rbx+56]
	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax
	mov	QWORD PTR $T1[rsp], rax
	mov	edx, DWORD PTR [r14]
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 31   : 	ModMultiChannelDelay(int numCh) {

	lea	rsi, QWORD PTR [rax+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rsi], rbx
	mov	QWORD PTR [rsi+8], rbx
	mov	QWORD PTR [rsi+16], rbx
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 163  : 		mdel_numberOfChannels = numCh;

	mov	DWORD PTR [rax], edx

; 164  : 		mdel_minDelayMs = 0.0;

	mov	QWORD PTR [rax+32], rbx

; 158  : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	mov	ebp, ebx
	test	edx, edx
	jle	SHORT $LN31@ModMultiCh
$LL32@ModMultiCh:

; 159  : 			mdel_DelayLines.push_back(new ModDelay);

	mov	ecx, 144				; 00000090H
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T2[rsp], rax
	mov	rcx, rax
	call	??0ModDelay@@QEAA@XZ			; ModDelay::ModDelay
	npad	1
	mov	QWORD PTR $T4[rsp], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 743  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rsi+8]
	cmp	rdx, QWORD PTR [rsi+16]
	je	SHORT $LN40@ModMultiCh

; 726  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	QWORD PTR [rdx], rax

; 727  :         _Orphan_range(_Mylast, _Mylast);
; 728  :         _Ty& _Result = *_Mylast;
; 729  :         ++_Mylast;

	add	QWORD PTR [rsi+8], 8

; 744  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN30@ModMultiCh
$LN40@ModMultiCh:

; 745  :         }
; 746  : 
; 747  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T4[rsp]
	mov	rcx, rsi
	call	??$_Emplace_reallocate@PEAVModDelay@@@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEAAPEAPEAVModDelay@@QEAPEAV2@$$QEAPEAV2@@Z ; std::vector<ModDelay *,std::allocator<ModDelay *> >::_Emplace_reallocate<ModDelay *>
$LN30@ModMultiCh:
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 158  : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	inc	ebp
	cmp	ebp, DWORD PTR [rdi]
	jl	SHORT $LL32@ModMultiCh
$LN31@ModMultiCh:

; 98   : 		mdel_modValmsec = modVal;

	mov	edx, 1106247680				; 41f00000H
	mov	DWORD PTR [rdi+48], edx

; 99   : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	cmp	DWORD PTR [rdi], ebx
	jle	SHORT $LN46@ModMultiCh
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1563 :         auto& _My_data = _Mypair._Myval2;

	mov	rcx, rbx
$LL47@ModMultiCh:

; 1564 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1565 :         _STL_VERIFY(
; 1566 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1567 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1568 : 
; 1569 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rsi]
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 100  : 			mdel_DelayLines[i]->setDeltaDelayValue(modVal);

	mov	rax, QWORD PTR [rcx+rax]
	mov	DWORD PTR [rax+124], edx

; 99   : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	inc	ebx
	lea	rcx, QWORD PTR [rcx+8]
	cmp	ebx, DWORD PTR [rdi]
	jl	SHORT $LL47@ModMultiCh
$LN46@ModMultiCh:
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h

; 132  : 		mdiff_MultiChDelay = new ModMultiChannelDelay(mdiff_numberOfChannels);

	mov	QWORD PTR [r14+24], rdi

; 133  : 		mdiff_Hadamard = new Hadamard(mdiff_numberOfChannels);

	mov	ecx, 16
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T7[rsp], rax
	mov	edx, DWORD PTR [r14]
	mov	rcx, rax
	call	??0Hadamard@@QEAA@H@Z			; Hadamard::Hadamard
	npad	1
	mov	QWORD PTR [r14+32], rax

; 134  : 		mdiff_Polarity = new FlipPolarity(mdiff_numberOfChannels);

	mov	ecx, 32					; 00000020H
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T9[rsp], rax
	mov	edx, DWORD PTR [r14]
	mov	rcx, rax
	call	??0FlipPolarity@@QEAA@H@Z		; FlipPolarity::FlipPolarity
	npad	1
	mov	QWORD PTR [r14+40], rax

; 100  : 		int lenghtInBytes = mdiff_numberOfChannels * sizeof(float);

	mov	eax, DWORD PTR [r14]
	shl	eax, 2

; 101  : 		mdiff_outMultiChDel = (float*)malloc(lenghtInBytes);

	movsxd	rbx, eax
	mov	rcx, rbx
	call	QWORD PTR __imp_malloc
	mov	QWORD PTR [r14+8], rax

; 102  : 		mdiff_outHadamard = (float*)malloc(lenghtInBytes);

	mov	rcx, rbx
	call	QWORD PTR __imp_malloc
	mov	QWORD PTR [r14+16], rax

; 103  : 		memset(mdiff_outMultiChDel, 0, lenghtInBytes);

	mov	r8, rbx
	xor	edx, edx
	mov	rcx, QWORD PTR [r14+8]
	call	QWORD PTR __imp_memset

; 104  : 		memset(mdiff_outHadamard, 0, lenghtInBytes);

	mov	r8, rbx
	xor	edx, edx
	mov	rcx, QWORD PTR [r14+16]
	call	QWORD PTR __imp_memset

; 29   : 		constructMCDF(numChInt);
; 30   : 	}

	mov	rax, r14
	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
??0ModMultiChannelDiffuser@@QEAA@H@Z ENDP		; ModMultiChannelDiffuser::ModMultiChannelDiffuser
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T4 = 80
$T9 = 80
$T7 = 80
this$ = 80
numChInt$ = 88
$T1 = 96
$T2 = 104
?dtor$0@?0???0ModMultiChannelDiffuser@@QEAA@H@Z@4HA PROC ; `ModMultiChannelDiffuser::ModMultiChannelDiffuser'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 56					; 00000038H
	mov	rcx, QWORD PTR $T1[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0ModMultiChannelDiffuser@@QEAA@H@Z@4HA ENDP ; `ModMultiChannelDiffuser::ModMultiChannelDiffuser'::`1'::dtor$0
$T4 = 80
$T9 = 80
$T7 = 80
this$ = 80
numChInt$ = 88
$T1 = 96
$T2 = 104
?dtor$3@?0???0ModMultiChannelDiffuser@@QEAA@H@Z@4HA PROC ; `ModMultiChannelDiffuser::ModMultiChannelDiffuser'::`1'::dtor$3
	mov	rcx, QWORD PTR $T1[rdx]
	add	rcx, 8
	jmp	??1?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEAA@XZ ; std::vector<ModDelay *,std::allocator<ModDelay *> >::~vector<ModDelay *,std::allocator<ModDelay *> >
?dtor$3@?0???0ModMultiChannelDiffuser@@QEAA@H@Z@4HA ENDP ; `ModMultiChannelDiffuser::ModMultiChannelDiffuser'::`1'::dtor$3
$T4 = 80
$T9 = 80
$T7 = 80
this$ = 80
numChInt$ = 88
$T1 = 96
$T2 = 104
?dtor$4@?0???0ModMultiChannelDiffuser@@QEAA@H@Z@4HA PROC ; `ModMultiChannelDiffuser::ModMultiChannelDiffuser'::`1'::dtor$4
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 144				; 00000090H
	mov	rcx, QWORD PTR $T2[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$4@?0???0ModMultiChannelDiffuser@@QEAA@H@Z@4HA ENDP ; `ModMultiChannelDiffuser::ModMultiChannelDiffuser'::`1'::dtor$4
$T4 = 80
$T9 = 80
$T7 = 80
this$ = 80
numChInt$ = 88
$T1 = 96
$T2 = 104
?dtor$1@?0???0ModMultiChannelDiffuser@@QEAA@H@Z@4HA PROC ; `ModMultiChannelDiffuser::ModMultiChannelDiffuser'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 16
	mov	rcx, QWORD PTR $T7[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???0ModMultiChannelDiffuser@@QEAA@H@Z@4HA ENDP ; `ModMultiChannelDiffuser::ModMultiChannelDiffuser'::`1'::dtor$1
$T4 = 80
$T9 = 80
$T7 = 80
this$ = 80
numChInt$ = 88
$T1 = 96
$T2 = 104
?dtor$2@?0???0ModMultiChannelDiffuser@@QEAA@H@Z@4HA PROC ; `ModMultiChannelDiffuser::ModMultiChannelDiffuser'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 32					; 00000020H
	mov	rcx, QWORD PTR $T9[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0???0ModMultiChannelDiffuser@@QEAA@H@Z@4HA ENDP ; `ModMultiChannelDiffuser::ModMultiChannelDiffuser'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 80
$T9 = 80
$T7 = 80
this$ = 80
numChInt$ = 88
$T1 = 96
$T2 = 104
?dtor$0@?0???0ModMultiChannelDiffuser@@QEAA@H@Z@4HA PROC ; `ModMultiChannelDiffuser::ModMultiChannelDiffuser'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 56					; 00000038H
	mov	rcx, QWORD PTR $T1[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0ModMultiChannelDiffuser@@QEAA@H@Z@4HA ENDP ; `ModMultiChannelDiffuser::ModMultiChannelDiffuser'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 80
$T9 = 80
$T7 = 80
this$ = 80
numChInt$ = 88
$T1 = 96
$T2 = 104
?dtor$3@?0???0ModMultiChannelDiffuser@@QEAA@H@Z@4HA PROC ; `ModMultiChannelDiffuser::ModMultiChannelDiffuser'::`1'::dtor$3
	mov	rcx, QWORD PTR $T1[rdx]
	add	rcx, 8
	jmp	??1?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEAA@XZ ; std::vector<ModDelay *,std::allocator<ModDelay *> >::~vector<ModDelay *,std::allocator<ModDelay *> >
?dtor$3@?0???0ModMultiChannelDiffuser@@QEAA@H@Z@4HA ENDP ; `ModMultiChannelDiffuser::ModMultiChannelDiffuser'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 80
$T9 = 80
$T7 = 80
this$ = 80
numChInt$ = 88
$T1 = 96
$T2 = 104
?dtor$4@?0???0ModMultiChannelDiffuser@@QEAA@H@Z@4HA PROC ; `ModMultiChannelDiffuser::ModMultiChannelDiffuser'::`1'::dtor$4
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 144				; 00000090H
	mov	rcx, QWORD PTR $T2[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$4@?0???0ModMultiChannelDiffuser@@QEAA@H@Z@4HA ENDP ; `ModMultiChannelDiffuser::ModMultiChannelDiffuser'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 80
$T9 = 80
$T7 = 80
this$ = 80
numChInt$ = 88
$T1 = 96
$T2 = 104
?dtor$1@?0???0ModMultiChannelDiffuser@@QEAA@H@Z@4HA PROC ; `ModMultiChannelDiffuser::ModMultiChannelDiffuser'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 16
	mov	rcx, QWORD PTR $T7[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???0ModMultiChannelDiffuser@@QEAA@H@Z@4HA ENDP ; `ModMultiChannelDiffuser::ModMultiChannelDiffuser'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 80
$T9 = 80
$T7 = 80
this$ = 80
numChInt$ = 88
$T1 = 96
$T2 = 104
?dtor$2@?0???0ModMultiChannelDiffuser@@QEAA@H@Z@4HA PROC ; `ModMultiChannelDiffuser::ModMultiChannelDiffuser'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 32					; 00000020H
	mov	rcx, QWORD PTR $T9[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0???0ModMultiChannelDiffuser@@QEAA@H@Z@4HA ENDP ; `ModMultiChannelDiffuser::ModMultiChannelDiffuser'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\Hadamard.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h
;	COMDAT ??1ModMultiChannelDiffuser@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1ModMultiChannelDiffuser@@QEAA@XZ PROC		; ModMultiChannelDiffuser::~ModMultiChannelDiffuser, COMDAT

; 32   : 	~ModMultiChannelDiffuser() {

$LN40:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 126  : 		delete mdiff_MultiChDelay;

	mov	rdi, QWORD PTR [rcx+24]

; 32   : 	~ModMultiChannelDiffuser() {

	mov	rbx, rcx

; 126  : 		delete mdiff_MultiChDelay;

	test	rdi, rdi
	je	SHORT $LN12@ModMultiCh
	mov	rcx, rdi
	call	??1ModMultiChannelDelay@@QEAA@XZ	; ModMultiChannelDelay::~ModMultiChannelDelay
	mov	edx, 56					; 00000038H
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN12@ModMultiCh:

; 127  : 		delete mdiff_Hadamard;

	mov	rdi, QWORD PTR [rbx+32]
	test	rdi, rdi
	je	SHORT $LN15@ModMultiCh
; File E:\FoxSuite\shimmer\include\Hadamard.h

; 29   : 		if (had_matrix) {

	mov	rcx, QWORD PTR [rdi+8]
	test	rcx, rcx
	je	SHORT $LN23@ModMultiCh

; 30   : 			for (int i = 0; i < had_numberOfChannels; i++) {

	xor	ebp, ebp
	cmp	DWORD PTR [rdi], ebp
	jle	SHORT $LN21@ModMultiCh
	xor	esi, esi
$LL22@ModMultiCh:

; 31   : 				delete[] had_matrix[i];

	mov	rcx, QWORD PTR [rdi+8]
	mov	rcx, QWORD PTR [rsi+rcx]
	call	??_V@YAXPEAX@Z				; operator delete[]
	inc	ebp
	lea	rsi, QWORD PTR [rsi+8]
	cmp	ebp, DWORD PTR [rdi]
	jl	SHORT $LL22@ModMultiCh
	mov	rcx, QWORD PTR [rdi+8]
$LN21@ModMultiCh:

; 32   : 			}
; 33   : 			delete[] had_matrix;

	call	??_V@YAXPEAX@Z				; operator delete[]
$LN23@ModMultiCh:

; 34   : 		}
; 35   : 		had_matrix = nullptr;

	and	QWORD PTR [rdi+8], 0
	mov	edx, 16
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN15@ModMultiCh:
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h

; 128  : 		delete mdiff_Polarity;

	mov	rdi, QWORD PTR [rbx+40]
	test	rdi, rdi
	je	SHORT $LN26@ModMultiCh
	mov	rcx, rdi
	call	??1FlipPolarity@@QEAA@XZ		; FlipPolarity::~FlipPolarity
	mov	edx, 32					; 00000020H
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN26@ModMultiCh:

; 113  : 		if (mdiff_outMultiChDel)

	mov	rcx, QWORD PTR [rbx+8]
	test	rcx, rcx
	je	SHORT $LN29@ModMultiCh

; 114  : 			free(mdiff_outMultiChDel);

	call	QWORD PTR __imp_free
$LN29@ModMultiCh:

; 115  : 		if (mdiff_outHadamard)

	mov	rcx, QWORD PTR [rbx+16]
	test	rcx, rcx
	je	SHORT $LN30@ModMultiCh

; 116  : 			free(mdiff_outHadamard);

	call	QWORD PTR __imp_free
$LN30@ModMultiCh:

; 121  : 		mdiff_outHadamard = nullptr;

	and	QWORD PTR [rbx+16], 0

; 122  : 		mdiff_outMultiChDel = nullptr;

	and	QWORD PTR [rbx+8], 0

; 33   : 		deleteBlocks();
; 34   : 		deleteInternalArrays();
; 35   : 	}

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??1ModMultiChannelDiffuser@@QEAA@XZ ENDP		; ModMultiChannelDiffuser::~ModMultiChannelDiffuser
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\src\Delay.cpp
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h
;	COMDAT ?init@ModMultiChannelDiffuser@@QEAAXMH@Z
_TEXT	SEGMENT
this$ = 64
bufferLengthMs$dead$ = 72
sampleRate$ = 80
?init@ModMultiChannelDiffuser@@QEAAXMH@Z PROC		; ModMultiChannelDiffuser::init, COMDAT

; 37   : 	void init(float bufferLengthMs, int sampleRate) {

$LN34:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 39   : 		mdiff_MultiChDelay->initDelayLines(bufferLengthMs, sampleRate);

	mov	rdi, QWORD PTR [rcx+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1544 :         return _My_data._Myfirst == _My_data._Mylast;

	xor	ebx, ebx
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h

; 38   : 		mdiff_sampleRate = sampleRate;

	mov	DWORD PTR [rcx+4], r8d
	mov	r15d, r8d
	mov	rsi, rcx
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 38   : 		mdel_sampleRate = sampleRate;

	mov	DWORD PTR [rdi+40], r8d
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1544 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	rax, QWORD PTR [rdi+16]
	cmp	QWORD PTR [rdi+8], rax
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 39   : 		if (!mdel_DelayLines.empty()) {

	je	SHORT $LN5@init

; 40   : 			for (int i = 0; i < mdel_numberOfChannels; i++)

	mov	ebp, ebx
	cmp	DWORD PTR [rdi], ebx
	jle	SHORT $LN5@init
	mov	r14d, ebx
$LL6@init:

; 41   : 				mdel_DelayLines[i]->init(bufferLengthMs, sampleRate);

	mov	rcx, QWORD PTR [rdi+8]
	mov	r8d, r15d
	movss	xmm1, DWORD PTR __real@44fa0000
	mov	rcx, QWORD PTR [rcx+r14]
	call	?init@ModDelay@@QEAAXMHW4OscillatorType@@@Z ; ModDelay::init
	inc	ebp
	lea	r14, QWORD PTR [r14+8]
	cmp	ebp, DWORD PTR [rdi]
	jl	SHORT $LL6@init
$LN5@init:
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h

; 57   : 	void setMakeUpGainDB(float makeUpGain) { mdiff_MultiChDelay->setMakeUpGaindB(makeUpGain); }

	mov	rdi, QWORD PTR [rsi+24]
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 83   : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	cmp	DWORD PTR [rdi], ebx
	jle	SHORT $LN17@init
	mov	rsi, rbx
$LL18@init:

; 84   : 			mdel_DelayLines[i]->setMakeUpGaindB(makeUpGain);

	mov	rax, QWORD PTR [rdi+8]
	mov	rcx, QWORD PTR [rsi+rax]
; File E:\FoxSuite\shimmer\include\src\Delay.cpp

; 135  : 	dly_makeUpGaindB = gaindB;

	mov	DWORD PTR [rcx+64], 1069547520		; 3fc00000H

; 136  : 
; 137  : 	// update parameters
; 138  : 	updateParameters();

	call	?updateParameters@Delay@@AEAAXXZ	; Delay::updateParameters
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 83   : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	inc	ebx
	lea	rsi, QWORD PTR [rsi+8]
	cmp	ebx, DWORD PTR [rdi]
	jl	SHORT $LL18@init
$LN17@init:
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h

; 41   : 	}

	mov	rbx, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rdi
	ret	0
?init@ModMultiChannelDiffuser@@QEAAXMH@Z ENDP		; ModMultiChannelDiffuser::init
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h
;	COMDAT ?setDelayLinesLength@ModMultiChannelDiffuser@@QEAAXMMW4DelayDistribution@@@Z
_TEXT	SEGMENT
this$ = 8
minDelayMs$dead$ = 16
maxDelayMs$ = 24
distr$ = 32
?setDelayLinesLength@ModMultiChannelDiffuser@@QEAAXMMW4DelayDistribution@@@Z PROC ; ModMultiChannelDiffuser::setDelayLinesLength, COMDAT

; 52   : 		mdiff_MultiChDelay->setDelayLinesLength(minDelayMs, maxDelayMs, distr);

	mov	rcx, QWORD PTR [rcx+24]
	jmp	?setDelayLinesLength@ModMultiChannelDelay@@QEAAXMMW4DelayDistribution@@@Z ; ModMultiChannelDelay::setDelayLinesLength
?setDelayLinesLength@ModMultiChannelDiffuser@@QEAAXMMW4DelayDistribution@@@Z ENDP ; ModMultiChannelDiffuser::setDelayLinesLength
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\src\Delay.cpp
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h
;	COMDAT ?setMakeUpGainDB@ModMultiChannelDiffuser@@QEAAXM@Z
_TEXT	SEGMENT
this$ = 48
makeUpGain$dead$ = 56
?setMakeUpGainDB@ModMultiChannelDiffuser@@QEAAXM@Z PROC	; ModMultiChannelDiffuser::setMakeUpGainDB, COMDAT

; 57   : 	void setMakeUpGainDB(float makeUpGain) { mdiff_MultiChDelay->setMakeUpGaindB(makeUpGain); }

$LN18:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rsi, QWORD PTR [rcx+24]
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 83   : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	xor	ebx, ebx
	cmp	DWORD PTR [rsi], ebx
	jle	SHORT $LN5@setMakeUpG
	mov	edi, ebx
$LL6@setMakeUpG:

; 84   : 			mdel_DelayLines[i]->setMakeUpGaindB(makeUpGain);

	mov	rax, QWORD PTR [rsi+8]
	mov	rcx, QWORD PTR [rdi+rax]
; File E:\FoxSuite\shimmer\include\src\Delay.cpp

; 135  : 	dly_makeUpGaindB = gaindB;

	mov	DWORD PTR [rcx+64], 1069547520		; 3fc00000H

; 136  : 
; 137  : 	// update parameters
; 138  : 	updateParameters();

	call	?updateParameters@Delay@@AEAAXXZ	; Delay::updateParameters
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 83   : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	inc	ebx
	lea	rdi, QWORD PTR [rdi+8]
	cmp	ebx, DWORD PTR [rsi]
	jl	SHORT $LL6@setMakeUpG
$LN5@setMakeUpG:
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h

; 57   : 	void setMakeUpGainDB(float makeUpGain) { mdiff_MultiChDelay->setMakeUpGaindB(makeUpGain); }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?setMakeUpGainDB@ModMultiChannelDiffuser@@QEAAXM@Z ENDP	; ModMultiChannelDiffuser::setMakeUpGainDB
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h
;	COMDAT ?setModDepth@ModMultiChannelDiffuser@@QEAAXM@Z
_TEXT	SEGMENT
this$ = 8
depth$ = 16
?setModDepth@ModMultiChannelDiffuser@@QEAAXM@Z PROC	; ModMultiChannelDiffuser::setModDepth, COMDAT

; 60   : 		mdiff_MultiChDelay->setModDepth(depth);

	mov	r8, QWORD PTR [rcx+24]
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 88   : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	xor	edx, edx
	cmp	DWORD PTR [r8], edx
	jle	SHORT $LN5@setModDept
	mov	r9d, edx
$LL6@setModDept:

; 89   : 			mdel_DelayLines[i]->setDeltaDelayValue(depth*mdel_modValmsec);

	mov	rax, QWORD PTR [r8+8]
	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR [r8+48]
	inc	edx
	mov	rcx, QWORD PTR [rax+r9]
	lea	r9, QWORD PTR [r9+8]
	movss	DWORD PTR [rcx+124], xmm0
	cmp	edx, DWORD PTR [r8]
	jl	SHORT $LL6@setModDept
$LN5@setModDept:
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h

; 61   : 	}

	ret	0
?setModDepth@ModMultiChannelDiffuser@@QEAAXM@Z ENDP	; ModMultiChannelDiffuser::setModDepth
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\LFO.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File E:\FoxSuite\shimmer\include\LFO.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h
;	COMDAT ?setModRate@ModMultiChannelDiffuser@@QEAAXM@Z
_TEXT	SEGMENT
this$ = 8
rate$dead$ = 16
?setModRate@ModMultiChannelDiffuser@@QEAAXM@Z PROC	; ModMultiChannelDiffuser::setModRate, COMDAT

; 64   : 		mdiff_MultiChDelay->setModRate(rate);

	mov	r8, QWORD PTR [rcx+24]
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 93   : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	xor	edx, edx
	cmp	DWORD PTR [r8], edx
	jle	SHORT $LN5@setModRate
	mov	r9d, edx
	mov	r10d, 1065353216			; 3f800000H
$LL6@setModRate:

; 94   : 			mdel_DelayLines[i]->setModRate(freq);

	mov	rax, QWORD PTR [r8+8]
	inc	edx
; File E:\FoxSuite\shimmer\include\LFO.h

; 122  : 		lfo_inc = WAVETABLE_SIZE * lfo_frequency / (float)lfo_sampleRate;

	movss	xmm1, DWORD PTR __real@45800000
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 94   : 			mdel_DelayLines[i]->setModRate(freq);

	mov	rcx, QWORD PTR [r9+rax]
	lea	r9, QWORD PTR [r9+8]
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 90   : 		mdly_LFO->setLFOfrequency(mdly_rate);

	mov	rax, QWORD PTR [rcx+104]
	mov	DWORD PTR [rcx+136], r10d
	movd	xmm0, DWORD PTR [rax+4]
; File E:\FoxSuite\shimmer\include\LFO.h

; 122  : 		lfo_inc = WAVETABLE_SIZE * lfo_frequency / (float)lfo_sampleRate;

	cvtdq2ps xmm0, xmm0

; 71   : 		lfo_frequency = frequency;

	mov	DWORD PTR [rax], r10d

; 122  : 		lfo_inc = WAVETABLE_SIZE * lfo_frequency / (float)lfo_sampleRate;

	divss	xmm1, xmm0
	movss	DWORD PTR [rax+20], xmm1
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 93   : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	cmp	edx, DWORD PTR [r8]
	jl	SHORT $LL6@setModRate
$LN5@setModRate:
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h

; 65   : 	}

	ret	0
?setModRate@ModMultiChannelDiffuser@@QEAAXM@Z ENDP	; ModMultiChannelDiffuser::setModRate
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h
;	COMDAT ?setModValue@ModMultiChannelDiffuser@@QEAAXM@Z
_TEXT	SEGMENT
this$ = 8
val$dead$ = 16
?setModValue@ModMultiChannelDiffuser@@QEAAXM@Z PROC	; ModMultiChannelDiffuser::setModValue, COMDAT

; 68   : 		mdiff_MultiChDelay->setModValueInMsec(val);

	mov	r8, QWORD PTR [rcx+24]
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 99   : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	xor	edx, edx
	mov	r10d, 1065353216			; 3f800000H
	mov	DWORD PTR [r8+48], r10d
	cmp	DWORD PTR [r8], edx
	jle	SHORT $LN5@setModValu
	mov	r9d, edx
$LL6@setModValu:

; 100  : 			mdel_DelayLines[i]->setDeltaDelayValue(modVal);

	mov	rax, QWORD PTR [r8+8]
	inc	edx
	mov	rcx, QWORD PTR [rax+r9]
	lea	r9, QWORD PTR [r9+8]
	mov	DWORD PTR [rcx+124], r10d
	cmp	edx, DWORD PTR [r8]
	jl	SHORT $LL6@setModValu
$LN5@setModValu:
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h

; 69   : 	}

	ret	0
?setModValue@ModMultiChannelDiffuser@@QEAAXM@Z ENDP	; ModMultiChannelDiffuser::setModValue
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File E:\FoxSuite\shimmer\include\LFO.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h
;	COMDAT ?setOscillatorType@ModMultiChannelDiffuser@@QEAAXW4OscillatorType@@@Z
_TEXT	SEGMENT
this$ = 48
type$dead$ = 56
?setOscillatorType@ModMultiChannelDiffuser@@QEAAXW4OscillatorType@@@Z PROC ; ModMultiChannelDiffuser::setOscillatorType, COMDAT

; 71   : 	void setOscillatorType(OscillatorType type) {

$LN22:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 72   : 		mdiff_MultiChDelay->setOscillatorType(type);

	mov	rdi, QWORD PTR [rcx+24]
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 104  : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	xor	ebx, ebx
	cmp	DWORD PTR [rdi], ebx
	jle	SHORT $LN5@setOscilla
	mov	esi, ebx
$LL6@setOscilla:

; 105  : 			mdel_DelayLines[i]->setLFOWaveform(type);

	mov	rax, QWORD PTR [rdi+8]
	mov	rcx, QWORD PTR [rsi+rax]
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 94   : 		mdly_lfoWaveform = wave;

	mov	DWORD PTR [rcx+116], 1

; 95   : 		mdly_LFO->setLFOWaveform(wave);

	mov	rcx, QWORD PTR [rcx+104]
; File E:\FoxSuite\shimmer\include\LFO.h

; 132  : 		lfo_table.clear();

	mov	rax, QWORD PTR [rcx+24]
	mov	QWORD PTR [rcx+32], rax

; 76   : 		lfo_waveform = waveform;

	mov	DWORD PTR [rcx+12], 1

; 77   : 		clearTable();
; 78   : 		createTable();

	call	?createTable@LFO@@AEAAXXZ		; LFO::createTable
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 104  : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	inc	ebx
	lea	rsi, QWORD PTR [rsi+8]
	cmp	ebx, DWORD PTR [rdi]
	jl	SHORT $LL6@setOscilla
$LN5@setOscilla:
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h

; 73   : 	}

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?setOscillatorType@ModMultiChannelDiffuser@@QEAAXW4OscillatorType@@@Z ENDP ; ModMultiChannelDiffuser::setOscillatorType
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h
;	COMDAT ?setOscillatorIsUnipolar@ModMultiChannelDiffuser@@QEAAX_N@Z
_TEXT	SEGMENT
this$ = 8
isUnipolar$dead$ = 16
?setOscillatorIsUnipolar@ModMultiChannelDiffuser@@QEAAX_N@Z PROC ; ModMultiChannelDiffuser::setOscillatorIsUnipolar, COMDAT

; 76   : 		mdiff_MultiChDelay->setOscillatorIsUnipolar(isUnipolar);

	mov	rdx, QWORD PTR [rcx+24]
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 109  : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	xor	r9d, r9d
	mov	r8d, r9d
	cmp	DWORD PTR [rdx], r9d
	jle	SHORT $LN5@setOscilla
	mov	ecx, r9d
$LL6@setOscilla:

; 110  : 			mdel_DelayLines[i]->setLFOUnipolar(isUnipolar);

	mov	rax, QWORD PTR [rdx+8]
	inc	r8d
	mov	rax, QWORD PTR [rcx+rax]
	lea	rcx, QWORD PTR [rcx+8]
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 99   : 		mdly_isUnipolar = isUnipolar;

	mov	BYTE PTR [rax+112], r9b

; 100  : 		mdly_LFO->setLFOunipolar(isUnipolar);

	mov	rax, QWORD PTR [rax+104]
	mov	BYTE PTR [rax+48], r9b
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 109  : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	cmp	r8d, DWORD PTR [rdx]
	jl	SHORT $LL6@setOscilla
$LN5@setOscilla:
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h

; 77   : 	}

	ret	0
?setOscillatorIsUnipolar@ModMultiChannelDiffuser@@QEAAX_N@Z ENDP ; ModMultiChannelDiffuser::setOscillatorIsUnipolar
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h
;	COMDAT ?setSampleRate@ModMultiChannelDiffuser@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
sampleRate$ = 56
?setSampleRate@ModMultiChannelDiffuser@@QEAAXH@Z PROC	; ModMultiChannelDiffuser::setSampleRate, COMDAT

; 79   : 	void setSampleRate(int sampleRate) {

$LN16:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 81   : 		mdiff_MultiChDelay->setSampleRate(sampleRate);

	mov	rdi, QWORD PTR [rcx+24]
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 114  : 		for (int i = 0; i < mdel_numberOfChannels; i++) {

	xor	ebx, ebx
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h

; 80   : 		mdiff_sampleRate = sampleRate;

	mov	DWORD PTR [rcx+4], edx
	mov	esi, edx
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 114  : 		for (int i = 0; i < mdel_numberOfChannels; i++) {

	cmp	DWORD PTR [rdi], ebx
	jle	SHORT $LN5@setSampleR
	mov	r14d, ebx
$LL6@setSampleR:

; 115  : 			mdel_sampleRate = sampleRate;

	mov	DWORD PTR [rdi+40], esi

; 116  : 			mdel_DelayLines[i]->setSampleRate(sampleRate);

	mov	edx, esi
	mov	rax, QWORD PTR [rdi+8]
	mov	rcx, QWORD PTR [r14+rax]
	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+8]
	inc	ebx
	lea	r14, QWORD PTR [r14+8]
	cmp	ebx, DWORD PTR [rdi]
	jl	SHORT $LL6@setSampleR
$LN5@setSampleR:
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h

; 82   : 	}

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
?setSampleRate@ModMultiChannelDiffuser@@QEAAXH@Z ENDP	; ModMultiChannelDiffuser::setSampleRate
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\FlipPolarity.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FlipPolarity.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h
;	COMDAT ?processAudio@ModMultiChannelDiffuser@@QEAAXPEAM0@Z
_TEXT	SEGMENT
this$ = 80
in$ = 88
out$ = 96
?processAudio@ModMultiChannelDiffuser@@QEAAXPEAM0@Z PROC ; ModMultiChannelDiffuser::processAudio, COMDAT

; 84   : 	void processAudio(float* in, float* out) {

$LN27:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 85   : 		mdiff_MultiChDelay->processAudio(in, mdiff_outMultiChDel);

	mov	r14, QWORD PTR [rcx+24]
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 121  : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	xor	esi, esi
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h

; 85   : 		mdiff_MultiChDelay->processAudio(in, mdiff_outMultiChDel);

	mov	rbx, QWORD PTR [rcx+8]
	mov	r13, r8
	mov	rbp, rdx
	mov	rdi, rcx
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 121  : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	mov	r12d, esi
	cmp	DWORD PTR [r14], esi
	jle	SHORT $LN5@processAud
	mov	r15d, esi
	sub	rbp, rbx
$LL6@processAud:

; 122  : 			out[i] = mdel_DelayLines[i]->processAudio(in[i]);

	mov	rax, QWORD PTR [r14+8]
	movss	xmm1, DWORD PTR [rbx+rbp]
	mov	rcx, QWORD PTR [r15+rax]
	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+16]
	movss	DWORD PTR [rbx], xmm0
	inc	r12d
	lea	r15, QWORD PTR [r15+8]
	lea	rbx, QWORD PTR [rbx+4]
	cmp	r12d, DWORD PTR [r14]
	jl	SHORT $LL6@processAud
	mov	rbx, QWORD PTR [rdi+8]
$LN5@processAud:
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h

; 86   : 		mdiff_Polarity->processAudio(mdiff_outMultiChDel, mdiff_outMultiChDel);

	mov	rax, QWORD PTR [rdi+40]
; File E:\FoxSuite\shimmer\include\FlipPolarity.h

; 29   : 		for (int i = 0; i < fp_numofChannels; i++) {			

	cmp	DWORD PTR [rax+24], esi
	jle	SHORT $LN12@processAud
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

	mov	rcx, QWORD PTR [rax]
	sub	rcx, rbx
$LL13@processAud:
	movd	xmm0, DWORD PTR [rcx+rbx]
; File E:\FoxSuite\shimmer\include\FlipPolarity.h

; 29   : 		for (int i = 0; i < fp_numofChannels; i++) {			

	inc	esi

; 30   : 			out[i] = in[i] * fp_flipPolarity[i];

	cvtdq2ps xmm0, xmm0
	mulss	xmm0, DWORD PTR [rbx]
	movss	DWORD PTR [rbx], xmm0
	lea	rbx, QWORD PTR [rbx+4]
	cmp	esi, DWORD PTR [rax+24]
	jl	SHORT $LL13@processAud
	mov	rbx, QWORD PTR [rdi+8]
$LN12@processAud:
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h

; 87   : 		mdiff_Hadamard->processAudio(mdiff_outMultiChDel, out);

	mov	rcx, QWORD PTR [rdi+32]
	mov	r8, r13
	mov	rdx, rbx

; 88   : 	}

	mov	rbx, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi

; 87   : 		mdiff_Hadamard->processAudio(mdiff_outMultiChDel, out);

	jmp	?processAudio@Hadamard@@QEAAXPEAM0@Z	; Hadamard::processAudio
?processAudio@ModMultiChannelDiffuser@@QEAAXPEAM0@Z ENDP ; ModMultiChannelDiffuser::processAudio
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h
;	COMDAT ?constructMCDF@ModMultiChannelDiffuser@@AEAAXH@Z
_TEXT	SEGMENT
$T4 = 80
$T9 = 80
$T7 = 80
this$ = 80
numCh$ = 88
$T1 = 96
$T2 = 104
?constructMCDF@ModMultiChannelDiffuser@@AEAAXH@Z PROC	; ModMultiChannelDiffuser::constructMCDF, COMDAT

; 92   : 	void constructMCDF(int numCh) {

$LN61:
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 32					; 00000020H
	mov	r14, rcx

; 93   : 		mdiff_numberOfChannels = numCh;

	mov	DWORD PTR [rcx], edx

; 121  : 		mdiff_outHadamard = nullptr;

	xor	ebx, ebx
	mov	QWORD PTR [rcx+16], rbx

; 122  : 		mdiff_outMultiChDel = nullptr;

	mov	QWORD PTR [rcx+8], rbx

; 132  : 		mdiff_MultiChDelay = new ModMultiChannelDelay(mdiff_numberOfChannels);

	lea	ecx, QWORD PTR [rbx+56]
	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax
	mov	QWORD PTR $T1[rsp], rax
	mov	edx, DWORD PTR [r14]
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 31   : 	ModMultiChannelDelay(int numCh) {

	lea	rsi, QWORD PTR [rax+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rsi], rbx
	mov	QWORD PTR [rsi+8], rbx
	mov	QWORD PTR [rsi+16], rbx
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 163  : 		mdel_numberOfChannels = numCh;

	mov	DWORD PTR [rax], edx

; 164  : 		mdel_minDelayMs = 0.0;

	mov	QWORD PTR [rax+32], rbx

; 158  : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	mov	ebp, ebx
	test	edx, edx
	jle	SHORT $LN29@constructM
$LL30@constructM:

; 159  : 			mdel_DelayLines.push_back(new ModDelay);

	mov	ecx, 144				; 00000090H
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T2[rsp], rax
	mov	rcx, rax
	call	??0ModDelay@@QEAA@XZ			; ModDelay::ModDelay
	npad	1
	mov	QWORD PTR $T4[rsp], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 743  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rsi+8]
	cmp	rdx, QWORD PTR [rsi+16]
	je	SHORT $LN38@constructM

; 726  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	QWORD PTR [rdx], rax

; 727  :         _Orphan_range(_Mylast, _Mylast);
; 728  :         _Ty& _Result = *_Mylast;
; 729  :         ++_Mylast;

	add	QWORD PTR [rsi+8], 8

; 744  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN28@constructM
$LN38@constructM:

; 745  :         }
; 746  : 
; 747  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T4[rsp]
	mov	rcx, rsi
	call	??$_Emplace_reallocate@PEAVModDelay@@@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEAAPEAPEAVModDelay@@QEAPEAV2@$$QEAPEAV2@@Z ; std::vector<ModDelay *,std::allocator<ModDelay *> >::_Emplace_reallocate<ModDelay *>
$LN28@constructM:
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 158  : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	inc	ebp
	cmp	ebp, DWORD PTR [rdi]
	jl	SHORT $LL30@constructM
$LN29@constructM:

; 98   : 		mdel_modValmsec = modVal;

	mov	edx, 1106247680				; 41f00000H
	mov	DWORD PTR [rdi+48], edx

; 99   : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	cmp	DWORD PTR [rdi], ebx
	jle	SHORT $LN44@constructM
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1563 :         auto& _My_data = _Mypair._Myval2;

	mov	rcx, rbx
$LL45@constructM:

; 1564 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1565 :         _STL_VERIFY(
; 1566 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1567 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1568 : 
; 1569 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rsi]
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 100  : 			mdel_DelayLines[i]->setDeltaDelayValue(modVal);

	mov	rax, QWORD PTR [rcx+rax]
	mov	DWORD PTR [rax+124], edx

; 99   : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	inc	ebx
	lea	rcx, QWORD PTR [rcx+8]
	cmp	ebx, DWORD PTR [rdi]
	jl	SHORT $LL45@constructM
$LN44@constructM:
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h

; 132  : 		mdiff_MultiChDelay = new ModMultiChannelDelay(mdiff_numberOfChannels);

	mov	QWORD PTR [r14+24], rdi

; 133  : 		mdiff_Hadamard = new Hadamard(mdiff_numberOfChannels);

	mov	ecx, 16
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T7[rsp], rax
	mov	edx, DWORD PTR [r14]
	mov	rcx, rax
	call	??0Hadamard@@QEAA@H@Z			; Hadamard::Hadamard
	npad	1
	mov	QWORD PTR [r14+32], rax

; 134  : 		mdiff_Polarity = new FlipPolarity(mdiff_numberOfChannels);

	mov	ecx, 32					; 00000020H
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T9[rsp], rax
	mov	edx, DWORD PTR [r14]
	mov	rcx, rax
	call	??0FlipPolarity@@QEAA@H@Z		; FlipPolarity::FlipPolarity
	npad	1
	mov	QWORD PTR [r14+40], rax

; 100  : 		int lenghtInBytes = mdiff_numberOfChannels * sizeof(float);

	mov	eax, DWORD PTR [r14]
	shl	eax, 2

; 101  : 		mdiff_outMultiChDel = (float*)malloc(lenghtInBytes);

	movsxd	rbx, eax
	mov	rcx, rbx
	call	QWORD PTR __imp_malloc
	mov	QWORD PTR [r14+8], rax

; 102  : 		mdiff_outHadamard = (float*)malloc(lenghtInBytes);

	mov	rcx, rbx
	call	QWORD PTR __imp_malloc
	mov	QWORD PTR [r14+16], rax

; 103  : 		memset(mdiff_outMultiChDel, 0, lenghtInBytes);

	mov	r8, rbx
	xor	edx, edx
	mov	rcx, QWORD PTR [r14+8]
	call	QWORD PTR __imp_memset

; 104  : 		memset(mdiff_outHadamard, 0, lenghtInBytes);

	mov	r8, rbx
	xor	edx, edx
	mov	rcx, QWORD PTR [r14+16]

; 94   : 		initPointers();
; 95   : 		constructBlocks();
; 96   : 		initInternalArrays();
; 97   : 	}

	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx

; 104  : 		memset(mdiff_outHadamard, 0, lenghtInBytes);

	rex_jmp	QWORD PTR __imp_memset
?constructMCDF@ModMultiChannelDiffuser@@AEAAXH@Z ENDP	; ModMultiChannelDiffuser::constructMCDF
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T4 = 80
$T9 = 80
$T7 = 80
this$ = 80
numCh$ = 88
$T1 = 96
$T2 = 104
?dtor$0@?0??constructMCDF@ModMultiChannelDiffuser@@AEAAXH@Z@4HA PROC ; `ModMultiChannelDiffuser::constructMCDF'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 56					; 00000038H
	mov	rcx, QWORD PTR $T1[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??constructMCDF@ModMultiChannelDiffuser@@AEAAXH@Z@4HA ENDP ; `ModMultiChannelDiffuser::constructMCDF'::`1'::dtor$0
$T4 = 80
$T9 = 80
$T7 = 80
this$ = 80
numCh$ = 88
$T1 = 96
$T2 = 104
?dtor$3@?0??constructMCDF@ModMultiChannelDiffuser@@AEAAXH@Z@4HA PROC ; `ModMultiChannelDiffuser::constructMCDF'::`1'::dtor$3
	mov	rcx, QWORD PTR $T1[rdx]
	add	rcx, 8
	jmp	??1?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEAA@XZ ; std::vector<ModDelay *,std::allocator<ModDelay *> >::~vector<ModDelay *,std::allocator<ModDelay *> >
?dtor$3@?0??constructMCDF@ModMultiChannelDiffuser@@AEAAXH@Z@4HA ENDP ; `ModMultiChannelDiffuser::constructMCDF'::`1'::dtor$3
$T4 = 80
$T9 = 80
$T7 = 80
this$ = 80
numCh$ = 88
$T1 = 96
$T2 = 104
?dtor$4@?0??constructMCDF@ModMultiChannelDiffuser@@AEAAXH@Z@4HA PROC ; `ModMultiChannelDiffuser::constructMCDF'::`1'::dtor$4
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 144				; 00000090H
	mov	rcx, QWORD PTR $T2[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$4@?0??constructMCDF@ModMultiChannelDiffuser@@AEAAXH@Z@4HA ENDP ; `ModMultiChannelDiffuser::constructMCDF'::`1'::dtor$4
$T4 = 80
$T9 = 80
$T7 = 80
this$ = 80
numCh$ = 88
$T1 = 96
$T2 = 104
?dtor$1@?0??constructMCDF@ModMultiChannelDiffuser@@AEAAXH@Z@4HA PROC ; `ModMultiChannelDiffuser::constructMCDF'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 16
	mov	rcx, QWORD PTR $T7[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??constructMCDF@ModMultiChannelDiffuser@@AEAAXH@Z@4HA ENDP ; `ModMultiChannelDiffuser::constructMCDF'::`1'::dtor$1
$T4 = 80
$T9 = 80
$T7 = 80
this$ = 80
numCh$ = 88
$T1 = 96
$T2 = 104
?dtor$2@?0??constructMCDF@ModMultiChannelDiffuser@@AEAAXH@Z@4HA PROC ; `ModMultiChannelDiffuser::constructMCDF'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 32					; 00000020H
	mov	rcx, QWORD PTR $T9[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0??constructMCDF@ModMultiChannelDiffuser@@AEAAXH@Z@4HA ENDP ; `ModMultiChannelDiffuser::constructMCDF'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 80
$T9 = 80
$T7 = 80
this$ = 80
numCh$ = 88
$T1 = 96
$T2 = 104
?dtor$0@?0??constructMCDF@ModMultiChannelDiffuser@@AEAAXH@Z@4HA PROC ; `ModMultiChannelDiffuser::constructMCDF'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 56					; 00000038H
	mov	rcx, QWORD PTR $T1[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??constructMCDF@ModMultiChannelDiffuser@@AEAAXH@Z@4HA ENDP ; `ModMultiChannelDiffuser::constructMCDF'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 80
$T9 = 80
$T7 = 80
this$ = 80
numCh$ = 88
$T1 = 96
$T2 = 104
?dtor$3@?0??constructMCDF@ModMultiChannelDiffuser@@AEAAXH@Z@4HA PROC ; `ModMultiChannelDiffuser::constructMCDF'::`1'::dtor$3
	mov	rcx, QWORD PTR $T1[rdx]
	add	rcx, 8
	jmp	??1?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEAA@XZ ; std::vector<ModDelay *,std::allocator<ModDelay *> >::~vector<ModDelay *,std::allocator<ModDelay *> >
?dtor$3@?0??constructMCDF@ModMultiChannelDiffuser@@AEAAXH@Z@4HA ENDP ; `ModMultiChannelDiffuser::constructMCDF'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 80
$T9 = 80
$T7 = 80
this$ = 80
numCh$ = 88
$T1 = 96
$T2 = 104
?dtor$4@?0??constructMCDF@ModMultiChannelDiffuser@@AEAAXH@Z@4HA PROC ; `ModMultiChannelDiffuser::constructMCDF'::`1'::dtor$4
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 144				; 00000090H
	mov	rcx, QWORD PTR $T2[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$4@?0??constructMCDF@ModMultiChannelDiffuser@@AEAAXH@Z@4HA ENDP ; `ModMultiChannelDiffuser::constructMCDF'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 80
$T9 = 80
$T7 = 80
this$ = 80
numCh$ = 88
$T1 = 96
$T2 = 104
?dtor$1@?0??constructMCDF@ModMultiChannelDiffuser@@AEAAXH@Z@4HA PROC ; `ModMultiChannelDiffuser::constructMCDF'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 16
	mov	rcx, QWORD PTR $T7[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??constructMCDF@ModMultiChannelDiffuser@@AEAAXH@Z@4HA ENDP ; `ModMultiChannelDiffuser::constructMCDF'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 80
$T9 = 80
$T7 = 80
this$ = 80
numCh$ = 88
$T1 = 96
$T2 = 104
?dtor$2@?0??constructMCDF@ModMultiChannelDiffuser@@AEAAXH@Z@4HA PROC ; `ModMultiChannelDiffuser::constructMCDF'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 32					; 00000020H
	mov	rcx, QWORD PTR $T9[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0??constructMCDF@ModMultiChannelDiffuser@@AEAAXH@Z@4HA ENDP ; `ModMultiChannelDiffuser::constructMCDF'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h
;	COMDAT ?initInternalArrays@ModMultiChannelDiffuser@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?initInternalArrays@ModMultiChannelDiffuser@@AEAAXXZ PROC ; ModMultiChannelDiffuser::initInternalArrays, COMDAT

; 99   : 	void initInternalArrays() {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 100  : 		int lenghtInBytes = mdiff_numberOfChannels * sizeof(float);

	mov	eax, DWORD PTR [rcx]
	mov	rdi, rcx
	shl	eax, 2

; 101  : 		mdiff_outMultiChDel = (float*)malloc(lenghtInBytes);

	movsxd	rbx, eax
	mov	rcx, rbx
	call	QWORD PTR __imp_malloc

; 102  : 		mdiff_outHadamard = (float*)malloc(lenghtInBytes);

	mov	rcx, rbx
	mov	QWORD PTR [rdi+8], rax
	call	QWORD PTR __imp_malloc

; 103  : 		memset(mdiff_outMultiChDel, 0, lenghtInBytes);

	mov	rcx, QWORD PTR [rdi+8]
	mov	r8, rbx
	xor	edx, edx
	mov	QWORD PTR [rdi+16], rax
	call	QWORD PTR __imp_memset

; 104  : 		memset(mdiff_outHadamard, 0, lenghtInBytes);

	mov	rcx, QWORD PTR [rdi+16]
	mov	r8, rbx
	xor	edx, edx

; 105  : 	}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi

; 104  : 		memset(mdiff_outHadamard, 0, lenghtInBytes);

	rex_jmp	QWORD PTR __imp_memset
?initInternalArrays@ModMultiChannelDiffuser@@AEAAXXZ ENDP ; ModMultiChannelDiffuser::initInternalArrays
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h
;	COMDAT ?deleteInternalArrays@ModMultiChannelDiffuser@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?deleteInternalArrays@ModMultiChannelDiffuser@@AEAAXXZ PROC ; ModMultiChannelDiffuser::deleteInternalArrays, COMDAT

; 112  : 	void deleteInternalArrays() {

$LN8:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 113  : 		if (mdiff_outMultiChDel)

	mov	rcx, QWORD PTR [rcx+8]
	test	rcx, rcx
	je	SHORT $LN2@deleteInte

; 114  : 			free(mdiff_outMultiChDel);

	call	QWORD PTR __imp_free
$LN2@deleteInte:

; 115  : 		if (mdiff_outHadamard)

	mov	rcx, QWORD PTR [rbx+16]
	test	rcx, rcx
	je	SHORT $LN3@deleteInte

; 116  : 			free(mdiff_outHadamard);

	call	QWORD PTR __imp_free
$LN3@deleteInte:

; 121  : 		mdiff_outHadamard = nullptr;

	and	QWORD PTR [rbx+16], 0

; 122  : 		mdiff_outMultiChDel = nullptr;

	and	QWORD PTR [rbx+8], 0

; 117  : 		initPointers();
; 118  : 	}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?deleteInternalArrays@ModMultiChannelDiffuser@@AEAAXXZ ENDP ; ModMultiChannelDiffuser::deleteInternalArrays
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h
;	COMDAT ?initPointers@ModMultiChannelDiffuser@@AEAAXXZ
_TEXT	SEGMENT
this$ = 8
?initPointers@ModMultiChannelDiffuser@@AEAAXXZ PROC	; ModMultiChannelDiffuser::initPointers, COMDAT

; 121  : 		mdiff_outHadamard = nullptr;

	and	QWORD PTR [rcx+16], 0

; 122  : 		mdiff_outMultiChDel = nullptr;

	and	QWORD PTR [rcx+8], 0

; 123  : 	}

	ret	0
?initPointers@ModMultiChannelDiffuser@@AEAAXXZ ENDP	; ModMultiChannelDiffuser::initPointers
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\Hadamard.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h
;	COMDAT ?deleteBlocks@ModMultiChannelDiffuser@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?deleteBlocks@ModMultiChannelDiffuser@@AEAAXXZ PROC	; ModMultiChannelDiffuser::deleteBlocks, COMDAT

; 125  : 	void deleteBlocks() {

$LN32:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 126  : 		delete mdiff_MultiChDelay;

	mov	rbx, QWORD PTR [rcx+24]
	mov	rdi, rcx
	test	rbx, rbx
	je	SHORT $LN10@deleteBloc
	mov	rcx, rbx
	call	??1ModMultiChannelDelay@@QEAA@XZ	; ModMultiChannelDelay::~ModMultiChannelDelay
	mov	edx, 56					; 00000038H
	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
$LN10@deleteBloc:

; 127  : 		delete mdiff_Hadamard;

	mov	rbx, QWORD PTR [rdi+32]
	test	rbx, rbx
	je	SHORT $LN13@deleteBloc
; File E:\FoxSuite\shimmer\include\Hadamard.h

; 29   : 		if (had_matrix) {

	mov	rcx, QWORD PTR [rbx+8]
	test	rcx, rcx
	je	SHORT $LN21@deleteBloc

; 30   : 			for (int i = 0; i < had_numberOfChannels; i++) {

	xor	ebp, ebp
	cmp	DWORD PTR [rbx], ebp
	jle	SHORT $LN19@deleteBloc
	xor	esi, esi
$LL20@deleteBloc:

; 31   : 				delete[] had_matrix[i];

	mov	rcx, QWORD PTR [rbx+8]
	mov	rcx, QWORD PTR [rcx+rsi]
	call	??_V@YAXPEAX@Z				; operator delete[]
	inc	ebp
	lea	rsi, QWORD PTR [rsi+8]
	cmp	ebp, DWORD PTR [rbx]
	jl	SHORT $LL20@deleteBloc
	mov	rcx, QWORD PTR [rbx+8]
$LN19@deleteBloc:

; 32   : 			}
; 33   : 			delete[] had_matrix;

	call	??_V@YAXPEAX@Z				; operator delete[]
$LN21@deleteBloc:

; 34   : 		}
; 35   : 		had_matrix = nullptr;

	and	QWORD PTR [rbx+8], 0
	mov	edx, 16
	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
$LN13@deleteBloc:
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h

; 128  : 		delete mdiff_Polarity;

	mov	rbx, QWORD PTR [rdi+40]
	test	rbx, rbx
	je	SHORT $LN24@deleteBloc
	mov	rcx, rbx
	call	??1FlipPolarity@@QEAA@XZ		; FlipPolarity::~FlipPolarity
	mov	edx, 32					; 00000020H
	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
$LN24@deleteBloc:

; 129  : 	}

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?deleteBlocks@ModMultiChannelDiffuser@@AEAAXXZ ENDP	; ModMultiChannelDiffuser::deleteBlocks
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h
;	COMDAT ?constructBlocks@ModMultiChannelDiffuser@@AEAAXXZ
_TEXT	SEGMENT
$T4 = 80
$T9 = 80
$T7 = 80
this$ = 80
$T1 = 88
$T2 = 96
?constructBlocks@ModMultiChannelDiffuser@@AEAAXXZ PROC	; ModMultiChannelDiffuser::constructBlocks, COMDAT

; 131  : 	void constructBlocks() {

$LN55:
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 32					; 00000020H
	mov	r14, rcx

; 132  : 		mdiff_MultiChDelay = new ModMultiChannelDelay(mdiff_numberOfChannels);

	mov	ecx, 56					; 00000038H
	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax
	mov	QWORD PTR $T1[rsp], rax
	mov	edx, DWORD PTR [r14]
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 31   : 	ModMultiChannelDelay(int numCh) {

	lea	rsi, QWORD PTR [rax+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	ebx, ebx
	mov	QWORD PTR [rsi], rbx
	mov	QWORD PTR [rsi+8], rbx
	mov	QWORD PTR [rsi+16], rbx
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 163  : 		mdel_numberOfChannels = numCh;

	mov	DWORD PTR [rax], edx

; 164  : 		mdel_minDelayMs = 0.0;

	mov	QWORD PTR [rax+32], rbx

; 158  : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	mov	ebp, ebx
	test	edx, edx
	jle	SHORT $LN25@constructB
$LL26@constructB:

; 159  : 			mdel_DelayLines.push_back(new ModDelay);

	mov	ecx, 144				; 00000090H
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T2[rsp], rax
	mov	rcx, rax
	call	??0ModDelay@@QEAA@XZ			; ModDelay::ModDelay
	npad	1
	mov	QWORD PTR $T4[rsp], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 743  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rsi+8]
	cmp	rdx, QWORD PTR [rsi+16]
	je	SHORT $LN34@constructB

; 726  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	QWORD PTR [rdx], rax

; 727  :         _Orphan_range(_Mylast, _Mylast);
; 728  :         _Ty& _Result = *_Mylast;
; 729  :         ++_Mylast;

	add	QWORD PTR [rsi+8], 8

; 744  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN24@constructB
$LN34@constructB:

; 745  :         }
; 746  : 
; 747  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T4[rsp]
	mov	rcx, rsi
	call	??$_Emplace_reallocate@PEAVModDelay@@@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEAAPEAPEAVModDelay@@QEAPEAV2@$$QEAPEAV2@@Z ; std::vector<ModDelay *,std::allocator<ModDelay *> >::_Emplace_reallocate<ModDelay *>
$LN24@constructB:
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 158  : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	inc	ebp
	cmp	ebp, DWORD PTR [rdi]
	jl	SHORT $LL26@constructB
$LN25@constructB:

; 98   : 		mdel_modValmsec = modVal;

	mov	edx, 1106247680				; 41f00000H
	mov	DWORD PTR [rdi+48], edx

; 99   : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	cmp	DWORD PTR [rdi], ebx
	jle	SHORT $LN40@constructB
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1563 :         auto& _My_data = _Mypair._Myval2;

	mov	rcx, rbx
$LL41@constructB:

; 1564 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1565 :         _STL_VERIFY(
; 1566 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1567 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1568 : 
; 1569 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rsi]
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 100  : 			mdel_DelayLines[i]->setDeltaDelayValue(modVal);

	mov	rax, QWORD PTR [rcx+rax]
	mov	DWORD PTR [rax+124], edx

; 99   : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	inc	ebx
	lea	rcx, QWORD PTR [rcx+8]
	cmp	ebx, DWORD PTR [rdi]
	jl	SHORT $LL41@constructB
$LN40@constructB:
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h

; 132  : 		mdiff_MultiChDelay = new ModMultiChannelDelay(mdiff_numberOfChannels);

	mov	QWORD PTR [r14+24], rdi

; 133  : 		mdiff_Hadamard = new Hadamard(mdiff_numberOfChannels);

	mov	ecx, 16
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T7[rsp], rax
	mov	edx, DWORD PTR [r14]
	mov	rcx, rax
	call	??0Hadamard@@QEAA@H@Z			; Hadamard::Hadamard
	npad	1
	mov	QWORD PTR [r14+32], rax

; 134  : 		mdiff_Polarity = new FlipPolarity(mdiff_numberOfChannels);

	mov	ecx, 32					; 00000020H
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T9[rsp], rax
	mov	edx, DWORD PTR [r14]
	mov	rcx, rax
	call	??0FlipPolarity@@QEAA@H@Z		; FlipPolarity::FlipPolarity
	npad	1
	mov	QWORD PTR [r14+40], rax

; 135  : 	}

	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
?constructBlocks@ModMultiChannelDiffuser@@AEAAXXZ ENDP	; ModMultiChannelDiffuser::constructBlocks
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T4 = 80
$T9 = 80
$T7 = 80
this$ = 80
$T1 = 88
$T2 = 96
?dtor$0@?0??constructBlocks@ModMultiChannelDiffuser@@AEAAXXZ@4HA PROC ; `ModMultiChannelDiffuser::constructBlocks'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 56					; 00000038H
	mov	rcx, QWORD PTR $T1[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??constructBlocks@ModMultiChannelDiffuser@@AEAAXXZ@4HA ENDP ; `ModMultiChannelDiffuser::constructBlocks'::`1'::dtor$0
$T4 = 80
$T9 = 80
$T7 = 80
this$ = 80
$T1 = 88
$T2 = 96
?dtor$3@?0??constructBlocks@ModMultiChannelDiffuser@@AEAAXXZ@4HA PROC ; `ModMultiChannelDiffuser::constructBlocks'::`1'::dtor$3
	mov	rcx, QWORD PTR $T1[rdx]
	add	rcx, 8
	jmp	??1?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEAA@XZ ; std::vector<ModDelay *,std::allocator<ModDelay *> >::~vector<ModDelay *,std::allocator<ModDelay *> >
?dtor$3@?0??constructBlocks@ModMultiChannelDiffuser@@AEAAXXZ@4HA ENDP ; `ModMultiChannelDiffuser::constructBlocks'::`1'::dtor$3
$T4 = 80
$T9 = 80
$T7 = 80
this$ = 80
$T1 = 88
$T2 = 96
?dtor$4@?0??constructBlocks@ModMultiChannelDiffuser@@AEAAXXZ@4HA PROC ; `ModMultiChannelDiffuser::constructBlocks'::`1'::dtor$4
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 144				; 00000090H
	mov	rcx, QWORD PTR $T2[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$4@?0??constructBlocks@ModMultiChannelDiffuser@@AEAAXXZ@4HA ENDP ; `ModMultiChannelDiffuser::constructBlocks'::`1'::dtor$4
$T4 = 80
$T9 = 80
$T7 = 80
this$ = 80
$T1 = 88
$T2 = 96
?dtor$1@?0??constructBlocks@ModMultiChannelDiffuser@@AEAAXXZ@4HA PROC ; `ModMultiChannelDiffuser::constructBlocks'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 16
	mov	rcx, QWORD PTR $T7[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??constructBlocks@ModMultiChannelDiffuser@@AEAAXXZ@4HA ENDP ; `ModMultiChannelDiffuser::constructBlocks'::`1'::dtor$1
$T4 = 80
$T9 = 80
$T7 = 80
this$ = 80
$T1 = 88
$T2 = 96
?dtor$2@?0??constructBlocks@ModMultiChannelDiffuser@@AEAAXXZ@4HA PROC ; `ModMultiChannelDiffuser::constructBlocks'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 32					; 00000020H
	mov	rcx, QWORD PTR $T9[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0??constructBlocks@ModMultiChannelDiffuser@@AEAAXXZ@4HA ENDP ; `ModMultiChannelDiffuser::constructBlocks'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 80
$T9 = 80
$T7 = 80
this$ = 80
$T1 = 88
$T2 = 96
?dtor$0@?0??constructBlocks@ModMultiChannelDiffuser@@AEAAXXZ@4HA PROC ; `ModMultiChannelDiffuser::constructBlocks'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 56					; 00000038H
	mov	rcx, QWORD PTR $T1[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??constructBlocks@ModMultiChannelDiffuser@@AEAAXXZ@4HA ENDP ; `ModMultiChannelDiffuser::constructBlocks'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 80
$T9 = 80
$T7 = 80
this$ = 80
$T1 = 88
$T2 = 96
?dtor$3@?0??constructBlocks@ModMultiChannelDiffuser@@AEAAXXZ@4HA PROC ; `ModMultiChannelDiffuser::constructBlocks'::`1'::dtor$3
	mov	rcx, QWORD PTR $T1[rdx]
	add	rcx, 8
	jmp	??1?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEAA@XZ ; std::vector<ModDelay *,std::allocator<ModDelay *> >::~vector<ModDelay *,std::allocator<ModDelay *> >
?dtor$3@?0??constructBlocks@ModMultiChannelDiffuser@@AEAAXXZ@4HA ENDP ; `ModMultiChannelDiffuser::constructBlocks'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 80
$T9 = 80
$T7 = 80
this$ = 80
$T1 = 88
$T2 = 96
?dtor$4@?0??constructBlocks@ModMultiChannelDiffuser@@AEAAXXZ@4HA PROC ; `ModMultiChannelDiffuser::constructBlocks'::`1'::dtor$4
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 144				; 00000090H
	mov	rcx, QWORD PTR $T2[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$4@?0??constructBlocks@ModMultiChannelDiffuser@@AEAAXXZ@4HA ENDP ; `ModMultiChannelDiffuser::constructBlocks'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 80
$T9 = 80
$T7 = 80
this$ = 80
$T1 = 88
$T2 = 96
?dtor$1@?0??constructBlocks@ModMultiChannelDiffuser@@AEAAXXZ@4HA PROC ; `ModMultiChannelDiffuser::constructBlocks'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 16
	mov	rcx, QWORD PTR $T7[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??constructBlocks@ModMultiChannelDiffuser@@AEAAXXZ@4HA ENDP ; `ModMultiChannelDiffuser::constructBlocks'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 80
$T9 = 80
$T7 = 80
this$ = 80
$T1 = 88
$T2 = 96
?dtor$2@?0??constructBlocks@ModMultiChannelDiffuser@@AEAAXXZ@4HA PROC ; `ModMultiChannelDiffuser::constructBlocks'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 32					; 00000020H
	mov	rcx, QWORD PTR $T9[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0??constructBlocks@ModMultiChannelDiffuser@@AEAAXXZ@4HA ENDP ; `ModMultiChannelDiffuser::constructBlocks'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT ??_GModMultiChannelDelay@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$dead$ = 56
??_GModMultiChannelDelay@@QEAAPEAXI@Z PROC		; ModMultiChannelDelay::`scalar deleting destructor', COMDAT
$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	call	??1ModMultiChannelDelay@@QEAA@XZ	; ModMultiChannelDelay::~ModMultiChannelDelay
	mov	edx, 56					; 00000038H
	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??_GModMultiChannelDelay@@QEAAPEAXI@Z ENDP		; ModMultiChannelDelay::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\include\Householder.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\include\Householder.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
;	COMDAT ??0ModMultiChannelFeedback@@QEAA@H@Z
_TEXT	SEGMENT
this$ = 64
numCH$ = 72
$T5 = 80
$T1 = 80
$T3 = 88
??0ModMultiChannelFeedback@@QEAA@H@Z PROC		; ModMultiChannelFeedback::ModMultiChannelFeedback, COMDAT

; 31   : 	ModMultiChannelFeedback(int numCH) {

$LN42:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 32					; 00000020H
	mov	ebx, edx
	mov	r14, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	esi, esi
	mov	QWORD PTR [rcx+40], rsi
	mov	QWORD PTR [rcx+48], rsi
	mov	QWORD PTR [rcx+56], rsi
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 168  : 		mcf_Householder = new Householder(numCh);

	lea	ecx, QWORD PTR [rsi+8]
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T1[rsp], rax
	movd	xmm0, ebx
; File E:\FoxSuite\shimmer\include\Householder.h

; 19   : 		hou_multiplier = -2.0 / hou_numberOfChannels;

	cvtdq2pd xmm0, xmm0
	movsd	xmm1, QWORD PTR __real@c000000000000000
	divsd	xmm1, xmm0
	cvtpd2ps xmm2, xmm1
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 168  : 		mcf_Householder = new Householder(numCh);

	mov	QWORD PTR [r14+32], rax

; 169  : 		mcf_numberOfChannels = numCh;

	mov	DWORD PTR [r14], ebx
; File E:\FoxSuite\shimmer\include\Householder.h

; 18   : 		hou_numberOfChannels = numCh;

	mov	DWORD PTR [rax], ebx

; 19   : 		hou_multiplier = -2.0 / hou_numberOfChannels;

	movss	DWORD PTR [rax+4], xmm2
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 171  : 		deleteDelayLines();

	mov	rcx, r14
	call	?deleteDelayLines@ModMultiChannelFeedback@@AEAAXXZ ; ModMultiChannelFeedback::deleteDelayLines

; 183  : 		for (int i = 0; i < mcf_numberOfChannels; i++)

	cmp	DWORD PTR [r14], esi
	jle	SHORT $LN23@ModMultiCh
$LL24@ModMultiCh:

; 184  : 			mcf_DelayLines.push_back(new ModDelay);

	mov	ecx, 144				; 00000090H
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T3[rsp], rax
	mov	rcx, rax
	call	??0ModDelay@@QEAA@XZ			; ModDelay::ModDelay
	npad	1
	mov	QWORD PTR $T5[rsp], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 743  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [r14+48]
	cmp	rdx, QWORD PTR [r14+56]
	je	SHORT $LN32@ModMultiCh

; 726  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	QWORD PTR [rdx], rax

; 727  :         _Orphan_range(_Mylast, _Mylast);
; 728  :         _Ty& _Result = *_Mylast;
; 729  :         ++_Mylast;

	add	QWORD PTR [r14+48], 8

; 744  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN22@ModMultiCh
$LN32@ModMultiCh:

; 745  :         }
; 746  : 
; 747  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T5[rsp]
	lea	rcx, QWORD PTR [r14+40]
	call	??$_Emplace_reallocate@PEAVModDelay@@@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEAAPEAPEAVModDelay@@QEAPEAV2@$$QEAPEAV2@@Z ; std::vector<ModDelay *,std::allocator<ModDelay *> >::_Emplace_reallocate<ModDelay *>
$LN22@ModMultiCh:
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 183  : 		for (int i = 0; i < mcf_numberOfChannels; i++)

	inc	esi
	cmp	esi, DWORD PTR [r14]
	jl	SHORT $LL24@ModMultiCh
$LN23@ModMultiCh:

; 32   : 		constructMCF(numCH);
; 33   : 	}

	mov	rax, r14
	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
??0ModMultiChannelFeedback@@QEAA@H@Z ENDP		; ModMultiChannelFeedback::ModMultiChannelFeedback
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
this$ = 64
numCH$ = 72
$T5 = 80
$T1 = 80
$T3 = 88
?dtor$0@?0???0ModMultiChannelFeedback@@QEAA@H@Z@4HA PROC ; `ModMultiChannelFeedback::ModMultiChannelFeedback'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 40					; 00000028H
	jmp	??1?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEAA@XZ ; std::vector<ModDelay *,std::allocator<ModDelay *> >::~vector<ModDelay *,std::allocator<ModDelay *> >
?dtor$0@?0???0ModMultiChannelFeedback@@QEAA@H@Z@4HA ENDP ; `ModMultiChannelFeedback::ModMultiChannelFeedback'::`1'::dtor$0
this$ = 64
numCH$ = 72
$T5 = 80
$T1 = 80
$T3 = 88
?dtor$2@?0???0ModMultiChannelFeedback@@QEAA@H@Z@4HA PROC ; `ModMultiChannelFeedback::ModMultiChannelFeedback'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 144				; 00000090H
	mov	rcx, QWORD PTR $T3[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0???0ModMultiChannelFeedback@@QEAA@H@Z@4HA ENDP ; `ModMultiChannelFeedback::ModMultiChannelFeedback'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
this$ = 64
numCH$ = 72
$T5 = 80
$T1 = 80
$T3 = 88
?dtor$0@?0???0ModMultiChannelFeedback@@QEAA@H@Z@4HA PROC ; `ModMultiChannelFeedback::ModMultiChannelFeedback'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 40					; 00000028H
	jmp	??1?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEAA@XZ ; std::vector<ModDelay *,std::allocator<ModDelay *> >::~vector<ModDelay *,std::allocator<ModDelay *> >
?dtor$0@?0???0ModMultiChannelFeedback@@QEAA@H@Z@4HA ENDP ; `ModMultiChannelFeedback::ModMultiChannelFeedback'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
this$ = 64
numCH$ = 72
$T5 = 80
$T1 = 80
$T3 = 88
?dtor$2@?0???0ModMultiChannelFeedback@@QEAA@H@Z@4HA PROC ; `ModMultiChannelFeedback::ModMultiChannelFeedback'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 144				; 00000090H
	mov	rcx, QWORD PTR $T3[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0???0ModMultiChannelFeedback@@QEAA@H@Z@4HA ENDP ; `ModMultiChannelFeedback::ModMultiChannelFeedback'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
;	COMDAT ??1ModMultiChannelFeedback@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1ModMultiChannelFeedback@@QEAA@XZ PROC		; ModMultiChannelFeedback::~ModMultiChannelFeedback, COMDAT

; 35   : 	~ModMultiChannelFeedback() {

$LN31:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 36   : 		deleteDelayLines();

	call	?deleteDelayLines@ModMultiChannelFeedback@@AEAAXXZ ; ModMultiChannelFeedback::deleteDelayLines

; 37   : 		delete mcf_Householder;

	mov	rcx, QWORD PTR [rbx+32]
	mov	edx, 8
	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rbx+40]
	test	rcx, rcx
	je	SHORT $LN6@ModMultiCh

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+56]
	sub	rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN22@ModMultiCh

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN19@ModMultiCh

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN22@ModMultiCh:

; 264  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

	and	QWORD PTR [rbx+40], 0

; 1768 :             _Mylast  = nullptr;

	and	QWORD PTR [rbx+48], 0

; 1769 :             _Myend   = nullptr;

	and	QWORD PTR [rbx+56], 0
$LN6@ModMultiCh:
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 38   : 	}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN19@ModMultiCh:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN28@ModMultiCh:
??1ModMultiChannelFeedback@@QEAA@XZ ENDP		; ModMultiChannelFeedback::~ModMultiChannelFeedback
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\include\src\CombFilter.cpp
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\include\src\CombFilter.cpp
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\include\src\CombFilter.cpp
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\include\src\CombFilter.cpp
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
;	COMDAT ?setDecayInSeconds@ModMultiChannelFeedback@@QEAAXM@Z
_TEXT	SEGMENT
this$ = 64
decay$ = 72
?setDecayInSeconds@ModMultiChannelFeedback@@QEAAXM@Z PROC ; ModMultiChannelFeedback::setDecayInSeconds, COMDAT

; 50   : 	void setDecayInSeconds(float decay) {

$LN18:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rsi
	mov	QWORD PTR [rax+24], rdi
	push	r14
	sub	rsp, 48					; 00000030H
	movaps	XMMWORD PTR [rax-24], xmm6

; 52   : 		for (int i = 0; i < mcf_numberOfChannels; i++)

	xor	ebx, ebx
	movaps	xmm6, xmm1
	mov	rdi, rcx
	movss	DWORD PTR [rcx+20], xmm6
	cmp	DWORD PTR [rcx], ebx
	jle	SHORT $LN3@setDecayIn
	mov	r14d, ebx
$LL4@setDecayIn:
; File E:\FoxSuite\shimmer\include\src\CombFilter.cpp

; 24   : 	float feedbackModule = (cf_decayInSeconds > 0.0) ? pow(10, -3.0 * dly_delayInmsec / (cf_decayInSeconds * 1000.0)) : 0.0;

	comiss	xmm6, DWORD PTR __real@00000000
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 53   : 			mcf_DelayLines[i]->setFeedbackFromDecay(decay);

	mov	rax, QWORD PTR [rdi+40]
	mov	rsi, QWORD PTR [r14+rax]
; File E:\FoxSuite\shimmer\include\src\CombFilter.cpp

; 21   : 	cf_decayInSeconds = decayInSeconds;

	movss	DWORD PTR [rsi+76], xmm6

; 24   : 	float feedbackModule = (cf_decayInSeconds > 0.0) ? pow(10, -3.0 * dly_delayInmsec / (cf_decayInSeconds * 1000.0)) : 0.0;

	xorps	xmm0, xmm0
	jbe	SHORT $LN11@setDecayIn
	movsd	xmm1, QWORD PTR __real@bf689374bc6a7efa
	movss	xmm2, DWORD PTR [rsi+24]
	cvtss2sd xmm0, xmm6
	cvtps2pd xmm2, xmm2
	divsd	xmm1, xmm0
	movsd	xmm0, QWORD PTR __real@4024000000000000
	mulsd	xmm1, xmm2
	call	QWORD PTR __imp_pow
$LN11@setDecayIn:
	movd	xmm1, DWORD PTR [rsi+80]
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 52   : 		for (int i = 0; i < mcf_numberOfChannels; i++)

	inc	ebx
; File E:\FoxSuite\shimmer\include\src\CombFilter.cpp

; 27   : 	cf_feedbackGain = cf_feedbackGainSign * feedbackModule;

	cvtdq2ps xmm1, xmm1
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 52   : 		for (int i = 0; i < mcf_numberOfChannels; i++)

	add	r14, 8
; File E:\FoxSuite\shimmer\include\src\CombFilter.cpp

; 24   : 	float feedbackModule = (cf_decayInSeconds > 0.0) ? pow(10, -3.0 * dly_delayInmsec / (cf_decayInSeconds * 1000.0)) : 0.0;

	cvtsd2ss xmm0, xmm0

; 27   : 	cf_feedbackGain = cf_feedbackGainSign * feedbackModule;

	mulss	xmm1, xmm0
	movss	DWORD PTR [rsi+72], xmm1
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 52   : 		for (int i = 0; i < mcf_numberOfChannels; i++)

	cmp	ebx, DWORD PTR [rdi]
	jl	SHORT $LL4@setDecayIn
$LN3@setDecayIn:

; 54   : 	}

	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	mov	rdi, QWORD PTR [rsp+80]
	movaps	xmm6, XMMWORD PTR [rsp+32]
	add	rsp, 48					; 00000030H
	pop	r14
	ret	0
?setDecayInSeconds@ModMultiChannelFeedback@@QEAAXM@Z ENDP ; ModMultiChannelFeedback::setDecayInSeconds
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\include\src\Delay.cpp
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
;	COMDAT ?init@ModMultiChannelFeedback@@QEAAXMH@Z
_TEXT	SEGMENT
this$ = 48
delayMs$dead$ = 56
sampleRate$ = 64
?init@ModMultiChannelFeedback@@QEAAXMH@Z PROC		; ModMultiChannelFeedback::init, COMDAT

; 56   : 	void init(float delayMs, int sampleRate) {

$LN18:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 59   : 		for (int i = 0; i < mcf_numberOfChannels; i++) {

	xor	edi, edi
	mov	DWORD PTR [rcx+16], 1157234688		; 44fa0000H
	mov	ebp, r8d
	mov	rbx, rcx
	mov	DWORD PTR [rcx+4], r8d
	cmp	DWORD PTR [rcx], edi
	jle	SHORT $LN3@init
	mov	esi, edi
$LL4@init:

; 60   : 			mcf_DelayLines[i]->init(delayMs, sampleRate);

	mov	rcx, QWORD PTR [rbx+40]
	mov	r8d, ebp
	movss	xmm1, DWORD PTR __real@44fa0000
	mov	rcx, QWORD PTR [rsi+rcx]
	call	?init@ModDelay@@QEAAXMHW4OscillatorType@@@Z ; ModDelay::init

; 61   : 			mcf_DelayLines[i]->setMakeUpGaindB(_DELAY_MAKEUP_GAIN_VALUE);

	mov	rax, QWORD PTR [rbx+40]
	mov	rcx, QWORD PTR [rsi+rax]
; File E:\FoxSuite\shimmer\include\src\Delay.cpp

; 135  : 	dly_makeUpGaindB = gaindB;

	mov	DWORD PTR [rcx+64], 1069547520		; 3fc00000H

; 136  : 
; 137  : 	// update parameters
; 138  : 	updateParameters();

	call	?updateParameters@Delay@@AEAAXXZ	; Delay::updateParameters
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 59   : 		for (int i = 0; i < mcf_numberOfChannels; i++) {

	inc	edi
	lea	rsi, QWORD PTR [rsi+8]
	cmp	edi, DWORD PTR [rbx]
	jl	SHORT $LL4@init
$LN3@init:

; 62   : 		}
; 63   : 	}

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?init@ModMultiChannelFeedback@@QEAAXMH@Z ENDP		; ModMultiChannelFeedback::init
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
;	COMDAT ?setSampleRate@ModMultiChannelFeedback@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
sampleRate$ = 56
?setSampleRate@ModMultiChannelFeedback@@QEAAXH@Z PROC	; ModMultiChannelFeedback::setSampleRate, COMDAT

; 65   : 	void setSampleRate(int sampleRate) {

$LN14:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 66   : 		for (int i = 0; i < mcf_numberOfChannels; i++)

	xor	ebx, ebx
	mov	ebp, edx
	mov	rdi, rcx
	cmp	DWORD PTR [rcx], ebx
	jle	SHORT $LN3@setSampleR
	mov	esi, ebx
$LL4@setSampleR:

; 67   : 			mcf_DelayLines[i]->setSampleRate(sampleRate);

	mov	rax, QWORD PTR [rdi+40]
	mov	edx, ebp
	mov	rcx, QWORD PTR [rsi+rax]
	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+8]
	inc	ebx
	lea	rsi, QWORD PTR [rsi+8]
	cmp	ebx, DWORD PTR [rdi]
	jl	SHORT $LL4@setSampleR
$LN3@setSampleR:

; 68   : 	}

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?setSampleRate@ModMultiChannelFeedback@@QEAAXH@Z ENDP	; ModMultiChannelFeedback::setSampleRate
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
;	COMDAT ?setDelayLengths@ModMultiChannelFeedback@@QEAAXMMW4DelayDistribution@@@Z
_TEXT	SEGMENT
this$ = 48
minDelay$ = 56
maxDelay$ = 64
distr$ = 72
?setDelayLengths@ModMultiChannelFeedback@@QEAAXMMW4DelayDistribution@@@Z PROC ; ModMultiChannelFeedback::setDelayLengths, COMDAT

; 70   : 	void setDelayLengths(float minDelay, float maxDelay = 0.0, DelayDistribution distr = DelayDistribution::Exponential) {

$LN9:
	sub	rsp, 40					; 00000028H

; 71   : 		mcf_minDelayLength = minDelay;
; 72   : 		if (maxDelay != 0.0)

	ucomiss	xmm2, DWORD PTR __real@00000000
	movss	DWORD PTR [rcx+8], xmm1
	je	SHORT $LN4@setDelayLe

; 73   : 			mcf_maxDelayLength = maxDelay;

	movss	DWORD PTR [rcx+12], xmm2
$LN4@setDelayLe:

; 74   : 		mcf_delayDistribution = distr;

	mov	DWORD PTR [rcx+24], r9d

; 75   : 		switch (distr) {

	test	r9d, r9d
	je	SHORT $LN5@setDelayLe
	cmp	r9d, 1
	jne	SHORT $LN2@setDelayLe

; 82   : 			break;
; 83   : 		}
; 84   : 		}
; 85   : 	}

	add	rsp, 40					; 00000028H

; 78   : 			break;
; 79   : 		}
; 80   : 		case DelayDistribution::RandomInRange: {
; 81   : 			setRandomInRangeDelayLines();

	jmp	?setRandomInRangeDelayLines@ModMultiChannelFeedback@@AEAAXXZ ; ModMultiChannelFeedback::setRandomInRangeDelayLines
$LN5@setDelayLe:

; 76   : 		case DelayDistribution::Exponential: {
; 77   : 			setDelayExponential();

	call	?setDelayExponential@ModMultiChannelFeedback@@AEAAXXZ ; ModMultiChannelFeedback::setDelayExponential
$LN2@setDelayLe:

; 82   : 			break;
; 83   : 		}
; 84   : 		}
; 85   : 	}

	add	rsp, 40					; 00000028H
	ret	0
?setDelayLengths@ModMultiChannelFeedback@@QEAAXMMW4DelayDistribution@@@Z ENDP ; ModMultiChannelFeedback::setDelayLengths
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\include\src\LPCombFilter.cpp
; File E:\FoxSuite\shimmer\include\LowPassFilter.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
;	COMDAT ?setDampingFrequency@ModMultiChannelFeedback@@QEAAXM@Z
_TEXT	SEGMENT
this$ = 64
freq$ = 72
?setDampingFrequency@ModMultiChannelFeedback@@QEAAXM@Z PROC ; ModMultiChannelFeedback::setDampingFrequency, COMDAT

; 87   : 	void setDampingFrequency(float freq) {

$LN18:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 48					; 00000030H

; 88   : 		for (int i = 0; i < mcf_numberOfChannels; i++)

	xor	ebx, ebx
	movaps	XMMWORD PTR [rsp+32], xmm6
	movaps	xmm6, xmm1
	mov	rdi, rcx
	cmp	DWORD PTR [rcx], ebx
	jle	SHORT $LN3@setDamping
	mov	esi, ebx
$LL4@setDamping:

; 89   : 			mcf_DelayLines[i]->setCutoffFrequency(freq);

	mov	rax, QWORD PTR [rdi+40]
	mov	rdx, QWORD PTR [rsi+rax]
; File E:\FoxSuite\shimmer\include\src\LPCombFilter.cpp

; 28   : 	lpcf_feedbackLPF->setCutoffFrequency(lpcf_cutoffFreq);

	mov	rcx, QWORD PTR [rdx+88]
	movss	DWORD PTR [rdx+96], xmm6
; File E:\FoxSuite\shimmer\include\LowPassFilter.h

; 68   : 		lpf_cutoffFreq = cutoffFreq;

	movss	DWORD PTR [rcx+4], xmm6

; 69   : 
; 70   : 		// update lpf gains
; 71   : 		updateGains();

	call	?updateGains@LowPassFilter@@QEAAXXZ	; LowPassFilter::updateGains
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 88   : 		for (int i = 0; i < mcf_numberOfChannels; i++)

	inc	ebx
	lea	rsi, QWORD PTR [rsi+8]
	cmp	ebx, DWORD PTR [rdi]
	jl	SHORT $LL4@setDamping
$LN3@setDamping:

; 90   : 	}

	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	movaps	xmm6, XMMWORD PTR [rsp+32]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
?setDampingFrequency@ModMultiChannelFeedback@@QEAAXM@Z ENDP ; ModMultiChannelFeedback::setDampingFrequency
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\include\src\LPCombFilter.cpp
; File E:\FoxSuite\shimmer\include\LowPassFilter.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
;	COMDAT ?setFilterType@ModMultiChannelFeedback@@QEAAXW4LPFilterType@@@Z
_TEXT	SEGMENT
this$ = 48
type$dead$ = 56
?setFilterType@ModMultiChannelFeedback@@QEAAXW4LPFilterType@@@Z PROC ; ModMultiChannelFeedback::setFilterType, COMDAT

; 92   : 	void setFilterType(LPFilterType type) {

$LN18:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 93   : 		for (int i = 0; i < mcf_numberOfChannels; i++)

	xor	ebx, ebx
	mov	rdi, rcx
	cmp	DWORD PTR [rcx], ebx
	jle	SHORT $LN3@setFilterT
	mov	esi, ebx
$LL4@setFilterT:
; File E:\FoxSuite\shimmer\include\src\LPCombFilter.cpp

; 32   : 	lpcf_feedbackLPF->setFilterType(type);

	mov	rax, QWORD PTR [rdi+40]
	mov	rdx, QWORD PTR [rsi+rax]
	mov	rcx, QWORD PTR [rdx+88]
; File E:\FoxSuite\shimmer\include\LowPassFilter.h

; 76   : 		lpf_type = type;

	mov	DWORD PTR [rcx], 6

; 77   : 
; 78   : 		// update lpf gains
; 79   : 		updateGains();

	call	?updateGains@LowPassFilter@@QEAAXXZ	; LowPassFilter::updateGains
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 93   : 		for (int i = 0; i < mcf_numberOfChannels; i++)

	inc	ebx
	lea	rsi, QWORD PTR [rsi+8]
	cmp	ebx, DWORD PTR [rdi]
	jl	SHORT $LL4@setFilterT
$LN3@setFilterT:

; 94   : 			mcf_DelayLines[i]->setFilterType(type);
; 95   : 	}

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?setFilterType@ModMultiChannelFeedback@@QEAAXW4LPFilterType@@@Z ENDP ; ModMultiChannelFeedback::setFilterType
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
;	COMDAT ?setModValue@ModMultiChannelFeedback@@QEAAXM@Z
_TEXT	SEGMENT
this$ = 8
val$dead$ = 16
?setModValue@ModMultiChannelFeedback@@QEAAXM@Z PROC	; ModMultiChannelFeedback::setModValue, COMDAT

; 98   : 		mcf_modValmsec = val;
; 99   : 		for (int i = 0; i < mcf_numberOfChannels; i++)

	xor	edx, edx
	mov	r10d, 1082130432			; 40800000H
	mov	r8, rcx
	mov	DWORD PTR [rcx+64], r10d
	cmp	DWORD PTR [rcx], edx
	jle	SHORT $LN3@setModValu
	mov	r9d, edx
$LL4@setModValu:

; 100  : 			mcf_DelayLines[i]->setDeltaDelayValue(val);

	mov	rax, QWORD PTR [r8+40]
	inc	edx
	mov	rcx, QWORD PTR [rax+r9]
	lea	r9, QWORD PTR [r9+8]
	mov	DWORD PTR [rcx+124], r10d
	cmp	edx, DWORD PTR [r8]
	jl	SHORT $LL4@setModValu
$LN3@setModValu:

; 101  : 	}

	ret	0
?setModValue@ModMultiChannelFeedback@@QEAAXM@Z ENDP	; ModMultiChannelFeedback::setModValue
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
;	COMDAT ?setModDepth@ModMultiChannelFeedback@@QEAAXM@Z
_TEXT	SEGMENT
this$ = 8
depth$ = 16
?setModDepth@ModMultiChannelFeedback@@QEAAXM@Z PROC	; ModMultiChannelFeedback::setModDepth, COMDAT

; 103  : 		for (int i = 0; i < mcf_numberOfChannels; i++)

	xor	edx, edx
	mov	r8, rcx
	cmp	DWORD PTR [rcx], edx
	jle	SHORT $LN3@setModDept
	mov	r9d, edx
$LL4@setModDept:

; 104  : 			mcf_DelayLines[i]->setDeltaDelayValue(depth* mcf_modValmsec);

	mov	rax, QWORD PTR [r8+40]
	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR [r8+64]
	inc	edx
	mov	rcx, QWORD PTR [r9+rax]
	lea	r9, QWORD PTR [r9+8]
	movss	DWORD PTR [rcx+124], xmm0
	cmp	edx, DWORD PTR [r8]
	jl	SHORT $LL4@setModDept
$LN3@setModDept:

; 105  : 	}

	ret	0
?setModDepth@ModMultiChannelFeedback@@QEAAXM@Z ENDP	; ModMultiChannelFeedback::setModDepth
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\include\LFO.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File E:\FoxSuite\shimmer\include\LFO.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
;	COMDAT ?setModRate@ModMultiChannelFeedback@@QEAAXM@Z
_TEXT	SEGMENT
this$ = 8
freq$ = 16
?setModRate@ModMultiChannelFeedback@@QEAAXM@Z PROC	; ModMultiChannelFeedback::setModRate, COMDAT

; 108  : 		for (int i = 0; i < mcf_numberOfChannels; i++)

	xor	edx, edx
	movaps	xmm3, xmm1
	mov	r8, rcx
	cmp	DWORD PTR [rcx], edx
	jle	SHORT $LN3@setModRate
	movaps	xmm2, xmm1
	mov	r9d, edx
	mulss	xmm2, DWORD PTR __real@45800000
$LL4@setModRate:

; 109  : 			mcf_DelayLines[i]->setModRate(freq);

	mov	rax, QWORD PTR [r8+40]
; File E:\FoxSuite\shimmer\include\LFO.h

; 122  : 		lfo_inc = WAVETABLE_SIZE * lfo_frequency / (float)lfo_sampleRate;

	movaps	xmm1, xmm2
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 108  : 		for (int i = 0; i < mcf_numberOfChannels; i++)

	inc	edx

; 109  : 			mcf_DelayLines[i]->setModRate(freq);

	mov	rcx, QWORD PTR [r9+rax]
	lea	r9, QWORD PTR [r9+8]
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 90   : 		mdly_LFO->setLFOfrequency(mdly_rate);

	mov	rax, QWORD PTR [rcx+104]
	movss	DWORD PTR [rcx+136], xmm3
	movd	xmm0, DWORD PTR [rax+4]
; File E:\FoxSuite\shimmer\include\LFO.h

; 122  : 		lfo_inc = WAVETABLE_SIZE * lfo_frequency / (float)lfo_sampleRate;

	cvtdq2ps xmm0, xmm0

; 71   : 		lfo_frequency = frequency;

	movss	DWORD PTR [rax], xmm3

; 122  : 		lfo_inc = WAVETABLE_SIZE * lfo_frequency / (float)lfo_sampleRate;

	divss	xmm1, xmm0
	movss	DWORD PTR [rax+20], xmm1
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 108  : 		for (int i = 0; i < mcf_numberOfChannels; i++)

	cmp	edx, DWORD PTR [r8]
	jl	SHORT $LL4@setModRate
$LN3@setModRate:

; 110  : 	}

	ret	0
?setModRate@ModMultiChannelFeedback@@QEAAXM@Z ENDP	; ModMultiChannelFeedback::setModRate
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File E:\FoxSuite\shimmer\include\LFO.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
;	COMDAT ?setOscillatorType@ModMultiChannelFeedback@@QEAAXW4OscillatorType@@@Z
_TEXT	SEGMENT
this$ = 48
type$dead$ = 56
?setOscillatorType@ModMultiChannelFeedback@@QEAAXW4OscillatorType@@@Z PROC ; ModMultiChannelFeedback::setOscillatorType, COMDAT

; 112  : 	void setOscillatorType(OscillatorType type) {

$LN20:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 113  : 		for (int i = 0; i < mcf_numberOfChannels; i++)

	xor	ebx, ebx
	mov	rdi, rcx
	cmp	DWORD PTR [rcx], ebx
	jle	SHORT $LN3@setOscilla
	mov	esi, ebx
$LL4@setOscilla:

; 114  : 			mcf_DelayLines[i]->setLFOWaveform(type);

	mov	rax, QWORD PTR [rdi+40]
	mov	rdx, QWORD PTR [rsi+rax]
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 95   : 		mdly_LFO->setLFOWaveform(wave);

	mov	rcx, QWORD PTR [rdx+104]
	mov	DWORD PTR [rdx+116], 1
; File E:\FoxSuite\shimmer\include\LFO.h

; 132  : 		lfo_table.clear();

	mov	rax, QWORD PTR [rcx+24]
	mov	QWORD PTR [rcx+32], rax

; 76   : 		lfo_waveform = waveform;

	mov	DWORD PTR [rcx+12], 1

; 77   : 		clearTable();
; 78   : 		createTable();

	call	?createTable@LFO@@AEAAXXZ		; LFO::createTable
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 113  : 		for (int i = 0; i < mcf_numberOfChannels; i++)

	inc	ebx
	lea	rsi, QWORD PTR [rsi+8]
	cmp	ebx, DWORD PTR [rdi]
	jl	SHORT $LL4@setOscilla
$LN3@setOscilla:

; 115  : 	}

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?setOscillatorType@ModMultiChannelFeedback@@QEAAXW4OscillatorType@@@Z ENDP ; ModMultiChannelFeedback::setOscillatorType
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
;	COMDAT ?setOscillatorIsUnipolar@ModMultiChannelFeedback@@QEAAX_N@Z
_TEXT	SEGMENT
this$ = 8
isUnipolar$dead$ = 16
?setOscillatorIsUnipolar@ModMultiChannelFeedback@@QEAAX_N@Z PROC ; ModMultiChannelFeedback::setOscillatorIsUnipolar, COMDAT

; 118  : 		for (int i = 0; i < mcf_numberOfChannels; i++)

	xor	r9d, r9d
	mov	r8d, r9d
	cmp	DWORD PTR [rcx], r9d
	jle	SHORT $LN3@setOscilla
	mov	edx, r9d
$LL4@setOscilla:

; 119  : 			mcf_DelayLines[i]->setLFOUnipolar(isUnipolar);

	mov	rax, QWORD PTR [rcx+40]
	inc	r8d
	mov	rax, QWORD PTR [rdx+rax]
	lea	rdx, QWORD PTR [rdx+8]
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 99   : 		mdly_isUnipolar = isUnipolar;

	mov	BYTE PTR [rax+112], r9b

; 100  : 		mdly_LFO->setLFOunipolar(isUnipolar);

	mov	rax, QWORD PTR [rax+104]
	mov	BYTE PTR [rax+48], r9b
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 118  : 		for (int i = 0; i < mcf_numberOfChannels; i++)

	cmp	r8d, DWORD PTR [rcx]
	jl	SHORT $LL4@setOscilla
$LN3@setOscilla:

; 120  : 	}

	ret	0
?setOscillatorIsUnipolar@ModMultiChannelFeedback@@QEAAX_N@Z ENDP ; ModMultiChannelFeedback::setOscillatorIsUnipolar
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\include\src\Delay.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\include\src\LPCombFilter.cpp
; File E:\FoxSuite\shimmer\include\LowPassFilter.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\include\Householder.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\include\src\Delay.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\src\Delay.cpp
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
;	COMDAT ?processAudio@ModMultiChannelFeedback@@QEAAXPEAM0@Z
_TEXT	SEGMENT
housein$ = 32
houseout$ = 56
this$ = 144
in$ = 152
out$ = 160
?processAudio@ModMultiChannelFeedback@@QEAAXPEAM0@Z PROC ; ModMultiChannelFeedback::processAudio, COMDAT

; 136  : 	void processAudio(float* in, float* out) {

$LN146:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rsi
	mov	QWORD PTR [rax+24], rdi
	push	rbp
	push	r12
	push	r13
	push	r14
	push	r15
	mov	rbp, rsp
	sub	rsp, 96					; 00000060H
	movaps	XMMWORD PTR [rax-56], xmm6
	mov	r15, r8
	mov	r12, rdx
	mov	rbx, rcx

; 137  : 		vector<float> houseout(mcf_numberOfChannels);

	movsxd	rdx, DWORD PTR [rcx]
	lea	rcx, QWORD PTR houseout$[rbp-96]
	call	??0?$vector@MV?$allocator@M@std@@@std@@QEAA@_KAEBV?$allocator@M@1@@Z ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
	npad	1

; 138  : 		vector<float> housein(mcf_numberOfChannels);				

	movsxd	rdx, DWORD PTR [rbx]
	lea	rcx, QWORD PTR housein$[rbp-96]
	call	??0?$vector@MV?$allocator@M@std@@@std@@QEAA@_KAEBV?$allocator@M@1@@Z ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >

; 139  : 
; 140  : 		// Read value from delay line and allocate it to output
; 141  : 		for (int i = 0; i < mcf_numberOfChannels; i++) {

	xor	r13d, r13d
	mov	r14d, r13d
	mov	eax, DWORD PTR [rbx]
	xorps	xmm6, xmm6
	test	eax, eax
	jle	SHORT $LN141@processAud
	mov	edi, r13d
	mov	rsi, r15
$LL4@processAud:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

	mov	rcx, QWORD PTR [rbx+40]
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 142  : 			float newDelayInmsec = mcf_DelayLines[i]->mdly_meanDelayValue + mcf_DelayLines[i]->mdly_deltaDelayValue * mcf_DelayLines[i]->mdly_LFO->processAudio();

	mov	r10, QWORD PTR [rcx+rdi]
	mov	rcx, QWORD PTR [r10+104]
	call	?processAudio@LFO@@QEAAMXZ		; LFO::processAudio
	mulss	xmm0, DWORD PTR [r10+124]
	addss	xmm0, DWORD PTR [r10+120]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rbx+40]
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 145  : 			mcf_DelayLines[i]->LPCombFilter::setDelayInmsec(newDelayInmsec);

	mov	rcx, QWORD PTR [rdi+rax]
; File E:\FoxSuite\shimmer\include\src\Delay.cpp

; 118  : 	if (delayInmsec > dly_lineLengthInmsec)

	movss	xmm1, DWORD PTR [rcx+16]
	comiss	xmm0, xmm1
	ja	SHORT $LN25@processAud

; 119  : 		delayInmsec = dly_lineLengthInmsec;
; 120  : 	else if (delayInmsec < 0.0)

	movaps	xmm1, xmm0
	maxss	xmm1, xmm6
$LN25@processAud:

; 121  : 		delayInmsec = 0.0;
; 122  : 
; 123  : 	// Set delay line length in milliseconds
; 124  : 	dly_delayInmsec = delayInmsec;

	movss	DWORD PTR [rcx+24], xmm1

; 125  : 
; 126  : 	// Update parameters based on new delay length
; 127  : 	updateParameters();

	call	?updateParameters@Delay@@AEAAXXZ	; Delay::updateParameters
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

	mov	rcx, QWORD PTR [rbx+40]
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 148  : 			out[i] = mcf_DelayLines[i]->readFromDelayLine();

	mov	rcx, QWORD PTR [rdi+rcx]
	call	?readFromDelayLine@Delay@@QEAAMXZ	; Delay::readFromDelayLine
	movss	DWORD PTR [rsi], xmm0

; 139  : 
; 140  : 		// Read value from delay line and allocate it to output
; 141  : 		for (int i = 0; i < mcf_numberOfChannels; i++) {

	inc	r14d
	add	rdi, 8
	add	rsi, 4
	mov	eax, DWORD PTR [rbx]
	cmp	r14d, eax
	jl	SHORT $LL4@processAud
$LN141@processAud:

; 149  : 		}
; 150  : 
; 151  : 		// Write the processed feedback value to delay lines
; 152  : 		for (int i = 0; i < mcf_numberOfChannels; i++) {

	mov	r8d, r13d
	test	eax, eax
	jle	$LN134@processAud
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

	mov	r10, QWORD PTR housein$[rbp-96]
	mov	r11, QWORD PTR [rbx+40]
	mov	rdx, r13
	mov	r9, r13
$LL7@processAud:
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 153  : 			housein[i] = mcf_DelayLines[i]->processLowPass(out[i]) * mcf_DelayLines[i]->getFeedback();

	movss	xmm5, DWORD PTR [rdx+r15]
	mov	rcx, QWORD PTR [r11+r9]
; File E:\FoxSuite\shimmer\include\src\LPCombFilter.cpp

; 36   : 	return lpcf_feedbackLPF->processAudio(xn);

	mov	rax, QWORD PTR [rcx+88]
; File E:\FoxSuite\shimmer\include\LowPassFilter.h

; 200  : 		float yn = lpf_a0 * xn + lpf_a1 * lpf_xn_1 + lpf_a2 * lpf_xn_2 - lpf_b1 * lpf_yn_1 - lpf_b2 * lpf_yn_2;

	movss	xmm3, DWORD PTR [rax+44]
	movss	xmm2, DWORD PTR [rax+52]
	movaps	xmm4, xmm3
	mulss	xmm4, DWORD PTR [rax+24]
	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR [rax+20]
	addss	xmm4, xmm0
	movss	xmm1, DWORD PTR [rax+28]
	mulss	xmm1, DWORD PTR [rax+48]
	addss	xmm4, xmm1
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [rax+32]
	subss	xmm4, xmm0
	movss	xmm1, DWORD PTR [rax+36]
	mulss	xmm1, DWORD PTR [rax+56]
	subss	xmm4, xmm1

; 192  : 		lpf_xn_2 = lpf_xn_1;

	movss	DWORD PTR [rax+48], xmm3

; 193  : 		lpf_yn_2 = lpf_yn_1;

	movss	DWORD PTR [rax+56], xmm2

; 194  : 		lpf_xn_1 = xn;

	movss	DWORD PTR [rax+44], xmm5

; 195  : 		lpf_yn_1 = yn;

	movss	DWORD PTR [rax+52], xmm4

; 205  : 		return lpf_c0 * yn;

	mulss	xmm4, DWORD PTR [rax+40]
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 153  : 			housein[i] = mcf_DelayLines[i]->processLowPass(out[i]) * mcf_DelayLines[i]->getFeedback();

	mulss	xmm4, DWORD PTR [rcx+72]
	movss	DWORD PTR [r10+rdx], xmm4

; 149  : 		}
; 150  : 
; 151  : 		// Write the processed feedback value to delay lines
; 152  : 		for (int i = 0; i < mcf_numberOfChannels; i++) {

	inc	r8d
	add	r9, 8
	add	rdx, 4
	cmp	r8d, DWORD PTR [rbx]
	jl	$LL7@processAud
$LN134@processAud:

; 154  : 		}
; 155  : 
; 156  : 		// Apply householder transformation
; 157  : 		mcf_Householder->processAudio(&housein[0], &houseout[0]);

	mov	r8, QWORD PTR [rbx+32]
; File E:\FoxSuite\shimmer\include\Householder.h

; 24   : 		for (int i = 0; i < hou_numberOfChannels; i++)

	movsxd	rdx, DWORD PTR [r8]
	mov	rcx, QWORD PTR housein$[rbp-96]
	test	rdx, rdx
	jle	SHORT $LN47@processAud
	mov	rax, r13
$LL126@processAud:

; 25   : 			sum += in[i];

	addss	xmm6, DWORD PTR [rcx+rax*4]

; 24   : 		for (int i = 0; i < hou_numberOfChannels; i++)

	inc	rax
	cmp	rax, rdx
	jl	SHORT $LL126@processAud
$LN47@processAud:

; 26   : 
; 27   : 		sum *= hou_multiplier;

	mulss	xmm6, DWORD PTR [r8+4]

; 28   : 
; 29   : 		for (int i = 0; i < hou_numberOfChannels; i++)

	mov	edx, r13d
	cmp	DWORD PTR [r8], r13d
	jle	SHORT $LN50@processAud
	mov	rax, QWORD PTR houseout$[rbp-96]
$LL51@processAud:

; 30   : 			out[i] = in[i] + sum;

	movaps	xmm0, xmm6
	addss	xmm0, DWORD PTR [rcx]
	movss	DWORD PTR [rax], xmm0

; 28   : 
; 29   : 		for (int i = 0; i < hou_numberOfChannels; i++)

	inc	edx
	add	rcx, 4
	add	rax, 4
	cmp	edx, DWORD PTR [r8]
	jl	SHORT $LL51@processAud
	mov	rcx, QWORD PTR housein$[rbp-96]
$LN50@processAud:
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 159  : 		for (int i = 0; i < mcf_numberOfChannels; i++) {

	mov	r9d, r13d
	cmp	DWORD PTR [rbx], r13d
	jle	SHORT $LN9@processAud
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1563 :         auto& _My_data = _Mypair._Myval2;

	mov	r8, r13
	mov	r10, r13
$LL10@processAud:

; 1569 :         return _My_data._Myfirst[_Pos];

	mov	rcx, QWORD PTR [rbx+40]
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 160  : 			mcf_DelayLines[i]->writeToDelayLine(in[i] + houseout[i]);

	mov	rax, QWORD PTR houseout$[rbp-96]
	movss	xmm0, DWORD PTR [r8+rax]
	addss	xmm0, DWORD PTR [r8+r12]
	mov	rdx, QWORD PTR [r10+rcx]
; File E:\FoxSuite\shimmer\include\src\Delay.cpp

; 167  : 	dly_buffer[dly_writeIndex] = xn;

	movsxd	rcx, DWORD PTR [rdx+32]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rdx+40]
; File E:\FoxSuite\shimmer\include\src\Delay.cpp

; 167  : 	dly_buffer[dly_writeIndex] = xn;

	movss	DWORD PTR [rax+rcx*4], xmm0

; 151  : 	dly_readIndex++;

	inc	DWORD PTR [rdx+28]

; 152  : 
; 153  : 	// check if reading index is out of delay line length
; 154  : 	if (dly_readIndex >= dly_lineLengthInSamples)

	mov	eax, DWORD PTR [rdx+28]
	cmp	eax, DWORD PTR [rdx+12]
	cmovge	eax, r13d
	mov	DWORD PTR [rdx+28], eax

; 155  : 		dly_readIndex = 0;
; 156  : 
; 157  : 	// Increase writing index
; 158  : 	dly_writeIndex++;

	inc	DWORD PTR [rdx+32]

; 159  : 
; 160  : 	// check if writing index is out of delay line length
; 161  : 	if (dly_writeIndex >= dly_lineLengthInSamples)

	mov	eax, DWORD PTR [rdx+32]
	cmp	eax, DWORD PTR [rdx+12]
	cmovge	eax, r13d
	mov	DWORD PTR [rdx+32], eax
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 159  : 		for (int i = 0; i < mcf_numberOfChannels; i++) {

	inc	r9d
	add	r10, 8
	add	r8, 4
	cmp	r9d, DWORD PTR [rbx]
	jl	SHORT $LL10@processAud
	mov	rcx, QWORD PTR housein$[rbp-96]
$LN9@processAud:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ebx, 4096				; 00001000H
	test	rcx, rcx
	je	SHORT $LN70@processAud

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR housein$[rbp-80]
	sub	rax, rcx
	sar	rax, 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax*4]
	mov	rax, rcx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, rbx
	jb	SHORT $LN86@processAud

; 155  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 156  : 
; 157  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN86@processAud
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN86@processAud:

; 264  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	xorps	xmm0, xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

	movdqu	XMMWORD PTR housein$[rbp-96], xmm0

; 1768 :             _Mylast  = nullptr;
; 1769 :             _Myend   = nullptr;

	mov	QWORD PTR housein$[rbp-80], r13
$LN70@processAud:

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR houseout$[rbp-96]
	test	rcx, rcx
	je	SHORT $LN95@processAud

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR houseout$[rbp-80]
	sub	rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -4
	mov	rax, rcx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, rbx
	jb	SHORT $LN111@processAud

; 155  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 156  : 
; 157  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN111@processAud
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN111@processAud:

; 264  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN95@processAud:
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 163  : 	}

	lea	r11, QWORD PTR [rsp+96]
	mov	rbx, QWORD PTR [r11+48]
	mov	rsi, QWORD PTR [r11+56]
	mov	rdi, QWORD PTR [r11+64]
	movaps	xmm6, XMMWORD PTR [rsp+80]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rbp
	ret	0
$LN143@processAud:
?processAudio@ModMultiChannelFeedback@@QEAAXPEAM0@Z ENDP ; ModMultiChannelFeedback::processAudio
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
housein$ = 32
houseout$ = 56
this$ = 144
in$ = 152
out$ = 160
?dtor$0@?0??processAudio@ModMultiChannelFeedback@@QEAAXPEAM0@Z@4HA PROC ; `ModMultiChannelFeedback::processAudio'::`1'::dtor$0
	lea	rcx, QWORD PTR houseout$[rdx]
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0??processAudio@ModMultiChannelFeedback@@QEAAXPEAM0@Z@4HA ENDP ; `ModMultiChannelFeedback::processAudio'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
housein$ = 32
houseout$ = 56
this$ = 144
in$ = 152
out$ = 160
?dtor$0@?0??processAudio@ModMultiChannelFeedback@@QEAAXPEAM0@Z@4HA PROC ; `ModMultiChannelFeedback::processAudio'::`1'::dtor$0
	lea	rcx, QWORD PTR houseout$[rdx]
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0??processAudio@ModMultiChannelFeedback@@QEAAXPEAM0@Z@4HA ENDP ; `ModMultiChannelFeedback::processAudio'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\include\Householder.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\include\Householder.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
;	COMDAT ?constructMCF@ModMultiChannelFeedback@@AEAAXH@Z
_TEXT	SEGMENT
$T5 = 48
$T1 = 48
this$ = 48
numCh$ = 56
$T3 = 64
?constructMCF@ModMultiChannelFeedback@@AEAAXH@Z PROC	; ModMultiChannelFeedback::constructMCF, COMDAT

; 167  : 	void constructMCF(int numCh) {

$LN33:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	ebx, edx
	mov	rsi, rcx

; 168  : 		mcf_Householder = new Householder(numCh);

	mov	ecx, 8
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T1[rsp], rax
	movd	xmm0, ebx
; File E:\FoxSuite\shimmer\include\Householder.h

; 19   : 		hou_multiplier = -2.0 / hou_numberOfChannels;

	cvtdq2pd xmm0, xmm0
	movsd	xmm1, QWORD PTR __real@c000000000000000
	divsd	xmm1, xmm0
	cvtpd2ps xmm2, xmm1
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 168  : 		mcf_Householder = new Householder(numCh);

	mov	QWORD PTR [rsi+32], rax

; 169  : 		mcf_numberOfChannels = numCh;

	mov	DWORD PTR [rsi], ebx
; File E:\FoxSuite\shimmer\include\Householder.h

; 18   : 		hou_numberOfChannels = numCh;

	mov	DWORD PTR [rax], ebx

; 19   : 		hou_multiplier = -2.0 / hou_numberOfChannels;

	movss	DWORD PTR [rax+4], xmm2
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 171  : 		deleteDelayLines();

	mov	rcx, rsi
	call	?deleteDelayLines@ModMultiChannelFeedback@@AEAAXXZ ; ModMultiChannelFeedback::deleteDelayLines

; 183  : 		for (int i = 0; i < mcf_numberOfChannels; i++)

	xor	edi, edi
	cmp	DWORD PTR [rsi], edi
	jle	SHORT $LN14@constructM
$LL15@constructM:

; 184  : 			mcf_DelayLines.push_back(new ModDelay);

	mov	ecx, 144				; 00000090H
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T3[rsp], rax
	mov	rcx, rax
	call	??0ModDelay@@QEAA@XZ			; ModDelay::ModDelay
	npad	1
	mov	QWORD PTR $T5[rsp], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 743  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rsi+48]
	cmp	rdx, QWORD PTR [rsi+56]
	je	SHORT $LN23@constructM

; 726  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	QWORD PTR [rdx], rax

; 727  :         _Orphan_range(_Mylast, _Mylast);
; 728  :         _Ty& _Result = *_Mylast;
; 729  :         ++_Mylast;

	add	QWORD PTR [rsi+48], 8

; 744  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN13@constructM
$LN23@constructM:

; 745  :         }
; 746  : 
; 747  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T5[rsp]
	lea	rcx, QWORD PTR [rsi+40]
	call	??$_Emplace_reallocate@PEAVModDelay@@@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEAAPEAPEAVModDelay@@QEAPEAV2@$$QEAPEAV2@@Z ; std::vector<ModDelay *,std::allocator<ModDelay *> >::_Emplace_reallocate<ModDelay *>
$LN13@constructM:
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 183  : 		for (int i = 0; i < mcf_numberOfChannels; i++)

	inc	edi
	cmp	edi, DWORD PTR [rsi]
	jl	SHORT $LL15@constructM
$LN14@constructM:

; 172  : 		allocateDelayLines();
; 173  : 	}

	mov	rbx, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?constructMCF@ModMultiChannelFeedback@@AEAAXH@Z ENDP	; ModMultiChannelFeedback::constructMCF
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T5 = 48
$T1 = 48
this$ = 48
numCh$ = 56
$T3 = 64
?dtor$1@?0??constructMCF@ModMultiChannelFeedback@@AEAAXH@Z@4HA PROC ; `ModMultiChannelFeedback::constructMCF'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 144				; 00000090H
	mov	rcx, QWORD PTR $T3[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??constructMCF@ModMultiChannelFeedback@@AEAAXH@Z@4HA ENDP ; `ModMultiChannelFeedback::constructMCF'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
$T5 = 48
$T1 = 48
this$ = 48
numCh$ = 56
$T3 = 64
?dtor$1@?0??constructMCF@ModMultiChannelFeedback@@AEAAXH@Z@4HA PROC ; `ModMultiChannelFeedback::constructMCF'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 144				; 00000090H
	mov	rcx, QWORD PTR $T3[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??constructMCF@ModMultiChannelFeedback@@AEAAXH@Z@4HA ENDP ; `ModMultiChannelFeedback::constructMCF'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
;	COMDAT ?deleteDelayLines@ModMultiChannelFeedback@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?deleteDelayLines@ModMultiChannelFeedback@@AEAAXXZ PROC	; ModMultiChannelFeedback::deleteDelayLines, COMDAT

; 175  : 	void deleteDelayLines() {

$LN32:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	push	r14
	sub	rsp, 32					; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1544 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	rdx, QWORD PTR [rcx+40]
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 175  : 	void deleteDelayLines() {

	mov	rbx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1544 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	rax, QWORD PTR [rcx+48]
	mov	r8, rdx
	cmp	rdx, rax
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 176  : 		if (!mcf_DelayLines.empty())

	je	SHORT $LN3@deleteDela
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	rax, rdx
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 177  : 			for (int i = 0; i < mcf_DelayLines.size(); i++)

	xor	ebp, ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	rax, 3
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 177  : 			for (int i = 0; i < mcf_DelayLines.size(); i++)

	test	rax, rax
	je	SHORT $LN3@deleteDela
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1548 :         auto& _My_data = _Mypair._Myval2;

	xor	r14d, r14d
$LL4@deleteDela:
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 178  : 				delete mcf_DelayLines[i];

	mov	rdi, QWORD PTR [r14+rdx]
	test	rdi, rdi
	je	SHORT $LN2@deleteDela
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 51   : 		delete mdly_LFO;

	mov	rsi, QWORD PTR [rdi+104]
	lea	rax, OFFSET FLAT:??_7ModDelay@@6B@
	mov	QWORD PTR [rdi], rax
	test	rsi, rsi
	je	SHORT $LN24@deleteDela
	mov	rcx, rsi
	call	??1LFO@@QEAA@XZ				; LFO::~LFO
	mov	edx, 56					; 00000038H
	mov	rcx, rsi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN24@deleteDela:

; 52   : 	}

	mov	rcx, rdi
	call	??1LPCombFilter@@QEAA@XZ		; LPCombFilter::~LPCombFilter
	mov	edx, 144				; 00000090H
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN2@deleteDela:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	r8, QWORD PTR [rbx+40]
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 177  : 			for (int i = 0; i < mcf_DelayLines.size(); i++)

	inc	ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rbx+48]
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 177  : 			for (int i = 0; i < mcf_DelayLines.size(); i++)

	add	r14, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	rcx, r8
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 177  : 			for (int i = 0; i < mcf_DelayLines.size(); i++)

	movsxd	rax, ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	rcx, 3
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 177  : 			for (int i = 0; i < mcf_DelayLines.size(); i++)

	mov	rdx, r8
	cmp	rax, rcx
	jb	SHORT $LL4@deleteDela
$LN3@deleteDela:

; 179  : 		mcf_DelayLines.clear();
; 180  : 	}

	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+72]
	mov	QWORD PTR [rbx+48], r8
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
?deleteDelayLines@ModMultiChannelFeedback@@AEAAXXZ ENDP	; ModMultiChannelFeedback::deleteDelayLines
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
;	COMDAT ?allocateDelayLines@ModMultiChannelFeedback@@AEAAXXZ
_TEXT	SEGMENT
$T3 = 48
this$ = 48
$T1 = 56
?allocateDelayLines@ModMultiChannelFeedback@@AEAAXXZ PROC ; ModMultiChannelFeedback::allocateDelayLines, COMDAT

; 182  : 	void allocateDelayLines() {

$LN22:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx

; 183  : 		for (int i = 0; i < mcf_numberOfChannels; i++)

	xor	ebx, ebx
	cmp	DWORD PTR [rcx], ebx
	jle	SHORT $LN3@allocateDe
$LL4@allocateDe:

; 184  : 			mcf_DelayLines.push_back(new ModDelay);

	mov	ecx, 144				; 00000090H
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, rax
	call	??0ModDelay@@QEAA@XZ			; ModDelay::ModDelay
	npad	1
	mov	QWORD PTR $T3[rsp], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 743  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rdi+48]
	cmp	rdx, QWORD PTR [rdi+56]
	je	SHORT $LN12@allocateDe

; 726  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	QWORD PTR [rdx], rax

; 727  :         _Orphan_range(_Mylast, _Mylast);
; 728  :         _Ty& _Result = *_Mylast;
; 729  :         ++_Mylast;

	add	QWORD PTR [rdi+48], 8

; 744  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN2@allocateDe
$LN12@allocateDe:

; 745  :         }
; 746  : 
; 747  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T3[rsp]
	lea	rcx, QWORD PTR [rdi+40]
	call	??$_Emplace_reallocate@PEAVModDelay@@@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEAAPEAPEAVModDelay@@QEAPEAV2@$$QEAPEAV2@@Z ; std::vector<ModDelay *,std::allocator<ModDelay *> >::_Emplace_reallocate<ModDelay *>
$LN2@allocateDe:
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 183  : 		for (int i = 0; i < mcf_numberOfChannels; i++)

	inc	ebx
	cmp	ebx, DWORD PTR [rdi]
	jl	SHORT $LL4@allocateDe
$LN3@allocateDe:

; 185  : 	}

	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?allocateDelayLines@ModMultiChannelFeedback@@AEAAXXZ ENDP ; ModMultiChannelFeedback::allocateDelayLines
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T3 = 48
this$ = 48
$T1 = 56
?dtor$0@?0??allocateDelayLines@ModMultiChannelFeedback@@AEAAXXZ@4HA PROC ; `ModMultiChannelFeedback::allocateDelayLines'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 144				; 00000090H
	mov	rcx, QWORD PTR $T1[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??allocateDelayLines@ModMultiChannelFeedback@@AEAAXXZ@4HA ENDP ; `ModMultiChannelFeedback::allocateDelayLines'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
$T3 = 48
this$ = 48
$T1 = 56
?dtor$0@?0??allocateDelayLines@ModMultiChannelFeedback@@AEAAXXZ@4HA PROC ; `ModMultiChannelFeedback::allocateDelayLines'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 144				; 00000090H
	mov	rcx, QWORD PTR $T1[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??allocateDelayLines@ModMultiChannelFeedback@@AEAAXXZ@4HA ENDP ; `ModMultiChannelFeedback::allocateDelayLines'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File E:\FoxSuite\shimmer\include\src\Delay.cpp
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
;	COMDAT ?setDelayExponential@ModMultiChannelFeedback@@AEAAXXZ
_TEXT	SEGMENT
expo$ = 32
$T2 = 56
this$ = 96
?setDelayExponential@ModMultiChannelFeedback@@AEAAXXZ PROC ; ModMultiChannelFeedback::setDelayExponential, COMDAT

; 187  : 	void setDelayExponential() {

$LN75:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rsi
	mov	QWORD PTR [rax+24], rdi
	push	r14
	sub	rsp, 80					; 00000050H
	mov	rbx, rcx

; 188  : 		vector<float> expo(mcf_numberOfChannels);

	movsxd	rdx, DWORD PTR [rcx]
	lea	rcx, QWORD PTR [rax-56]
	call	??0?$vector@MV?$allocator@M@std@@@std@@QEAA@_KAEBV?$allocator@M@1@@Z ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
	npad	1

; 189  : 		expo = exponentialVector(mcf_minDelayLength, mcf_maxDelayLength, mcf_numberOfChannels);

	mov	r9d, DWORD PTR [rbx]
	movss	xmm2, DWORD PTR [rbx+12]
	movss	xmm1, DWORD PTR [rbx+8]
	lea	rcx, QWORD PTR $T2[rsp]
	call	?exponentialVector@@YA?AV?$vector@MV?$allocator@M@std@@@std@@MMH@Z ; exponentialVector
	mov	rdx, rax
	lea	rcx, QWORD PTR expo$[rsp]
	call	??4?$vector@MV?$allocator@M@std@@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::vector<float,std::allocator<float> >::operator=
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR $T2[rsp]
	test	rcx, rcx
	je	SHORT $LN11@setDelayEx

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR $T2[rsp+16]
	sub	rax, rcx
	sar	rax, 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax*4]
	mov	rax, rcx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN27@setDelayEx

; 155  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 156  : 
; 157  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN27@setDelayEx
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN27@setDelayEx:

; 264  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN11@setDelayEx:
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 190  : 		for (int i = 0; i < mcf_numberOfChannels; i++)

	xor	edi, edi
	cmp	DWORD PTR [rbx], edi
	jle	SHORT $LN3@setDelayEx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1563 :         auto& _My_data = _Mypair._Myval2;

	xor	esi, esi
	xor	r14d, r14d
$LL4@setDelayEx:

; 1564 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1565 :         _STL_VERIFY(
; 1566 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1567 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1568 : 
; 1569 :         return _My_data._Myfirst[_Pos];

	mov	rcx, QWORD PTR [rbx+40]
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 191  : 			mcf_DelayLines[i]->setDelayInmsec(expo[i]);

	mov	rax, QWORD PTR expo$[rsp]
	movss	xmm1, DWORD PTR [rsi+rax]
	mov	rcx, QWORD PTR [r14+rcx]
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 84   : 		mdly_meanDelayValue = delay;

	movss	DWORD PTR [rcx+120], xmm1
; File E:\FoxSuite\shimmer\include\src\Delay.cpp

; 118  : 	if (delayInmsec > dly_lineLengthInmsec)

	movss	xmm0, DWORD PTR [rcx+16]
	comiss	xmm1, xmm0
	ja	SHORT $LN42@setDelayEx

; 119  : 		delayInmsec = dly_lineLengthInmsec;
; 120  : 	else if (delayInmsec < 0.0)

	movaps	xmm0, xmm1
	maxss	xmm0, DWORD PTR __real@00000000
$LN42@setDelayEx:

; 121  : 		delayInmsec = 0.0;
; 122  : 
; 123  : 	// Set delay line length in milliseconds
; 124  : 	dly_delayInmsec = delayInmsec;

	movss	DWORD PTR [rcx+24], xmm0

; 125  : 
; 126  : 	// Update parameters based on new delay length
; 127  : 	updateParameters();

	call	?updateParameters@Delay@@AEAAXXZ	; Delay::updateParameters
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 190  : 		for (int i = 0; i < mcf_numberOfChannels; i++)

	inc	edi
	add	r14, 8
	add	rsi, 4
	cmp	edi, DWORD PTR [rbx]
	jl	SHORT $LL4@setDelayEx
$LN3@setDelayEx:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR expo$[rsp]
	test	rcx, rcx
	je	SHORT $LN47@setDelayEx

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR expo$[rsp+16]
	sub	rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -4
	mov	rax, rcx

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN63@setDelayEx

; 155  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 156  : 
; 157  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN63@setDelayEx
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN63@setDelayEx:

; 264  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN47@setDelayEx:
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 192  : 	}

	mov	rbx, QWORD PTR [rsp+96]
	mov	rsi, QWORD PTR [rsp+104]
	mov	rdi, QWORD PTR [rsp+112]
	add	rsp, 80					; 00000050H
	pop	r14
	ret	0
$LN72@setDelayEx:
?setDelayExponential@ModMultiChannelFeedback@@AEAAXXZ ENDP ; ModMultiChannelFeedback::setDelayExponential
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
expo$ = 32
$T2 = 56
this$ = 96
?dtor$0@?0??setDelayExponential@ModMultiChannelFeedback@@AEAAXXZ@4HA PROC ; `ModMultiChannelFeedback::setDelayExponential'::`1'::dtor$0
	lea	rcx, QWORD PTR expo$[rdx]
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0??setDelayExponential@ModMultiChannelFeedback@@AEAAXXZ@4HA ENDP ; `ModMultiChannelFeedback::setDelayExponential'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
expo$ = 32
$T2 = 56
this$ = 96
?dtor$0@?0??setDelayExponential@ModMultiChannelFeedback@@AEAAXXZ@4HA PROC ; `ModMultiChannelFeedback::setDelayExponential'::`1'::dtor$0
	lea	rcx, QWORD PTR expo$[rdx]
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0??setDelayExponential@ModMultiChannelFeedback@@AEAAXXZ@4HA ENDP ; `ModMultiChannelFeedback::setDelayExponential'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\include\utils.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\include\utils.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\include\utils.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\include\utils.h
; File E:\FoxSuite\shimmer\include\src\Delay.cpp
; File E:\FoxSuite\shimmer\include\utils.h
; File E:\FoxSuite\shimmer\include\src\Delay.cpp
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File E:\FoxSuite\shimmer\include\src\Delay.cpp
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
;	COMDAT ?setRandomInRangeDelayLines@ModMultiChannelFeedback@@AEAAXXZ
_TEXT	SEGMENT
this$ = 96
?setRandomInRangeDelayLines@ModMultiChannelFeedback@@AEAAXXZ PROC ; ModMultiChannelFeedback::setRandomInRangeDelayLines, COMDAT

; 194  : 	void setRandomInRangeDelayLines() {

$LN23:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rsi
	push	rdi
	sub	rsp, 80					; 00000050H
	movd	xmm0, DWORD PTR [rcx]
	mov	rbx, rcx
	movaps	XMMWORD PTR [rax-24], xmm6
	movaps	XMMWORD PTR [rax-40], xmm7
	movaps	XMMWORD PTR [rax-56], xmm8

; 197  : 		for (int i = 0; i < mcf_numberOfChannels; i++) {

	xor	eax, eax
	movss	xmm8, DWORD PTR [rcx+12]
	subss	xmm8, DWORD PTR [rcx+8]
	cvtdq2ps xmm0, xmm0
	divss	xmm8, xmm0
	cmp	DWORD PTR [rcx], eax
	jle	$LN3@setRandomI
	mov	edi, eax
$LL4@setRandomI:

; 198  : 			dlyLength = randomInRange(mcf_minDelayLength + step * i, mcf_minDelayLength + step * (i + 1));

	movss	xmm6, DWORD PTR [rbx+8]
	lea	esi, DWORD PTR [rax+1]
	xorps	xmm7, xmm7
	cvtsi2ss xmm7, eax
	mulss	xmm7, xmm8
	addss	xmm7, xmm6
; File E:\FoxSuite\shimmer\include\utils.h

; 105  : 	float unitRand = rand() / float(RAND_MAX);

	call	QWORD PTR __imp_rand
	xorps	xmm0, xmm0
	xorps	xmm1, xmm1
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 198  : 			dlyLength = randomInRange(mcf_minDelayLength + step * i, mcf_minDelayLength + step * (i + 1));

	cvtsi2ss xmm0, esi
; File E:\FoxSuite\shimmer\include\utils.h

; 105  : 	float unitRand = rand() / float(RAND_MAX);

	cvtsi2ss xmm1, eax
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 199  : 			mcf_DelayLines[i]->setDelayInmsec(dlyLength);

	mov	rax, QWORD PTR [rbx+40]
	mov	rcx, QWORD PTR [rdi+rax]
; File E:\FoxSuite\shimmer\include\utils.h

; 105  : 	float unitRand = rand() / float(RAND_MAX);

	mulss	xmm1, DWORD PTR __real@38000100
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 198  : 			dlyLength = randomInRange(mcf_minDelayLength + step * i, mcf_minDelayLength + step * (i + 1));

	mulss	xmm0, xmm8
	addss	xmm0, xmm6
; File E:\FoxSuite\shimmer\include\utils.h

; 106  : 	return min + unitRand * (max - min);

	subss	xmm0, xmm7
	mulss	xmm1, xmm0
; File E:\FoxSuite\shimmer\include\src\Delay.cpp

; 118  : 	if (delayInmsec > dly_lineLengthInmsec)

	movss	xmm0, DWORD PTR [rcx+16]
; File E:\FoxSuite\shimmer\include\utils.h

; 106  : 	return min + unitRand * (max - min);

	addss	xmm1, xmm7
; File E:\FoxSuite\shimmer\include\src\Delay.cpp

; 118  : 	if (delayInmsec > dly_lineLengthInmsec)

	comiss	xmm1, xmm0
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 84   : 		mdly_meanDelayValue = delay;

	movss	DWORD PTR [rcx+120], xmm1
; File E:\FoxSuite\shimmer\include\src\Delay.cpp

; 118  : 	if (delayInmsec > dly_lineLengthInmsec)

	ja	SHORT $LN15@setRandomI

; 119  : 		delayInmsec = dly_lineLengthInmsec;
; 120  : 	else if (delayInmsec < 0.0)

	movaps	xmm0, xmm1
	maxss	xmm0, DWORD PTR __real@00000000
$LN15@setRandomI:

; 121  : 		delayInmsec = 0.0;
; 122  : 
; 123  : 	// Set delay line length in milliseconds
; 124  : 	dly_delayInmsec = delayInmsec;

	movss	DWORD PTR [rcx+24], xmm0

; 125  : 
; 126  : 	// Update parameters based on new delay length
; 127  : 	updateParameters();

	call	?updateParameters@Delay@@AEAAXXZ	; Delay::updateParameters
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 197  : 		for (int i = 0; i < mcf_numberOfChannels; i++) {

	add	rdi, 8
	mov	eax, esi
	cmp	esi, DWORD PTR [rbx]
	jl	SHORT $LL4@setRandomI
$LN3@setRandomI:

; 200  : 		}
; 201  : 	}

	mov	rbx, QWORD PTR [rsp+96]
	mov	rsi, QWORD PTR [rsp+104]
	movaps	xmm6, XMMWORD PTR [rsp+64]
	movaps	xmm7, XMMWORD PTR [rsp+48]
	movaps	xmm8, XMMWORD PTR [rsp+32]
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
?setRandomInRangeDelayLines@ModMultiChannelFeedback@@AEAAXXZ ENDP ; ModMultiChannelFeedback::setRandomInRangeDelayLines
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ChannelSplitter.h
;	COMDAT ??0ChannelSplitter@@QEAA@HH@Z
_TEXT	SEGMENT
this$ = 8
numChIn$ = 16
numChOut$ = 24
??0ChannelSplitter@@QEAA@HH@Z PROC			; ChannelSplitter::ChannelSplitter, COMDAT

; 20   : 		setNumberOfChannelsIn(numChIn); 

	mov	DWORD PTR [rcx], edx

; 21   : 		setNumberOfChannelsOut(numChOut); 
; 22   : 	}

	mov	rax, rcx
	mov	DWORD PTR [rcx+4], r8d
	ret	0
??0ChannelSplitter@@QEAA@HH@Z ENDP			; ChannelSplitter::ChannelSplitter
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ChannelSplitter.h
;	COMDAT ??1ChannelSplitter@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1ChannelSplitter@@QEAA@XZ PROC			; ChannelSplitter::~ChannelSplitter, COMDAT

; 24   : 	~ChannelSplitter() { };

	ret	0
??1ChannelSplitter@@QEAA@XZ ENDP			; ChannelSplitter::~ChannelSplitter
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ChannelSplitter.h
;	COMDAT ?setNumberOfChannelsIn@ChannelSplitter@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 8
numChIn$ = 16
?setNumberOfChannelsIn@ChannelSplitter@@QEAAXH@Z PROC	; ChannelSplitter::setNumberOfChannelsIn, COMDAT

; 26   : 	void setNumberOfChannelsIn(int numChIn) { cspl_numberOfChannelsIn = numChIn; }

	mov	DWORD PTR [rcx], edx
	ret	0
?setNumberOfChannelsIn@ChannelSplitter@@QEAAXH@Z ENDP	; ChannelSplitter::setNumberOfChannelsIn
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ChannelSplitter.h
;	COMDAT ?setNumberOfChannelsOut@ChannelSplitter@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 8
numCh$ = 16
?setNumberOfChannelsOut@ChannelSplitter@@QEAAXH@Z PROC	; ChannelSplitter::setNumberOfChannelsOut, COMDAT

; 28   : 	void setNumberOfChannelsOut(int numCh) { cspl_numberOfChannelsOut = numCh; }

	mov	DWORD PTR [rcx+4], edx
	ret	0
?setNumberOfChannelsOut@ChannelSplitter@@QEAAXH@Z ENDP	; ChannelSplitter::setNumberOfChannelsOut
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ChannelSplitter.h
;	COMDAT ?processAudio@ChannelSplitter@@QEAAXPEAM0@Z
_TEXT	SEGMENT
this$ = 8
in$ = 16
out$ = 24
?processAudio@ChannelSplitter@@QEAAXPEAM0@Z PROC	; ChannelSplitter::processAudio, COMDAT

; 35   : 		float input;
; 36   : 		if (cspl_numberOfChannelsIn != 1) {

	xor	eax, eax
	mov	r9, r8
	cmp	DWORD PTR [rcx], 1
	je	SHORT $LN8@processAud

; 37   : 			input = 0;
; 38   : 			for (int i = 0; i < cspl_numberOfChannelsIn; i++) {

	movsxd	r10, DWORD PTR [rcx]
	xorps	xmm1, xmm1
	test	r10, r10
	jle	SHORT $LN3@processAud
	mov	r8d, eax
$LL15@processAud:

; 39   : 				input += in[i];

	addss	xmm1, DWORD PTR [rdx+r8*4]
	inc	r8
	cmp	r8, r10
	jl	SHORT $LL15@processAud
$LN3@processAud:
	movd	xmm0, DWORD PTR [rcx]

; 40   : 			}
; 41   : 			input = input / cspl_numberOfChannelsIn;

	cvtdq2ps xmm0, xmm0
	divss	xmm1, xmm0

; 42   : 		}

	jmp	SHORT $LN9@processAud
$LN8@processAud:

; 43   : 		else
; 44   : 			input = in[0];

	movss	xmm1, DWORD PTR [rdx]
$LN9@processAud:

; 45   : 
; 46   : 		for (int i = 0; i < cspl_numberOfChannelsOut; i++) out[i] = input; }

	cmp	DWORD PTR [rcx+4], eax
	jle	SHORT $LN6@processAud
$LL7@processAud:
	movss	DWORD PTR [r9], xmm1
	inc	eax
	lea	r9, QWORD PTR [r9+4]
	cmp	eax, DWORD PTR [rcx+4]
	jl	SHORT $LL7@processAud
$LN6@processAud:
	ret	0
?processAudio@ChannelSplitter@@QEAAXPEAM0@Z ENDP	; ChannelSplitter::processAudio
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ChannelMixer.h
;	COMDAT ??0ChannelMixer@@QEAA@HH@Z
_TEXT	SEGMENT
this$ = 8
numChIn$ = 16
numChOut$ = 24
??0ChannelMixer@@QEAA@HH@Z PROC				; ChannelMixer::ChannelMixer, COMDAT

; 26   : 		setNumberOfInputChannels(numChIn);
; 27   : 		setNumberOfOutputChannels(numChOut);
; 28   : 		mix_mode = DEFAULT_MIXING_LOGIC;

	and	DWORD PTR [rcx+8], 0

; 29   : 	}

	mov	rax, rcx
	mov	DWORD PTR [rcx], edx
	mov	DWORD PTR [rcx+4], r8d
	ret	0
??0ChannelMixer@@QEAA@HH@Z ENDP				; ChannelMixer::ChannelMixer
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ChannelMixer.h
;	COMDAT ??1ChannelMixer@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1ChannelMixer@@QEAA@XZ PROC				; ChannelMixer::~ChannelMixer, COMDAT

; 31   : 	~ChannelMixer() {}

	ret	0
??1ChannelMixer@@QEAA@XZ ENDP				; ChannelMixer::~ChannelMixer
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ChannelMixer.h
;	COMDAT ?setNumberOfInputChannels@ChannelMixer@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 8
numChIn$ = 16
?setNumberOfInputChannels@ChannelMixer@@QEAAXH@Z PROC	; ChannelMixer::setNumberOfInputChannels, COMDAT

; 33   : 	void setNumberOfInputChannels(int numChIn) { mix_numberOfChannelsIn = numChIn; }

	mov	DWORD PTR [rcx], edx
	ret	0
?setNumberOfInputChannels@ChannelMixer@@QEAAXH@Z ENDP	; ChannelMixer::setNumberOfInputChannels
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ChannelMixer.h
;	COMDAT ?setNumberOfOutputChannels@ChannelMixer@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 8
numChOut$ = 16
?setNumberOfOutputChannels@ChannelMixer@@QEAAXH@Z PROC	; ChannelMixer::setNumberOfOutputChannels, COMDAT

; 35   : 	void setNumberOfOutputChannels(int numChOut) { mix_numberOfChannelsOut = numChOut; }

	mov	DWORD PTR [rcx+4], edx
	ret	0
?setNumberOfOutputChannels@ChannelMixer@@QEAAXH@Z ENDP	; ChannelMixer::setNumberOfOutputChannels
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ChannelMixer.h
;	COMDAT ?setMixMode@ChannelMixer@@QEAAXW4MixMode@@@Z
_TEXT	SEGMENT
this$ = 8
mode$dead$ = 16
?setMixMode@ChannelMixer@@QEAAXW4MixMode@@@Z PROC	; ChannelMixer::setMixMode, COMDAT

; 37   : 	void setMixMode(MixMode mode) { mix_mode = mode; }

	mov	DWORD PTR [rcx+8], 1
	ret	0
?setMixMode@ChannelMixer@@QEAAXW4MixMode@@@Z ENDP	; ChannelMixer::setMixMode
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ChannelMixer.h
;	COMDAT ?processAudio@ChannelMixer@@QEAAXPEAM0@Z
_TEXT	SEGMENT
this$ = 8
in$ = 16
out$ = 24
?processAudio@ChannelMixer@@QEAAXPEAM0@Z PROC		; ChannelMixer::processAudio, COMDAT

; 40   : 		switch (mix_mode) {

	mov	r9d, DWORD PTR [rcx+8]
	xor	eax, eax
	test	r9d, r9d
	je	SHORT $LN11@processAud
	cmp	r9d, 1
	jne	SHORT $LN13@processAud

; 41   : 		case MixMode::First: {
; 42   : 			if (mix_numberOfChannelsOut == 1)

	cmp	DWORD PTR [rcx+4], r9d
	jne	SHORT $LN8@processAud

; 43   : 				out[0] = in[0];

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [r8], eax

; 58   : 			}
; 59   : 			break;
; 60   : 		}
; 61   : 		}					
; 62   : 	}

	ret	0
$LN8@processAud:

; 44   : 			else if(mix_numberOfChannelsOut == 2) {

	cmp	DWORD PTR [rcx+4], 2
	jne	SHORT $LN13@processAud

; 45   : 				out[0] = in[0];

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [r8], eax

; 46   : 				out[1] = in[1];

	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [r8+4], eax

; 58   : 			}
; 59   : 			break;
; 60   : 		}
; 61   : 		}					
; 62   : 	}

	ret	0
$LN11@processAud:

; 47   : 			}
; 48   : 			break;
; 49   : 		}
; 50   : 		case MixMode::WeightedSum: {
; 51   : 			float dummyOut = 0.0;
; 52   : 			for (int i = 0; i < mix_numberOfChannelsIn; i++) dummyOut += in[i];

	movsxd	r9, DWORD PTR [rcx]
	xorps	xmm1, xmm1
	test	r9, r9
	jle	SHORT $LN5@processAud
$LL17@processAud:
	addss	xmm1, DWORD PTR [rdx+rax*4]
	inc	rax
	cmp	rax, r9
	jl	SHORT $LL17@processAud
$LN5@processAud:

; 53   : 			if (mix_numberOfChannelsOut == 1)

	cmp	DWORD PTR [rcx+4], 1
	movd	xmm0, DWORD PTR [rcx]
	jne	SHORT $LN12@processAud

; 54   : 				out[0] = dummyOut / mix_numberOfChannelsIn;

	cvtdq2ps xmm0, xmm0
	divss	xmm1, xmm0
	movss	DWORD PTR [r8], xmm1

; 58   : 			}
; 59   : 			break;
; 60   : 		}
; 61   : 		}					
; 62   : 	}

	ret	0
$LN12@processAud:

; 55   : 			else {
; 56   : 				out[0] = dummyOut / (0.5 * mix_numberOfChannelsIn);

	movsd	xmm2, QWORD PTR __real@4000000000000000
	cvtdq2pd xmm0, xmm0
	cvtss2sd xmm1, xmm1
	divsd	xmm2, xmm0
	mulsd	xmm2, xmm1
	cvtpd2ps xmm0, xmm2
	movss	DWORD PTR [r8], xmm0

; 57   : 				out[1] = out[0];

	movss	DWORD PTR [r8+4], xmm0
$LN13@processAud:

; 58   : 			}
; 59   : 			break;
; 60   : 		}
; 61   : 		}					
; 62   : 	}

	ret	0
?processAudio@ChannelMixer@@QEAAXPEAM0@Z ENDP		; ChannelMixer::processAudio
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\HighPassFilter.h
;	COMDAT ??0HighPassFilter@@QEAA@HMW4HPFilterType@@@Z
_TEXT	SEGMENT
this$ = 48
sampleRate$dead$ = 56
freq$dead$ = 64
type$dead$ = 72
??0HighPassFilter@@QEAA@HMW4HPFilterType@@@Z PROC	; HighPassFilter::HighPassFilter, COMDAT

; 38   : 	HighPassFilter(int sampleRate = _TEMPLATE_SAMPLERATE, float freq = MAX_HPF_FREQUENCY, HPFilterType type = DEFAULT_HIGH_PASS_FILTER_TYPE) {

$LN4:
	push	rbx
	sub	rsp, 32					; 00000020H

; 39   : 		hpf_cutoffFreq = freq;
; 40   : 		hpf_sampleRate = sampleRate;
; 41   : 		hpf_type = type;

	xor	eax, eax
	mov	DWORD PTR [rcx+4], 1183109120		; 4684d000H
	mov	DWORD PTR [rcx], eax
	mov	rbx, rcx

; 42   : 		hpf_shelvingGaindB = DEFAULT_SHELVING_GAIN;
; 43   : 		hpf_Q = DEFAULT_RESONANCE;
; 44   : 		hpf_xn_1 = 0.0;

	mov	QWORD PTR [rcx+44], rax

; 45   : 		hpf_xn_2 = 0.0;
; 46   : 		hpf_yn_1 = 0.0;

	mov	QWORD PTR [rcx+52], rax
	mov	DWORD PTR [rcx+8], 44100		; 0000ac44H
	mov	DWORD PTR [rcx+12], -1061158912		; c0c00000H
	mov	DWORD PTR [rcx+16], 1060437492		; 3f34fdf4H

; 47   : 		hpf_yn_2 = 0.0;
; 48   : 		updateGains();

	call	?updateGains@HighPassFilter@@QEAAXXZ	; HighPassFilter::updateGains

; 49   : 	}

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0HighPassFilter@@QEAA@HMW4HPFilterType@@@Z ENDP	; HighPassFilter::HighPassFilter
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\HighPassFilter.h
;	COMDAT ??1HighPassFilter@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1HighPassFilter@@QEAA@XZ PROC				; HighPassFilter::~HighPassFilter, COMDAT

; 51   : 	~HighPassFilter() {}

	ret	0
??1HighPassFilter@@QEAA@XZ ENDP				; HighPassFilter::~HighPassFilter
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\HighPassFilter.h
;	COMDAT ?init@HighPassFilter@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 8
sampleRate$ = 16
?init@HighPassFilter@@QEAAXH@Z PROC			; HighPassFilter::init, COMDAT

; 54   : 		// set internal sample rate
; 55   : 		hpf_sampleRate = sampleRate;

	mov	DWORD PTR [rcx+8], edx

; 56   : 	}

	ret	0
?init@HighPassFilter@@QEAAXH@Z ENDP			; HighPassFilter::init
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\HighPassFilter.h
;	COMDAT ?setSampleRate@HighPassFilter@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 8
sampleRate$ = 16
?setSampleRate@HighPassFilter@@QEAAXH@Z PROC		; HighPassFilter::setSampleRate, COMDAT

; 59   : 		// allocate internal sample rate
; 60   : 		hpf_sampleRate = sampleRate;

	mov	DWORD PTR [rcx+8], edx

; 61   : 
; 62   : 		// update hpf gains
; 63   : 		updateGains();

	jmp	?updateGains@HighPassFilter@@QEAAXXZ	; HighPassFilter::updateGains
?setSampleRate@HighPassFilter@@QEAAXH@Z ENDP		; HighPassFilter::setSampleRate
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\HighPassFilter.h
;	COMDAT ?setCutoffFrequency@HighPassFilter@@QEAAXM@Z
_TEXT	SEGMENT
this$ = 8
cutoffFreq$ = 16
?setCutoffFrequency@HighPassFilter@@QEAAXM@Z PROC	; HighPassFilter::setCutoffFrequency, COMDAT

; 67   : 		// allocate cutoff frequency value
; 68   : 		hpf_cutoffFreq = cutoffFreq;

	movss	DWORD PTR [rcx+4], xmm1

; 69   : 
; 70   : 		// update hpf gains
; 71   : 		updateGains();

	jmp	?updateGains@HighPassFilter@@QEAAXXZ	; HighPassFilter::updateGains
?setCutoffFrequency@HighPassFilter@@QEAAXM@Z ENDP	; HighPassFilter::setCutoffFrequency
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\HighPassFilter.h
;	COMDAT ?setFilterType@HighPassFilter@@QEAAXW4HPFilterType@@@Z
_TEXT	SEGMENT
this$ = 8
type$dead$ = 16
?setFilterType@HighPassFilter@@QEAAXW4HPFilterType@@@Z PROC ; HighPassFilter::setFilterType, COMDAT

; 75   : 		// allocate filter type
; 76   : 		hpf_type = type;

	mov	DWORD PTR [rcx], 2

; 77   : 
; 78   : 		// update hpf gains
; 79   : 		updateGains();

	jmp	?updateGains@HighPassFilter@@QEAAXXZ	; HighPassFilter::updateGains
?setFilterType@HighPassFilter@@QEAAXW4HPFilterType@@@Z ENDP ; HighPassFilter::setFilterType
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\HighPassFilter.h
;	COMDAT ?updateGains@HighPassFilter@@QEAAXXZ
_TEXT	SEGMENT
this$ = 128
?updateGains@HighPassFilter@@QEAAXXZ PROC		; HighPassFilter::updateGains, COMDAT

; 92   : 	void updateGains() {

$LN13:
	mov	rax, rsp
	push	rbx
	sub	rsp, 112				; 00000070H
	movaps	XMMWORD PTR [rax-24], xmm6
	mov	rbx, rcx

; 93   : 		switch (hpf_type) {

	mov	ecx, DWORD PTR [rcx]
	movaps	XMMWORD PTR [rax-40], xmm7
	movaps	XMMWORD PTR [rax-56], xmm8
	movaps	XMMWORD PTR [rax-72], xmm9
	movaps	XMMWORD PTR [rax-88], xmm10
	test	ecx, ecx
	je	$LN4@updateGain
	sub	ecx, 1
	je	$LN5@updateGain
	sub	ecx, 1
	je	$LN6@updateGain
	cmp	ecx, 1
	jne	$LN2@updateGain

; 131  : 		}
; 132  : 		case HPFilterType::DigitalFirstOrder: {
; 133  : 			float thetac = 2.0 * M_PI * hpf_cutoffFreq / (float)hpf_sampleRate;

	movss	xmm2, DWORD PTR [rbx+4]
	xorps	xmm0, xmm0
	cvtsi2ss xmm0, DWORD PTR [rbx+8]
	cvtps2pd xmm2, xmm2
	cvtps2pd xmm1, xmm0
	mulsd	xmm2, QWORD PTR __real@401921fb54442d18
	divsd	xmm2, xmm1
	cvtpd2ps xmm0, xmm2

; 134  : 			float gamma = cos(thetac) / (1.0 + sin(thetac));

	cvtps2pd xmm6, xmm0
	movaps	xmm0, xmm6
	call	QWORD PTR __imp_cos
	movaps	xmm7, xmm0
	movaps	xmm0, xmm6
	call	QWORD PTR __imp_sin
	addsd	xmm0, QWORD PTR __real@3ff0000000000000
	xorps	xmm2, xmm2
	divsd	xmm7, xmm0
	cvtsd2ss xmm2, xmm7

; 135  : 			hpf_a0 = (1.0 + gamma) / 2.0;

	movaps	xmm1, xmm2

; 136  : 			hpf_a1 = -hpf_a0;
; 137  : 			hpf_a2 = 0.0;
; 138  : 			hpf_b1 = -gamma;

	xorps	xmm2, DWORD PTR __xmm@80000000800000008000000080000000
	addss	xmm1, DWORD PTR __real@3f800000
	movss	DWORD PTR [rbx+32], xmm2
$LN11@updateGain:

; 139  : 			hpf_b2 = 0.0;
; 140  : 			hpf_c0 = 1.0;
; 141  : 			break;
; 142  : 		}		
; 143  : 		}
; 144  : 	}

	mulss	xmm1, DWORD PTR __real@3f000000
	and	DWORD PTR [rbx+28], 0
	and	DWORD PTR [rbx+36], 0
	movss	DWORD PTR [rbx+20], xmm1
	xorps	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR [rbx+24], xmm1
	jmp	$LN9@updateGain
$LN6@updateGain:
	movss	xmm2, DWORD PTR [rbx+4]
	xorps	xmm0, xmm0

; 117  : 		}
; 118  : 		case HPFilterType::Shelving: {
; 119  : 			float thetac = 2.0 * M_PI * hpf_cutoffFreq / (float)hpf_sampleRate;

	cvtsi2ss xmm0, DWORD PTR [rbx+8]
	cvtps2pd xmm2, xmm2
	cvtps2pd xmm1, xmm0
	mulsd	xmm2, QWORD PTR __real@401921fb54442d18

; 120  : 			float mi = pow(10.0, hpf_shelvingGaindB / 20.0);

	movss	xmm0, DWORD PTR [rbx+12]
	mulss	xmm0, DWORD PTR __real@3d4ccccd
	divsd	xmm2, xmm1
	cvtps2pd xmm1, xmm0
	movsd	xmm0, QWORD PTR __real@4024000000000000
	cvtpd2ps xmm7, xmm2
	call	QWORD PTR __imp_pow

; 121  : 			float beta = (1.0 + mi) / 4.0;
; 122  : 			float delta = beta * tan(thetac / 2.0);

	mulss	xmm7, DWORD PTR __real@3f000000
	xorps	xmm6, xmm6
	movss	xmm9, DWORD PTR __real@3f800000
	cvtsd2ss xmm6, xmm0
	cvtps2pd xmm0, xmm7
	addss	xmm6, xmm9
	mulss	xmm6, DWORD PTR __real@3e800000
	call	QWORD PTR __imp_tan
	cvtps2pd xmm1, xmm6
	xorps	xmm2, xmm2

; 123  : 			float gamma = (1.0 - delta) / (1.0 + delta);

	movaps	xmm3, xmm9
	mulsd	xmm0, xmm1
	cvtsd2ss xmm2, xmm0
	subss	xmm3, xmm2
	addss	xmm2, xmm9
	divss	xmm3, xmm2

; 124  : 			hpf_a0 = (1.0 + gamma) / 2.0;

	movaps	xmm1, xmm3

; 125  : 			hpf_a1 = -hpf_a0;
; 126  : 			hpf_a2 = 0.0;
; 127  : 			hpf_b1 = -gamma;

	xorps	xmm3, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR [rbx+32], xmm3
	addss	xmm1, xmm9

; 128  : 			hpf_b2 = 0.0;
; 129  : 			hpf_c0 = 1.0;// mi - 1.0;
; 130  : 			break;

	jmp	$LN11@updateGain
$LN5@updateGain:
	movss	xmm0, DWORD PTR [rbx+4]

; 102  : 			hpf_c0 = 1.0;
; 103  : 			break;
; 104  : 		}
; 105  : 		case HPFilterType::LinkwitzRiley: {
; 106  : 			float omegac = M_PI * hpf_cutoffFreq;

	cvtps2pd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@400921fb54442d18
	cvtpd2ps xmm8, xmm0
	xorps	xmm0, xmm0

; 107  : 			float thetac = omegac / (float)hpf_sampleRate;

	cvtsi2ss xmm0, DWORD PTR [rbx+8]
	movaps	xmm1, xmm8
	divss	xmm1, xmm0

; 108  : 			float k = omegac / tan(thetac);

	cvtps2pd xmm6, xmm8
	cvtps2pd xmm0, xmm1
	call	QWORD PTR __imp_tan

; 109  : 			float delta = k * k + omegac * omegac + 2 * k * omegac;
; 110  : 			hpf_a0 = k * k / delta;

	movss	xmm3, DWORD PTR __real@3f800000
	movaps	xmm7, xmm8
	divsd	xmm6, xmm0
	mulss	xmm7, xmm8

; 111  : 			hpf_a1 = -2 * hpf_a0;
; 112  : 			hpf_a2 = hpf_a0;
; 113  : 			hpf_b1 = (-2 * k * k + 2 * omegac * omegac) / delta;

	movaps	xmm2, xmm8
	cvtpd2ps xmm6, xmm6
	movaps	xmm0, xmm7
	addss	xmm2, xmm8
	movaps	xmm4, xmm6
	movaps	xmm9, xmm6
	mulss	xmm9, xmm6
	addss	xmm4, xmm6
	mulss	xmm2, xmm8
	addss	xmm0, xmm9
	movaps	xmm5, xmm4
	mulss	xmm5, xmm8
	mulss	xmm4, xmm6
	addss	xmm0, xmm5
	subss	xmm2, xmm4
	divss	xmm3, xmm0
	movaps	xmm1, xmm3
	mulss	xmm2, xmm3
	mulss	xmm1, xmm9

; 114  : 			hpf_b2 = (-2 * k * omegac + k * k + omegac * omegac) / delta;

	subss	xmm9, xmm5
	movss	DWORD PTR [rbx+32], xmm2
	movaps	xmm0, xmm1
	movss	DWORD PTR [rbx+20], xmm1
	mulss	xmm0, DWORD PTR __real@c0000000
	addss	xmm9, xmm7
	movss	DWORD PTR [rbx+28], xmm1
	movss	DWORD PTR [rbx+24], xmm0
	mulss	xmm9, xmm3
	movss	DWORD PTR [rbx+36], xmm9

; 115  : 			hpf_c0 = 1.0;
; 116  : 			break;

	jmp	$LN9@updateGain
$LN4@updateGain:
	movss	xmm0, DWORD PTR [rbx+4]
	xorps	xmm1, xmm1

; 94   : 		case HPFilterType::Butterworth: {
; 95   : 			// define hpf fb and ff gains
; 96   : 			float C = tan((M_PI * hpf_cutoffFreq) / (float)hpf_sampleRate);

	cvtsi2ss xmm1, DWORD PTR [rbx+8]
	cvtps2pd xmm0, xmm0
	cvtps2pd xmm2, xmm1
	mulsd	xmm0, QWORD PTR __real@400921fb54442d18
	divsd	xmm0, xmm2
	call	QWORD PTR __imp_tan
	xorps	xmm7, xmm7
	cvtsd2ss xmm7, xmm0

; 97   : 			hpf_a0 = 1.0 / (1.0 + sqrt(2.0) * C + C * C);

	movsd	xmm0, QWORD PTR __real@4000000000000000
	cvtps2pd xmm9, xmm7
	mulss	xmm7, xmm7
	cvtps2pd xmm10, xmm7
	call	QWORD PTR __imp_sqrt
	movsd	xmm8, QWORD PTR __real@3ff0000000000000

; 98   : 			hpf_a1 = -2.0 * hpf_a0;
; 99   : 			hpf_a2 = hpf_a0;
; 100  : 			hpf_b1 = 2.0 * hpf_a0 * (C * C - 1.0);

	subss	xmm7, DWORD PTR __real@3f800000
	mulsd	xmm0, xmm9
	movaps	xmm1, xmm8
	addsd	xmm0, xmm8
	addsd	xmm0, xmm10
	divsd	xmm1, xmm0

; 101  : 			hpf_b2 = hpf_a0 * (1.0 - sqrt(2.0) * C + C * C);

	movsd	xmm0, QWORD PTR __real@4000000000000000
	cvtpd2ps xmm2, xmm1
	movaps	xmm1, xmm2
	movss	DWORD PTR [rbx+20], xmm2
	mulss	xmm1, DWORD PTR __real@c0000000
	movss	DWORD PTR [rbx+28], xmm2
	addss	xmm2, xmm2
	movss	DWORD PTR [rbx+24], xmm1
	mulss	xmm2, xmm7
	movss	DWORD PTR [rbx+32], xmm2
	call	QWORD PTR __imp_sqrt
	mulsd	xmm0, xmm9
	subsd	xmm8, xmm0
	movss	xmm0, DWORD PTR [rbx+20]
	cvtps2pd xmm0, xmm0
	addsd	xmm8, xmm10
	mulsd	xmm0, xmm8
	cvtpd2ps xmm0, xmm0
	movss	DWORD PTR [rbx+36], xmm0
$LN9@updateGain:

; 139  : 			hpf_b2 = 0.0;
; 140  : 			hpf_c0 = 1.0;
; 141  : 			break;
; 142  : 		}		
; 143  : 		}
; 144  : 	}

	mov	DWORD PTR [rbx+40], 1065353216		; 3f800000H
$LN2@updateGain:
	movaps	xmm6, XMMWORD PTR [rsp+96]
	movaps	xmm7, XMMWORD PTR [rsp+80]
	movaps	xmm8, XMMWORD PTR [rsp+64]
	movaps	xmm9, XMMWORD PTR [rsp+48]
	movaps	xmm10, XMMWORD PTR [rsp+32]
	add	rsp, 112				; 00000070H
	pop	rbx
	ret	0
?updateGains@HighPassFilter@@QEAAXXZ ENDP		; HighPassFilter::updateGains
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\HighPassFilter.h
;	COMDAT ?updateBuffers@HighPassFilter@@QEAAXMM@Z
_TEXT	SEGMENT
this$ = 8
xn$ = 16
yn$ = 24
?updateBuffers@HighPassFilter@@QEAAXMM@Z PROC		; HighPassFilter::updateBuffers, COMDAT

; 147  : 		hpf_xn_2 = hpf_xn_1;

	mov	eax, DWORD PTR [rcx+44]
	mov	DWORD PTR [rcx+48], eax

; 148  : 		hpf_yn_2 = hpf_yn_1;

	mov	eax, DWORD PTR [rcx+52]

; 149  : 		hpf_xn_1 = xn;
; 150  : 		hpf_yn_1 = yn;

	movss	DWORD PTR [rcx+52], xmm2
	mov	DWORD PTR [rcx+56], eax
	movss	DWORD PTR [rcx+44], xmm1

; 151  : 	}

	ret	0
?updateBuffers@HighPassFilter@@QEAAXMM@Z ENDP		; HighPassFilter::updateBuffers
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\HighPassFilter.h
;	COMDAT ?processAudio@HighPassFilter@@QEAAMM@Z
_TEXT	SEGMENT
this$ = 32
xn$ = 40
?processAudio@HighPassFilter@@QEAAMM@Z PROC		; HighPassFilter::processAudio, COMDAT

; 153  : 	float processAudio(float xn) {

$LN6:
	sub	rsp, 24

; 154  : 		// compute filtered output
; 155  : 		float yn = hpf_a0 * xn + hpf_a1 * hpf_xn_1 + hpf_a2 * hpf_xn_2 - hpf_b1 * hpf_yn_1 - hpf_b2 * hpf_yn_2;

	movss	xmm4, DWORD PTR [rcx+44]
	movaps	xmm0, xmm1
	movss	xmm3, DWORD PTR [rcx+52]
	movaps	xmm5, xmm4
	mulss	xmm5, DWORD PTR [rcx+24]
	movaps	xmm2, xmm3
	mulss	xmm0, DWORD PTR [rcx+20]
	mulss	xmm2, DWORD PTR [rcx+32]
	addss	xmm5, xmm0
	movaps	XMMWORD PTR [rsp], xmm6
	movaps	xmm6, xmm1
	movss	xmm1, DWORD PTR [rcx+28]
	mulss	xmm1, DWORD PTR [rcx+48]

; 149  : 		hpf_xn_1 = xn;

	movss	DWORD PTR [rcx+44], xmm6

; 161  : 	}

	movaps	xmm6, XMMWORD PTR [rsp]
	addss	xmm5, xmm1

; 147  : 		hpf_xn_2 = hpf_xn_1;

	movss	DWORD PTR [rcx+48], xmm4

; 154  : 		// compute filtered output
; 155  : 		float yn = hpf_a0 * xn + hpf_a1 * hpf_xn_1 + hpf_a2 * hpf_xn_2 - hpf_b1 * hpf_yn_1 - hpf_b2 * hpf_yn_2;

	movss	xmm1, DWORD PTR [rcx+36]
	mulss	xmm1, DWORD PTR [rcx+56]

; 148  : 		hpf_yn_2 = hpf_yn_1;

	movss	DWORD PTR [rcx+56], xmm3

; 154  : 		// compute filtered output
; 155  : 		float yn = hpf_a0 * xn + hpf_a1 * hpf_xn_1 + hpf_a2 * hpf_xn_2 - hpf_b1 * hpf_yn_1 - hpf_b2 * hpf_yn_2;

	subss	xmm5, xmm2
	subss	xmm5, xmm1

; 150  : 		hpf_yn_1 = yn;

	movss	DWORD PTR [rcx+52], xmm5

; 156  : 
; 157  : 		// update buffers
; 158  : 		updateBuffers(xn, yn);
; 159  : 
; 160  : 		return hpf_c0 * yn;

	mulss	xmm5, DWORD PTR [rcx+40]
	movaps	xmm0, xmm5

; 161  : 	}

	add	rsp, 24
	ret	0
?processAudio@HighPassFilter@@QEAAMM@Z ENDP		; HighPassFilter::processAudio
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\Modulation.h
;	COMDAT ?setModulationValue@Modulation@@AEAAXM@Z
_TEXT	SEGMENT
this$ = 8
modVal$ = 16
?setModulationValue@Modulation@@AEAAXM@Z PROC		; Modulation::setModulationValue, COMDAT

; 38   : 		mod_modValue = modVal;

	movss	DWORD PTR [rcx+172], xmm1

; 39   : 		ModDelay::setDeltaDelayValue(modVal);

	movss	DWORD PTR [rcx+124], xmm1

; 40   : 	}

	ret	0
?setModulationValue@Modulation@@AEAAXM@Z ENDP		; Modulation::setModulationValue
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\Modulation.h
;	COMDAT ??0Modulation@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0Modulation@@QEAA@XZ PROC				; Modulation::Modulation, COMDAT

; 44   : 	Modulation() {}

$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	call	??0ModDelay@@QEAA@XZ			; ModDelay::ModDelay
	lea	rax, OFFSET FLAT:??_7Modulation@@6B@
	mov	QWORD PTR [rbx], rax
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0Modulation@@QEAA@XZ ENDP				; Modulation::Modulation
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\Modulation.h
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File E:\FoxSuite\shimmer\include\Modulation.h
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File E:\FoxSuite\shimmer\include\Modulation.h
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File E:\FoxSuite\shimmer\include\Modulation.h
;	COMDAT ??1Modulation@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1Modulation@@QEAA@XZ PROC				; Modulation::~Modulation, COMDAT

; 46   : 	~Modulation() {}

$LN13:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 51   : 		delete mdly_LFO;

	mov	rdi, QWORD PTR [rcx+104]
	lea	rax, OFFSET FLAT:??_7ModDelay@@6B@
	mov	QWORD PTR [rcx], rax
; File E:\FoxSuite\shimmer\include\Modulation.h

; 46   : 	~Modulation() {}

	mov	rbx, rcx
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 51   : 		delete mdly_LFO;

	test	rdi, rdi
	je	SHORT $LN9@Modulation
	mov	rcx, rdi
	call	??1LFO@@QEAA@XZ				; LFO::~LFO
	mov	edx, 56					; 00000038H
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN9@Modulation:

; 52   : 	}

	mov	rcx, rbx
; File E:\FoxSuite\shimmer\include\Modulation.h

; 46   : 	~Modulation() {}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 52   : 	}

	jmp	??1LPCombFilter@@QEAA@XZ		; LPCombFilter::~LPCombFilter
??1Modulation@@QEAA@XZ ENDP				; Modulation::~Modulation
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\Modulation.h
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File E:\FoxSuite\shimmer\include\Modulation.h
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File E:\FoxSuite\shimmer\include\LFO.h
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File E:\FoxSuite\shimmer\include\src\Delay.cpp
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File E:\FoxSuite\shimmer\include\src\Delay.cpp
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File E:\FoxSuite\shimmer\include\src\Delay.cpp
; File E:\FoxSuite\shimmer\include\Modulation.h
;	COMDAT ?init@Modulation@@QEAAXW4ModulationType@@H@Z
_TEXT	SEGMENT
this$ = 48
type$dead$ = 56
sampleRate$ = 64
?init@Modulation@@QEAAXW4ModulationType@@H@Z PROC	; Modulation::init, COMDAT

; 48   : 	void init(ModulationType type, int sampleRate) {

$LN31:
	push	rbx
	sub	rsp, 32					; 00000020H

; 49   : 		ModDelay::init(DEFAULT_MOD_BUFFER_LENGTH, sampleRate);

	movss	xmm1, DWORD PTR __real@42200000
	mov	rbx, rcx
	call	?init@ModDelay@@QEAAXMHW4OscillatorType@@@Z ; ModDelay::init
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 95   : 		mdly_LFO->setLFOWaveform(wave);

	mov	rcx, QWORD PTR [rbx+104]
; File E:\FoxSuite\shimmer\include\Modulation.h

; 85   : 		mod_type = modType;

	mov	DWORD PTR [rbx+144], 1
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 94   : 		mdly_lfoWaveform = wave;

	mov	DWORD PTR [rbx+116], 1
; File E:\FoxSuite\shimmer\include\LFO.h

; 132  : 		lfo_table.clear();

	mov	rax, QWORD PTR [rcx+24]
	mov	QWORD PTR [rcx+32], rax

; 76   : 		lfo_waveform = waveform;

	mov	DWORD PTR [rcx+12], 1

; 77   : 		clearTable();
; 78   : 		createTable();

	call	?createTable@LFO@@AEAAXXZ		; LFO::createTable
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 100  : 		mdly_LFO->setLFOunipolar(isUnipolar);

	mov	rax, QWORD PTR [rbx+104]
; File E:\FoxSuite\shimmer\include\src\Delay.cpp

; 118  : 	if (delayInmsec > dly_lineLengthInmsec)

	movss	xmm1, DWORD PTR __real@3dcccccd
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 99   : 		mdly_isUnipolar = isUnipolar;

	mov	BYTE PTR [rbx+112], 1

; 100  : 		mdly_LFO->setLFOunipolar(isUnipolar);

	mov	BYTE PTR [rax+48], 1
; File E:\FoxSuite\shimmer\include\src\Delay.cpp

; 118  : 	if (delayInmsec > dly_lineLengthInmsec)

	movss	xmm0, DWORD PTR [rbx+16]
	comiss	xmm0, xmm1
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 84   : 		mdly_meanDelayValue = delay;

	mov	DWORD PTR [rbx+120], 1036831949		; 3dcccccdH
; File E:\FoxSuite\shimmer\include\src\Delay.cpp

; 118  : 	if (delayInmsec > dly_lineLengthInmsec)

	jb	SHORT $LN24@init

; 119  : 		delayInmsec = dly_lineLengthInmsec;
; 120  : 	else if (delayInmsec < 0.0)
; 121  : 		delayInmsec = 0.0;

	movaps	xmm0, xmm1
$LN24@init:

; 122  : 
; 123  : 	// Set delay line length in milliseconds
; 124  : 	dly_delayInmsec = delayInmsec;
; 125  : 
; 126  : 	// Update parameters based on new delay length
; 127  : 	updateParameters();

	mov	rcx, rbx
	movss	DWORD PTR [rbx+24], xmm0
	call	?updateParameters@Delay@@AEAAXXZ	; Delay::updateParameters
; File E:\FoxSuite\shimmer\include\Modulation.h

; 38   : 		mod_modValue = modVal;

	mov	eax, 1084017869				; 409ccccdH

; 157  : 		setModWet(wet);

	mov	DWORD PTR [rbx+148], 1065353216		; 3f800000H

; 38   : 		mod_modValue = modVal;

	mov	DWORD PTR [rbx+172], eax

; 39   : 		ModDelay::setDeltaDelayValue(modVal);

	mov	DWORD PTR [rbx+124], eax

; 155  : 		setModMix(mix);

	xor	eax, eax

; 156  : 		setModDry(dry);

	mov	QWORD PTR [rbx+152], rax

; 72   : 		mod_fb = fb;

	mov	DWORD PTR [rbx+160], eax

; 73   : 		ModDelay::setFeedback(fb);

	mov	DWORD PTR [rbx+72], eax

; 50   : 		setModType(type);				
; 51   : 	}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?init@Modulation@@QEAAXW4ModulationType@@H@Z ENDP	; Modulation::init
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\Modulation.h
;	COMDAT ?setModDry@Modulation@@QEAAXM@Z
_TEXT	SEGMENT
this$ = 8
dry$ = 16
?setModDry@Modulation@@QEAAXM@Z PROC			; Modulation::setModDry, COMDAT

; 54   : 		mod_dry = dry;

	movss	DWORD PTR [rcx+152], xmm1

; 55   : 	}

	ret	0
?setModDry@Modulation@@QEAAXM@Z ENDP			; Modulation::setModDry
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\Modulation.h
;	COMDAT ?setModWet@Modulation@@QEAAXM@Z
_TEXT	SEGMENT
this$ = 8
wet$ = 16
?setModWet@Modulation@@QEAAXM@Z PROC			; Modulation::setModWet, COMDAT

; 58   : 		mod_wet = wet;

	movss	DWORD PTR [rcx+148], xmm1

; 59   : 	}

	ret	0
?setModWet@Modulation@@QEAAXM@Z ENDP			; Modulation::setModWet
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\Modulation.h
;	COMDAT ?setModDepth@Modulation@@QEAAXM@Z
_TEXT	SEGMENT
this$ = 8
depth$ = 16
?setModDepth@Modulation@@QEAAXM@Z PROC			; Modulation::setModDepth, COMDAT

; 62   : 		mod_depth = depth;

	movss	DWORD PTR [rcx+168], xmm1

; 63   : 		ModDelay::setDeltaDelayValue(mod_modValue * mod_depth);

	mulss	xmm1, DWORD PTR [rcx+172]
	movss	DWORD PTR [rcx+124], xmm1

; 64   : 	}

	ret	0
?setModDepth@Modulation@@QEAAXM@Z ENDP			; Modulation::setModDepth
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\Modulation.h
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File E:\FoxSuite\shimmer\include\Modulation.h
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File E:\FoxSuite\shimmer\include\LFO.h
; File E:\FoxSuite\shimmer\include\Modulation.h
;	COMDAT ?setModRate@Modulation@@QEAAXM@Z
_TEXT	SEGMENT
this$ = 8
rate$ = 16
?setModRate@Modulation@@QEAAXM@Z PROC			; Modulation::setModRate, COMDAT
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 90   : 		mdly_LFO->setLFOfrequency(mdly_rate);

	mov	rax, QWORD PTR [rcx+104]
; File E:\FoxSuite\shimmer\include\Modulation.h

; 67   : 		mod_rate = rate;

	movss	DWORD PTR [rcx+164], xmm1
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 89   : 		mdly_rate = modRate;

	movss	DWORD PTR [rcx+136], xmm1
	movd	xmm0, DWORD PTR [rax+4]
; File E:\FoxSuite\shimmer\include\LFO.h

; 71   : 		lfo_frequency = frequency;

	movss	DWORD PTR [rax], xmm1

; 122  : 		lfo_inc = WAVETABLE_SIZE * lfo_frequency / (float)lfo_sampleRate;

	mulss	xmm1, DWORD PTR __real@45800000
	cvtdq2ps xmm0, xmm0
	divss	xmm1, xmm0
	movss	DWORD PTR [rax+20], xmm1
; File E:\FoxSuite\shimmer\include\Modulation.h

; 69   : 	}

	ret	0
?setModRate@Modulation@@QEAAXM@Z ENDP			; Modulation::setModRate
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\Modulation.h
;	COMDAT ?setModFeedback@Modulation@@QEAAXM@Z
_TEXT	SEGMENT
this$ = 8
fb$ = 16
?setModFeedback@Modulation@@QEAAXM@Z PROC		; Modulation::setModFeedback, COMDAT

; 72   : 		mod_fb = fb;

	movss	DWORD PTR [rcx+160], xmm1

; 73   : 		ModDelay::setFeedback(fb);

	movss	DWORD PTR [rcx+72], xmm1

; 74   : 	}

	ret	0
?setModFeedback@Modulation@@QEAAXM@Z ENDP		; Modulation::setModFeedback
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\Modulation.h
;	COMDAT ?setModMix@Modulation@@QEAAXM@Z
_TEXT	SEGMENT
this$ = 8
mix$ = 16
?setModMix@Modulation@@QEAAXM@Z PROC			; Modulation::setModMix, COMDAT

; 77   : 		mod_mix = mix;

	movss	DWORD PTR [rcx+156], xmm1

; 78   : 	}

	ret	0
?setModMix@Modulation@@QEAAXM@Z ENDP			; Modulation::setModMix
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\Modulation.h
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File E:\FoxSuite\shimmer\include\LFO.h
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File E:\FoxSuite\shimmer\include\Modulation.h
;	COMDAT ?setSampleRate@Modulation@@UEAAXH@Z
_TEXT	SEGMENT
this$ = 8
sampleRate$ = 16
?setSampleRate@Modulation@@UEAAXH@Z PROC		; Modulation::setSampleRate, COMDAT
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 104  : 		mdly_LFO->setSampleRate(sampleRate);

	mov	rax, QWORD PTR [rcx+104]
	movd	xmm0, edx
; File E:\FoxSuite\shimmer\include\LFO.h

; 122  : 		lfo_inc = WAVETABLE_SIZE * lfo_frequency / (float)lfo_sampleRate;

	cvtdq2ps xmm0, xmm0

; 94   : 		lfo_sampleRate = sampleRate;

	mov	DWORD PTR [rax+4], edx

; 122  : 		lfo_inc = WAVETABLE_SIZE * lfo_frequency / (float)lfo_sampleRate;

	movss	xmm1, DWORD PTR [rax]
	mulss	xmm1, DWORD PTR __real@45800000
	divss	xmm1, xmm0
	movss	DWORD PTR [rax+20], xmm1
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 105  : 		LPCombFilter::setSampleRate(sampleRate);

	jmp	?setSampleRate@Delay@@UEAAXH@Z		; Delay::setSampleRate
?setSampleRate@Modulation@@UEAAXH@Z ENDP		; Modulation::setSampleRate
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\Modulation.h
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File E:\FoxSuite\shimmer\include\LFO.h
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File E:\FoxSuite\shimmer\include\src\Delay.cpp
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File E:\FoxSuite\shimmer\include\src\Delay.cpp
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File E:\FoxSuite\shimmer\include\src\Delay.cpp
; File E:\FoxSuite\shimmer\include\Modulation.h
;	COMDAT ?setModType@Modulation@@QEAAXW4ModulationType@@@Z
_TEXT	SEGMENT
this$ = 48
modType$dead$ = 56
?setModType@Modulation@@QEAAXW4ModulationType@@@Z PROC	; Modulation::setModType, COMDAT

; 84   : 	void setModType(ModulationType modType) {

$LN29:
	push	rbx
	sub	rsp, 32					; 00000020H

; 85   : 		mod_type = modType;

	mov	DWORD PTR [rcx+144], 1
	mov	rbx, rcx
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 94   : 		mdly_lfoWaveform = wave;

	mov	DWORD PTR [rcx+116], 1

; 95   : 		mdly_LFO->setLFOWaveform(wave);

	mov	rcx, QWORD PTR [rcx+104]
; File E:\FoxSuite\shimmer\include\LFO.h

; 132  : 		lfo_table.clear();

	mov	rax, QWORD PTR [rcx+24]
	mov	QWORD PTR [rcx+32], rax

; 76   : 		lfo_waveform = waveform;

	mov	DWORD PTR [rcx+12], 1

; 77   : 		clearTable();
; 78   : 		createTable();

	call	?createTable@LFO@@AEAAXXZ		; LFO::createTable
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 100  : 		mdly_LFO->setLFOunipolar(isUnipolar);

	mov	rax, QWORD PTR [rbx+104]
; File E:\FoxSuite\shimmer\include\src\Delay.cpp

; 118  : 	if (delayInmsec > dly_lineLengthInmsec)

	movss	xmm1, DWORD PTR __real@3dcccccd
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 99   : 		mdly_isUnipolar = isUnipolar;

	mov	BYTE PTR [rbx+112], 1

; 100  : 		mdly_LFO->setLFOunipolar(isUnipolar);

	mov	BYTE PTR [rax+48], 1
; File E:\FoxSuite\shimmer\include\src\Delay.cpp

; 118  : 	if (delayInmsec > dly_lineLengthInmsec)

	movss	xmm0, DWORD PTR [rbx+16]
	comiss	xmm0, xmm1
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 84   : 		mdly_meanDelayValue = delay;

	mov	DWORD PTR [rbx+120], 1036831949		; 3dcccccdH
; File E:\FoxSuite\shimmer\include\src\Delay.cpp

; 118  : 	if (delayInmsec > dly_lineLengthInmsec)

	jb	SHORT $LN22@setModType

; 119  : 		delayInmsec = dly_lineLengthInmsec;
; 120  : 	else if (delayInmsec < 0.0)
; 121  : 		delayInmsec = 0.0;

	movaps	xmm0, xmm1
$LN22@setModType:

; 122  : 
; 123  : 	// Set delay line length in milliseconds
; 124  : 	dly_delayInmsec = delayInmsec;
; 125  : 
; 126  : 	// Update parameters based on new delay length
; 127  : 	updateParameters();

	mov	rcx, rbx
	movss	DWORD PTR [rbx+24], xmm0
	call	?updateParameters@Delay@@AEAAXXZ	; Delay::updateParameters
; File E:\FoxSuite\shimmer\include\Modulation.h

; 38   : 		mod_modValue = modVal;

	mov	eax, 1084017869				; 409ccccdH

; 157  : 		setModWet(wet);

	mov	DWORD PTR [rbx+148], 1065353216		; 3f800000H

; 38   : 		mod_modValue = modVal;

	mov	DWORD PTR [rbx+172], eax

; 39   : 		ModDelay::setDeltaDelayValue(modVal);

	mov	DWORD PTR [rbx+124], eax

; 86   : 		OscillatorType lfo_type = OscillatorType::Triangular;
; 87   : 
; 88   : 		float feedback = 0.0;
; 89   : 		float wet = 1.0;
; 90   : 		float dry = 0.0;
; 91   : 		bool isUnipolar = true;
; 92   : 		float meanDel = 0.0;
; 93   : 		float deltaDel = 0.0;
; 94   : 		float minDel, maxDel;
; 95   : 		float mix = 0.0;
; 96   : 
; 97   : 		switch (mod_type) {
; 98   : 		case ModulationType::Flanger: {
; 99   : 			minDel = 1.0;
; 100  : 			maxDel = 7.0;
; 101  : 			wet = 0.5;
; 102  : 			dry = 0.5;
; 103  : 			mix = 0.5;
; 104  : 			feedback = 0.0;
; 105  : 			lfo_type = OscillatorType::Triangular;
; 106  : 			isUnipolar = true;
; 107  : 			meanDel = minDel;
; 108  : 			deltaDel = (maxDel - minDel);
; 109  : 			break;
; 110  : 		}
; 111  : 
; 112  : 		case ModulationType::Vibrato: {
; 113  : 			minDel = 0.1;
; 114  : 			maxDel = 5.0;
; 115  : 			wet = 1.0;
; 116  : 			dry = 0.0;
; 117  : 			feedback = 0.0;
; 118  : 			lfo_type = OscillatorType::Sine;
; 119  : 			isUnipolar = true;
; 120  : 			meanDel = minDel;
; 121  : 			deltaDel = (maxDel - minDel);
; 122  : 			break;
; 123  : 		}
; 124  : 
; 125  : 		case ModulationType::Chorus: {
; 126  : 			minDel = 1.0;
; 127  : 			maxDel = 20.0;
; 128  : 			wet = 0.5;
; 129  : 			dry = 1.0;
; 130  : 			feedback = 0.0;
; 131  : 			lfo_type = OscillatorType::Triangular;
; 132  : 			isUnipolar = false;
; 133  : 			deltaDel = (maxDel - minDel) / 2.0;
; 134  : 			meanDel = minDel + deltaDel;
; 135  : 			break;
; 136  : 		}
; 137  : 		case ModulationType::WhiteChorus: {
; 138  : 			minDel = 1.0;
; 139  : 			maxDel = 20.0;
; 140  : 			wet = 0.5;
; 141  : 			dry = 1.0;
; 142  : 			feedback = 0.7;
; 143  : 			lfo_type = OscillatorType::Triangular;
; 144  : 			isUnipolar = false;
; 145  : 			deltaDel = (maxDel - minDel) / 2.0;
; 146  : 			meanDel = minDel + deltaDel;
; 147  : 			break;
; 148  : 		}
; 149  : 		}
; 150  : 
; 151  : 		ModDelay::setLFOWaveform(lfo_type);
; 152  : 		ModDelay::setLFOUnipolar(isUnipolar);
; 153  : 		ModDelay::setDelayInmsec(meanDel);
; 154  : 		setModulationValue(deltaDel);
; 155  : 		setModMix(mix);

	xor	eax, eax

; 156  : 		setModDry(dry);

	mov	QWORD PTR [rbx+152], rax

; 72   : 		mod_fb = fb;

	mov	DWORD PTR [rbx+160], eax

; 73   : 		ModDelay::setFeedback(fb);

	mov	DWORD PTR [rbx+72], eax

; 158  : 		setModFeedback(feedback);
; 159  : 	}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?setModType@Modulation@@QEAAXW4ModulationType@@@Z ENDP	; Modulation::setModType
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\Modulation.h
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File E:\FoxSuite\shimmer\include\Modulation.h
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File E:\FoxSuite\shimmer\include\src\Delay.cpp
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File E:\FoxSuite\shimmer\include\src\Delay.cpp
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File E:\FoxSuite\shimmer\include\Modulation.h
;	COMDAT ?processAudio@Modulation@@UEAAMM@Z
_TEXT	SEGMENT
this$ = 64
xn$ = 72
?processAudio@Modulation@@UEAAMM@Z PROC			; Modulation::processAudio, COMDAT

; 161  : 	float processAudio(float xn) {	

$LN11:
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	rbx, rcx
	movaps	XMMWORD PTR [rsp+32], xmm6
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 110  : 		float newDelayInmsec = mdly_meanDelayValue + mdly_deltaDelayValue * mdly_LFO->processAudio();

	mov	rcx, QWORD PTR [rcx+104]
; File E:\FoxSuite\shimmer\include\Modulation.h

; 161  : 	float processAudio(float xn) {	

	movaps	xmm6, xmm1
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 110  : 		float newDelayInmsec = mdly_meanDelayValue + mdly_deltaDelayValue * mdly_LFO->processAudio();

	call	?processAudio@LFO@@QEAAMXZ		; LFO::processAudio
	mulss	xmm0, DWORD PTR [rbx+124]
; File E:\FoxSuite\shimmer\include\src\Delay.cpp

; 118  : 	if (delayInmsec > dly_lineLengthInmsec)

	movss	xmm2, DWORD PTR [rbx+16]
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 110  : 		float newDelayInmsec = mdly_meanDelayValue + mdly_deltaDelayValue * mdly_LFO->processAudio();

	addss	xmm0, DWORD PTR [rbx+120]
; File E:\FoxSuite\shimmer\include\src\Delay.cpp

; 118  : 	if (delayInmsec > dly_lineLengthInmsec)

	comiss	xmm0, xmm2
	ja	SHORT $LN8@processAud

; 119  : 		delayInmsec = dly_lineLengthInmsec;
; 120  : 	else if (delayInmsec < 0.0)

	movaps	xmm2, xmm0
	maxss	xmm2, DWORD PTR __real@00000000
$LN8@processAud:

; 121  : 		delayInmsec = 0.0;
; 122  : 
; 123  : 	// Set delay line length in milliseconds
; 124  : 	dly_delayInmsec = delayInmsec;
; 125  : 
; 126  : 	// Update parameters based on new delay length
; 127  : 	updateParameters();

	mov	rcx, rbx
	movss	DWORD PTR [rbx+24], xmm2
	call	?updateParameters@Delay@@AEAAXXZ	; Delay::updateParameters
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 116  : 		float yn = LPCombFilter::processAudio(xn);

	movaps	xmm1, xmm6
	mov	rcx, rbx
	call	?processAudio@LPCombFilter@@UEAAMM@Z	; LPCombFilter::processAudio
; File E:\FoxSuite\shimmer\include\Modulation.h

; 163  : 		return mod_dry * xn + mod_wet * yn;

	mulss	xmm6, DWORD PTR [rbx+152]
	mulss	xmm0, DWORD PTR [rbx+148]
	addss	xmm0, xmm6

; 164  : 	}

	movaps	xmm6, XMMWORD PTR [rsp+32]
	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
?processAudio@Modulation@@UEAAMM@Z ENDP			; Modulation::processAudio
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
;	COMDAT ??0FDN@@QEAA@HHHHH@Z
_TEXT	SEGMENT
this$ = 64
numChIn$ = 72
numChInt$dead$ = 80
numChOut$dead$ = 88
numDiffStep$dead$ = 96
numModDiffusers$dead$ = 104
??0FDN@@QEAA@HHHHH@Z PROC				; FDN::FDN, COMDAT

; 121  : 	FDN(int numChIn, int numChInt, int numChOut, int numDiffStep, int numModDiffusers) {

$LN61:
	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	rbx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx+24], rax
	mov	QWORD PTR [rcx+32], rax
	mov	QWORD PTR [rcx+40], rax
	mov	QWORD PTR [rcx+48], rax
	mov	QWORD PTR [rcx+56], rax
	mov	QWORD PTR [rcx+64], rax
	mov	QWORD PTR [rcx+80], rax
	mov	QWORD PTR [rcx+88], rax
	mov	QWORD PTR [rcx+96], rax
	mov	QWORD PTR [rcx+104], rax
	mov	QWORD PTR [rcx+112], rax
	mov	QWORD PTR [rcx+120], rax
	mov	QWORD PTR [rcx+144], rax
	mov	QWORD PTR [rcx+152], rax
	mov	QWORD PTR [rcx+160], rax
	mov	QWORD PTR [rcx+192], rax
	mov	QWORD PTR [rcx+200], rax
	mov	QWORD PTR [rcx+208], rax
	mov	QWORD PTR [rcx+216], rax
	mov	QWORD PTR [rcx+224], rax
	mov	QWORD PTR [rcx+232], rax
	mov	QWORD PTR [rcx+240], rax
	mov	QWORD PTR [rcx+248], rax
	mov	QWORD PTR [rcx+256], rax
; File E:\FoxSuite\shimmer\include\FDN.h

; 122  : 		constructFDN(numChIn, numChInt, numChOut, numDiffStep, numModDiffusers);

	call	?constructFDN@FDN@@AEAAXHHHHH@Z		; FDN::constructFDN
	npad	1

; 123  : 	}

	mov	rax, rbx
	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
??0FDN@@QEAA@HHHHH@Z ENDP				; FDN::FDN
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
this$ = 64
numChIn$ = 72
numChInt$dead$ = 80
numChOut$dead$ = 88
numDiffStep$dead$ = 96
numModDiffusers$dead$ = 104
?dtor$0@?0???0FDN@@QEAA@HHHHH@Z@4HA PROC		; `FDN::FDN'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 24
	jmp	??1?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEAA@XZ ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::~vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >
?dtor$0@?0???0FDN@@QEAA@HHHHH@Z@4HA ENDP		; `FDN::FDN'::`1'::dtor$0
this$ = 64
numChIn$ = 72
numChInt$dead$ = 80
numChOut$dead$ = 88
numDiffStep$dead$ = 96
numModDiffusers$dead$ = 104
?dtor$1@?0???0FDN@@QEAA@HHHHH@Z@4HA PROC		; `FDN::FDN'::`1'::dtor$1
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 48					; 00000030H
	jmp	??1?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEAA@XZ ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::~vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >
?dtor$1@?0???0FDN@@QEAA@HHHHH@Z@4HA ENDP		; `FDN::FDN'::`1'::dtor$1
this$ = 64
numChIn$ = 72
numChInt$dead$ = 80
numChOut$dead$ = 88
numDiffStep$dead$ = 96
numModDiffusers$dead$ = 104
?dtor$2@?0???0FDN@@QEAA@HHHHH@Z@4HA PROC		; `FDN::FDN'::`1'::dtor$2
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 80					; 00000050H
	jmp	??1?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEAA@XZ ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::~vector<LowPassFilter *,std::allocator<LowPassFilter *> >
?dtor$2@?0???0FDN@@QEAA@HHHHH@Z@4HA ENDP		; `FDN::FDN'::`1'::dtor$2
this$ = 64
numChIn$ = 72
numChInt$dead$ = 80
numChOut$dead$ = 88
numDiffStep$dead$ = 96
numModDiffusers$dead$ = 104
?dtor$3@?0???0FDN@@QEAA@HHHHH@Z@4HA PROC		; `FDN::FDN'::`1'::dtor$3
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 104				; 00000068H
	jmp	??1?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@QEAA@XZ ; std::vector<Modulation *,std::allocator<Modulation *> >::~vector<Modulation *,std::allocator<Modulation *> >
?dtor$3@?0???0FDN@@QEAA@HHHHH@Z@4HA ENDP		; `FDN::FDN'::`1'::dtor$3
this$ = 64
numChIn$ = 72
numChInt$dead$ = 80
numChOut$dead$ = 88
numDiffStep$dead$ = 96
numModDiffusers$dead$ = 104
?dtor$4@?0???0FDN@@QEAA@HHHHH@Z@4HA PROC		; `FDN::FDN'::`1'::dtor$4
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 144				; 00000090H
	jmp	??1?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEAA@XZ ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::~vector<HighPassFilter *,std::allocator<HighPassFilter *> >
?dtor$4@?0???0FDN@@QEAA@HHHHH@Z@4HA ENDP		; `FDN::FDN'::`1'::dtor$4
this$ = 64
numChIn$ = 72
numChInt$dead$ = 80
numChOut$dead$ = 88
numDiffStep$dead$ = 96
numModDiffusers$dead$ = 104
?dtor$5@?0???0FDN@@QEAA@HHHHH@Z@4HA PROC		; `FDN::FDN'::`1'::dtor$5
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 192				; 000000c0H
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$5@?0???0FDN@@QEAA@HHHHH@Z@4HA ENDP		; `FDN::FDN'::`1'::dtor$5
this$ = 64
numChIn$ = 72
numChInt$dead$ = 80
numChOut$dead$ = 88
numDiffStep$dead$ = 96
numModDiffusers$dead$ = 104
?dtor$6@?0???0FDN@@QEAA@HHHHH@Z@4HA PROC		; `FDN::FDN'::`1'::dtor$6
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 216				; 000000d8H
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$6@?0???0FDN@@QEAA@HHHHH@Z@4HA ENDP		; `FDN::FDN'::`1'::dtor$6
this$ = 64
numChIn$ = 72
numChInt$dead$ = 80
numChOut$dead$ = 88
numDiffStep$dead$ = 96
numModDiffusers$dead$ = 104
?dtor$7@?0???0FDN@@QEAA@HHHHH@Z@4HA PROC		; `FDN::FDN'::`1'::dtor$7
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 240				; 000000f0H
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$7@?0???0FDN@@QEAA@HHHHH@Z@4HA ENDP		; `FDN::FDN'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
this$ = 64
numChIn$ = 72
numChInt$dead$ = 80
numChOut$dead$ = 88
numDiffStep$dead$ = 96
numModDiffusers$dead$ = 104
?dtor$0@?0???0FDN@@QEAA@HHHHH@Z@4HA PROC		; `FDN::FDN'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 24
	jmp	??1?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEAA@XZ ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::~vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >
?dtor$0@?0???0FDN@@QEAA@HHHHH@Z@4HA ENDP		; `FDN::FDN'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
this$ = 64
numChIn$ = 72
numChInt$dead$ = 80
numChOut$dead$ = 88
numDiffStep$dead$ = 96
numModDiffusers$dead$ = 104
?dtor$1@?0???0FDN@@QEAA@HHHHH@Z@4HA PROC		; `FDN::FDN'::`1'::dtor$1
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 48					; 00000030H
	jmp	??1?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEAA@XZ ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::~vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >
?dtor$1@?0???0FDN@@QEAA@HHHHH@Z@4HA ENDP		; `FDN::FDN'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
this$ = 64
numChIn$ = 72
numChInt$dead$ = 80
numChOut$dead$ = 88
numDiffStep$dead$ = 96
numModDiffusers$dead$ = 104
?dtor$2@?0???0FDN@@QEAA@HHHHH@Z@4HA PROC		; `FDN::FDN'::`1'::dtor$2
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 80					; 00000050H
	jmp	??1?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEAA@XZ ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::~vector<LowPassFilter *,std::allocator<LowPassFilter *> >
?dtor$2@?0???0FDN@@QEAA@HHHHH@Z@4HA ENDP		; `FDN::FDN'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
this$ = 64
numChIn$ = 72
numChInt$dead$ = 80
numChOut$dead$ = 88
numDiffStep$dead$ = 96
numModDiffusers$dead$ = 104
?dtor$3@?0???0FDN@@QEAA@HHHHH@Z@4HA PROC		; `FDN::FDN'::`1'::dtor$3
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 104				; 00000068H
	jmp	??1?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@QEAA@XZ ; std::vector<Modulation *,std::allocator<Modulation *> >::~vector<Modulation *,std::allocator<Modulation *> >
?dtor$3@?0???0FDN@@QEAA@HHHHH@Z@4HA ENDP		; `FDN::FDN'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
this$ = 64
numChIn$ = 72
numChInt$dead$ = 80
numChOut$dead$ = 88
numDiffStep$dead$ = 96
numModDiffusers$dead$ = 104
?dtor$4@?0???0FDN@@QEAA@HHHHH@Z@4HA PROC		; `FDN::FDN'::`1'::dtor$4
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 144				; 00000090H
	jmp	??1?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEAA@XZ ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::~vector<HighPassFilter *,std::allocator<HighPassFilter *> >
?dtor$4@?0???0FDN@@QEAA@HHHHH@Z@4HA ENDP		; `FDN::FDN'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
this$ = 64
numChIn$ = 72
numChInt$dead$ = 80
numChOut$dead$ = 88
numDiffStep$dead$ = 96
numModDiffusers$dead$ = 104
?dtor$5@?0???0FDN@@QEAA@HHHHH@Z@4HA PROC		; `FDN::FDN'::`1'::dtor$5
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 192				; 000000c0H
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$5@?0???0FDN@@QEAA@HHHHH@Z@4HA ENDP		; `FDN::FDN'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
this$ = 64
numChIn$ = 72
numChInt$dead$ = 80
numChOut$dead$ = 88
numDiffStep$dead$ = 96
numModDiffusers$dead$ = 104
?dtor$6@?0???0FDN@@QEAA@HHHHH@Z@4HA PROC		; `FDN::FDN'::`1'::dtor$6
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 216				; 000000d8H
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$6@?0???0FDN@@QEAA@HHHHH@Z@4HA ENDP		; `FDN::FDN'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
this$ = 64
numChIn$ = 72
numChInt$dead$ = 80
numChOut$dead$ = 88
numDiffStep$dead$ = 96
numModDiffusers$dead$ = 104
?dtor$7@?0???0FDN@@QEAA@HHHHH@Z@4HA PROC		; `FDN::FDN'::`1'::dtor$7
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 240				; 000000f0H
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$7@?0???0FDN@@QEAA@HHHHH@Z@4HA ENDP		; `FDN::FDN'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\Hadamard.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File E:\FoxSuite\shimmer\include\FDN.h
;	COMDAT ??1FDN@@QEAA@XZ
_TEXT	SEGMENT
this$ = 64
??1FDN@@QEAA@XZ PROC					; FDN::~FDN, COMDAT

; 126  : 	~FDN() { 

$LN368:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	push	r13
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 575  : 		delete fdn_Splitter;

	xor	r15d, r15d
	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN14@FDN
	lea	edx, QWORD PTR [r15+8]
	call	??3@YAXPEAX_K@Z				; operator delete
$LN14@FDN:

; 576  : 		delete fdn_Mixer;

	mov	rcx, QWORD PTR [rbx+8]
	test	rcx, rcx
	je	SHORT $LN17@FDN
	mov	edx, 12
	call	??3@YAXPEAX_K@Z				; operator delete
$LN17@FDN:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1544 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	rdx, QWORD PTR [rbx+24]
	mov	r13d, 48				; 00000030H
	mov	rax, QWORD PTR [rbx+32]
	cmp	rdx, rax
; File E:\FoxSuite\shimmer\include\FDN.h

; 582  : 		if (!fdn_Diffuser.empty()) {

	je	SHORT $LN26@FDN
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	rax, rdx
; File E:\FoxSuite\shimmer\include\FDN.h

; 584  : 			for (int i = 0; i < fdn_Diffuser.size(); i++) 

	mov	ebp, r15d
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	rax, 3
; File E:\FoxSuite\shimmer\include\FDN.h

; 584  : 			for (int i = 0; i < fdn_Diffuser.size(); i++) 

	test	rax, rax
	je	SHORT $LN21@FDN
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1548 :         auto& _My_data = _Mypair._Myval2;

	mov	rsi, r15
$LL22@FDN:
; File E:\FoxSuite\shimmer\include\FDN.h

; 585  : 				delete fdn_Diffuser[i];

	mov	rdi, QWORD PTR [rsi+rdx]
	test	rdi, rdi
	je	SHORT $LN20@FDN
	mov	rcx, rdi
	call	??1MultiChannelDiffuser@@QEAA@XZ	; MultiChannelDiffuser::~MultiChannelDiffuser
	mov	rdx, r13
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN20@FDN:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR [rbx+24]
; File E:\FoxSuite\shimmer\include\FDN.h

; 584  : 			for (int i = 0; i < fdn_Diffuser.size(); i++) 

	inc	ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rbx+32]
; File E:\FoxSuite\shimmer\include\FDN.h

; 584  : 			for (int i = 0; i < fdn_Diffuser.size(); i++) 

	add	rsi, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	rcx, rdx
; File E:\FoxSuite\shimmer\include\FDN.h

; 584  : 			for (int i = 0; i < fdn_Diffuser.size(); i++) 

	movsxd	rax, ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	rcx, 3
; File E:\FoxSuite\shimmer\include\FDN.h

; 584  : 			for (int i = 0; i < fdn_Diffuser.size(); i++) 

	cmp	rax, rcx
	jb	SHORT $LL22@FDN
$LN21@FDN:

; 586  : 
; 587  : 			// "clear" calls distructors as well (if present)
; 588  : 			fdn_Diffuser.clear();

	mov	QWORD PTR [rbx+32], rdx
$LN26@FDN:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1544 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	rdx, QWORD PTR [rbx+48]
	mov	rax, QWORD PTR [rbx+56]
	cmp	rdx, rax
; File E:\FoxSuite\shimmer\include\FDN.h

; 592  : 		if (!fdn_ModDiffuser.empty()) {

	je	SHORT $LN27@FDN
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	rax, rdx
; File E:\FoxSuite\shimmer\include\FDN.h

; 593  : 			for (int i = 0; i < fdn_ModDiffuser.size(); i++)

	mov	ebp, r15d
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	rax, 3
; File E:\FoxSuite\shimmer\include\FDN.h

; 593  : 			for (int i = 0; i < fdn_ModDiffuser.size(); i++)

	test	rax, rax
	je	SHORT $LN24@FDN
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1548 :         auto& _My_data = _Mypair._Myval2;

	mov	rsi, r15
$LL25@FDN:
; File E:\FoxSuite\shimmer\include\FDN.h

; 594  : 				delete fdn_ModDiffuser[i];

	mov	rdi, QWORD PTR [rsi+rdx]
	test	rdi, rdi
	je	SHORT $LN23@FDN
	mov	rcx, rdi
	call	??1ModMultiChannelDiffuser@@QEAA@XZ	; ModMultiChannelDiffuser::~ModMultiChannelDiffuser
	mov	rdx, r13
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN23@FDN:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR [rbx+48]
; File E:\FoxSuite\shimmer\include\FDN.h

; 593  : 			for (int i = 0; i < fdn_ModDiffuser.size(); i++)

	inc	ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rbx+56]
; File E:\FoxSuite\shimmer\include\FDN.h

; 593  : 			for (int i = 0; i < fdn_ModDiffuser.size(); i++)

	add	rsi, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	rcx, rdx
; File E:\FoxSuite\shimmer\include\FDN.h

; 593  : 			for (int i = 0; i < fdn_ModDiffuser.size(); i++)

	movsxd	rax, ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	rcx, 3
; File E:\FoxSuite\shimmer\include\FDN.h

; 593  : 			for (int i = 0; i < fdn_ModDiffuser.size(); i++)

	cmp	rax, rcx
	jb	SHORT $LL25@FDN
$LN24@FDN:

; 595  : 			fdn_ModDiffuser.clear();

	mov	QWORD PTR [rbx+56], rdx
$LN27@FDN:

; 596  : 		}
; 597  : 
; 598  : 		// Delete output diffuser
; 599  : 		delete fdn_OutputDiffusion;

	mov	rdi, QWORD PTR [rbx+136]
	test	rdi, rdi
	je	SHORT $LN54@FDN
	mov	rcx, rdi
	call	??1MultiChannelDiffuser@@QEAA@XZ	; MultiChannelDiffuser::~MultiChannelDiffuser
	mov	rdx, r13
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN54@FDN:

; 604  : 		delete fdn_Feedback;

	mov	rdi, QWORD PTR [rbx+72]
	test	rdi, rdi
	je	SHORT $LN61@FDN
	mov	rcx, rdi
	call	??1ModMultiChannelFeedback@@QEAA@XZ	; ModMultiChannelFeedback::~ModMultiChannelFeedback
	mov	edx, 72					; 00000048H
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN61@FDN:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1544 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	rax, QWORD PTR [rbx+192]
	cmp	rax, QWORD PTR [rbx+200]
; File E:\FoxSuite\shimmer\include\FDN.h

; 639  : 		if (!fdn_tmpDiffuser.empty())

	je	SHORT $LN64@FDN

; 640  : 			fdn_tmpDiffuser.clear();

	mov	QWORD PTR [rbx+200], rax
$LN64@FDN:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1544 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	rax, QWORD PTR [rbx+216]
	cmp	rax, QWORD PTR [rbx+224]
; File E:\FoxSuite\shimmer\include\FDN.h

; 641  : 		if (!fdn_tmpFeedback.empty())

	je	SHORT $LN65@FDN

; 642  : 			fdn_tmpFeedback.clear();

	mov	QWORD PTR [rbx+224], rax
$LN65@FDN:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1544 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	rax, QWORD PTR [rbx+240]
	cmp	rax, QWORD PTR [rbx+248]
; File E:\FoxSuite\shimmer\include\FDN.h

; 643  : 		if (!fdn_outEarly.empty())		

	je	SHORT $LN66@FDN

; 644  : 			fdn_outEarly.clear();				

	mov	QWORD PTR [rbx+248], rax
$LN66@FDN:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1544 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	rdx, QWORD PTR [rbx+80]
	mov	ebp, 60					; 0000003cH
	mov	rax, QWORD PTR [rbx+88]
	cmp	rdx, rax
; File E:\FoxSuite\shimmer\include\FDN.h

; 609  : 		if (!fdn_LPFOutput.empty()) {

	je	SHORT $LN81@FDN
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	rax, rdx
; File E:\FoxSuite\shimmer\include\FDN.h

; 610  : 			for (int i = 0; i < fdn_LPFOutput.size(); i++)

	mov	esi, r15d
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	rax, 3
; File E:\FoxSuite\shimmer\include\FDN.h

; 610  : 			for (int i = 0; i < fdn_LPFOutput.size(); i++)

	test	rax, rax
	je	SHORT $LN76@FDN
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1548 :         auto& _My_data = _Mypair._Myval2;

	mov	rdi, r15
$LL77@FDN:
; File E:\FoxSuite\shimmer\include\FDN.h

; 611  : 				delete fdn_LPFOutput[i];

	mov	rcx, QWORD PTR [rdi+rdx]
	test	rcx, rcx
	je	SHORT $LN75@FDN
	mov	rdx, rbp
	call	??3@YAXPEAX_K@Z				; operator delete
$LN75@FDN:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR [rbx+80]
; File E:\FoxSuite\shimmer\include\FDN.h

; 610  : 			for (int i = 0; i < fdn_LPFOutput.size(); i++)

	inc	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rbx+88]
; File E:\FoxSuite\shimmer\include\FDN.h

; 610  : 			for (int i = 0; i < fdn_LPFOutput.size(); i++)

	add	rdi, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	rcx, rdx
; File E:\FoxSuite\shimmer\include\FDN.h

; 610  : 			for (int i = 0; i < fdn_LPFOutput.size(); i++)

	movsxd	rax, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	rcx, 3
; File E:\FoxSuite\shimmer\include\FDN.h

; 610  : 			for (int i = 0; i < fdn_LPFOutput.size(); i++)

	cmp	rax, rcx
	jb	SHORT $LL77@FDN
$LN76@FDN:

; 612  : 			fdn_LPFOutput.clear();

	mov	QWORD PTR [rbx+88], rdx
$LN81@FDN:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1544 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	rdx, QWORD PTR [rbx+144]
	mov	rax, QWORD PTR [rbx+152]
	cmp	rdx, rax
; File E:\FoxSuite\shimmer\include\FDN.h

; 614  : 		if (!fdn_HPFOutput.empty()) {

	je	SHORT $LN82@FDN
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	rax, rdx
; File E:\FoxSuite\shimmer\include\FDN.h

; 615  : 			for (int i = 0; i < fdn_HPFOutput.size(); i++)

	mov	esi, r15d
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	rax, 3
; File E:\FoxSuite\shimmer\include\FDN.h

; 615  : 			for (int i = 0; i < fdn_HPFOutput.size(); i++)

	test	rax, rax
	je	SHORT $LN79@FDN
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1548 :         auto& _My_data = _Mypair._Myval2;

	mov	rdi, r15
$LL80@FDN:
; File E:\FoxSuite\shimmer\include\FDN.h

; 616  : 				delete fdn_HPFOutput[i];

	mov	rcx, QWORD PTR [rdi+rdx]
	test	rcx, rcx
	je	SHORT $LN78@FDN
	mov	rdx, rbp
	call	??3@YAXPEAX_K@Z				; operator delete
$LN78@FDN:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR [rbx+144]
; File E:\FoxSuite\shimmer\include\FDN.h

; 615  : 			for (int i = 0; i < fdn_HPFOutput.size(); i++)

	inc	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rbx+152]
; File E:\FoxSuite\shimmer\include\FDN.h

; 615  : 			for (int i = 0; i < fdn_HPFOutput.size(); i++)

	add	rdi, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	rcx, rdx
; File E:\FoxSuite\shimmer\include\FDN.h

; 615  : 			for (int i = 0; i < fdn_HPFOutput.size(); i++)

	movsxd	rax, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	rcx, 3
; File E:\FoxSuite\shimmer\include\FDN.h

; 615  : 			for (int i = 0; i < fdn_HPFOutput.size(); i++)

	cmp	rax, rcx
	jb	SHORT $LL80@FDN
$LN79@FDN:

; 617  : 			fdn_HPFOutput.clear();

	mov	QWORD PTR [rbx+152], rdx
$LN82@FDN:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1544 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	rdx, QWORD PTR [rbx+104]
	mov	rax, QWORD PTR [rbx+112]
	cmp	rdx, rax
; File E:\FoxSuite\shimmer\include\FDN.h

; 623  : 		if (!fdn_Modulation.empty()) {

	je	SHORT $LN110@FDN
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	rax, rdx
; File E:\FoxSuite\shimmer\include\FDN.h

; 624  : 			for (int i = 0; i < fdn_Modulation.size(); i++)

	mov	ebp, r15d
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	rax, 3
; File E:\FoxSuite\shimmer\include\FDN.h

; 624  : 			for (int i = 0; i < fdn_Modulation.size(); i++)

	test	rax, rax
	je	SHORT $LN108@FDN
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1548 :         auto& _My_data = _Mypair._Myval2;

	mov	r14, r15
$LL109@FDN:
; File E:\FoxSuite\shimmer\include\FDN.h

; 625  : 				delete fdn_Modulation[i];

	mov	rdi, QWORD PTR [r14+rdx]
	test	rdi, rdi
	je	SHORT $LN107@FDN
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 51   : 		delete mdly_LFO;

	mov	rsi, QWORD PTR [rdi+104]
	lea	rax, OFFSET FLAT:??_7ModDelay@@6B@
	mov	QWORD PTR [rdi], rax
	test	rsi, rsi
	je	SHORT $LN132@FDN
	mov	rcx, rsi
	call	??1LFO@@QEAA@XZ				; LFO::~LFO
	mov	edx, 56					; 00000038H
	mov	rcx, rsi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN132@FDN:

; 52   : 	}

	mov	rcx, rdi
	call	??1LPCombFilter@@QEAA@XZ		; LPCombFilter::~LPCombFilter
	mov	edx, 176				; 000000b0H
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN107@FDN:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR [rbx+104]
; File E:\FoxSuite\shimmer\include\FDN.h

; 624  : 			for (int i = 0; i < fdn_Modulation.size(); i++)

	inc	ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rbx+112]
; File E:\FoxSuite\shimmer\include\FDN.h

; 624  : 			for (int i = 0; i < fdn_Modulation.size(); i++)

	add	r14, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	rcx, rdx
; File E:\FoxSuite\shimmer\include\FDN.h

; 624  : 			for (int i = 0; i < fdn_Modulation.size(); i++)

	movsxd	rax, ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	rcx, 3
; File E:\FoxSuite\shimmer\include\FDN.h

; 624  : 			for (int i = 0; i < fdn_Modulation.size(); i++)

	cmp	rax, rcx
	jb	SHORT $LL109@FDN
$LN108@FDN:

; 626  : 			fdn_Modulation.clear();

	mov	QWORD PTR [rbx+112], rdx
$LN110@FDN:

; 127  : 		deleteInterfaceBlocks();
; 128  : 		deleteDiffusionBlocks();	
; 129  : 		deleteFeedbackBlock();
; 130  : 		deleteInternalArrays();
; 131  : 		deleteFilters();
; 132  : 		deleteChorus();
; 133  : 
; 134  : 		// Delete early reflection block
; 135  : 		delete fdn_EarlyReflections;

	mov	rdi, QWORD PTR [rbx+16]
	test	rdi, rdi
	je	SHORT $LN135@FDN
	mov	rcx, rdi
	call	??1MultiChannelDelay@@QEAA@XZ		; MultiChannelDelay::~MultiChannelDelay
	mov	rdx, r13
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN135@FDN:

; 136  : 
; 137  : 		// Delete mix matrix for output mixing after feedback stage
; 138  : 		delete fdn_MixMatrix;

	mov	rdi, QWORD PTR [rbx+128]
	test	rdi, rdi
	je	SHORT $LN138@FDN
; File E:\FoxSuite\shimmer\include\Hadamard.h

; 29   : 		if (had_matrix) {

	mov	rcx, QWORD PTR [rdi+8]
	test	rcx, rcx
	je	SHORT $LN146@FDN

; 30   : 			for (int i = 0; i < had_numberOfChannels; i++) {

	mov	ebp, r15d
	cmp	DWORD PTR [rdi], r15d
	jle	SHORT $LN144@FDN
	mov	rsi, r15
$LL145@FDN:

; 31   : 				delete[] had_matrix[i];

	mov	rcx, QWORD PTR [rdi+8]
	mov	rcx, QWORD PTR [rcx+rsi]
	call	??_V@YAXPEAX@Z				; operator delete[]
	inc	ebp
	lea	rsi, QWORD PTR [rsi+8]
	cmp	ebp, DWORD PTR [rdi]
	jl	SHORT $LL145@FDN
	mov	rcx, QWORD PTR [rdi+8]
$LN144@FDN:

; 32   : 			}
; 33   : 			delete[] had_matrix;

	call	??_V@YAXPEAX@Z				; operator delete[]
$LN146@FDN:
	mov	edx, 16

; 34   : 		}
; 35   : 		had_matrix = nullptr;

	mov	QWORD PTR [rdi+8], r15
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN138@FDN:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rbx+240]
	mov	edi, 4096				; 00001000H
	test	rcx, rcx
	je	SHORT $LN151@FDN

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+256]
	sub	rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -4

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, rdi
	jb	SHORT $LN167@FDN

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN333@FDN

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN167@FDN:

; 264  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

	mov	QWORD PTR [rbx+240], r15

; 1768 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+248], r15

; 1769 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+256], r15
$LN151@FDN:

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rbx+216]
	test	rcx, rcx
	je	SHORT $LN176@FDN

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+232]
	sub	rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -4

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, rdi
	jb	SHORT $LN192@FDN

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN333@FDN

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN192@FDN:

; 264  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

	mov	QWORD PTR [rbx+216], r15

; 1768 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+224], r15

; 1769 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+232], r15
$LN176@FDN:

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rbx+192]
	test	rcx, rcx
	je	SHORT $LN200@FDN

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+208]
	sub	rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -4

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, rdi
	jb	SHORT $LN216@FDN

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN333@FDN

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN216@FDN:

; 264  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

	mov	QWORD PTR [rbx+192], r15

; 1768 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+200], r15

; 1769 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+208], r15
$LN200@FDN:

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rbx+144]
	test	rcx, rcx
	je	SHORT $LN224@FDN

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+160]
	sub	rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, rdi
	jb	SHORT $LN240@FDN

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN333@FDN

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN240@FDN:

; 264  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

	mov	QWORD PTR [rbx+144], r15

; 1768 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+152], r15

; 1769 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+160], r15
$LN224@FDN:

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rbx+104]
	test	rcx, rcx
	je	SHORT $LN248@FDN

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+120]
	sub	rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, rdi
	jb	SHORT $LN264@FDN

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN333@FDN

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN264@FDN:

; 264  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

	mov	QWORD PTR [rbx+104], r15

; 1768 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+112], r15

; 1769 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+120], r15
$LN248@FDN:

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rbx+80]
	test	rcx, rcx
	je	SHORT $LN272@FDN

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+96]
	sub	rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, rdi
	jb	SHORT $LN288@FDN

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN333@FDN

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN288@FDN:

; 264  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

	mov	QWORD PTR [rbx+80], r15

; 1768 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+88], r15

; 1769 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+96], r15
$LN272@FDN:

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rbx+48]
	test	rcx, rcx
	je	SHORT $LN296@FDN

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+64]
	sub	rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, rdi
	jb	SHORT $LN312@FDN

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN333@FDN

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN312@FDN:

; 264  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

	mov	QWORD PTR [rbx+48], r15

; 1768 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+56], r15

; 1769 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+64], r15
$LN296@FDN:

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rbx+24]
	test	rcx, rcx
	je	SHORT $LN320@FDN

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+40]
	sub	rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, rdi
	jb	SHORT $LN336@FDN

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN333@FDN

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN336@FDN:

; 264  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

	mov	QWORD PTR [rbx+24], r15

; 1768 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+32], r15

; 1769 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+40], r15
$LN320@FDN:
; File E:\FoxSuite\shimmer\include\FDN.h

; 140  : 	}	

	mov	rbx, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	mov	rdi, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r13
	ret	0
$LN333@FDN:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN365@FDN:
??1FDN@@QEAA@XZ ENDP					; FDN::~FDN
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\MultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\src\Delay.cpp
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\LFO.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File E:\FoxSuite\shimmer\include\LFO.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File E:\FoxSuite\shimmer\include\LFO.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\Modulation.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\Modulation.h
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File E:\FoxSuite\shimmer\include\Modulation.h
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File E:\FoxSuite\shimmer\include\LFO.h
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File E:\FoxSuite\shimmer\include\src\Delay.cpp
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File E:\FoxSuite\shimmer\include\src\Delay.cpp
; File E:\FoxSuite\shimmer\include\Modulation.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\Modulation.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\Modulation.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\Modulation.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\Modulation.h
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File E:\FoxSuite\shimmer\include\LFO.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\Modulation.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\include\src\Delay.cpp
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\include\LFO.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File E:\FoxSuite\shimmer\include\LFO.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File E:\FoxSuite\shimmer\include\LFO.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\include\src\LPCombFilter.cpp
; File E:\FoxSuite\shimmer\include\LowPassFilter.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\include\src\LPCombFilter.cpp
; File E:\FoxSuite\shimmer\include\LowPassFilter.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\MultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\LowPassFilter.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\HighPassFilter.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\LowPassFilter.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\HighPassFilter.h
; File E:\FoxSuite\shimmer\include\FDN.h
;	COMDAT ?initialize@FDN@@QEAAXMMHM@Z
_TEXT	SEGMENT
this$ = 80
diffusionMaximumLength$dead$ = 88
feedbackMaxLength$dead$ = 96
i$1$ = 104
sampleRate$ = 104
earlyrefBuffLength$dead$ = 112
?initialize@FDN@@QEAAXMMHM@Z PROC			; FDN::initialize, COMDAT

; 143  : 	void initialize(float diffusionMaximumLength, float feedbackMaxLength, int sampleRate, float earlyrefBuffLength = DEFAULT_EARLYREFL_BUFFER_LENGTH) {

$LN436:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	mov	DWORD PTR [rax+32], r9d
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 144  : 		fdn_sampleRate = sampleRate;
; 145  : 		fdn_earlBufferLength = earlyrefBuffLength;
; 146  : 		fdn_diffBufferLength = diffusionMaximumLength;
; 147  : 		fdn_feedBufferLength = feedbackMaxLength;
; 148  : 		fdn_diffLogic = DEFAULT_DIFFUSER_DELAY_LOGIC;
; 149  : 		fdn_diffDelDistr = DEFAULT_DIFFUSER_DELAY_DISTRIBUTION;
; 150  : 		fdn_feedDelDistr = DEFAULT_FEEDBACK_DELAY_DISTRIBUTION;
; 151  : 		fdn_reflDistr = DEFAULT_EARLYREFL_DELAY_DISTRIBUTION;
; 152  : 		fdn_decay = 0.0;
; 153  : 		fdn_decayMultiplier = 1.0;
; 154  : 		
; 155  : 		// Early reflections
; 156  : 		fdn_EarlyReflections->initDelayLines(earlyrefBuffLength, sampleRate);

	mov	rsi, QWORD PTR [rcx+16]
	xor	ebx, ebx
	mov	eax, 1157234688				; 44fa0000H
	mov	DWORD PTR [rcx+264], r9d
	mov	DWORD PTR [rcx+268], 1101004800		; 41a00000H
	mov	r15d, 1065353216			; 3f800000H
	mov	DWORD PTR [rcx+272], eax
	mov	r12d, r9d
	mov	DWORD PTR [rcx+276], eax
	lea	r13d, QWORD PTR [rbx+1]
	mov	DWORD PTR [rcx+280], r13d
	mov	rdi, rcx
	mov	DWORD PTR [rcx+284], r13d
	mov	QWORD PTR [rcx+288], rbx
	mov	DWORD PTR [rcx+296], ebx
	mov	DWORD PTR [rcx+300], r15d
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h

; 36   : 		mdel_sampleRate = sampleRate;

	mov	DWORD PTR [rsi+40], r9d
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1544 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	rax, QWORD PTR [rsi+16]
	cmp	QWORD PTR [rsi+8], rax
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h

; 37   : 		if (!mdel_DelayLines.empty()) {

	je	SHORT $LN17@initialize

; 38   : 			for (int i = 0; i < mdel_numberOfChannels; i++)

	mov	ebp, ebx
	cmp	DWORD PTR [rsi], ebx
	jle	SHORT $LN17@initialize
	mov	r14d, ebx
$LL18@initialize:

; 39   : 				mdel_DelayLines[i]->init(bufferLengthMs, sampleRate);

	mov	rax, QWORD PTR [rsi+8]
	mov	r8d, r12d
	movss	xmm1, DWORD PTR __real@41a00000
	mov	rcx, QWORD PTR [r14+rax]
	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax]
	add	ebp, r13d
	lea	r14, QWORD PTR [r14+8]
	cmp	ebp, DWORD PTR [rsi]
	jl	SHORT $LL18@initialize
$LN17@initialize:
; File E:\FoxSuite\shimmer\include\FDN.h

; 160  : 		for (int i = 0; i < fdn_diffusionSteps - fdn_numModDiffuser; i++)

	mov	eax, DWORD PTR [rdi+180]
	mov	ebp, ebx
	mov	ecx, DWORD PTR [rdi+184]
	sub	eax, ecx

; 328  : 		fdn_earlyWeight = weight;

	mov	DWORD PTR [rdi+304], r15d

; 160  : 		for (int i = 0; i < fdn_diffusionSteps - fdn_numModDiffuser; i++)

	test	eax, eax
	jle	SHORT $LN3@initialize
	mov	r14, rbx
$LL4@initialize:

; 161  : 			fdn_Diffuser[i]->init(diffusionMaximumLength, sampleRate);

	mov	rax, QWORD PTR [rdi+24]
	mov	rcx, QWORD PTR [r14+rax]
; File E:\FoxSuite\shimmer\include\MultiChannelDiffuser.h

; 38   : 		mdiff_MultiChDelay->initDelayLines(bufferLengthMs, sampleRate);

	mov	rsi, QWORD PTR [rcx+24]
	mov	DWORD PTR [rcx+4], r12d
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h

; 36   : 		mdel_sampleRate = sampleRate;

	mov	DWORD PTR [rsi+40], r12d
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1544 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	rax, QWORD PTR [rsi+16]
	cmp	QWORD PTR [rsi+8], rax
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h

; 37   : 		if (!mdel_DelayLines.empty()) {

	je	SHORT $LN2@initialize

; 38   : 			for (int i = 0; i < mdel_numberOfChannels; i++)

	mov	r12d, ebx
	cmp	DWORD PTR [rsi], ebx
	jle	SHORT $LN431@initialize
	mov	r13d, DWORD PTR sampleRate$[rsp]
	mov	r15, rbx
$LL34@initialize:

; 39   : 				mdel_DelayLines[i]->init(bufferLengthMs, sampleRate);

	mov	rax, QWORD PTR [rsi+8]
	mov	r8d, r13d
	movss	xmm1, DWORD PTR __real@44fa0000
	mov	rcx, QWORD PTR [r15+rax]
	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax]
	inc	r12d
	lea	r15, QWORD PTR [r15+8]
	cmp	r12d, DWORD PTR [rsi]
	jl	SHORT $LL34@initialize

; 38   : 			for (int i = 0; i < mdel_numberOfChannels; i++)

	mov	r13d, 1
$LN431@initialize:
; File E:\FoxSuite\shimmer\include\FDN.h

; 160  : 		for (int i = 0; i < fdn_diffusionSteps - fdn_numModDiffuser; i++)

	mov	r12d, DWORD PTR sampleRate$[rsp]
$LN2@initialize:
	mov	eax, DWORD PTR [rdi+180]
	add	ebp, r13d
	mov	ecx, DWORD PTR [rdi+184]
	add	r14, 8
	sub	eax, ecx
	cmp	ebp, eax
	jl	SHORT $LL4@initialize
$LN3@initialize:

; 163  : 		for (int i = 0; i < fdn_numModDiffuser; i++) {

	mov	DWORD PTR i$1$[rsp], ebx
	test	ecx, ecx
	jle	$LN6@initialize
	mov	r14, rbx
$LL7@initialize:

; 164  : 			fdn_ModDiffuser[i]->init(diffusionMaximumLength, sampleRate);

	mov	rax, QWORD PTR [rdi+48]
	mov	r13, QWORD PTR [r14+rax]
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h

; 39   : 		mdiff_MultiChDelay->initDelayLines(bufferLengthMs, sampleRate);

	mov	rsi, QWORD PTR [r13+24]
	mov	DWORD PTR [r13+4], r12d
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 38   : 		mdel_sampleRate = sampleRate;

	mov	DWORD PTR [rsi+40], r12d
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1544 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	rax, QWORD PTR [rsi+16]
	cmp	QWORD PTR [rsi+8], rax
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 39   : 		if (!mdel_DelayLines.empty()) {

	je	SHORT $LN47@initialize

; 40   : 			for (int i = 0; i < mdel_numberOfChannels; i++)

	mov	ebp, ebx
	cmp	DWORD PTR [rsi], ebx
	jle	SHORT $LN47@initialize
	mov	r15, rbx
$LL48@initialize:

; 41   : 				mdel_DelayLines[i]->init(bufferLengthMs, sampleRate);

	mov	rcx, QWORD PTR [rsi+8]
	mov	r8d, r12d
	movss	xmm1, DWORD PTR __real@44fa0000
	mov	rcx, QWORD PTR [r15+rcx]
	call	?init@ModDelay@@QEAAXMHW4OscillatorType@@@Z ; ModDelay::init
	inc	ebp
	lea	r15, QWORD PTR [r15+8]
	cmp	ebp, DWORD PTR [rsi]
	jl	SHORT $LL48@initialize
$LN47@initialize:
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h

; 57   : 	void setMakeUpGainDB(float makeUpGain) { mdiff_MultiChDelay->setMakeUpGaindB(makeUpGain); }

	mov	rsi, QWORD PTR [r13+24]
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 83   : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	mov	ebp, ebx
	mov	r13d, 1
	cmp	DWORD PTR [rsi], ebx
	jle	SHORT $LN429@initialize
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h

; 57   : 	void setMakeUpGainDB(float makeUpGain) { mdiff_MultiChDelay->setMakeUpGaindB(makeUpGain); }

	mov	r15, rbx
$LL60@initialize:
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 84   : 			mdel_DelayLines[i]->setMakeUpGaindB(makeUpGain);

	mov	rax, QWORD PTR [rsi+8]
	mov	rcx, QWORD PTR [r15+rax]
; File E:\FoxSuite\shimmer\include\src\Delay.cpp

; 135  : 	dly_makeUpGaindB = gaindB;

	mov	DWORD PTR [rcx+64], 1069547520		; 3fc00000H

; 136  : 
; 137  : 	// update parameters
; 138  : 	updateParameters();

	call	?updateParameters@Delay@@AEAAXXZ	; Delay::updateParameters
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 83   : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	add	ebp, r13d
	lea	r15, QWORD PTR [r15+8]
	cmp	ebp, DWORD PTR [rsi]
	jl	SHORT $LL60@initialize
$LN429@initialize:
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h

; 68   : 		mdiff_MultiChDelay->setModValueInMsec(val);

	mov	rax, QWORD PTR [rdi+48]
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 98   : 		mdel_modValmsec = modVal;

	mov	r15d, 1065353216			; 3f800000H

; 99   : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	mov	r9d, ebx
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h

; 68   : 		mdiff_MultiChDelay->setModValueInMsec(val);

	mov	rcx, QWORD PTR [r14+rax]
	mov	rdx, QWORD PTR [rcx+24]
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 98   : 		mdel_modValmsec = modVal;

	mov	DWORD PTR [rdx+48], r15d

; 99   : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	cmp	DWORD PTR [rdx], ebx
	jle	SHORT $LN430@initialize
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

	mov	r8, rbx
$LL73@initialize:
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 100  : 			mdel_DelayLines[i]->setDeltaDelayValue(modVal);

	mov	rax, QWORD PTR [rdx+8]
	add	r9d, r13d
	mov	rcx, QWORD PTR [r8+rax]
	lea	r8, QWORD PTR [r8+8]
	mov	DWORD PTR [rcx+124], r15d
	cmp	r9d, DWORD PTR [rdx]
	jl	SHORT $LL73@initialize
$LN430@initialize:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

	mov	rcx, QWORD PTR [rdi+48]
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 93   : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	mov	r9d, ebx
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h

; 64   : 		mdiff_MultiChDelay->setModRate(rate);

	mov	rax, QWORD PTR [r14+rcx]
	mov	rdx, QWORD PTR [rax+24]
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 93   : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	cmp	DWORD PTR [rdx], ebx
	jle	SHORT $LN83@initialize
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

	mov	r8, rbx
$LL84@initialize:
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 94   : 			mdel_DelayLines[i]->setModRate(freq);

	mov	rax, QWORD PTR [rdx+8]
	add	r9d, r13d
; File E:\FoxSuite\shimmer\include\LFO.h

; 122  : 		lfo_inc = WAVETABLE_SIZE * lfo_frequency / (float)lfo_sampleRate;

	movss	xmm1, DWORD PTR __real@45800000
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 94   : 			mdel_DelayLines[i]->setModRate(freq);

	mov	rcx, QWORD PTR [r8+rax]
	lea	r8, QWORD PTR [r8+8]
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 90   : 		mdly_LFO->setLFOfrequency(mdly_rate);

	mov	rax, QWORD PTR [rcx+104]
	mov	DWORD PTR [rcx+136], r15d
	movd	xmm0, DWORD PTR [rax+4]
; File E:\FoxSuite\shimmer\include\LFO.h

; 122  : 		lfo_inc = WAVETABLE_SIZE * lfo_frequency / (float)lfo_sampleRate;

	cvtdq2ps xmm0, xmm0

; 71   : 		lfo_frequency = frequency;

	mov	DWORD PTR [rax], r15d

; 122  : 		lfo_inc = WAVETABLE_SIZE * lfo_frequency / (float)lfo_sampleRate;

	divss	xmm1, xmm0
	movss	DWORD PTR [rax+20], xmm1
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 93   : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	cmp	r9d, DWORD PTR [rdx]
	jl	SHORT $LL84@initialize
	mov	rcx, QWORD PTR [rdi+48]
$LN83@initialize:
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h

; 72   : 		mdiff_MultiChDelay->setOscillatorType(type);

	mov	rax, QWORD PTR [r14+rcx]
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 104  : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	mov	ebp, ebx
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h

; 72   : 		mdiff_MultiChDelay->setOscillatorType(type);

	mov	rsi, QWORD PTR [rax+24]
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 104  : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	cmp	DWORD PTR [rsi], ebx
	jle	SHORT $LN100@initialize
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

	mov	r15, rbx
$LL101@initialize:
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 105  : 			mdel_DelayLines[i]->setLFOWaveform(type);

	mov	rax, QWORD PTR [rsi+8]
	mov	rcx, QWORD PTR [r15+rax]
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 94   : 		mdly_lfoWaveform = wave;

	mov	DWORD PTR [rcx+116], r13d

; 95   : 		mdly_LFO->setLFOWaveform(wave);

	mov	rcx, QWORD PTR [rcx+104]
; File E:\FoxSuite\shimmer\include\LFO.h

; 132  : 		lfo_table.clear();

	mov	rax, QWORD PTR [rcx+24]
	mov	QWORD PTR [rcx+32], rax

; 76   : 		lfo_waveform = waveform;

	mov	DWORD PTR [rcx+12], r13d

; 77   : 		clearTable();
; 78   : 		createTable();

	call	?createTable@LFO@@AEAAXXZ		; LFO::createTable
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 104  : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	add	ebp, r13d
	lea	r15, QWORD PTR [r15+8]
	cmp	ebp, DWORD PTR [rsi]
	jl	SHORT $LL101@initialize
	mov	rcx, QWORD PTR [rdi+48]
$LN100@initialize:
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h

; 76   : 		mdiff_MultiChDelay->setOscillatorIsUnipolar(isUnipolar);

	mov	rax, QWORD PTR [r14+rcx]
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 109  : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	mov	r8d, ebx
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h

; 76   : 		mdiff_MultiChDelay->setOscillatorIsUnipolar(isUnipolar);

	mov	rcx, QWORD PTR [rax+24]
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 109  : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	cmp	DWORD PTR [rcx], ebx
	jle	SHORT $LN5@initialize
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

	mov	rdx, rbx
$LL118@initialize:
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 110  : 			mdel_DelayLines[i]->setLFOUnipolar(isUnipolar);

	mov	rax, QWORD PTR [rcx+8]
	add	r8d, r13d
	mov	rax, QWORD PTR [rdx+rax]
	lea	rdx, QWORD PTR [rdx+8]
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 99   : 		mdly_isUnipolar = isUnipolar;

	mov	BYTE PTR [rax+112], bl

; 100  : 		mdly_LFO->setLFOunipolar(isUnipolar);

	mov	rax, QWORD PTR [rax+104]
	mov	BYTE PTR [rax+48], bl
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 109  : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	cmp	r8d, DWORD PTR [rcx]
	jl	SHORT $LL118@initialize
$LN5@initialize:
; File E:\FoxSuite\shimmer\include\FDN.h

; 163  : 		for (int i = 0; i < fdn_numModDiffuser; i++) {

	mov	edx, DWORD PTR i$1$[rsp]
	add	r14, 8
	add	edx, r13d
	mov	DWORD PTR i$1$[rsp], edx
	cmp	edx, DWORD PTR [rdi+184]
	jl	$LL7@initialize
$LN6@initialize:

; 172  : 		for (int i = 0; i < fdn_internalChannels; i++)

	mov	eax, DWORD PTR [rdi+172]
	mov	ebp, ebx
	test	eax, eax
	jle	$LN9@initialize
	mov	r14, rbx
	mov	r15d, 1084017869			; 409ccccdH
$LL10@initialize:

; 173  : 			fdn_Modulation[i]->init(DEFAULT_MODULATION_TYPE, sampleRate);

	mov	rax, QWORD PTR [rdi+104]
; File E:\FoxSuite\shimmer\include\Modulation.h

; 49   : 		ModDelay::init(DEFAULT_MOD_BUFFER_LENGTH, sampleRate);

	mov	r8d, r12d
	movss	xmm1, DWORD PTR __real@42200000
; File E:\FoxSuite\shimmer\include\FDN.h

; 173  : 			fdn_Modulation[i]->init(DEFAULT_MODULATION_TYPE, sampleRate);

	mov	rsi, QWORD PTR [r14+rax]
; File E:\FoxSuite\shimmer\include\Modulation.h

; 49   : 		ModDelay::init(DEFAULT_MOD_BUFFER_LENGTH, sampleRate);

	mov	rcx, rsi
	call	?init@ModDelay@@QEAAXMHW4OscillatorType@@@Z ; ModDelay::init
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 95   : 		mdly_LFO->setLFOWaveform(wave);

	mov	rcx, QWORD PTR [rsi+104]
; File E:\FoxSuite\shimmer\include\Modulation.h

; 85   : 		mod_type = modType;

	mov	DWORD PTR [rsi+144], r13d
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 94   : 		mdly_lfoWaveform = wave;

	mov	DWORD PTR [rsi+116], r13d
; File E:\FoxSuite\shimmer\include\LFO.h

; 132  : 		lfo_table.clear();

	mov	rax, QWORD PTR [rcx+24]
	mov	QWORD PTR [rcx+32], rax

; 76   : 		lfo_waveform = waveform;

	mov	DWORD PTR [rcx+12], r13d

; 77   : 		clearTable();
; 78   : 		createTable();

	call	?createTable@LFO@@AEAAXXZ		; LFO::createTable
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 100  : 		mdly_LFO->setLFOunipolar(isUnipolar);

	mov	rax, QWORD PTR [rsi+104]
	mov	BYTE PTR [rsi+112], r13b
	mov	BYTE PTR [rax+48], r13b
; File E:\FoxSuite\shimmer\include\src\Delay.cpp

; 118  : 	if (delayInmsec > dly_lineLengthInmsec)

	movss	xmm0, DWORD PTR [rsi+16]
	comiss	xmm0, DWORD PTR __real@3dcccccd
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 84   : 		mdly_meanDelayValue = delay;

	mov	DWORD PTR [rsi+120], 1036831949		; 3dcccccdH
; File E:\FoxSuite\shimmer\include\src\Delay.cpp

; 118  : 	if (delayInmsec > dly_lineLengthInmsec)

	jb	SHORT $LN149@initialize

; 119  : 		delayInmsec = dly_lineLengthInmsec;
; 120  : 	else if (delayInmsec < 0.0)
; 121  : 		delayInmsec = 0.0;

	movss	xmm0, DWORD PTR __real@3dcccccd
$LN149@initialize:

; 122  : 
; 123  : 	// Set delay line length in milliseconds
; 124  : 	dly_delayInmsec = delayInmsec;
; 125  : 
; 126  : 	// Update parameters based on new delay length
; 127  : 	updateParameters();

	mov	rcx, rsi
	movss	DWORD PTR [rsi+24], xmm0
	call	?updateParameters@Delay@@AEAAXXZ	; Delay::updateParameters
; File E:\FoxSuite\shimmer\include\Modulation.h

; 38   : 		mod_modValue = modVal;

	mov	DWORD PTR [rsi+172], r15d
; File E:\FoxSuite\shimmer\include\FDN.h

; 172  : 		for (int i = 0; i < fdn_internalChannels; i++)

	add	ebp, r13d
; File E:\FoxSuite\shimmer\include\Modulation.h

; 39   : 		ModDelay::setDeltaDelayValue(modVal);

	mov	DWORD PTR [rsi+124], r15d
; File E:\FoxSuite\shimmer\include\FDN.h

; 172  : 		for (int i = 0; i < fdn_internalChannels; i++)

	add	r14, 8
; File E:\FoxSuite\shimmer\include\Modulation.h

; 156  : 		setModDry(dry);

	mov	QWORD PTR [rsi+152], rbx

; 157  : 		setModWet(wet);

	mov	DWORD PTR [rsi+148], 1065353216		; 3f800000H

; 72   : 		mod_fb = fb;

	mov	DWORD PTR [rsi+160], ebx

; 73   : 		ModDelay::setFeedback(fb);

	mov	DWORD PTR [rsi+72], ebx
; File E:\FoxSuite\shimmer\include\FDN.h

; 172  : 		for (int i = 0; i < fdn_internalChannels; i++)

	mov	eax, DWORD PTR [rdi+172]
	cmp	ebp, eax
	jl	$LL10@initialize
$LN9@initialize:

; 235  : 		for (int i = 0; i < fdn_internalChannels; i++)

	mov	r8d, ebx
	test	eax, eax
	jle	SHORT $LN157@initialize
	mov	rdx, rbx
$LL158@initialize:

; 236  : 			fdn_Modulation[i]->setModDepth(depth);	

	mov	rax, QWORD PTR [rdi+104]
	add	r8d, r13d
	mov	rcx, QWORD PTR [rdx+rax]
	lea	rdx, QWORD PTR [rdx+8]
; File E:\FoxSuite\shimmer\include\Modulation.h

; 62   : 		mod_depth = depth;

	mov	DWORD PTR [rcx+168], ebx

; 63   : 		ModDelay::setDeltaDelayValue(mod_modValue * mod_depth);

	mov	DWORD PTR [rcx+124], ebx
; File E:\FoxSuite\shimmer\include\FDN.h

; 235  : 		for (int i = 0; i < fdn_internalChannels; i++)

	mov	eax, DWORD PTR [rdi+172]
	cmp	r8d, eax
	jl	SHORT $LL158@initialize
$LN157@initialize:

; 229  : 		for (int i = 0; i < fdn_internalChannels; i++)

	mov	edx, ebx
	test	eax, eax
	jle	SHORT $LN166@initialize
	mov	rcx, rbx
$LL167@initialize:

; 230  : 			fdn_Modulation[i]->setModRate(rate);

	mov	rax, QWORD PTR [rdi+104]
	add	edx, r13d
	mov	rax, QWORD PTR [rcx+rax]
	lea	rcx, QWORD PTR [rcx+8]
; File E:\FoxSuite\shimmer\include\Modulation.h

; 67   : 		mod_rate = rate;

	mov	DWORD PTR [rax+164], ebx
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 89   : 		mdly_rate = modRate;

	mov	DWORD PTR [rax+136], ebx

; 90   : 		mdly_LFO->setLFOfrequency(mdly_rate);

	mov	rax, QWORD PTR [rax+104]
; File E:\FoxSuite\shimmer\include\LFO.h

; 71   : 		lfo_frequency = frequency;

	mov	DWORD PTR [rax], ebx

; 122  : 		lfo_inc = WAVETABLE_SIZE * lfo_frequency / (float)lfo_sampleRate;

	mov	DWORD PTR [rax+20], ebx
; File E:\FoxSuite\shimmer\include\FDN.h

; 229  : 		for (int i = 0; i < fdn_internalChannels; i++)

	mov	eax, DWORD PTR [rdi+172]
	cmp	edx, eax
	jl	SHORT $LL167@initialize
$LN166@initialize:

; 241  : 		for (int i = 0; i < fdn_internalChannels; i++)

	mov	r8d, ebx
	test	eax, eax
	jle	SHORT $LN181@initialize
	mov	rdx, rbx
$LL182@initialize:

; 242  : 			fdn_Modulation[i]->setModFeedback(fb);

	mov	rax, QWORD PTR [rdi+104]
	add	r8d, r13d
	mov	rcx, QWORD PTR [rdx+rax]
	lea	rdx, QWORD PTR [rdx+8]
; File E:\FoxSuite\shimmer\include\Modulation.h

; 72   : 		mod_fb = fb;

	mov	DWORD PTR [rcx+160], ebx

; 73   : 		ModDelay::setFeedback(fb);

	mov	DWORD PTR [rcx+72], ebx
; File E:\FoxSuite\shimmer\include\FDN.h

; 241  : 		for (int i = 0; i < fdn_internalChannels; i++)

	cmp	r8d, DWORD PTR [rdi+172]
	jl	SHORT $LL182@initialize
$LN181@initialize:

; 247  : 		fdn_modWet = sin(mix * 0.5 * M_PI);

	movsd	xmm0, QWORD PTR __real@3ff921fb54442d18
	call	QWORD PTR __imp_sin
	xorps	xmm1, xmm1
	cvtsd2ss xmm1, xmm0

; 248  : 		fdn_modDry = cos(mix * 0.5 * M_PI);

	movsd	xmm0, QWORD PTR __real@3ff921fb54442d18
	movss	DWORD PTR [rdi+312], xmm1
	call	QWORD PTR __imp_cos

; 174  : 		setModDepth(0.0);
; 175  : 		setModRate(0.0);
; 176  : 		setModFeedback(0.0);
; 177  : 		setModMix(1.0);
; 178  : 
; 179  : 		// Feedback
; 180  : 		fdn_Feedback->init(feedbackMaxLength, sampleRate);

	mov	rsi, QWORD PTR [rdi+72]

; 248  : 		fdn_modDry = cos(mix * 0.5 * M_PI);

	xorps	xmm1, xmm1
	cvtsd2ss xmm1, xmm0
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 59   : 		for (int i = 0; i < mcf_numberOfChannels; i++) {

	mov	ebp, ebx
; File E:\FoxSuite\shimmer\include\FDN.h

; 248  : 		fdn_modDry = cos(mix * 0.5 * M_PI);

	movss	DWORD PTR [rdi+316], xmm1
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 57   : 		mcf_delayBufferSizeMs = delayMs;

	mov	DWORD PTR [rsi+16], 1157234688		; 44fa0000H

; 58   : 		mcf_sampleRate = sampleRate;

	mov	DWORD PTR [rsi+4], r12d

; 59   : 		for (int i = 0; i < mcf_numberOfChannels; i++) {

	cmp	DWORD PTR [rsi], ebx
	jle	SHORT $LN192@initialize
	mov	r14, rbx
$LL193@initialize:

; 60   : 			mcf_DelayLines[i]->init(delayMs, sampleRate);

	mov	rcx, QWORD PTR [rsi+40]
	mov	r8d, r12d
	movss	xmm1, DWORD PTR __real@44fa0000
	mov	rcx, QWORD PTR [r14+rcx]
	call	?init@ModDelay@@QEAAXMHW4OscillatorType@@@Z ; ModDelay::init

; 61   : 			mcf_DelayLines[i]->setMakeUpGaindB(_DELAY_MAKEUP_GAIN_VALUE);

	mov	rax, QWORD PTR [rsi+40]
	mov	rcx, QWORD PTR [r14+rax]
; File E:\FoxSuite\shimmer\include\src\Delay.cpp

; 135  : 	dly_makeUpGaindB = gaindB;

	mov	DWORD PTR [rcx+64], 1069547520		; 3fc00000H

; 136  : 
; 137  : 	// update parameters
; 138  : 	updateParameters();

	call	?updateParameters@Delay@@AEAAXXZ	; Delay::updateParameters
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 59   : 		for (int i = 0; i < mcf_numberOfChannels; i++) {

	add	ebp, r13d
	lea	r14, QWORD PTR [r14+8]
	cmp	ebp, DWORD PTR [rsi]
	jl	SHORT $LL193@initialize
$LN192@initialize:
; File E:\FoxSuite\shimmer\include\FDN.h

; 181  : 		fdn_Feedback->setModValue(_FEEDBACK_MAX_MODULATION_VALUE);

	mov	rdx, QWORD PTR [rdi+72]
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 98   : 		mcf_modValmsec = val;

	mov	r10d, 1082130432			; 40800000H

; 99   : 		for (int i = 0; i < mcf_numberOfChannels; i++)

	mov	r8d, ebx
	mov	DWORD PTR [rdx+64], r10d
	cmp	DWORD PTR [rdx], ebx
	jle	SHORT $LN203@initialize
	mov	r9, rbx
$LL204@initialize:

; 100  : 			mcf_DelayLines[i]->setDeltaDelayValue(val);

	mov	rax, QWORD PTR [rdx+40]
	add	r8d, r13d
	mov	rcx, QWORD PTR [r9+rax]
	lea	r9, QWORD PTR [r9+8]
	mov	DWORD PTR [rcx+124], r10d
	cmp	r8d, DWORD PTR [rdx]
	jl	SHORT $LL204@initialize
$LN203@initialize:
; File E:\FoxSuite\shimmer\include\FDN.h

; 182  : 		fdn_Feedback->setModRate(_FEEDBACK_MAX_MODULATION_RATE);

	mov	rsi, QWORD PTR [rdi+72]
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 108  : 		for (int i = 0; i < mcf_numberOfChannels; i++)

	mov	r8d, ebx
	mov	eax, DWORD PTR [rsi]
	test	eax, eax
	jle	SHORT $LN210@initialize
	mov	rdx, rbx
	mov	r9d, 1053609165				; 3ecccccdH
$LL211@initialize:

; 109  : 			mcf_DelayLines[i]->setModRate(freq);

	mov	rax, QWORD PTR [rsi+40]
	add	r8d, r13d
; File E:\FoxSuite\shimmer\include\LFO.h

; 122  : 		lfo_inc = WAVETABLE_SIZE * lfo_frequency / (float)lfo_sampleRate;

	movss	xmm1, DWORD PTR __real@44cccccd
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 109  : 			mcf_DelayLines[i]->setModRate(freq);

	mov	rcx, QWORD PTR [rdx+rax]
	lea	rdx, QWORD PTR [rdx+8]
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 90   : 		mdly_LFO->setLFOfrequency(mdly_rate);

	mov	rax, QWORD PTR [rcx+104]
	mov	DWORD PTR [rcx+136], r9d
	movd	xmm0, DWORD PTR [rax+4]
; File E:\FoxSuite\shimmer\include\LFO.h

; 122  : 		lfo_inc = WAVETABLE_SIZE * lfo_frequency / (float)lfo_sampleRate;

	cvtdq2ps xmm0, xmm0

; 71   : 		lfo_frequency = frequency;

	mov	DWORD PTR [rax], r9d

; 122  : 		lfo_inc = WAVETABLE_SIZE * lfo_frequency / (float)lfo_sampleRate;

	divss	xmm1, xmm0
	movss	DWORD PTR [rax+20], xmm1
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 108  : 		for (int i = 0; i < mcf_numberOfChannels; i++)

	cmp	r8d, DWORD PTR [rsi]
	jl	SHORT $LL211@initialize
	mov	rsi, QWORD PTR [rdi+72]
	mov	eax, DWORD PTR [rsi]
$LN210@initialize:

; 113  : 		for (int i = 0; i < mcf_numberOfChannels; i++)

	mov	ebp, ebx
	test	eax, eax
	jle	SHORT $LN223@initialize
	mov	r14, rbx
$LL224@initialize:

; 114  : 			mcf_DelayLines[i]->setLFOWaveform(type);

	mov	rax, QWORD PTR [rsi+40]
	mov	rcx, QWORD PTR [r14+rax]
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 94   : 		mdly_lfoWaveform = wave;

	mov	DWORD PTR [rcx+116], r13d

; 95   : 		mdly_LFO->setLFOWaveform(wave);

	mov	rcx, QWORD PTR [rcx+104]
; File E:\FoxSuite\shimmer\include\LFO.h

; 132  : 		lfo_table.clear();

	mov	rax, QWORD PTR [rcx+24]
	mov	QWORD PTR [rcx+32], rax

; 76   : 		lfo_waveform = waveform;

	mov	DWORD PTR [rcx+12], r13d

; 77   : 		clearTable();
; 78   : 		createTable();

	call	?createTable@LFO@@AEAAXXZ		; LFO::createTable
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 113  : 		for (int i = 0; i < mcf_numberOfChannels; i++)

	add	ebp, r13d
	lea	r14, QWORD PTR [r14+8]
	cmp	ebp, DWORD PTR [rsi]
	jl	SHORT $LL224@initialize
	mov	rsi, QWORD PTR [rdi+72]
	mov	eax, DWORD PTR [rsi]
$LN223@initialize:

; 118  : 		for (int i = 0; i < mcf_numberOfChannels; i++)

	mov	edx, ebx
	test	eax, eax
	jle	SHORT $LN236@initialize
	mov	rcx, rbx
$LL237@initialize:

; 119  : 			mcf_DelayLines[i]->setLFOUnipolar(isUnipolar);

	mov	rax, QWORD PTR [rsi+40]
	add	edx, r13d
	mov	rax, QWORD PTR [rcx+rax]
	lea	rcx, QWORD PTR [rcx+8]
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 99   : 		mdly_isUnipolar = isUnipolar;

	mov	BYTE PTR [rax+112], bl

; 100  : 		mdly_LFO->setLFOunipolar(isUnipolar);

	mov	rax, QWORD PTR [rax+104]
	mov	BYTE PTR [rax+48], bl
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 118  : 		for (int i = 0; i < mcf_numberOfChannels; i++)

	cmp	edx, DWORD PTR [rsi]
	jl	SHORT $LL237@initialize
	mov	rsi, QWORD PTR [rdi+72]
	mov	eax, DWORD PTR [rsi]
$LN236@initialize:

; 93   : 		for (int i = 0; i < mcf_numberOfChannels; i++)

	mov	ebp, ebx
	test	eax, eax
	jle	SHORT $LN247@initialize
	mov	r14, rbx
$LL248@initialize:
; File E:\FoxSuite\shimmer\include\src\LPCombFilter.cpp

; 32   : 	lpcf_feedbackLPF->setFilterType(type);

	mov	rax, QWORD PTR [rsi+40]
	mov	rcx, QWORD PTR [r14+rax]
	mov	rcx, QWORD PTR [rcx+88]
; File E:\FoxSuite\shimmer\include\LowPassFilter.h

; 76   : 		lpf_type = type;

	mov	DWORD PTR [rcx], 6

; 77   : 
; 78   : 		// update lpf gains
; 79   : 		updateGains();

	call	?updateGains@LowPassFilter@@QEAAXXZ	; LowPassFilter::updateGains
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 93   : 		for (int i = 0; i < mcf_numberOfChannels; i++)

	add	ebp, r13d
	lea	r14, QWORD PTR [r14+8]
	cmp	ebp, DWORD PTR [rsi]
	jl	SHORT $LL248@initialize
	mov	rsi, QWORD PTR [rdi+72]
	mov	eax, DWORD PTR [rsi]
$LN247@initialize:

; 88   : 		for (int i = 0; i < mcf_numberOfChannels; i++)

	mov	ebp, ebx
	mov	r15d, 1184645120			; 469c4000H
	test	eax, eax
	jle	SHORT $LN260@initialize
	mov	r14, rbx
$LL261@initialize:

; 89   : 			mcf_DelayLines[i]->setCutoffFrequency(freq);

	mov	rax, QWORD PTR [rsi+40]
	mov	rcx, QWORD PTR [r14+rax]
; File E:\FoxSuite\shimmer\include\src\LPCombFilter.cpp

; 25   : 	lpcf_cutoffFreq = cutoffFreq;

	mov	DWORD PTR [rcx+96], r15d

; 26   : 
; 27   : 	// set LPF cutoff frequency to the inserted value
; 28   : 	lpcf_feedbackLPF->setCutoffFrequency(lpcf_cutoffFreq);

	mov	rcx, QWORD PTR [rcx+88]
; File E:\FoxSuite\shimmer\include\LowPassFilter.h

; 68   : 		lpf_cutoffFreq = cutoffFreq;

	mov	DWORD PTR [rcx+4], r15d

; 69   : 
; 70   : 		// update lpf gains
; 71   : 		updateGains();

	call	?updateGains@LowPassFilter@@QEAAXXZ	; LowPassFilter::updateGains
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 88   : 		for (int i = 0; i < mcf_numberOfChannels; i++)

	add	ebp, r13d
	lea	r14, QWORD PTR [r14+8]
	cmp	ebp, DWORD PTR [rsi]
	jl	SHORT $LL261@initialize
$LN260@initialize:
; File E:\FoxSuite\shimmer\include\FDN.h

; 189  : 		fdn_OutputDiffusion->init(diffusionMaximumLength, sampleRate);

	mov	rax, QWORD PTR [rdi+136]
; File E:\FoxSuite\shimmer\include\MultiChannelDiffuser.h

; 38   : 		mdiff_MultiChDelay->initDelayLines(bufferLengthMs, sampleRate);

	mov	rsi, QWORD PTR [rax+24]
	mov	DWORD PTR [rax+4], r12d
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h

; 36   : 		mdel_sampleRate = sampleRate;

	mov	DWORD PTR [rsi+40], r12d
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1544 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	rax, QWORD PTR [rsi+16]
	cmp	QWORD PTR [rsi+8], rax
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h

; 37   : 		if (!mdel_DelayLines.empty()) {

	je	SHORT $LN273@initialize

; 38   : 			for (int i = 0; i < mdel_numberOfChannels; i++)

	mov	ebp, ebx
	cmp	DWORD PTR [rsi], ebx
	jle	SHORT $LN273@initialize
	mov	r14, rbx
$LL274@initialize:

; 39   : 				mdel_DelayLines[i]->init(bufferLengthMs, sampleRate);

	mov	rax, QWORD PTR [rsi+8]
	mov	r8d, r12d
	movss	xmm1, DWORD PTR __real@44fa0000
	mov	rcx, QWORD PTR [r14+rax]
	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax]
	add	ebp, r13d
	lea	r14, QWORD PTR [r14+8]
	cmp	ebp, DWORD PTR [rsi]
	jl	SHORT $LL274@initialize
$LN273@initialize:
; File E:\FoxSuite\shimmer\include\FDN.h

; 192  : 		for (int i = 0; i < fdn_outputChannels; i++) {

	mov	eax, DWORD PTR [rdi+176]
	mov	r8d, ebx
	test	eax, eax
	jle	SHORT $LN12@initialize
	mov	rdx, rbx
$LL13@initialize:

; 193  : 			fdn_LPFOutput[i]->init(sampleRate);

	mov	rax, QWORD PTR [rdi+80]
	add	r8d, r13d
	mov	rcx, QWORD PTR [rdx+rax]
	mov	DWORD PTR [rcx+8], r12d

; 194  : 			fdn_HPFOutput[i]->init(sampleRate);

	mov	rax, QWORD PTR [rdi+144]
	mov	rcx, QWORD PTR [rdx+rax]
	lea	rdx, QWORD PTR [rdx+8]
	mov	DWORD PTR [rcx+8], r12d
	mov	eax, DWORD PTR [rdi+176]
	cmp	r8d, eax
	jl	SHORT $LL13@initialize
$LN12@initialize:

; 280  : 		for (int i = 0; i < fdn_outputChannels; i++)

	mov	ebp, ebx
	test	eax, eax
	jle	SHORT $LN287@initialize
	mov	rsi, rbx
$LL288@initialize:

; 281  : 			fdn_LPFOutput[i]->setFilterType(type);

	mov	rax, QWORD PTR [rdi+80]
	mov	rcx, QWORD PTR [rsi+rax]
; File E:\FoxSuite\shimmer\include\LowPassFilter.h

; 76   : 		lpf_type = type;

	mov	DWORD PTR [rcx], 6

; 77   : 
; 78   : 		// update lpf gains
; 79   : 		updateGains();

	call	?updateGains@LowPassFilter@@QEAAXXZ	; LowPassFilter::updateGains
; File E:\FoxSuite\shimmer\include\FDN.h

; 280  : 		for (int i = 0; i < fdn_outputChannels; i++)

	mov	eax, DWORD PTR [rdi+176]
	lea	rsi, QWORD PTR [rsi+8]
	add	ebp, r13d
	cmp	ebp, eax
	jl	SHORT $LL288@initialize
$LN287@initialize:

; 286  : 		for (int i = 0; i < fdn_outputChannels; i++)

	mov	ebp, ebx
	test	eax, eax
	jle	SHORT $LN296@initialize
	mov	rsi, rbx
$LL297@initialize:

; 287  : 			fdn_HPFOutput[i]->setFilterType(type);

	mov	rax, QWORD PTR [rdi+144]
	mov	rcx, QWORD PTR [rsi+rax]
; File E:\FoxSuite\shimmer\include\HighPassFilter.h

; 76   : 		hpf_type = type;

	mov	DWORD PTR [rcx], 2

; 77   : 
; 78   : 		// update hpf gains
; 79   : 		updateGains();

	call	?updateGains@HighPassFilter@@QEAAXXZ	; HighPassFilter::updateGains
; File E:\FoxSuite\shimmer\include\FDN.h

; 286  : 		for (int i = 0; i < fdn_outputChannels; i++)

	mov	eax, DWORD PTR [rdi+176]
	lea	rsi, QWORD PTR [rsi+8]
	add	ebp, r13d
	cmp	ebp, eax
	jl	SHORT $LL297@initialize
$LN296@initialize:

; 268  : 		for (int i = 0; i < fdn_outputChannels; i++)

	mov	ebp, ebx
	test	eax, eax
	jle	SHORT $LN314@initialize
	mov	rsi, rbx
$LL306@initialize:

; 269  : 			fdn_LPFOutput[i]->setCutoffFrequency(freq);

	mov	rax, QWORD PTR [rdi+80]
	mov	rcx, QWORD PTR [rsi+rax]
; File E:\FoxSuite\shimmer\include\LowPassFilter.h

; 68   : 		lpf_cutoffFreq = cutoffFreq;

	mov	DWORD PTR [rcx+4], r15d

; 69   : 
; 70   : 		// update lpf gains
; 71   : 		updateGains();

	call	?updateGains@LowPassFilter@@QEAAXXZ	; LowPassFilter::updateGains
; File E:\FoxSuite\shimmer\include\FDN.h

; 268  : 		for (int i = 0; i < fdn_outputChannels; i++)

	mov	eax, DWORD PTR [rdi+176]
	lea	rsi, QWORD PTR [rsi+8]
	add	ebp, r13d
	cmp	ebp, eax
	jl	SHORT $LL306@initialize

; 274  : 		for (int i = 0; i < fdn_outputChannels; i++)

	test	eax, eax
	jle	SHORT $LN314@initialize
	mov	rsi, rbx
$LL315@initialize:

; 275  : 			fdn_HPFOutput[i]->setCutoffFrequency(freq);

	mov	rax, QWORD PTR [rdi+144]
	mov	rcx, QWORD PTR [rsi+rax]
; File E:\FoxSuite\shimmer\include\HighPassFilter.h

; 68   : 		hpf_cutoffFreq = cutoffFreq;

	mov	DWORD PTR [rcx+4], 1101004800		; 41a00000H

; 69   : 
; 70   : 		// update hpf gains
; 71   : 		updateGains();

	call	?updateGains@HighPassFilter@@QEAAXXZ	; HighPassFilter::updateGains
; File E:\FoxSuite\shimmer\include\FDN.h

; 274  : 		for (int i = 0; i < fdn_outputChannels; i++)

	add	ebx, r13d
	lea	rsi, QWORD PTR [rsi+8]
	cmp	ebx, DWORD PTR [rdi+176]
	jl	SHORT $LL315@initialize
$LN314@initialize:

; 195  : 		}	
; 196  : 		setLowPassType(LPF_FILTER_TYPE);
; 197  : 		setHighPassType(HPF_FILTER_TYPE);
; 198  : 		setLowPassFrequency(MAX_LPF_FREQUENCY);
; 199  : 		setHighPassFrequency(MIN_HPF_FREQUENCY);
; 200  : 	}	

	mov	rbx, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
?initialize@FDN@@QEAAXMMHM@Z ENDP			; FDN::initialize
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\include\src\CombFilter.cpp
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\include\src\CombFilter.cpp
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\include\src\CombFilter.cpp
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\include\src\CombFilter.cpp
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\include\FDN.h
;	COMDAT ?setDecayInSeconds@FDN@@QEAAXM@Z
_TEXT	SEGMENT
this$ = 64
decaySeconds$ = 72
?setDecayInSeconds@FDN@@QEAAXM@Z PROC			; FDN::setDecayInSeconds, COMDAT

; 203  : 	void setDecayInSeconds(float decaySeconds) {	

$LN20:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rsi
	mov	QWORD PTR [rax+24], rdi
	push	r14
	sub	rsp, 48					; 00000030H

; 205  : 		fdn_Feedback->setDecayInSeconds(fdn_decay * fdn_decayMultiplier);

	mov	rdi, QWORD PTR [rcx+72]
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 52   : 		for (int i = 0; i < mcf_numberOfChannels; i++)

	xor	ebx, ebx
	movaps	XMMWORD PTR [rax-24], xmm6
; File E:\FoxSuite\shimmer\include\FDN.h

; 203  : 	void setDecayInSeconds(float decaySeconds) {	

	movaps	xmm6, xmm1

; 204  : 		fdn_decay = decaySeconds;

	movss	DWORD PTR [rcx+296], xmm6

; 205  : 		fdn_Feedback->setDecayInSeconds(fdn_decay * fdn_decayMultiplier);

	mulss	xmm6, DWORD PTR [rcx+300]
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 51   : 		mcf_decay = decay;

	movss	DWORD PTR [rdi+20], xmm6

; 52   : 		for (int i = 0; i < mcf_numberOfChannels; i++)

	cmp	DWORD PTR [rdi], ebx
	jle	SHORT $LN5@setDecayIn
	mov	r14d, ebx
$LL6@setDecayIn:
; File E:\FoxSuite\shimmer\include\src\CombFilter.cpp

; 24   : 	float feedbackModule = (cf_decayInSeconds > 0.0) ? pow(10, -3.0 * dly_delayInmsec / (cf_decayInSeconds * 1000.0)) : 0.0;

	comiss	xmm6, DWORD PTR __real@00000000
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 53   : 			mcf_DelayLines[i]->setFeedbackFromDecay(decay);

	mov	rax, QWORD PTR [rdi+40]
	mov	rsi, QWORD PTR [r14+rax]
; File E:\FoxSuite\shimmer\include\src\CombFilter.cpp

; 21   : 	cf_decayInSeconds = decayInSeconds;

	movss	DWORD PTR [rsi+76], xmm6

; 24   : 	float feedbackModule = (cf_decayInSeconds > 0.0) ? pow(10, -3.0 * dly_delayInmsec / (cf_decayInSeconds * 1000.0)) : 0.0;

	xorps	xmm0, xmm0
	jbe	SHORT $LN13@setDecayIn
	movsd	xmm1, QWORD PTR __real@bf689374bc6a7efa
	movss	xmm2, DWORD PTR [rsi+24]
	cvtss2sd xmm0, xmm6
	cvtps2pd xmm2, xmm2
	divsd	xmm1, xmm0
	movsd	xmm0, QWORD PTR __real@4024000000000000
	mulsd	xmm1, xmm2
	call	QWORD PTR __imp_pow
$LN13@setDecayIn:
	movd	xmm1, DWORD PTR [rsi+80]
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 52   : 		for (int i = 0; i < mcf_numberOfChannels; i++)

	inc	ebx
; File E:\FoxSuite\shimmer\include\src\CombFilter.cpp

; 27   : 	cf_feedbackGain = cf_feedbackGainSign * feedbackModule;

	cvtdq2ps xmm1, xmm1
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 52   : 		for (int i = 0; i < mcf_numberOfChannels; i++)

	add	r14, 8
; File E:\FoxSuite\shimmer\include\src\CombFilter.cpp

; 24   : 	float feedbackModule = (cf_decayInSeconds > 0.0) ? pow(10, -3.0 * dly_delayInmsec / (cf_decayInSeconds * 1000.0)) : 0.0;

	cvtsd2ss xmm0, xmm0

; 27   : 	cf_feedbackGain = cf_feedbackGainSign * feedbackModule;

	mulss	xmm1, xmm0
	movss	DWORD PTR [rsi+72], xmm1
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 52   : 		for (int i = 0; i < mcf_numberOfChannels; i++)

	cmp	ebx, DWORD PTR [rdi]
	jl	SHORT $LL6@setDecayIn
$LN5@setDecayIn:
; File E:\FoxSuite\shimmer\include\FDN.h

; 206  : 	}	

	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	mov	rdi, QWORD PTR [rsp+80]
	movaps	xmm6, XMMWORD PTR [rsp+32]
	add	rsp, 48					; 00000030H
	pop	r14
	ret	0
?setDecayInSeconds@FDN@@QEAAXM@Z ENDP			; FDN::setDecayInSeconds
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\utils.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\utils.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\utils.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\utils.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\MultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\MultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\MultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\MultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\utils.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\utils.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\include\LFO.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File E:\FoxSuite\shimmer\include\LFO.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\include\FDN.h
;	COMDAT ?setRoomSize@FDN@@QEAAXMW4DiffuserDelayLogic@@W4DelayDistribution@@1@Z
_TEXT	SEGMENT
this$ = 128
size$ = 136
logic$dead$ = 144
diffDistr$dead$ = 152
feedDistr$dead$ = 160
?setRoomSize@FDN@@QEAAXMW4DiffuserDelayLogic@@W4DelayDistribution@@1@Z PROC ; FDN::setRoomSize, COMDAT

; 209  : 	void setRoomSize(float size, DiffuserDelayLogic logic = DiffuserDelayLogic::Empty, DelayDistribution diffDistr = DelayDistribution::Empty, DelayDistribution feedDistr = DelayDistribution::Empty) {

$LN113:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 96					; 00000060H
	mov	rbx, rcx
	movaps	XMMWORD PTR [rax-40], xmm6

; 210  : 		if (logic == DiffuserDelayLogic::Empty)
; 211  : 			logic = fdn_diffLogic;

	mov	ecx, DWORD PTR [rcx+292]

; 216  : 
; 217  : 		float diffMaxdel = mapValueIntoRange(0.5 * size, DEFAULT_DIFFUSER_MIN_DELAY, fdn_diffBufferLength);

	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@3f000000

; 307  : 		switch (logic) {

	xor	edi, edi
	movaps	XMMWORD PTR [rax-56], xmm7
; File E:\FoxSuite\shimmer\include\utils.h

; 61   :     return minvalue + value * (maxValue - minvalue);

	movss	xmm7, DWORD PTR [rbx+272]
; File E:\FoxSuite\shimmer\include\FDN.h

; 213  : 			diffDistr = fdn_diffDelDistr;

	mov	r15d, DWORD PTR [rbx+280]

; 214  : 		if (feedDistr == DelayDistribution::Empty)
; 215  : 			feedDistr = fdn_feedDelDistr;

	mov	esi, DWORD PTR [rbx+284]
	movaps	XMMWORD PTR [rax-72], xmm8
; File E:\FoxSuite\shimmer\include\utils.h

; 61   :     return minvalue + value * (maxValue - minvalue);

	movss	xmm8, DWORD PTR [rbx+276]
	movaps	XMMWORD PTR [rax-88], xmm10
; File E:\FoxSuite\shimmer\include\FDN.h

; 209  : 	void setRoomSize(float size, DiffuserDelayLogic logic = DiffuserDelayLogic::Empty, DelayDistribution diffDistr = DelayDistribution::Empty, DelayDistribution feedDistr = DelayDistribution::Empty) {

	movaps	xmm10, xmm1
; File E:\FoxSuite\shimmer\include\utils.h

; 61   :     return minvalue + value * (maxValue - minvalue);

	subss	xmm7, DWORD PTR __real@41f00000
	mulss	xmm7, xmm0
	addss	xmm7, DWORD PTR __real@41f00000
; File E:\FoxSuite\shimmer\include\FDN.h

; 218  : 		float feedMaxdel = mapValueIntoRange(size, diffMaxdel + 20.0, fdn_feedBufferLength);

	movaps	xmm0, xmm7
	addss	xmm0, DWORD PTR __real@41a00000
; File E:\FoxSuite\shimmer\include\utils.h

; 61   :     return minvalue + value * (maxValue - minvalue);

	subss	xmm8, xmm0
	mulss	xmm8, xmm10
	addss	xmm8, xmm0
; File E:\FoxSuite\shimmer\include\FDN.h

; 307  : 		switch (logic) {

	test	ecx, ecx
	je	$LN13@setRoomSiz
	cmp	ecx, 1
	jne	$LN11@setRoomSiz

; 511  : 		for (int i = 0; i < fdn_diffusionSteps - fdn_numModDiffuser; i++)

	mov	eax, DWORD PTR [rbx+180]
	mov	ebp, edi
	mov	ecx, DWORD PTR [rbx+184]
	sub	eax, ecx
	test	eax, eax
	jle	SHORT $LN36@setRoomSiz
	mov	r14d, edi
$LL37@setRoomSiz:
; File E:\FoxSuite\shimmer\include\MultiChannelDiffuser.h

; 50   : 		mdiff_MultiChDelay->setDelayLinesLength(minDelayMs, maxDelayMs, distr);

	mov	rax, QWORD PTR [rbx+24]
	mov	r9d, r15d
	movaps	xmm2, xmm7
	mov	rcx, QWORD PTR [r14+rax]
	mov	rcx, QWORD PTR [rcx+24]
	call	?setDelayLinesLength@MultiChannelDelay@@QEAAXMMW4DelayDistribution@@@Z ; MultiChannelDelay::setDelayLinesLength
; File E:\FoxSuite\shimmer\include\FDN.h

; 511  : 		for (int i = 0; i < fdn_diffusionSteps - fdn_numModDiffuser; i++)

	mov	eax, DWORD PTR [rbx+180]
	lea	r14, QWORD PTR [r14+8]
	mov	ecx, DWORD PTR [rbx+184]
	inc	ebp
	sub	eax, ecx
	cmp	ebp, eax
	jl	SHORT $LL37@setRoomSiz
$LN36@setRoomSiz:

; 513  : 		for (int i = 0; i < fdn_numModDiffuser; i++)

	mov	ebp, edi
	test	ecx, ecx
	jle	SHORT $LN39@setRoomSiz
	mov	r14, rdi
$LL40@setRoomSiz:
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h

; 52   : 		mdiff_MultiChDelay->setDelayLinesLength(minDelayMs, maxDelayMs, distr);

	mov	rax, QWORD PTR [rbx+48]
	mov	r9d, r15d
	movaps	xmm2, xmm7
	mov	rcx, QWORD PTR [r14+rax]
	mov	rcx, QWORD PTR [rcx+24]
	call	?setDelayLinesLength@ModMultiChannelDelay@@QEAAXMMW4DelayDistribution@@@Z ; ModMultiChannelDelay::setDelayLinesLength
; File E:\FoxSuite\shimmer\include\FDN.h

; 513  : 		for (int i = 0; i < fdn_numModDiffuser; i++)

	inc	ebp
	lea	r14, QWORD PTR [r14+8]
	cmp	ebp, DWORD PTR [rbx+184]
	jl	SHORT $LL40@setRoomSiz
$LN39@setRoomSiz:
; File E:\FoxSuite\shimmer\include\MultiChannelDiffuser.h

; 50   : 		mdiff_MultiChDelay->setDelayLinesLength(minDelayMs, maxDelayMs, distr);

	movaps	xmm2, xmm7
	jmp	SHORT $LN109@setRoomSiz
$LN13@setRoomSiz:
; File E:\FoxSuite\shimmer\include\FDN.h

; 498  : 		for (int i = fdn_numModDiffuser - 1; i >=0; i--) {

	mov	ecx, DWORD PTR [rbx+184]

; 309  : 			setDoubledDiffuserDelayLengths(delayMinLength, delayMaxLength, distr);

	movaps	xmm6, xmm7

; 498  : 		for (int i = fdn_numModDiffuser - 1; i >=0; i--) {

	lea	eax, DWORD PTR [rcx-1]

; 309  : 			setDoubledDiffuserDelayLengths(delayMinLength, delayMaxLength, distr);

	movsxd	rbp, eax

; 498  : 		for (int i = fdn_numModDiffuser - 1; i >=0; i--) {

	test	eax, eax
	js	SHORT $LN18@setRoomSiz
$LL19@setRoomSiz:
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h

; 52   : 		mdiff_MultiChDelay->setDelayLinesLength(minDelayMs, maxDelayMs, distr);

	mov	rax, QWORD PTR [rbx+48]
	mov	r9d, r15d
	movaps	xmm2, xmm6
	mov	rcx, QWORD PTR [rax+rbp*8]
	mov	rcx, QWORD PTR [rcx+24]
	call	?setDelayLinesLength@ModMultiChannelDelay@@QEAAXMMW4DelayDistribution@@@Z ; ModMultiChannelDelay::setDelayLinesLength
; File E:\FoxSuite\shimmer\include\FDN.h

; 498  : 		for (int i = fdn_numModDiffuser - 1; i >=0; i--) {

	sub	rbp, 1

; 499  : 			fdn_ModDiffuser[i]->setDelayLinesLength(minDelayMs, maxDelayMs, distr);
; 500  : 			maxDelayMs *= 0.5;

	mulss	xmm6, DWORD PTR __real@3f000000
	jns	SHORT $LL19@setRoomSiz
	mov	ecx, DWORD PTR [rbx+184]
$LN18@setRoomSiz:

; 502  : 		for (int i = fdn_diffusionSteps - fdn_numModDiffuser - 1; i >= 0; i--) {

	mov	eax, DWORD PTR [rbx+180]
	sub	eax, ecx
	sub	eax, 1
	movsxd	rbp, eax
	js	SHORT $LN21@setRoomSiz
$LL22@setRoomSiz:
; File E:\FoxSuite\shimmer\include\MultiChannelDiffuser.h

; 50   : 		mdiff_MultiChDelay->setDelayLinesLength(minDelayMs, maxDelayMs, distr);

	mov	rax, QWORD PTR [rbx+24]
	mov	r9d, r15d
	movaps	xmm2, xmm6
	mov	rcx, QWORD PTR [rax+rbp*8]
	mov	rcx, QWORD PTR [rcx+24]
	call	?setDelayLinesLength@MultiChannelDelay@@QEAAXMMW4DelayDistribution@@@Z ; MultiChannelDelay::setDelayLinesLength
; File E:\FoxSuite\shimmer\include\FDN.h

; 502  : 		for (int i = fdn_diffusionSteps - fdn_numModDiffuser - 1; i >= 0; i--) {

	sub	rbp, 1

; 503  : 			fdn_Diffuser[i]->setDelayLinesLength(minDelayMs, maxDelayMs, distr);
; 504  : 			maxDelayMs *= 0.5;

	mulss	xmm6, DWORD PTR __real@3f000000
	jns	SHORT $LL22@setRoomSiz
$LN21@setRoomSiz:

; 505  : 		}		
; 506  : 		fdn_OutputDiffusion->setDelayLinesLength(minDelayMs, maxDelayMs * 2.0, distr);

	addss	xmm6, xmm6
; File E:\FoxSuite\shimmer\include\MultiChannelDiffuser.h

; 50   : 		mdiff_MultiChDelay->setDelayLinesLength(minDelayMs, maxDelayMs, distr);

	movaps	xmm2, xmm6
$LN109@setRoomSiz:
; File E:\FoxSuite\shimmer\include\FDN.h

; 321  : 		fdn_feedDelDistr = distr;

	mov	rcx, QWORD PTR [rbx+136]
	mov	r9d, r15d
	mov	rcx, QWORD PTR [rcx+24]
	call	?setDelayLinesLength@MultiChannelDelay@@QEAAXMMW4DelayDistribution@@@Z ; MultiChannelDelay::setDelayLinesLength
$LN11@setRoomSiz:
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 72   : 		if (maxDelay != 0.0)

	ucomiss	xmm8, DWORD PTR __real@00000000
; File E:\FoxSuite\shimmer\include\FDN.h

; 322  : 		fdn_Feedback->setDelayLengths(mindelay, maxDelay, distr);

	mov	rcx, QWORD PTR [rbx+72]
	mov	DWORD PTR [rbx+284], esi

; 219  : 		setDiffuserDelayLengths(diffMaxdel, logic, diffDistr, DEFAULT_DIFFUSER_MIN_DELAY);
; 220  : 		setFeedbackDelayLengths(0.5 * diffMaxdel, feedMaxdel, feedDistr);

	mulss	xmm7, DWORD PTR __real@3f000000
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 71   : 		mcf_minDelayLength = minDelay;

	movss	DWORD PTR [rcx+8], xmm7

; 72   : 		if (maxDelay != 0.0)

	je	SHORT $LN57@setRoomSiz

; 73   : 			mcf_maxDelayLength = maxDelay;

	movss	DWORD PTR [rcx+12], xmm8
$LN57@setRoomSiz:

; 74   : 		mcf_delayDistribution = distr;

	mov	DWORD PTR [rcx+24], esi

; 75   : 		switch (distr) {

	test	esi, esi
	je	SHORT $LN58@setRoomSiz
	cmp	esi, 1
	jne	SHORT $LN55@setRoomSiz

; 78   : 			break;
; 79   : 		}
; 80   : 		case DelayDistribution::RandomInRange: {
; 81   : 			setRandomInRangeDelayLines();

	call	?setRandomInRangeDelayLines@ModMultiChannelFeedback@@AEAAXXZ ; ModMultiChannelFeedback::setRandomInRangeDelayLines
	jmp	SHORT $LN55@setRoomSiz
$LN58@setRoomSiz:

; 76   : 		case DelayDistribution::Exponential: {
; 77   : 			setDelayExponential();

	call	?setDelayExponential@ModMultiChannelFeedback@@AEAAXXZ ; ModMultiChannelFeedback::setDelayExponential
$LN55@setRoomSiz:
; File E:\FoxSuite\shimmer\include\FDN.h

; 323  : 		setDecayInSeconds(fdn_decay);

	movss	xmm1, DWORD PTR [rbx+296]
	mov	rcx, rbx
	call	?setDecayInSeconds@FDN@@QEAAXM@Z	; FDN::setDecayInSeconds

; 222  : 		setDecayInSeconds(fdn_decay);

	movss	xmm1, DWORD PTR [rbx+296]
; File E:\FoxSuite\shimmer\include\utils.h

; 61   :     return minvalue + value * (maxValue - minvalue);

	movaps	xmm0, xmm10
	mulss	xmm0, DWORD PTR __real@3ff33333
; File E:\FoxSuite\shimmer\include\FDN.h

; 222  : 		setDecayInSeconds(fdn_decay);

	mov	rcx, rbx
; File E:\FoxSuite\shimmer\include\utils.h

; 61   :     return minvalue + value * (maxValue - minvalue);

	addss	xmm0, DWORD PTR __real@3dcccccd
; File E:\FoxSuite\shimmer\include\FDN.h

; 221  : 		fdn_decayMultiplier = mapValueIntoRange(size, 0.1, 2.0);

	movss	DWORD PTR [rbx+300], xmm0

; 222  : 		setDecayInSeconds(fdn_decay);

	call	?setDecayInSeconds@FDN@@QEAAXM@Z	; FDN::setDecayInSeconds

; 223  : 		fdn_Feedback->setModDepth(size);		

	mov	rdx, QWORD PTR [rbx+72]
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 103  : 		for (int i = 0; i < mcf_numberOfChannels; i++)

	mov	r9d, edi
	mov	eax, DWORD PTR [rdx]
	test	eax, eax
	jle	$LN74@setRoomSiz
	mov	r8, rdi
$LL66@setRoomSiz:

; 104  : 			mcf_DelayLines[i]->setDeltaDelayValue(depth* mcf_modValmsec);

	mov	rax, QWORD PTR [rdx+40]
	movaps	xmm0, xmm10
	mulss	xmm0, DWORD PTR [rdx+64]
	inc	r9d
	mov	rcx, QWORD PTR [r8+rax]
	lea	r8, QWORD PTR [r8+8]
	movss	DWORD PTR [rcx+124], xmm0
	cmp	r9d, DWORD PTR [rdx]
	jl	SHORT $LL66@setRoomSiz
	mov	rdx, QWORD PTR [rbx+72]
	mov	eax, DWORD PTR [rdx]

; 108  : 		for (int i = 0; i < mcf_numberOfChannels; i++)

	test	eax, eax
	jle	SHORT $LN74@setRoomSiz
	movss	xmm2, DWORD PTR __real@3f800000
	mov	r8, rdi
	subss	xmm2, xmm10
	mulss	xmm2, DWORD PTR __real@3ecccccd
	movaps	xmm3, xmm2
	mulss	xmm3, DWORD PTR __real@45800000
$LL75@setRoomSiz:

; 109  : 			mcf_DelayLines[i]->setModRate(freq);

	mov	rax, QWORD PTR [rdx+40]
; File E:\FoxSuite\shimmer\include\LFO.h

; 122  : 		lfo_inc = WAVETABLE_SIZE * lfo_frequency / (float)lfo_sampleRate;

	movaps	xmm1, xmm3
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 108  : 		for (int i = 0; i < mcf_numberOfChannels; i++)

	inc	edi

; 109  : 			mcf_DelayLines[i]->setModRate(freq);

	mov	rcx, QWORD PTR [r8+rax]
	lea	r8, QWORD PTR [r8+8]
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 90   : 		mdly_LFO->setLFOfrequency(mdly_rate);

	mov	rax, QWORD PTR [rcx+104]
	movss	DWORD PTR [rcx+136], xmm2
	movd	xmm0, DWORD PTR [rax+4]
; File E:\FoxSuite\shimmer\include\LFO.h

; 122  : 		lfo_inc = WAVETABLE_SIZE * lfo_frequency / (float)lfo_sampleRate;

	cvtdq2ps xmm0, xmm0

; 71   : 		lfo_frequency = frequency;

	movss	DWORD PTR [rax], xmm2

; 122  : 		lfo_inc = WAVETABLE_SIZE * lfo_frequency / (float)lfo_sampleRate;

	divss	xmm1, xmm0
	movss	DWORD PTR [rax+20], xmm1
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 108  : 		for (int i = 0; i < mcf_numberOfChannels; i++)

	cmp	edi, DWORD PTR [rdx]
	jl	SHORT $LL75@setRoomSiz
$LN74@setRoomSiz:
; File E:\FoxSuite\shimmer\include\FDN.h

; 225  : 	}	

	movaps	xmm6, XMMWORD PTR [rsp+80]
	lea	r11, QWORD PTR [rsp+96]
	mov	rbx, QWORD PTR [r11+32]
	mov	rbp, QWORD PTR [r11+40]
	mov	rsi, QWORD PTR [r11+48]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm10, XMMWORD PTR [r11-64]
	movaps	xmm7, XMMWORD PTR [rsp+64]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	rdi
	ret	0
?setRoomSize@FDN@@QEAAXMW4DiffuserDelayLogic@@W4DelayDistribution@@1@Z ENDP ; FDN::setRoomSize
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\LFO.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File E:\FoxSuite\shimmer\include\Modulation.h
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File E:\FoxSuite\shimmer\include\LFO.h
; File E:\FoxSuite\shimmer\include\FDN.h
;	COMDAT ?setModRate@FDN@@QEAAXM@Z
_TEXT	SEGMENT
this$ = 8
rate$ = 16
?setModRate@FDN@@QEAAXM@Z PROC				; FDN::setModRate, COMDAT

; 229  : 		for (int i = 0; i < fdn_internalChannels; i++)

	xor	edx, edx
	movaps	xmm2, xmm1
	mov	r8, rcx
	cmp	DWORD PTR [rcx+172], edx
	jle	SHORT $LN3@setModRate
	movaps	xmm3, xmm1
	mov	r9d, edx
	mulss	xmm3, DWORD PTR __real@45800000
$LL4@setModRate:

; 230  : 			fdn_Modulation[i]->setModRate(rate);

	mov	rax, QWORD PTR [r8+104]
; File E:\FoxSuite\shimmer\include\LFO.h

; 122  : 		lfo_inc = WAVETABLE_SIZE * lfo_frequency / (float)lfo_sampleRate;

	movaps	xmm1, xmm3
; File E:\FoxSuite\shimmer\include\FDN.h

; 229  : 		for (int i = 0; i < fdn_internalChannels; i++)

	inc	edx

; 230  : 			fdn_Modulation[i]->setModRate(rate);

	mov	rcx, QWORD PTR [r9+rax]
	lea	r9, QWORD PTR [r9+8]
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 90   : 		mdly_LFO->setLFOfrequency(mdly_rate);

	mov	rax, QWORD PTR [rcx+104]
; File E:\FoxSuite\shimmer\include\Modulation.h

; 67   : 		mod_rate = rate;

	movss	DWORD PTR [rcx+164], xmm2
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 89   : 		mdly_rate = modRate;

	movss	DWORD PTR [rcx+136], xmm2
	movd	xmm0, DWORD PTR [rax+4]
; File E:\FoxSuite\shimmer\include\LFO.h

; 122  : 		lfo_inc = WAVETABLE_SIZE * lfo_frequency / (float)lfo_sampleRate;

	cvtdq2ps xmm0, xmm0

; 71   : 		lfo_frequency = frequency;

	movss	DWORD PTR [rax], xmm2

; 122  : 		lfo_inc = WAVETABLE_SIZE * lfo_frequency / (float)lfo_sampleRate;

	divss	xmm1, xmm0
	movss	DWORD PTR [rax+20], xmm1
; File E:\FoxSuite\shimmer\include\FDN.h

; 229  : 		for (int i = 0; i < fdn_internalChannels; i++)

	cmp	edx, DWORD PTR [r8+172]
	jl	SHORT $LL4@setModRate
$LN3@setModRate:

; 231  : 	}

	ret	0
?setModRate@FDN@@QEAAXM@Z ENDP				; FDN::setModRate
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\Modulation.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\Modulation.h
; File E:\FoxSuite\shimmer\include\FDN.h
;	COMDAT ?setModDepth@FDN@@QEAAXM@Z
_TEXT	SEGMENT
this$ = 8
depth$ = 16
?setModDepth@FDN@@QEAAXM@Z PROC				; FDN::setModDepth, COMDAT

; 235  : 		for (int i = 0; i < fdn_internalChannels; i++)

	xor	r8d, r8d
	cmp	DWORD PTR [rcx+172], r8d
	jle	SHORT $LN3@setModDept
	mov	r9d, r8d
$LL4@setModDept:

; 236  : 			fdn_Modulation[i]->setModDepth(depth);	

	mov	rax, QWORD PTR [rcx+104]
; File E:\FoxSuite\shimmer\include\Modulation.h

; 63   : 		ModDelay::setDeltaDelayValue(mod_modValue * mod_depth);

	movaps	xmm0, xmm1
; File E:\FoxSuite\shimmer\include\FDN.h

; 235  : 		for (int i = 0; i < fdn_internalChannels; i++)

	inc	r8d

; 236  : 			fdn_Modulation[i]->setModDepth(depth);	

	mov	rdx, QWORD PTR [r9+rax]
	lea	r9, QWORD PTR [r9+8]
; File E:\FoxSuite\shimmer\include\Modulation.h

; 63   : 		ModDelay::setDeltaDelayValue(mod_modValue * mod_depth);

	mulss	xmm0, DWORD PTR [rdx+172]
	movss	DWORD PTR [rdx+168], xmm1
	movss	DWORD PTR [rdx+124], xmm0
; File E:\FoxSuite\shimmer\include\FDN.h

; 235  : 		for (int i = 0; i < fdn_internalChannels; i++)

	cmp	r8d, DWORD PTR [rcx+172]
	jl	SHORT $LL4@setModDept
$LN3@setModDept:

; 237  : 	}

	ret	0
?setModDepth@FDN@@QEAAXM@Z ENDP				; FDN::setModDepth
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\Modulation.h
; File E:\FoxSuite\shimmer\include\FDN.h
;	COMDAT ?setModFeedback@FDN@@QEAAXM@Z
_TEXT	SEGMENT
this$ = 8
fb$dead$ = 16
?setModFeedback@FDN@@QEAAXM@Z PROC			; FDN::setModFeedback, COMDAT

; 241  : 		for (int i = 0; i < fdn_internalChannels; i++)

	xor	r10d, r10d
	mov	r9d, r10d
	cmp	DWORD PTR [rcx+172], r10d
	jle	SHORT $LN3@setModFeed
	mov	r8d, r10d
$LL4@setModFeed:

; 242  : 			fdn_Modulation[i]->setModFeedback(fb);

	mov	rax, QWORD PTR [rcx+104]
	inc	r9d
	mov	rdx, QWORD PTR [r8+rax]
	lea	r8, QWORD PTR [r8+8]
; File E:\FoxSuite\shimmer\include\Modulation.h

; 72   : 		mod_fb = fb;

	mov	DWORD PTR [rdx+160], r10d

; 73   : 		ModDelay::setFeedback(fb);

	mov	DWORD PTR [rdx+72], r10d
; File E:\FoxSuite\shimmer\include\FDN.h

; 241  : 		for (int i = 0; i < fdn_internalChannels; i++)

	cmp	r9d, DWORD PTR [rcx+172]
	jl	SHORT $LL4@setModFeed
$LN3@setModFeed:

; 243  : 	}

	ret	0
?setModFeedback@FDN@@QEAAXM@Z ENDP			; FDN::setModFeedback
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\FDN.h
;	COMDAT ?setModMix@FDN@@QEAAXM@Z
_TEXT	SEGMENT
this$ = 48
mix$dead$ = 56
?setModMix@FDN@@QEAAXM@Z PROC				; FDN::setModMix, COMDAT

; 246  : 	void setModMix(float mix) {

$LN4:
	push	rbx
	sub	rsp, 32					; 00000020H

; 247  : 		fdn_modWet = sin(mix * 0.5 * M_PI);

	movsd	xmm0, QWORD PTR __real@3ff921fb54442d18
	mov	rbx, rcx
	call	QWORD PTR __imp_sin
	xorps	xmm1, xmm1
	cvtsd2ss xmm1, xmm0

; 248  : 		fdn_modDry = cos(mix * 0.5 * M_PI);

	movsd	xmm0, QWORD PTR __real@3ff921fb54442d18
	movss	DWORD PTR [rbx+312], xmm1
	call	QWORD PTR __imp_cos
	xorps	xmm1, xmm1
	cvtsd2ss xmm1, xmm0
	movss	DWORD PTR [rbx+316], xmm1

; 249  : 	}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?setModMix@FDN@@QEAAXM@Z ENDP				; FDN::setModMix
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\include\src\LPCombFilter.cpp
; File E:\FoxSuite\shimmer\include\LowPassFilter.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\include\FDN.h
;	COMDAT ?setDampingFrequency@FDN@@QEAAXM@Z
_TEXT	SEGMENT
this$ = 64
freq$ = 72
?setDampingFrequency@FDN@@QEAAXM@Z PROC			; FDN::setDampingFrequency, COMDAT

; 257  : 	void setDampingFrequency(float freq) {

$LN20:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 48					; 00000030H

; 258  : 		fdn_Feedback->setDampingFrequency(freq);

	mov	rdi, QWORD PTR [rcx+72]
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 88   : 		for (int i = 0; i < mcf_numberOfChannels; i++)

	xor	ebx, ebx
	movaps	XMMWORD PTR [rsp+32], xmm6
; File E:\FoxSuite\shimmer\include\FDN.h

; 257  : 	void setDampingFrequency(float freq) {

	movaps	xmm6, xmm1
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 88   : 		for (int i = 0; i < mcf_numberOfChannels; i++)

	cmp	DWORD PTR [rdi], ebx
	jle	SHORT $LN5@setDamping
	mov	esi, ebx
$LL6@setDamping:

; 89   : 			mcf_DelayLines[i]->setCutoffFrequency(freq);

	mov	rax, QWORD PTR [rdi+40]
	mov	rcx, QWORD PTR [rsi+rax]
; File E:\FoxSuite\shimmer\include\src\LPCombFilter.cpp

; 25   : 	lpcf_cutoffFreq = cutoffFreq;

	movss	DWORD PTR [rcx+96], xmm6

; 26   : 
; 27   : 	// set LPF cutoff frequency to the inserted value
; 28   : 	lpcf_feedbackLPF->setCutoffFrequency(lpcf_cutoffFreq);

	mov	rcx, QWORD PTR [rcx+88]
; File E:\FoxSuite\shimmer\include\LowPassFilter.h

; 68   : 		lpf_cutoffFreq = cutoffFreq;

	movss	DWORD PTR [rcx+4], xmm6

; 69   : 
; 70   : 		// update lpf gains
; 71   : 		updateGains();

	call	?updateGains@LowPassFilter@@QEAAXXZ	; LowPassFilter::updateGains
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 88   : 		for (int i = 0; i < mcf_numberOfChannels; i++)

	inc	ebx
	lea	rsi, QWORD PTR [rsi+8]
	cmp	ebx, DWORD PTR [rdi]
	jl	SHORT $LL6@setDamping
$LN5@setDamping:
; File E:\FoxSuite\shimmer\include\FDN.h

; 259  : 	}

	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	movaps	xmm6, XMMWORD PTR [rsp+32]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
?setDampingFrequency@FDN@@QEAAXM@Z ENDP			; FDN::setDampingFrequency
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\include\src\LPCombFilter.cpp
; File E:\FoxSuite\shimmer\include\LowPassFilter.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\include\FDN.h
;	COMDAT ?setDampingType@FDN@@QEAAXW4LPFilterType@@@Z
_TEXT	SEGMENT
this$ = 48
type$dead$ = 56
?setDampingType@FDN@@QEAAXW4LPFilterType@@@Z PROC	; FDN::setDampingType, COMDAT

; 262  : 	void setDampingType(LPFilterType type) {

$LN20:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 263  : 		fdn_Feedback->setFilterType(type);

	mov	rdi, QWORD PTR [rcx+72]
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 93   : 		for (int i = 0; i < mcf_numberOfChannels; i++)

	xor	ebx, ebx
	cmp	DWORD PTR [rdi], ebx
	jle	SHORT $LN5@setDamping
	mov	esi, ebx
$LL6@setDamping:
; File E:\FoxSuite\shimmer\include\src\LPCombFilter.cpp

; 32   : 	lpcf_feedbackLPF->setFilterType(type);

	mov	rax, QWORD PTR [rdi+40]
	mov	rcx, QWORD PTR [rax+rsi]
	mov	rcx, QWORD PTR [rcx+88]
; File E:\FoxSuite\shimmer\include\LowPassFilter.h

; 76   : 		lpf_type = type;

	mov	DWORD PTR [rcx], 6

; 77   : 
; 78   : 		// update lpf gains
; 79   : 		updateGains();

	call	?updateGains@LowPassFilter@@QEAAXXZ	; LowPassFilter::updateGains
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 93   : 		for (int i = 0; i < mcf_numberOfChannels; i++)

	inc	ebx
	lea	rsi, QWORD PTR [rsi+8]
	cmp	ebx, DWORD PTR [rdi]
	jl	SHORT $LL6@setDamping
$LN5@setDamping:
; File E:\FoxSuite\shimmer\include\FDN.h

; 264  : 	}

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?setDampingType@FDN@@QEAAXW4LPFilterType@@@Z ENDP	; FDN::setDampingType
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\LowPassFilter.h
; File E:\FoxSuite\shimmer\include\FDN.h
;	COMDAT ?setLowPassFrequency@FDN@@QEAAXM@Z
_TEXT	SEGMENT
this$ = 64
freq$ = 72
?setLowPassFrequency@FDN@@QEAAXM@Z PROC			; FDN::setLowPassFrequency, COMDAT

; 267  : 	void setLowPassFrequency(float freq) {

$LN16:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 48					; 00000030H

; 268  : 		for (int i = 0; i < fdn_outputChannels; i++)

	xor	ebx, ebx
	movaps	XMMWORD PTR [rsp+32], xmm6
	movaps	xmm6, xmm1
	mov	rdi, rcx
	cmp	DWORD PTR [rcx+176], ebx
	jle	SHORT $LN3@setLowPass
	mov	esi, ebx
$LL4@setLowPass:

; 269  : 			fdn_LPFOutput[i]->setCutoffFrequency(freq);

	mov	rax, QWORD PTR [rdi+80]
	mov	rcx, QWORD PTR [rsi+rax]
; File E:\FoxSuite\shimmer\include\LowPassFilter.h

; 68   : 		lpf_cutoffFreq = cutoffFreq;

	movss	DWORD PTR [rcx+4], xmm6

; 69   : 
; 70   : 		// update lpf gains
; 71   : 		updateGains();

	call	?updateGains@LowPassFilter@@QEAAXXZ	; LowPassFilter::updateGains
; File E:\FoxSuite\shimmer\include\FDN.h

; 268  : 		for (int i = 0; i < fdn_outputChannels; i++)

	inc	ebx
	lea	rsi, QWORD PTR [rsi+8]
	cmp	ebx, DWORD PTR [rdi+176]
	jl	SHORT $LL4@setLowPass
$LN3@setLowPass:

; 270  : 	}

	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	movaps	xmm6, XMMWORD PTR [rsp+32]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
?setLowPassFrequency@FDN@@QEAAXM@Z ENDP			; FDN::setLowPassFrequency
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\HighPassFilter.h
; File E:\FoxSuite\shimmer\include\FDN.h
;	COMDAT ?setHighPassFrequency@FDN@@QEAAXM@Z
_TEXT	SEGMENT
this$ = 64
freq$ = 72
?setHighPassFrequency@FDN@@QEAAXM@Z PROC		; FDN::setHighPassFrequency, COMDAT

; 273  : 	void setHighPassFrequency(float freq) {

$LN16:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 48					; 00000030H

; 274  : 		for (int i = 0; i < fdn_outputChannels; i++)

	xor	ebx, ebx
	movaps	XMMWORD PTR [rsp+32], xmm6
	movaps	xmm6, xmm1
	mov	rdi, rcx
	cmp	DWORD PTR [rcx+176], ebx
	jle	SHORT $LN3@setHighPas
	mov	esi, ebx
$LL4@setHighPas:

; 275  : 			fdn_HPFOutput[i]->setCutoffFrequency(freq);

	mov	rax, QWORD PTR [rdi+144]
	mov	rcx, QWORD PTR [rsi+rax]
; File E:\FoxSuite\shimmer\include\HighPassFilter.h

; 68   : 		hpf_cutoffFreq = cutoffFreq;

	movss	DWORD PTR [rcx+4], xmm6

; 69   : 
; 70   : 		// update hpf gains
; 71   : 		updateGains();

	call	?updateGains@HighPassFilter@@QEAAXXZ	; HighPassFilter::updateGains
; File E:\FoxSuite\shimmer\include\FDN.h

; 274  : 		for (int i = 0; i < fdn_outputChannels; i++)

	inc	ebx
	lea	rsi, QWORD PTR [rsi+8]
	cmp	ebx, DWORD PTR [rdi+176]
	jl	SHORT $LL4@setHighPas
$LN3@setHighPas:

; 276  : 	}

	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	movaps	xmm6, XMMWORD PTR [rsp+32]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
?setHighPassFrequency@FDN@@QEAAXM@Z ENDP		; FDN::setHighPassFrequency
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\LowPassFilter.h
; File E:\FoxSuite\shimmer\include\FDN.h
;	COMDAT ?setLowPassType@FDN@@QEAAXW4LPFilterType@@@Z
_TEXT	SEGMENT
this$ = 48
type$ = 56
?setLowPassType@FDN@@QEAAXW4LPFilterType@@@Z PROC	; FDN::setLowPassType, COMDAT

; 279  : 	void setLowPassType(LPFilterType type) {

$LN16:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 280  : 		for (int i = 0; i < fdn_outputChannels; i++)

	xor	ebx, ebx
	mov	ebp, edx
	mov	rdi, rcx
	cmp	DWORD PTR [rcx+176], ebx
	jle	SHORT $LN3@setLowPass
	mov	esi, ebx
$LL4@setLowPass:

; 281  : 			fdn_LPFOutput[i]->setFilterType(type);

	mov	rax, QWORD PTR [rdi+80]
	mov	rcx, QWORD PTR [rsi+rax]
; File E:\FoxSuite\shimmer\include\LowPassFilter.h

; 76   : 		lpf_type = type;

	mov	DWORD PTR [rcx], ebp

; 77   : 
; 78   : 		// update lpf gains
; 79   : 		updateGains();

	call	?updateGains@LowPassFilter@@QEAAXXZ	; LowPassFilter::updateGains
; File E:\FoxSuite\shimmer\include\FDN.h

; 280  : 		for (int i = 0; i < fdn_outputChannels; i++)

	inc	ebx
	lea	rsi, QWORD PTR [rsi+8]
	cmp	ebx, DWORD PTR [rdi+176]
	jl	SHORT $LL4@setLowPass
$LN3@setLowPass:

; 282  : 	}

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?setLowPassType@FDN@@QEAAXW4LPFilterType@@@Z ENDP	; FDN::setLowPassType
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\HighPassFilter.h
; File E:\FoxSuite\shimmer\include\FDN.h
;	COMDAT ?setHighPassType@FDN@@QEAAXW4HPFilterType@@@Z
_TEXT	SEGMENT
this$ = 48
type$dead$ = 56
?setHighPassType@FDN@@QEAAXW4HPFilterType@@@Z PROC	; FDN::setHighPassType, COMDAT

; 285  : 	void setHighPassType(HPFilterType type) {

$LN16:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 286  : 		for (int i = 0; i < fdn_outputChannels; i++)

	xor	ebx, ebx
	mov	rdi, rcx
	cmp	DWORD PTR [rcx+176], ebx
	jle	SHORT $LN3@setHighPas
	mov	esi, ebx
$LL4@setHighPas:

; 287  : 			fdn_HPFOutput[i]->setFilterType(type);

	mov	rax, QWORD PTR [rdi+144]
	mov	rcx, QWORD PTR [rsi+rax]
; File E:\FoxSuite\shimmer\include\HighPassFilter.h

; 76   : 		hpf_type = type;

	mov	DWORD PTR [rcx], 2

; 77   : 
; 78   : 		// update hpf gains
; 79   : 		updateGains();

	call	?updateGains@HighPassFilter@@QEAAXXZ	; HighPassFilter::updateGains
; File E:\FoxSuite\shimmer\include\FDN.h

; 286  : 		for (int i = 0; i < fdn_outputChannels; i++)

	inc	ebx
	lea	rsi, QWORD PTR [rsi+8]
	cmp	ebx, DWORD PTR [rdi+176]
	jl	SHORT $LL4@setHighPas
$LN3@setHighPas:

; 288  : 	}

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?setHighPassType@FDN@@QEAAXW4HPFilterType@@@Z ENDP	; FDN::setHighPassType
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\FDN.h
;	COMDAT ?setStereoSpread@FDN@@QEAAXM@Z
_TEXT	SEGMENT
this$ = 8
spread$ = 16
?setStereoSpread@FDN@@QEAAXM@Z PROC			; FDN::setStereoSpread, COMDAT

; 291  : 	void setStereoSpread(float spread) {

$LN29:
	mov	QWORD PTR [rsp+8], rbx

; 293  : 		for (int i = 0; i < fdn_numModDiffuser; i++)

	xor	r8d, r8d
	movss	DWORD PTR [rcx+308], xmm1
	mov	rdx, rcx
	cmp	DWORD PTR [rcx+184], r8d
	jle	SHORT $LN3@setStereoS
	xor	r9d, r9d
$LL4@setStereoS:
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h

; 60   : 		mdiff_MultiChDelay->setModDepth(depth);

	mov	rax, QWORD PTR [rdx+48]
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 88   : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	xor	ebx, ebx
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h

; 60   : 		mdiff_MultiChDelay->setModDepth(depth);

	mov	rcx, QWORD PTR [rax+r9]
	mov	r10, QWORD PTR [rcx+24]
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 88   : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	cmp	DWORD PTR [r10], ebx
	jle	SHORT $LN2@setStereoS
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

	xor	r11d, r11d
$LL13@setStereoS:
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 89   : 			mdel_DelayLines[i]->setDeltaDelayValue(depth*mdel_modValmsec);

	mov	rax, QWORD PTR [r10+8]
	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR [r10+48]
	inc	ebx
	mov	rcx, QWORD PTR [r11+rax]
	lea	r11, QWORD PTR [r11+8]
	movss	DWORD PTR [rcx+124], xmm0
	cmp	ebx, DWORD PTR [r10]
	jl	SHORT $LL13@setStereoS
$LN2@setStereoS:
; File E:\FoxSuite\shimmer\include\FDN.h

; 293  : 		for (int i = 0; i < fdn_numModDiffuser; i++)

	inc	r8d
	add	r9, 8
	cmp	r8d, DWORD PTR [rdx+184]
	jl	SHORT $LL4@setStereoS
$LN3@setStereoS:

; 294  : 			fdn_ModDiffuser[i]->setModDepth(spread);		
; 295  : 	}	

	mov	rbx, QWORD PTR [rsp+8]
	ret	0
?setStereoSpread@FDN@@QEAAXM@Z ENDP			; FDN::setStereoSpread
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\MultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\MultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\MultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\FDN.h
;	COMDAT ?setDiffuserDelayLengths@FDN@@QEAAXMW4DiffuserDelayLogic@@W4DelayDistribution@@M@Z
_TEXT	SEGMENT
this$ = 64
delayMaxLength$ = 72
logic$ = 80
distr$ = 88
delayMinLength$dead$ = 96
?setDiffuserDelayLengths@FDN@@QEAAXMW4DiffuserDelayLogic@@W4DelayDistribution@@M@Z PROC ; FDN::setDiffuserDelayLengths, COMDAT

; 304  : 	void setDiffuserDelayLengths(float delayMaxLength, DiffuserDelayLogic logic = DEFAULT_DIFFUSER_DELAY_LOGIC, DelayDistribution distr = DEFAULT_DIFFUSER_DELAY_DISTRIBUTION, float delayMinLength = DEFAULT_DIFFUSER_MIN_DELAY) {

$LN61:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	push	r14
	sub	rsp, 48					; 00000030H

; 305  : 		fdn_diffLogic = logic;
; 306  : 		fdn_diffDelDistr = distr;
; 307  : 		switch (logic) {

	xor	edi, edi
	movaps	XMMWORD PTR [rax-24], xmm6
	mov	DWORD PTR [rcx+292], r8d
	mov	esi, r9d
	mov	DWORD PTR [rcx+280], r9d
	movaps	xmm6, xmm1
	mov	rbx, rcx
	test	r8d, r8d
	je	$LN4@setDiffuse
	cmp	r8d, 1
	jne	$LN2@setDiffuse

; 511  : 		for (int i = 0; i < fdn_diffusionSteps - fdn_numModDiffuser; i++)

	mov	eax, DWORD PTR [rbx+180]
	mov	r14d, edi
	mov	ecx, DWORD PTR [rcx+184]
	sub	eax, ecx
	test	eax, eax
	jle	SHORT $LN27@setDiffuse
	mov	ebp, edi
$LL28@setDiffuse:
; File E:\FoxSuite\shimmer\include\MultiChannelDiffuser.h

; 50   : 		mdiff_MultiChDelay->setDelayLinesLength(minDelayMs, maxDelayMs, distr);

	mov	rax, QWORD PTR [rbx+24]
	mov	r9d, esi
	movaps	xmm2, xmm6
	mov	rcx, QWORD PTR [rax+rbp]
	mov	rcx, QWORD PTR [rcx+24]
	call	?setDelayLinesLength@MultiChannelDelay@@QEAAXMMW4DelayDistribution@@@Z ; MultiChannelDelay::setDelayLinesLength
; File E:\FoxSuite\shimmer\include\FDN.h

; 511  : 		for (int i = 0; i < fdn_diffusionSteps - fdn_numModDiffuser; i++)

	mov	eax, DWORD PTR [rbx+180]
	lea	rbp, QWORD PTR [rbp+8]
	mov	ecx, DWORD PTR [rbx+184]
	inc	r14d
	sub	eax, ecx
	cmp	r14d, eax
	jl	SHORT $LL28@setDiffuse
$LN27@setDiffuse:

; 513  : 		for (int i = 0; i < fdn_numModDiffuser; i++)

	test	ecx, ecx
	jle	$LN30@setDiffuse
	mov	rbp, rdi
$LL31@setDiffuse:
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h

; 52   : 		mdiff_MultiChDelay->setDelayLinesLength(minDelayMs, maxDelayMs, distr);

	mov	rax, QWORD PTR [rbx+48]
	mov	r9d, esi
	movaps	xmm2, xmm6
	mov	rcx, QWORD PTR [rax+rbp]
	mov	rcx, QWORD PTR [rcx+24]
	call	?setDelayLinesLength@ModMultiChannelDelay@@QEAAXMMW4DelayDistribution@@@Z ; ModMultiChannelDelay::setDelayLinesLength
; File E:\FoxSuite\shimmer\include\FDN.h

; 513  : 		for (int i = 0; i < fdn_numModDiffuser; i++)

	inc	edi
	lea	rbp, QWORD PTR [rbp+8]
	cmp	edi, DWORD PTR [rbx+184]
	jl	SHORT $LL31@setDiffuse
; File E:\FoxSuite\shimmer\include\MultiChannelDiffuser.h

; 50   : 		mdiff_MultiChDelay->setDelayLinesLength(minDelayMs, maxDelayMs, distr);

	jmp	SHORT $LN30@setDiffuse
$LN4@setDiffuse:
; File E:\FoxSuite\shimmer\include\FDN.h

; 498  : 		for (int i = fdn_numModDiffuser - 1; i >=0; i--) {

	mov	ecx, DWORD PTR [rcx+184]
	lea	eax, DWORD PTR [rcx-1]

; 308  : 		case DiffuserDelayLogic::Doubled: {
; 309  : 			setDoubledDiffuserDelayLengths(delayMinLength, delayMaxLength, distr);

	movsxd	rbp, eax

; 498  : 		for (int i = fdn_numModDiffuser - 1; i >=0; i--) {

	test	eax, eax
	js	SHORT $LN9@setDiffuse
$LL10@setDiffuse:
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h

; 52   : 		mdiff_MultiChDelay->setDelayLinesLength(minDelayMs, maxDelayMs, distr);

	mov	rax, QWORD PTR [rbx+48]
	mov	r9d, esi
	movaps	xmm2, xmm6
	mov	rcx, QWORD PTR [rax+rbp*8]
	mov	rcx, QWORD PTR [rcx+24]
	call	?setDelayLinesLength@ModMultiChannelDelay@@QEAAXMMW4DelayDistribution@@@Z ; ModMultiChannelDelay::setDelayLinesLength
; File E:\FoxSuite\shimmer\include\FDN.h

; 498  : 		for (int i = fdn_numModDiffuser - 1; i >=0; i--) {

	sub	rbp, 1

; 499  : 			fdn_ModDiffuser[i]->setDelayLinesLength(minDelayMs, maxDelayMs, distr);
; 500  : 			maxDelayMs *= 0.5;

	mulss	xmm6, DWORD PTR __real@3f000000
	jns	SHORT $LL10@setDiffuse
	mov	ecx, DWORD PTR [rbx+184]
$LN9@setDiffuse:

; 502  : 		for (int i = fdn_diffusionSteps - fdn_numModDiffuser - 1; i >= 0; i--) {

	mov	eax, DWORD PTR [rbx+180]
	sub	eax, ecx
	sub	eax, 1
	movsxd	rbp, eax
	js	SHORT $LN12@setDiffuse
$LL13@setDiffuse:
; File E:\FoxSuite\shimmer\include\MultiChannelDiffuser.h

; 50   : 		mdiff_MultiChDelay->setDelayLinesLength(minDelayMs, maxDelayMs, distr);

	mov	rax, QWORD PTR [rbx+24]
	mov	r9d, esi
	movaps	xmm2, xmm6
	mov	rcx, QWORD PTR [rax+rbp*8]
	mov	rcx, QWORD PTR [rcx+24]
	call	?setDelayLinesLength@MultiChannelDelay@@QEAAXMMW4DelayDistribution@@@Z ; MultiChannelDelay::setDelayLinesLength
; File E:\FoxSuite\shimmer\include\FDN.h

; 502  : 		for (int i = fdn_diffusionSteps - fdn_numModDiffuser - 1; i >= 0; i--) {

	sub	rbp, 1

; 503  : 			fdn_Diffuser[i]->setDelayLinesLength(minDelayMs, maxDelayMs, distr);
; 504  : 			maxDelayMs *= 0.5;

	mulss	xmm6, DWORD PTR __real@3f000000
	jns	SHORT $LL13@setDiffuse
$LN12@setDiffuse:

; 505  : 		}		
; 506  : 		fdn_OutputDiffusion->setDelayLinesLength(minDelayMs, maxDelayMs * 2.0, distr);

	addss	xmm6, xmm6
$LN30@setDiffuse:

; 310  : 			break;
; 311  : 		}
; 312  : 		case DiffuserDelayLogic::Equal: {
; 313  : 			setEqualDiffuserDelayLengths(delayMinLength, delayMaxLength, distr);
; 314  : 			break;
; 315  : 		}
; 316  : 		}
; 317  : 	}

	mov	rcx, QWORD PTR [rbx+136]
	mov	r9d, esi
	movaps	xmm2, xmm6
	mov	rcx, QWORD PTR [rcx+24]
	call	?setDelayLinesLength@MultiChannelDelay@@QEAAXMMW4DelayDistribution@@@Z ; MultiChannelDelay::setDelayLinesLength
$LN2@setDiffuse:
	mov	rbx, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	mov	rdi, QWORD PTR [rsp+88]
	movaps	xmm6, XMMWORD PTR [rsp+32]
	add	rsp, 48					; 00000030H
	pop	r14
	ret	0
?setDiffuserDelayLengths@FDN@@QEAAXMW4DiffuserDelayLogic@@W4DelayDistribution@@M@Z ENDP ; FDN::setDiffuserDelayLengths
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\include\FDN.h
;	COMDAT ?setFeedbackDelayLengths@FDN@@QEAAXMMW4DelayDistribution@@@Z
_TEXT	SEGMENT
this$ = 48
mindelay$ = 56
maxDelay$ = 64
distr$ = 72
?setFeedbackDelayLengths@FDN@@QEAAXMMW4DelayDistribution@@@Z PROC ; FDN::setFeedbackDelayLengths, COMDAT

; 320  : 	void setFeedbackDelayLengths(float mindelay, float maxDelay, DelayDistribution distr = DEFAULT_FEEDBACK_DELAY_DISTRIBUTION) {

$LN11:
	push	rbx
	sub	rsp, 32					; 00000020H
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 72   : 		if (maxDelay != 0.0)

	ucomiss	xmm2, DWORD PTR __real@00000000
; File E:\FoxSuite\shimmer\include\FDN.h

; 321  : 		fdn_feedDelDistr = distr;

	mov	DWORD PTR [rcx+284], r9d
	mov	rbx, rcx

; 322  : 		fdn_Feedback->setDelayLengths(mindelay, maxDelay, distr);

	mov	rcx, QWORD PTR [rcx+72]
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 71   : 		mcf_minDelayLength = minDelay;

	movss	DWORD PTR [rcx+8], xmm1

; 72   : 		if (maxDelay != 0.0)

	je	SHORT $LN6@setFeedbac

; 73   : 			mcf_maxDelayLength = maxDelay;

	movss	DWORD PTR [rcx+12], xmm2
$LN6@setFeedbac:

; 74   : 		mcf_delayDistribution = distr;

	mov	DWORD PTR [rcx+24], r9d

; 75   : 		switch (distr) {

	test	r9d, r9d
	je	SHORT $LN7@setFeedbac
	cmp	r9d, 1
	jne	SHORT $LN4@setFeedbac

; 78   : 			break;
; 79   : 		}
; 80   : 		case DelayDistribution::RandomInRange: {
; 81   : 			setRandomInRangeDelayLines();

	call	?setRandomInRangeDelayLines@ModMultiChannelFeedback@@AEAAXXZ ; ModMultiChannelFeedback::setRandomInRangeDelayLines
	jmp	SHORT $LN4@setFeedbac
$LN7@setFeedbac:

; 76   : 		case DelayDistribution::Exponential: {
; 77   : 			setDelayExponential();

	call	?setDelayExponential@ModMultiChannelFeedback@@AEAAXXZ ; ModMultiChannelFeedback::setDelayExponential
$LN4@setFeedbac:
; File E:\FoxSuite\shimmer\include\FDN.h

; 323  : 		setDecayInSeconds(fdn_decay);

	movss	xmm1, DWORD PTR [rbx+296]
	mov	rcx, rbx

; 324  : 	}

	add	rsp, 32					; 00000020H
	pop	rbx

; 323  : 		setDecayInSeconds(fdn_decay);

	jmp	?setDecayInSeconds@FDN@@QEAAXM@Z	; FDN::setDecayInSeconds
?setFeedbackDelayLengths@FDN@@QEAAXMMW4DelayDistribution@@@Z ENDP ; FDN::setFeedbackDelayLengths
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\FDN.h
;	COMDAT ?setEarlyReflWeight@FDN@@QEAAXM@Z
_TEXT	SEGMENT
this$ = 8
weight$dead$ = 16
?setEarlyReflWeight@FDN@@QEAAXM@Z PROC			; FDN::setEarlyReflWeight, COMDAT

; 328  : 		fdn_earlyWeight = weight;

	mov	DWORD PTR [rcx+304], 1065353216		; 3f800000H

; 329  : 	}

	ret	0
?setEarlyReflWeight@FDN@@QEAAXM@Z ENDP			; FDN::setEarlyReflWeight
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\MultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\MultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\LowPassFilter.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\HighPassFilter.h
; File E:\FoxSuite\shimmer\include\FDN.h
;	COMDAT ?setSampleRate@FDN@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 80
sampleRate$ = 88
?setSampleRate@FDN@@QEAAXH@Z PROC			; FDN::setSampleRate, COMDAT

; 402  : 	void setSampleRate(int sampleRate) { 

$LN112:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 404  : 		fdn_EarlyReflections->setSampleRate(sampleRate);

	mov	rbp, QWORD PTR [rcx+16]
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h

; 86   : 		for (int i = 0; i < mdel_numberOfChannels; i++) {

	xor	ebx, ebx
; File E:\FoxSuite\shimmer\include\FDN.h

; 403  : 		fdn_sampleRate = sampleRate;		

	mov	DWORD PTR [rcx+264], edx
	mov	esi, edx
	mov	rdi, rcx
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h

; 86   : 		for (int i = 0; i < mdel_numberOfChannels; i++) {

	mov	r15d, ebx
	cmp	DWORD PTR [rbp], ebx
	jle	SHORT $LN17@setSampleR
	mov	r14d, ebx
$LL18@setSampleR:

; 87   : 			mdel_sampleRate = sampleRate;

	mov	DWORD PTR [rbp+40], esi

; 88   : 			mdel_DelayLines[i]->setSampleRate(sampleRate);

	mov	edx, esi
	mov	rax, QWORD PTR [rbp+8]
	mov	rcx, QWORD PTR [r14+rax]
	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+8]
	inc	r15d
	lea	r14, QWORD PTR [r14+8]
	cmp	r15d, DWORD PTR [rbp]
	jl	SHORT $LL18@setSampleR
$LN17@setSampleR:
; File E:\FoxSuite\shimmer\include\FDN.h

; 405  : 		for (int i = 0; i < fdn_diffusionSteps - fdn_numModDiffuser; i++)

	mov	eax, DWORD PTR [rdi+180]
	mov	ebp, ebx
	mov	ecx, DWORD PTR [rdi+184]
	sub	eax, ecx
	test	eax, eax
	jle	SHORT $LN3@setSampleR
	mov	r14, rbx
$LL4@setSampleR:

; 406  : 			fdn_Diffuser[i]->setSampleRate(sampleRate);		

	mov	rax, QWORD PTR [rdi+24]
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h

; 86   : 		for (int i = 0; i < mdel_numberOfChannels; i++) {

	mov	r13d, ebx
; File E:\FoxSuite\shimmer\include\FDN.h

; 406  : 			fdn_Diffuser[i]->setSampleRate(sampleRate);		

	mov	rcx, QWORD PTR [r14+rax]
; File E:\FoxSuite\shimmer\include\MultiChannelDiffuser.h

; 59   : 		mdiff_MultiChDelay->setSampleRate(sampleRate); 

	mov	r15, QWORD PTR [rcx+24]
	mov	DWORD PTR [rcx+4], esi
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h

; 86   : 		for (int i = 0; i < mdel_numberOfChannels; i++) {

	cmp	DWORD PTR [r15], ebx
	jle	SHORT $LN2@setSampleR
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

	mov	r12, rbx
$LL29@setSampleR:
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h

; 87   : 			mdel_sampleRate = sampleRate;

	mov	DWORD PTR [r15+40], esi

; 88   : 			mdel_DelayLines[i]->setSampleRate(sampleRate);

	mov	edx, esi
	mov	rax, QWORD PTR [r15+8]
	mov	rcx, QWORD PTR [r12+rax]
	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+8]
	inc	r13d
	lea	r12, QWORD PTR [r12+8]
	cmp	r13d, DWORD PTR [r15]
	jl	SHORT $LL29@setSampleR
$LN2@setSampleR:
; File E:\FoxSuite\shimmer\include\FDN.h

; 405  : 		for (int i = 0; i < fdn_diffusionSteps - fdn_numModDiffuser; i++)

	mov	eax, DWORD PTR [rdi+180]
	inc	ebp
	mov	ecx, DWORD PTR [rdi+184]
	add	r14, 8
	sub	eax, ecx
	cmp	ebp, eax
	jl	SHORT $LL4@setSampleR
$LN3@setSampleR:

; 407  : 		for (int i = 0; i < fdn_numModDiffuser; i++)

	mov	ebp, ebx
	test	ecx, ecx
	jle	SHORT $LN6@setSampleR
	mov	r14, rbx
$LL7@setSampleR:

; 408  : 			fdn_ModDiffuser[i]->setSampleRate(sampleRate);

	mov	rax, QWORD PTR [rdi+48]
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 114  : 		for (int i = 0; i < mdel_numberOfChannels; i++) {

	mov	r13d, ebx
; File E:\FoxSuite\shimmer\include\FDN.h

; 408  : 			fdn_ModDiffuser[i]->setSampleRate(sampleRate);

	mov	rcx, QWORD PTR [r14+rax]
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h

; 81   : 		mdiff_MultiChDelay->setSampleRate(sampleRate);

	mov	r15, QWORD PTR [rcx+24]
	mov	DWORD PTR [rcx+4], esi
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 114  : 		for (int i = 0; i < mdel_numberOfChannels; i++) {

	cmp	DWORD PTR [r15], ebx
	jle	SHORT $LN5@setSampleR
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

	mov	r12, rbx
$LL40@setSampleR:
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 115  : 			mdel_sampleRate = sampleRate;

	mov	DWORD PTR [r15+40], esi

; 116  : 			mdel_DelayLines[i]->setSampleRate(sampleRate);

	mov	edx, esi
	mov	rax, QWORD PTR [r15+8]
	mov	rcx, QWORD PTR [r12+rax]
	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+8]
	inc	r13d
	lea	r12, QWORD PTR [r12+8]
	cmp	r13d, DWORD PTR [r15]
	jl	SHORT $LL40@setSampleR
$LN5@setSampleR:
; File E:\FoxSuite\shimmer\include\FDN.h

; 407  : 		for (int i = 0; i < fdn_numModDiffuser; i++)

	inc	ebp
	add	r14, 8
	cmp	ebp, DWORD PTR [rdi+184]
	jl	SHORT $LL7@setSampleR
$LN6@setSampleR:

; 409  : 		for (int i = 0; i < fdn_internalChannels; i++)

	mov	ebp, ebx
	cmp	DWORD PTR [rdi+172], ebx
	jle	SHORT $LN9@setSampleR
	mov	r14, rbx
$LL10@setSampleR:

; 410  : 			fdn_Modulation[i]->setSampleRate(sampleRate);

	mov	rax, QWORD PTR [rdi+104]
	mov	edx, esi
	mov	rcx, QWORD PTR [r14+rax]
	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+8]
	inc	ebp
	lea	r14, QWORD PTR [r14+8]
	cmp	ebp, DWORD PTR [rdi+172]
	jl	SHORT $LL10@setSampleR
$LN9@setSampleR:

; 411  : 		fdn_OutputDiffusion->setSampleRate(sampleRate);

	mov	rax, QWORD PTR [rdi+136]
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h

; 86   : 		for (int i = 0; i < mdel_numberOfChannels; i++) {

	mov	r14d, ebx
; File E:\FoxSuite\shimmer\include\MultiChannelDiffuser.h

; 59   : 		mdiff_MultiChDelay->setSampleRate(sampleRate); 

	mov	rbp, QWORD PTR [rax+24]
	mov	DWORD PTR [rax+4], esi
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h

; 86   : 		for (int i = 0; i < mdel_numberOfChannels; i++) {

	cmp	DWORD PTR [rbp], ebx
	jle	SHORT $LN50@setSampleR
	mov	r15, rbx
$LL51@setSampleR:

; 87   : 			mdel_sampleRate = sampleRate;

	mov	DWORD PTR [rbp+40], esi

; 88   : 			mdel_DelayLines[i]->setSampleRate(sampleRate);

	mov	edx, esi
	mov	rax, QWORD PTR [rbp+8]
	mov	rcx, QWORD PTR [r15+rax]
	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+8]
	inc	r14d
	lea	r15, QWORD PTR [r15+8]
	cmp	r14d, DWORD PTR [rbp]
	jl	SHORT $LL51@setSampleR
$LN50@setSampleR:
; File E:\FoxSuite\shimmer\include\FDN.h

; 412  : 		fdn_Feedback->setSampleRate(sampleRate);

	mov	rbp, QWORD PTR [rdi+72]
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 66   : 		for (int i = 0; i < mcf_numberOfChannels; i++)

	mov	r14d, ebx
	cmp	DWORD PTR [rbp], ebx
	jle	SHORT $LN57@setSampleR
	mov	r15, rbx
$LL58@setSampleR:

; 67   : 			mcf_DelayLines[i]->setSampleRate(sampleRate);

	mov	rax, QWORD PTR [rbp+40]
	mov	edx, esi
	mov	rcx, QWORD PTR [r15+rax]
	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+8]
	inc	r14d
	lea	r15, QWORD PTR [r15+8]
	cmp	r14d, DWORD PTR [rbp]
	jl	SHORT $LL58@setSampleR
$LN57@setSampleR:
; File E:\FoxSuite\shimmer\include\FDN.h

; 413  : 		for (int i = 0; i < fdn_outputChannels; i++) {

	cmp	DWORD PTR [rdi+176], ebx
	jle	SHORT $LN12@setSampleR
	mov	r14, rbx
$LL13@setSampleR:

; 414  : 			fdn_LPFOutput[i]->setSampleRate(sampleRate);

	mov	rax, QWORD PTR [rdi+80]
	mov	rcx, QWORD PTR [r14+rax]
; File E:\FoxSuite\shimmer\include\LowPassFilter.h

; 60   : 		lpf_sampleRate = sampleRate;

	mov	DWORD PTR [rcx+8], esi

; 61   : 
; 62   : 		// update lpf gains
; 63   : 		updateGains();

	call	?updateGains@LowPassFilter@@QEAAXXZ	; LowPassFilter::updateGains
; File E:\FoxSuite\shimmer\include\FDN.h

; 415  : 			fdn_HPFOutput[i]->setSampleRate(sampleRate);

	mov	rax, QWORD PTR [rdi+144]
	mov	rcx, QWORD PTR [r14+rax]
; File E:\FoxSuite\shimmer\include\HighPassFilter.h

; 60   : 		hpf_sampleRate = sampleRate;

	mov	DWORD PTR [rcx+8], esi

; 61   : 
; 62   : 		// update hpf gains
; 63   : 		updateGains();

	call	?updateGains@HighPassFilter@@QEAAXXZ	; HighPassFilter::updateGains
; File E:\FoxSuite\shimmer\include\FDN.h

; 413  : 		for (int i = 0; i < fdn_outputChannels; i++) {

	inc	ebx
	lea	r14, QWORD PTR [r14+8]
	cmp	ebx, DWORD PTR [rdi+176]
	jl	SHORT $LL13@setSampleR
$LN12@setSampleR:

; 416  : 		}
; 417  : 	}	

	mov	rbx, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
?setSampleRate@FDN@@QEAAXH@Z ENDP			; FDN::setSampleRate
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\FDN.h
;	COMDAT ?setMixMode@FDN@@QEAAXW4MixMode@@@Z
_TEXT	SEGMENT
this$ = 8
mode$dead$ = 16
?setMixMode@FDN@@QEAAXW4MixMode@@@Z PROC		; FDN::setMixMode, COMDAT

; 421  : 		fdn_Mixer->setMixMode(mode); 

	mov	rax, QWORD PTR [rcx+8]
	mov	DWORD PTR [rax+8], 1

; 422  : 	}

	ret	0
?setMixMode@FDN@@QEAAXW4MixMode@@@Z ENDP		; FDN::setMixMode
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\ChannelSplitter.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\ChannelSplitter.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\FlipPolarity.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\FlipPolarity.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FlipPolarity.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\ChannelMixer.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\LowPassFilter.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\HighPassFilter.h
; File E:\FoxSuite\shimmer\include\FDN.h
;	COMDAT ?processAudio@FDN@@QEAAXPEAM0@Z
_TEXT	SEGMENT
tv2065 = 32
$T28 = 40
this$ = 128
in$ = 136
out$ = 144
?processAudio@FDN@@QEAAXPEAM0@Z PROC			; FDN::processAudio, COMDAT

; 439  : 	void processAudio(float* in, float* out) { 

$LN178:
	mov	rax, rsp
	mov	QWORD PTR [rax+16], rbx
	mov	QWORD PTR [rax+24], r8
	mov	QWORD PTR [rax+8], rcx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 64					; 00000040H
	mov	rbx, rcx
	movaps	XMMWORD PTR [rax-72], xmm6
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

	mov	rcx, QWORD PTR [rcx+192]
; File E:\FoxSuite\shimmer\include\FDN.h

; 439  : 	void processAudio(float* in, float* out) { 

	mov	rsi, r8
; File E:\FoxSuite\shimmer\include\ChannelSplitter.h

; 36   : 		if (cspl_numberOfChannelsIn != 1) {

	xor	edi, edi
	xorps	xmm6, xmm6
; File E:\FoxSuite\shimmer\include\FDN.h

; 441  : 		fdn_Splitter->processAudio(in, &fdn_tmpDiffuser[0]);

	mov	r8, QWORD PTR [rbx]
; File E:\FoxSuite\shimmer\include\ChannelSplitter.h

; 36   : 		if (cspl_numberOfChannelsIn != 1) {

	cmp	DWORD PTR [r8], 1
	je	SHORT $LN28@processAud

; 37   : 			input = 0;
; 38   : 			for (int i = 0; i < cspl_numberOfChannelsIn; i++) {

	movsxd	r9, DWORD PTR [r8]
	xorps	xmm1, xmm1
	test	r9, r9
	jle	SHORT $LN23@processAud
	mov	eax, edi
$LL144@processAud:

; 39   : 				input += in[i];

	addss	xmm1, DWORD PTR [rdx+rax*4]
	inc	rax
	cmp	rax, r9
	jl	SHORT $LL144@processAud
$LN23@processAud:
	movd	xmm0, DWORD PTR [r8]

; 40   : 			}
; 41   : 			input = input / cspl_numberOfChannelsIn;

	cvtdq2ps xmm0, xmm0
	divss	xmm1, xmm0

; 42   : 		}

	jmp	SHORT $LN29@processAud
$LN28@processAud:

; 43   : 		else
; 44   : 			input = in[0];

	movss	xmm1, DWORD PTR [rdx]
$LN29@processAud:

; 45   : 
; 46   : 		for (int i = 0; i < cspl_numberOfChannelsOut; i++) out[i] = input; }

	mov	eax, edi
	cmp	DWORD PTR [r8+4], edi
	jle	SHORT $LN26@processAud
$LL27@processAud:
	movss	DWORD PTR [rcx], xmm1
	inc	eax
	lea	rcx, QWORD PTR [rcx+4]
	cmp	eax, DWORD PTR [r8+4]
	jl	SHORT $LL27@processAud
$LN26@processAud:
; File E:\FoxSuite\shimmer\include\FDN.h

; 444  : 		for (int i = 0; i < fdn_diffusionSteps - fdn_numModDiffuser; i++)

	mov	eax, DWORD PTR [rbx+180]
	mov	ebp, edi
	mov	ecx, DWORD PTR [rbx+184]
	sub	eax, ecx
	test	eax, eax
	jle	SHORT $LN3@processAud
	mov	r14, rdi
$LL4@processAud:

; 445  : 			fdn_Diffuser[i]->processAudio(&fdn_tmpDiffuser[0], &fdn_tmpDiffuser[0]);

	mov	rcx, QWORD PTR [rbx+24]
	mov	rdx, QWORD PTR [rbx+192]
	mov	r8, rdx
	mov	rcx, QWORD PTR [r14+rcx]
	call	?processAudio@MultiChannelDiffuser@@QEAAXPEAM0@Z ; MultiChannelDiffuser::processAudio
	mov	eax, DWORD PTR [rbx+180]
	lea	r14, QWORD PTR [r14+8]
	mov	ecx, DWORD PTR [rbx+184]
	inc	ebp
	sub	eax, ecx
	cmp	ebp, eax
	jl	SHORT $LL4@processAud
$LN3@processAud:

; 448  : 		for (int i = 0; i < fdn_numModDiffuser; i++)

	mov	r12d, edi
	test	ecx, ecx
	jle	$LN6@processAud
	mov	r15, rdi
$LL7@processAud:

; 449  : 			fdn_ModDiffuser[i]->processAudio(&fdn_tmpDiffuser[0], &fdn_tmpDiffuser[0]);

	mov	rax, QWORD PTR [rbx+48]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

	mov	r8, QWORD PTR [rbx+192]
	mov	QWORD PTR $T28[rsp], r8
; File E:\FoxSuite\shimmer\include\FDN.h

; 449  : 			fdn_ModDiffuser[i]->processAudio(&fdn_tmpDiffuser[0], &fdn_tmpDiffuser[0]);

	mov	rbp, QWORD PTR [r15+rax]
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h

; 85   : 		mdiff_MultiChDelay->processAudio(in, mdiff_outMultiChDel);

	mov	rsi, QWORD PTR [rbp+24]
	mov	r14, QWORD PTR [rbp+8]
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 121  : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	cmp	DWORD PTR [rsi], edi
	jle	SHORT $LN173@processAud
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

	mov	r13, r8
	mov	ebx, edi
	sub	r13, r14
$LL48@processAud:
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 122  : 			out[i] = mdel_DelayLines[i]->processAudio(in[i]);

	mov	rax, QWORD PTR [rsi+8]
	movss	xmm1, DWORD PTR [r14+r13]
	mov	rcx, QWORD PTR [rdi+rax]
	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+16]
	movss	DWORD PTR [r14], xmm0
	inc	ebx
	lea	rdi, QWORD PTR [rdi+8]
	lea	r14, QWORD PTR [r14+4]
	cmp	ebx, DWORD PTR [rsi]
	jl	SHORT $LL48@processAud
	mov	rbx, QWORD PTR this$[rsp]
	xor	edi, edi
	mov	r8, QWORD PTR $T28[rsp]
$LN173@processAud:
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h

; 86   : 		mdiff_Polarity->processAudio(mdiff_outMultiChDel, mdiff_outMultiChDel);

	mov	rcx, QWORD PTR [rbp+40]
; File E:\FoxSuite\shimmer\include\FlipPolarity.h

; 29   : 		for (int i = 0; i < fp_numofChannels; i++) {			

	mov	r9d, edi
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h

; 86   : 		mdiff_Polarity->processAudio(mdiff_outMultiChDel, mdiff_outMultiChDel);

	mov	rdx, QWORD PTR [rbp+8]
; File E:\FoxSuite\shimmer\include\FlipPolarity.h

; 29   : 		for (int i = 0; i < fp_numofChannels; i++) {			

	cmp	DWORD PTR [rcx+24], edi
	jle	SHORT $LN174@processAud
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

	mov	r10, QWORD PTR [rcx]
	mov	rax, rdx
	sub	r10, rdx
$LL55@processAud:
	movd	xmm0, DWORD PTR [r10+rax]
; File E:\FoxSuite\shimmer\include\FlipPolarity.h

; 29   : 		for (int i = 0; i < fp_numofChannels; i++) {			

	inc	r9d

; 30   : 			out[i] = in[i] * fp_flipPolarity[i];

	cvtdq2ps xmm0, xmm0
	mulss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR [rax], xmm0
	lea	rax, QWORD PTR [rax+4]
	cmp	r9d, DWORD PTR [rcx+24]
	jl	SHORT $LL55@processAud
$LN174@processAud:
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h

; 87   : 		mdiff_Hadamard->processAudio(mdiff_outMultiChDel, out);

	mov	rcx, QWORD PTR [rbp+32]
	call	?processAudio@Hadamard@@QEAAXPEAM0@Z	; Hadamard::processAudio
; File E:\FoxSuite\shimmer\include\FDN.h

; 448  : 		for (int i = 0; i < fdn_numModDiffuser; i++)

	inc	r12d
	add	r15, 8
	cmp	r12d, DWORD PTR [rbx+184]
	jl	$LL7@processAud
	mov	rsi, QWORD PTR out$[rsp]
$LN6@processAud:

; 450  : 						
; 451  : 		// Spill-out the diffused signal and send to multi-channel delay for early reflections
; 452  : 		fdn_EarlyReflections->processAudio(&fdn_tmpDiffuser[0], &fdn_outEarly[0]);

	mov	r15, QWORD PTR [rbx+16]
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h

; 93   : 		for (int i = 0; i < mdel_numberOfChannels; i++) 

	mov	r12d, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

	mov	r14, QWORD PTR [rbx+240]
	mov	rbp, QWORD PTR [rbx+192]
; File E:\FoxSuite\shimmer\include\MultiChannelDelay.h

; 93   : 		for (int i = 0; i < mdel_numberOfChannels; i++) 

	cmp	DWORD PTR [r15], edi
	jle	SHORT $LN65@processAud
	mov	r13, rdi
	sub	rbp, r14
$LL66@processAud:

; 94   : 			out[i] = mdel_DelayLines[i]->processAudio(in[i]);

	mov	rax, QWORD PTR [r15+8]
	movss	xmm1, DWORD PTR [r14+rbp]
	mov	rcx, QWORD PTR [rax+r13]
	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+16]
	movss	DWORD PTR [r14], xmm0
	inc	r12d
	lea	r13, QWORD PTR [r13+8]
	lea	r14, QWORD PTR [r14+4]
	cmp	r12d, DWORD PTR [r15]
	jl	SHORT $LL66@processAud
	mov	rbp, QWORD PTR [rbx+192]
$LN65@processAud:
; File E:\FoxSuite\shimmer\include\FDN.h

; 455  : 		fdn_Feedback->processAudio(&fdn_tmpDiffuser[0], &fdn_tmpFeedback[0]);

	mov	r8, QWORD PTR [rbx+216]
	mov	rdx, rbp
	mov	rcx, QWORD PTR [rbx+72]
	call	?processAudio@ModMultiChannelFeedback@@QEAAXPEAM0@Z ; ModMultiChannelFeedback::processAudio

; 456  : 		
; 457  : 		// Apply Hadamard mixing matrix to "align" channels
; 458  : 		fdn_MixMatrix->processAudio(&fdn_tmpFeedback[0], &fdn_tmpFeedback[0]);

	mov	rdx, QWORD PTR [rbx+216]
	mov	rcx, QWORD PTR [rbx+128]
	mov	r8, rdx
	call	?processAudio@Hadamard@@QEAAXPEAM0@Z	; Hadamard::processAudio

; 459  : 		
; 460  : 		// Apply the shortest diffusion step to the aligned channels to spread out the reverb
; 461  : 		fdn_OutputDiffusion->processAudio(&fdn_tmpFeedback[0], &fdn_tmpFeedback[0]);

	mov	rdx, QWORD PTR [rbx+216]
	mov	rcx, QWORD PTR [rbx+136]
	mov	r8, rdx
	call	?processAudio@MultiChannelDiffuser@@QEAAXPEAM0@Z ; MultiChannelDiffuser::processAudio

; 462  : 
; 463  : 		// Sum-up early reflections and reverbered signals
; 464  : 		for (int i = 0; i < fdn_internalChannels; i++)

	mov	ecx, DWORD PTR [rbx+172]
	mov	edx, edi
	test	ecx, ecx
	jle	SHORT $LN9@processAud
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

	mov	r8, QWORD PTR [rbx+216]
	mov	rax, rdi
	mov	r9, QWORD PTR [rbx+240]
$LL10@processAud:
; File E:\FoxSuite\shimmer\include\FDN.h

; 465  : 			fdn_tmpFeedback[i] += fdn_earlyWeight * fdn_outEarly[i];		

	movss	xmm0, DWORD PTR [rax+r9]
	inc	edx
	mulss	xmm0, DWORD PTR [rbx+304]
	addss	xmm0, DWORD PTR [rax+r8]
	movss	DWORD PTR [rax+r8], xmm0
	add	rax, 4
	mov	ecx, DWORD PTR [rbx+172]
	cmp	edx, ecx
	jl	SHORT $LL10@processAud
$LN9@processAud:

; 468  : 		for (int i = 0; i < fdn_internalChannels; i++) {

	mov	rdx, QWORD PTR [rbx+216]
	mov	r14d, edi
	test	ecx, ecx
	jle	SHORT $LN161@processAud
	mov	rbp, rdi
	mov	r15, rdi
$LL13@processAud:

; 469  : 			float mod = fdn_Modulation[i]->processAudio(fdn_tmpFeedback[i]);

	mov	rax, QWORD PTR [rbx+104]
	movss	xmm1, DWORD PTR [rdx+rbp]
	mov	rcx, QWORD PTR [r15+rax]
	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

	mov	rdx, QWORD PTR [rbx+216]
; File E:\FoxSuite\shimmer\include\FDN.h

; 468  : 		for (int i = 0; i < fdn_internalChannels; i++) {

	inc	r14d

; 470  : 			fdn_tmpFeedback[i] = fdn_modWet * mod + fdn_modDry * fdn_tmpFeedback[i];

	movss	xmm1, DWORD PTR [rbx+316]
	add	r15, 8
	mulss	xmm0, DWORD PTR [rbx+312]
	mulss	xmm1, DWORD PTR [rdx+rbp]
	addss	xmm0, xmm1
	movss	DWORD PTR [rdx+rbp], xmm0
	add	rbp, 4
	cmp	r14d, DWORD PTR [rbx+172]
	jl	SHORT $LL13@processAud
$LN161@processAud:

; 471  : 		}
; 472  : 
; 473  : 		// Mix-down N internal channels into output channels
; 474  : 		fdn_Mixer->processAudio(&fdn_tmpFeedback[0], out);

	mov	rcx, QWORD PTR [rbx+8]
; File E:\FoxSuite\shimmer\include\ChannelMixer.h

; 40   : 		switch (mix_mode) {

	mov	r8d, DWORD PTR [rcx+8]
	test	r8d, r8d
	je	SHORT $LN106@processAud
	cmp	r8d, 1
	jne	SHORT $LN108@processAud

; 41   : 		case MixMode::First: {
; 42   : 			if (mix_numberOfChannelsOut == 1)

	cmp	DWORD PTR [rcx+4], r8d
	jne	SHORT $LN103@processAud

; 43   : 				out[0] = in[0];

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rsi], eax
	jmp	SHORT $LN108@processAud
$LN103@processAud:

; 44   : 			else if(mix_numberOfChannelsOut == 2) {

	cmp	DWORD PTR [rcx+4], 2
	jne	SHORT $LN108@processAud

; 45   : 				out[0] = in[0];

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rsi], eax

; 46   : 				out[1] = in[1];

	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rsi+4], eax

; 47   : 			}
; 48   : 			break;

	jmp	SHORT $LN108@processAud
$LN106@processAud:

; 49   : 		}
; 50   : 		case MixMode::WeightedSum: {
; 51   : 			float dummyOut = 0.0;
; 52   : 			for (int i = 0; i < mix_numberOfChannelsIn; i++) dummyOut += in[i];

	movsxd	r8, DWORD PTR [rcx]
	test	r8, r8
	jle	SHORT $LN100@processAud
	mov	rax, rdi
$LL146@processAud:
	addss	xmm6, DWORD PTR [rdx+rax*4]
	inc	rax
	cmp	rax, r8
	jl	SHORT $LL146@processAud
$LN100@processAud:

; 53   : 			if (mix_numberOfChannelsOut == 1)

	cmp	DWORD PTR [rcx+4], 1
	movd	xmm0, DWORD PTR [rcx]
	jne	SHORT $LN107@processAud

; 54   : 				out[0] = dummyOut / mix_numberOfChannelsIn;

	cvtdq2ps xmm0, xmm0
	divss	xmm6, xmm0
	movss	DWORD PTR [rsi], xmm6
	jmp	SHORT $LN108@processAud
$LN107@processAud:

; 55   : 			else {
; 56   : 				out[0] = dummyOut / (0.5 * mix_numberOfChannelsIn);

	movsd	xmm2, QWORD PTR __real@4000000000000000
	xorps	xmm1, xmm1
	cvtdq2pd xmm0, xmm0
	cvtss2sd xmm1, xmm6
	divsd	xmm2, xmm0
	mulsd	xmm2, xmm1
	cvtpd2ps xmm0, xmm2
	movss	DWORD PTR [rsi], xmm0

; 57   : 				out[1] = out[0];

	movss	DWORD PTR [rsi+4], xmm0
$LN108@processAud:
; File E:\FoxSuite\shimmer\include\FDN.h

; 477  : 		if (fdn_outputChannels == 2) {

	mov	eax, DWORD PTR [rbx+176]
	cmp	eax, 2
	jne	SHORT $LN17@processAud

; 478  : 			float mid = 0.5*(out[0] + out[1]);
; 479  : 			float side = 0.5*(out[0] - out[1]);

	movss	xmm3, DWORD PTR [rsi+4]
	movss	xmm2, DWORD PTR [rsi]

; 480  : 			side *= fdn_stereoSpread;

	movss	xmm1, DWORD PTR [rbx+308]
	subss	xmm2, xmm3
	addss	xmm3, DWORD PTR [rsi]

; 481  : 			mid *= (1.0 - fdn_stereoSpread);

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, xmm1
	mulss	xmm2, DWORD PTR __real@3f000000
	mulss	xmm3, DWORD PTR __real@3f000000
	mulss	xmm2, xmm1
	mulss	xmm3, xmm0

; 482  : 			out[0] = mid + side;

	movaps	xmm0, xmm2
	addss	xmm0, xmm3

; 483  : 			out[1] = mid - side;

	subss	xmm3, xmm2
	movss	DWORD PTR [rsi], xmm0
	movss	DWORD PTR [rsi+4], xmm3
	jmp	SHORT $LN175@processAud
$LN17@processAud:

; 484  : 		}
; 485  : 		
; 486  : 		// Apply Low & High Pass filtering
; 487  : 		for (int i = 0; i < fdn_outputChannels; i++) {

	test	eax, eax
	jle	$LN15@processAud
$LN175@processAud:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

	mov	rdx, QWORD PTR [rbx+144]
	mov	rcx, QWORD PTR [rbx+80]
	sub	rcx, rdx
$LL16@processAud:
; File E:\FoxSuite\shimmer\include\FDN.h

; 488  : 			out[i] = fdn_LPFOutput[i]->processAudio(out[i]);

	mov	rax, QWORD PTR [rcx+rdx]
	inc	edi
	movss	xmm4, DWORD PTR [rsi]
; File E:\FoxSuite\shimmer\include\LowPassFilter.h

; 200  : 		float yn = lpf_a0 * xn + lpf_a1 * lpf_xn_1 + lpf_a2 * lpf_xn_2 - lpf_b1 * lpf_yn_1 - lpf_b2 * lpf_yn_2;

	movaps	xmm5, xmm4
	mulss	xmm5, DWORD PTR [rax+20]
	movss	xmm3, DWORD PTR [rax+44]
	movss	xmm2, DWORD PTR [rax+52]
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR [rax+24]
	movss	xmm1, DWORD PTR [rax+28]
	mulss	xmm1, DWORD PTR [rax+48]

; 194  : 		lpf_xn_1 = xn;

	movss	DWORD PTR [rax+44], xmm4

; 200  : 		float yn = lpf_a0 * xn + lpf_a1 * lpf_xn_1 + lpf_a2 * lpf_xn_2 - lpf_b1 * lpf_yn_1 - lpf_b2 * lpf_yn_2;

	addss	xmm5, xmm0

; 192  : 		lpf_xn_2 = lpf_xn_1;

	movss	DWORD PTR [rax+48], xmm3

; 200  : 		float yn = lpf_a0 * xn + lpf_a1 * lpf_xn_1 + lpf_a2 * lpf_xn_2 - lpf_b1 * lpf_yn_1 - lpf_b2 * lpf_yn_2;

	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [rax+32]
	addss	xmm5, xmm1
	movss	xmm1, DWORD PTR [rax+36]
	mulss	xmm1, DWORD PTR [rax+56]

; 193  : 		lpf_yn_2 = lpf_yn_1;

	movss	DWORD PTR [rax+56], xmm2

; 200  : 		float yn = lpf_a0 * xn + lpf_a1 * lpf_xn_1 + lpf_a2 * lpf_xn_2 - lpf_b1 * lpf_yn_1 - lpf_b2 * lpf_yn_2;

	subss	xmm5, xmm0
	subss	xmm5, xmm1

; 195  : 		lpf_yn_1 = yn;

	movss	DWORD PTR [rax+52], xmm5

; 205  : 		return lpf_c0 * yn;

	mulss	xmm5, DWORD PTR [rax+40]
; File E:\FoxSuite\shimmer\include\FDN.h

; 489  : 			out[i] = fdn_HPFOutput[i]->processAudio(out[i]);

	mov	rax, QWORD PTR [rdx]
	add	rdx, 8
; File E:\FoxSuite\shimmer\include\HighPassFilter.h

; 155  : 		float yn = hpf_a0 * xn + hpf_a1 * hpf_xn_1 + hpf_a2 * hpf_xn_2 - hpf_b1 * hpf_yn_1 - hpf_b2 * hpf_yn_2;

	movaps	xmm0, xmm5
	movss	xmm3, DWORD PTR [rax+44]
	mulss	xmm0, DWORD PTR [rax+20]
	movaps	xmm4, xmm3
	mulss	xmm4, DWORD PTR [rax+24]
	movss	xmm2, DWORD PTR [rax+52]
	movss	xmm1, DWORD PTR [rax+28]
	mulss	xmm1, DWORD PTR [rax+48]
	addss	xmm4, xmm0
	movaps	xmm0, xmm2

; 147  : 		hpf_xn_2 = hpf_xn_1;

	movss	DWORD PTR [rax+48], xmm3

; 155  : 		float yn = hpf_a0 * xn + hpf_a1 * hpf_xn_1 + hpf_a2 * hpf_xn_2 - hpf_b1 * hpf_yn_1 - hpf_b2 * hpf_yn_2;

	mulss	xmm0, DWORD PTR [rax+32]
	addss	xmm4, xmm1

; 149  : 		hpf_xn_1 = xn;

	movss	DWORD PTR [rax+44], xmm5

; 155  : 		float yn = hpf_a0 * xn + hpf_a1 * hpf_xn_1 + hpf_a2 * hpf_xn_2 - hpf_b1 * hpf_yn_1 - hpf_b2 * hpf_yn_2;

	movss	xmm1, DWORD PTR [rax+36]
	mulss	xmm1, DWORD PTR [rax+56]

; 148  : 		hpf_yn_2 = hpf_yn_1;

	movss	DWORD PTR [rax+56], xmm2

; 155  : 		float yn = hpf_a0 * xn + hpf_a1 * hpf_xn_1 + hpf_a2 * hpf_xn_2 - hpf_b1 * hpf_yn_1 - hpf_b2 * hpf_yn_2;

	subss	xmm4, xmm0
	subss	xmm4, xmm1

; 150  : 		hpf_yn_1 = yn;

	movss	DWORD PTR [rax+52], xmm4

; 160  : 		return hpf_c0 * yn;

	mulss	xmm4, DWORD PTR [rax+40]
; File E:\FoxSuite\shimmer\include\FDN.h

; 489  : 			out[i] = fdn_HPFOutput[i]->processAudio(out[i]);

	movss	DWORD PTR [rsi], xmm4
	add	rsi, 4
	cmp	edi, DWORD PTR [rbx+176]
	jl	$LL16@processAud
$LN15@processAud:

; 490  : 		}
; 491  : 
; 492  : 	};

	mov	rbx, QWORD PTR [rsp+136]
	movaps	xmm6, XMMWORD PTR [rsp+48]
	add	rsp, 64					; 00000040H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
?processAudio@FDN@@QEAAXPEAM0@Z ENDP			; FDN::processAudio
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\MultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\MultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\MultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\MultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\FDN.h
;	COMDAT ?setDoubledDiffuserDelayLengths@FDN@@AEAAXMMW4DelayDistribution@@@Z
_TEXT	SEGMENT
this$ = 64
minDelayMs$dead$ = 72
maxDelayMs$ = 80
distr$ = 88
?setDoubledDiffuserDelayLengths@FDN@@AEAAXMMW4DelayDistribution@@@Z PROC ; FDN::setDoubledDiffuserDelayLengths, COMDAT

; 497  : 	void setDoubledDiffuserDelayLengths(float minDelayMs, float maxDelayMs, DelayDistribution distr = DEFAULT_DIFFUSER_DELAY_DISTRIBUTION) {

$LN29:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, rcx
	movaps	XMMWORD PTR [rsp+32], xmm6

; 498  : 		for (int i = fdn_numModDiffuser - 1; i >=0; i--) {

	mov	ecx, DWORD PTR [rcx+184]
	mov	esi, r9d
	movaps	xmm6, xmm2
	lea	eax, DWORD PTR [rcx-1]
	movsxd	rdi, eax
	test	eax, eax
	js	SHORT $LN3@setDoubled
$LL4@setDoubled:
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h

; 52   : 		mdiff_MultiChDelay->setDelayLinesLength(minDelayMs, maxDelayMs, distr);

	mov	rax, QWORD PTR [rbx+48]
	mov	r9d, esi
	movaps	xmm2, xmm6
	mov	rcx, QWORD PTR [rax+rdi*8]
	mov	rcx, QWORD PTR [rcx+24]
	call	?setDelayLinesLength@ModMultiChannelDelay@@QEAAXMMW4DelayDistribution@@@Z ; ModMultiChannelDelay::setDelayLinesLength
; File E:\FoxSuite\shimmer\include\FDN.h

; 498  : 		for (int i = fdn_numModDiffuser - 1; i >=0; i--) {

	sub	rdi, 1

; 499  : 			fdn_ModDiffuser[i]->setDelayLinesLength(minDelayMs, maxDelayMs, distr);
; 500  : 			maxDelayMs *= 0.5;

	mulss	xmm6, DWORD PTR __real@3f000000
	jns	SHORT $LL4@setDoubled
	mov	ecx, DWORD PTR [rbx+184]
$LN3@setDoubled:

; 502  : 		for (int i = fdn_diffusionSteps - fdn_numModDiffuser - 1; i >= 0; i--) {

	mov	eax, DWORD PTR [rbx+180]
	sub	eax, ecx
	sub	eax, 1
	movsxd	rdi, eax
	js	SHORT $LN6@setDoubled
$LL7@setDoubled:
; File E:\FoxSuite\shimmer\include\MultiChannelDiffuser.h

; 50   : 		mdiff_MultiChDelay->setDelayLinesLength(minDelayMs, maxDelayMs, distr);

	mov	rax, QWORD PTR [rbx+24]
	mov	r9d, esi
	movaps	xmm2, xmm6
	mov	rcx, QWORD PTR [rax+rdi*8]
	mov	rcx, QWORD PTR [rcx+24]
	call	?setDelayLinesLength@MultiChannelDelay@@QEAAXMMW4DelayDistribution@@@Z ; MultiChannelDelay::setDelayLinesLength
; File E:\FoxSuite\shimmer\include\FDN.h

; 502  : 		for (int i = fdn_diffusionSteps - fdn_numModDiffuser - 1; i >= 0; i--) {

	sub	rdi, 1

; 503  : 			fdn_Diffuser[i]->setDelayLinesLength(minDelayMs, maxDelayMs, distr);
; 504  : 			maxDelayMs *= 0.5;

	mulss	xmm6, DWORD PTR __real@3f000000
	jns	SHORT $LL7@setDoubled
$LN6@setDoubled:
; File E:\FoxSuite\shimmer\include\MultiChannelDiffuser.h

; 50   : 		mdiff_MultiChDelay->setDelayLinesLength(minDelayMs, maxDelayMs, distr);

	mov	rcx, QWORD PTR [rbx+136]
; File E:\FoxSuite\shimmer\include\FDN.h

; 506  : 		fdn_OutputDiffusion->setDelayLinesLength(minDelayMs, maxDelayMs * 2.0, distr);

	addss	xmm6, xmm6
; File E:\FoxSuite\shimmer\include\MultiChannelDiffuser.h

; 50   : 		mdiff_MultiChDelay->setDelayLinesLength(minDelayMs, maxDelayMs, distr);

	mov	r9d, esi
	mov	rcx, QWORD PTR [rcx+24]
	movaps	xmm2, xmm6
; File E:\FoxSuite\shimmer\include\FDN.h

; 507  : 	}

	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	movaps	xmm6, XMMWORD PTR [rsp+32]
	add	rsp, 48					; 00000030H
	pop	rdi
; File E:\FoxSuite\shimmer\include\MultiChannelDiffuser.h

; 50   : 		mdiff_MultiChDelay->setDelayLinesLength(minDelayMs, maxDelayMs, distr);

	jmp	?setDelayLinesLength@MultiChannelDelay@@QEAAXMMW4DelayDistribution@@@Z ; MultiChannelDelay::setDelayLinesLength
?setDoubledDiffuserDelayLengths@FDN@@AEAAXMMW4DelayDistribution@@@Z ENDP ; FDN::setDoubledDiffuserDelayLengths
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\MultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\MultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\MultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\FDN.h
;	COMDAT ?setEqualDiffuserDelayLengths@FDN@@AEAAXMMW4DelayDistribution@@@Z
_TEXT	SEGMENT
this$ = 64
minDelayMs$dead$ = 72
maxDelayMs$ = 80
distr$ = 88
?setEqualDiffuserDelayLengths@FDN@@AEAAXMMW4DelayDistribution@@@Z PROC ; FDN::setEqualDiffuserDelayLengths, COMDAT

; 510  : 	void setEqualDiffuserDelayLengths(float minDelayMs, float maxDelayMs, DelayDistribution distr = DEFAULT_DIFFUSER_DELAY_DISTRIBUTION) {

$LN29:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	push	r14
	sub	rsp, 48					; 00000030H
	movaps	XMMWORD PTR [rax-24], xmm6
	mov	rdi, rcx

; 511  : 		for (int i = 0; i < fdn_diffusionSteps - fdn_numModDiffuser; i++)

	mov	ecx, DWORD PTR [rcx+184]
	xor	ebx, ebx
	mov	ebp, r9d
	movaps	xmm6, xmm2
	mov	r14d, ebx
	mov	eax, DWORD PTR [rdi+180]
	sub	eax, ecx
	test	eax, eax
	jle	SHORT $LN3@setEqualDi
	mov	esi, ebx
$LL4@setEqualDi:
; File E:\FoxSuite\shimmer\include\MultiChannelDiffuser.h

; 50   : 		mdiff_MultiChDelay->setDelayLinesLength(minDelayMs, maxDelayMs, distr);

	mov	rax, QWORD PTR [rdi+24]
	mov	r9d, ebp
	movaps	xmm2, xmm6
	mov	rcx, QWORD PTR [rax+rsi]
	mov	rcx, QWORD PTR [rcx+24]
	call	?setDelayLinesLength@MultiChannelDelay@@QEAAXMMW4DelayDistribution@@@Z ; MultiChannelDelay::setDelayLinesLength
; File E:\FoxSuite\shimmer\include\FDN.h

; 511  : 		for (int i = 0; i < fdn_diffusionSteps - fdn_numModDiffuser; i++)

	mov	eax, DWORD PTR [rdi+180]
	lea	rsi, QWORD PTR [rsi+8]
	mov	ecx, DWORD PTR [rdi+184]
	inc	r14d
	sub	eax, ecx
	cmp	r14d, eax
	jl	SHORT $LL4@setEqualDi
$LN3@setEqualDi:

; 513  : 		for (int i = 0; i < fdn_numModDiffuser; i++)

	test	ecx, ecx
	jle	SHORT $LN6@setEqualDi
	mov	rsi, rbx
$LL7@setEqualDi:
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h

; 52   : 		mdiff_MultiChDelay->setDelayLinesLength(minDelayMs, maxDelayMs, distr);

	mov	rax, QWORD PTR [rdi+48]
	mov	r9d, ebp
	movaps	xmm2, xmm6
	mov	rcx, QWORD PTR [rax+rsi]
	mov	rcx, QWORD PTR [rcx+24]
	call	?setDelayLinesLength@ModMultiChannelDelay@@QEAAXMMW4DelayDistribution@@@Z ; ModMultiChannelDelay::setDelayLinesLength
; File E:\FoxSuite\shimmer\include\FDN.h

; 513  : 		for (int i = 0; i < fdn_numModDiffuser; i++)

	inc	ebx
	lea	rsi, QWORD PTR [rsi+8]
	cmp	ebx, DWORD PTR [rdi+184]
	jl	SHORT $LL7@setEqualDi
$LN6@setEqualDi:
; File E:\FoxSuite\shimmer\include\MultiChannelDiffuser.h

; 50   : 		mdiff_MultiChDelay->setDelayLinesLength(minDelayMs, maxDelayMs, distr);

	mov	rcx, QWORD PTR [rdi+136]
	mov	r9d, ebp
	movaps	xmm2, xmm6
	mov	rcx, QWORD PTR [rcx+24]
; File E:\FoxSuite\shimmer\include\FDN.h

; 516  : 	}

	mov	rbx, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	mov	rdi, QWORD PTR [rsp+88]
	movaps	xmm6, XMMWORD PTR [rsp+32]
	add	rsp, 48					; 00000030H
	pop	r14
; File E:\FoxSuite\shimmer\include\MultiChannelDiffuser.h

; 50   : 		mdiff_MultiChDelay->setDelayLinesLength(minDelayMs, maxDelayMs, distr);

	jmp	?setDelayLinesLength@MultiChannelDelay@@QEAAXMMW4DelayDistribution@@@Z ; MultiChannelDelay::setDelayLinesLength
?setEqualDiffuserDelayLengths@FDN@@AEAAXMMW4DelayDistribution@@@Z ENDP ; FDN::setEqualDiffuserDelayLengths
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\ChannelSplitter.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\ChannelMixer.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\include\Householder.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\include\Householder.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\LowPassFilter.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\HighPassFilter.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\Modulation.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
;	COMDAT ?constructFDN@FDN@@AEAAXHHHHH@Z
_TEXT	SEGMENT
$T5 = 32
$T20 = 40
$T8 = 40
$T22 = 96
$T17 = 96
$T19 = 96
$T14 = 96
$T10 = 96
$T6 = 96
$T16 = 96
$T23 = 96
$T12 = 96
$T3 = 96
$T1 = 96
this$ = 96
numChIn$ = 104
numChInt$dead$ = 112
numChOut$dead$ = 120
$T26 = 120
$T27 = 120
$T25 = 120
numDiffStep$dead$ = 128
numModDiffuser$dead$ = 136
?constructFDN@FDN@@AEAAXHHHHH@Z PROC			; FDN::constructFDN, COMDAT

; 519  : 	void constructFDN(int numChIn, int numChInt, int numChOut, int numDiffStep, int numModDiffuser = DEFAULT_NUMBER_MOD_DIFFUSER) {

$LN120:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	mov	DWORD PTR [rsp+32], r9d
	push	rbp
	push	rdi
	push	r12
	push	r14
	push	r15
	mov	rbp, rsp
	sub	rsp, 48					; 00000030H
	mov	ebx, edx
	mov	rdi, rcx

; 520  : 		srand(_SEED_FOR_RAND_GENERATION);

	mov	ecx, 4231				; 00001087H
	call	QWORD PTR __imp_srand

; 521  : 		fdn_inputChannels = numChIn;

	mov	DWORD PTR [rdi+168], ebx

; 522  : 		fdn_internalChannels = numChInt;

	mov	DWORD PTR [rdi+172], 16

; 523  : 		fdn_outputChannels = numChOut;

	mov	DWORD PTR [rdi+176], 2

; 524  : 		fdn_diffusionSteps = numDiffStep;	

	mov	DWORD PTR [rdi+180], 5

; 525  : 		fdn_numModDiffuser = numModDiffuser;		

	mov	DWORD PTR [rdi+184], 1

; 526  : 
; 527  : 		constructDiffusionBlocks();

	mov	rcx, rdi
	call	?constructDiffusionBlocks@FDN@@AEAAXXZ	; FDN::constructDiffusionBlocks

; 530  : 		fdn_Splitter = new ChannelSplitter(fdn_inputChannels, fdn_internalChannels);

	mov	ecx, 8
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T1[rbp-48], rax
	mov	edx, DWORD PTR [rdi+172]
; File E:\FoxSuite\shimmer\include\ChannelSplitter.h

; 20   : 		setNumberOfChannelsIn(numChIn); 

	mov	ecx, DWORD PTR [rdi+168]
	mov	DWORD PTR [rax], ecx

; 21   : 		setNumberOfChannelsOut(numChOut); 

	mov	DWORD PTR [rax+4], edx
; File E:\FoxSuite\shimmer\include\FDN.h

; 530  : 		fdn_Splitter = new ChannelSplitter(fdn_inputChannels, fdn_internalChannels);

	mov	QWORD PTR [rdi], rax

; 531  : 		fdn_Mixer = new ChannelMixer(fdn_internalChannels, fdn_outputChannels);

	mov	ecx, 12
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T3[rbp-48], rax
	mov	edx, DWORD PTR [rdi+176]
; File E:\FoxSuite\shimmer\include\ChannelMixer.h

; 26   : 		setNumberOfInputChannels(numChIn);

	mov	ecx, DWORD PTR [rdi+172]
	mov	DWORD PTR [rax], ecx

; 27   : 		setNumberOfOutputChannels(numChOut);

	mov	DWORD PTR [rax+4], edx

; 28   : 		mix_mode = DEFAULT_MIXING_LOGIC;

	xor	esi, esi
	mov	DWORD PTR [rax+8], esi
; File E:\FoxSuite\shimmer\include\FDN.h

; 531  : 		fdn_Mixer = new ChannelMixer(fdn_internalChannels, fdn_outputChannels);

	mov	QWORD PTR [rdi+8], rax

; 534  : 		fdn_Feedback = new ModMultiChannelFeedback(fdn_internalChannels);

	lea	ecx, QWORD PTR [rsi+72]
	call	??2@YAPEAX_K@Z				; operator new
	mov	r15, rax
	mov	QWORD PTR $T5[rbp-48], rax
	mov	ebx, DWORD PTR [rdi+172]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rax+40], rsi
	mov	QWORD PTR [rax+48], rsi
	mov	QWORD PTR [rax+56], rsi
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 168  : 		mcf_Householder = new Householder(numCh);

	lea	ecx, QWORD PTR [rsi+8]
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T6[rbp-48], rax
	movd	xmm0, ebx
; File E:\FoxSuite\shimmer\include\Householder.h

; 19   : 		hou_multiplier = -2.0 / hou_numberOfChannels;

	cvtdq2pd xmm0, xmm0
	movsd	xmm1, QWORD PTR __real@c000000000000000
	divsd	xmm1, xmm0
	cvtpd2ps xmm2, xmm1
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 168  : 		mcf_Householder = new Householder(numCh);

	mov	QWORD PTR [r15+32], rax

; 169  : 		mcf_numberOfChannels = numCh;

	mov	DWORD PTR [r15], ebx
; File E:\FoxSuite\shimmer\include\Householder.h

; 18   : 		hou_numberOfChannels = numCh;

	mov	DWORD PTR [rax], ebx

; 19   : 		hou_multiplier = -2.0 / hou_numberOfChannels;

	movss	DWORD PTR [rax+4], xmm2
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 171  : 		deleteDelayLines();

	mov	rcx, r15
	call	?deleteDelayLines@ModMultiChannelFeedback@@AEAAXXZ ; ModMultiChannelFeedback::deleteDelayLines

; 183  : 		for (int i = 0; i < mcf_numberOfChannels; i++)

	mov	ebx, esi
	cmp	DWORD PTR [r15], esi
	jle	SHORT $LN44@constructF
$LL45@constructF:

; 184  : 			mcf_DelayLines.push_back(new ModDelay);

	mov	ecx, 144				; 00000090H
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T8[rbp-48], rax
	mov	rcx, rax
	call	??0ModDelay@@QEAA@XZ			; ModDelay::ModDelay
	npad	1
	mov	QWORD PTR $T10[rbp-48], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 743  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [r15+48]
	cmp	rdx, QWORD PTR [r15+56]
	je	SHORT $LN53@constructF

; 726  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	QWORD PTR [rdx], rax

; 727  :         _Orphan_range(_Mylast, _Mylast);
; 728  :         _Ty& _Result = *_Mylast;
; 729  :         ++_Mylast;

	add	QWORD PTR [r15+48], 8

; 744  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN43@constructF
$LN53@constructF:

; 745  :         }
; 746  : 
; 747  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T10[rbp-48]
	lea	rcx, QWORD PTR [r15+40]
	call	??$_Emplace_reallocate@PEAVModDelay@@@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEAAPEAPEAVModDelay@@QEAPEAV2@$$QEAPEAV2@@Z ; std::vector<ModDelay *,std::allocator<ModDelay *> >::_Emplace_reallocate<ModDelay *>
$LN43@constructF:
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 183  : 		for (int i = 0; i < mcf_numberOfChannels; i++)

	inc	ebx
	cmp	ebx, DWORD PTR [r15]
	jl	SHORT $LL45@constructF
$LN44@constructF:
; File E:\FoxSuite\shimmer\include\FDN.h

; 534  : 		fdn_Feedback = new ModMultiChannelFeedback(fdn_internalChannels);

	mov	QWORD PTR [rdi+72], r15

; 535  : 		
; 536  : 		// Construct objects used for early reflection purposes and set their internal channels correctly (MultiChannelDelay)
; 537  : 		fdn_EarlyReflections = new MultiChannelDelay(fdn_internalChannels);

	mov	ecx, 48					; 00000030H
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T12[rbp-48], rax
	mov	edx, DWORD PTR [rdi+172]
	mov	rcx, rax
	call	??0MultiChannelDelay@@QEAA@H@Z		; MultiChannelDelay::MultiChannelDelay
	npad	1
	mov	QWORD PTR [rdi+16], rax

; 561  : 		for (int i = 0; i < fdn_outputChannels; i++) {

	mov	r12d, esi
	cmp	DWORD PTR [rdi+176], esi
	jle	$LN59@constructF
	lea	r15, QWORD PTR [rdi+144]
$LL60@constructF:

; 562  : 			fdn_LPFOutput.push_back(new LowPassFilter());

	mov	ecx, 60					; 0000003cH
	call	??2@YAPEAX_K@Z				; operator new
	mov	rbx, rax
	mov	QWORD PTR $T14[rbp-48], rax
; File E:\FoxSuite\shimmer\include\LowPassFilter.h

; 39   : 			lpf_cutoffFreq = freq;

	mov	DWORD PTR [rax+4], 1184645120		; 469c4000H

; 40   : 			lpf_sampleRate = sampleRate;

	mov	DWORD PTR [rax+8], 44100		; 0000ac44H

; 41   : 			lpf_type = type;

	mov	DWORD PTR [rax], esi

; 42   : 			lpf_shelvingGaindB = DEFAULT_SHELVING_GAIN;

	mov	DWORD PTR [rax+12], -1061158912		; c0c00000H

; 43   : 			lpf_Q = DEFAULT_RESONANCE;

	mov	DWORD PTR [rax+16], 1060437492		; 3f34fdf4H

; 44   : 			lpf_xn_1 = 0.0;

	mov	QWORD PTR [rax+44], rsi

; 45   : 			lpf_xn_2 = 0.0;
; 46   : 			lpf_yn_1 = 0.0;

	mov	QWORD PTR [rax+52], rsi

; 47   : 			lpf_yn_2 = 0.0;
; 48   : 			updateGains();

	mov	rcx, rax
	call	?updateGains@LowPassFilter@@QEAAXXZ	; LowPassFilter::updateGains
; File E:\FoxSuite\shimmer\include\FDN.h

; 562  : 			fdn_LPFOutput.push_back(new LowPassFilter());

	mov	QWORD PTR $T16[rbp-48], rbx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 743  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rdi+88]
	cmp	rdx, QWORD PTR [rdi+96]
	je	SHORT $LN73@constructF

; 726  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	QWORD PTR [rdx], rbx

; 727  :         _Orphan_range(_Mylast, _Mylast);
; 728  :         _Ty& _Result = *_Mylast;
; 729  :         ++_Mylast;

	add	QWORD PTR [rdi+88], 8

; 744  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN72@constructF
$LN73@constructF:

; 745  :         }
; 746  : 
; 747  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T16[rbp-48]
	lea	rcx, QWORD PTR [rdi+80]
	call	??$_Emplace_reallocate@PEAVLowPassFilter@@@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEAAPEAPEAVLowPassFilter@@QEAPEAV2@$$QEAPEAV2@@Z ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::_Emplace_reallocate<LowPassFilter *>
$LN72@constructF:
; File E:\FoxSuite\shimmer\include\FDN.h

; 563  : 			fdn_HPFOutput.push_back(new HighPassFilter());

	mov	ecx, 60					; 0000003cH
	call	??2@YAPEAX_K@Z				; operator new
	mov	rbx, rax
	mov	QWORD PTR $T17[rbp-48], rax
; File E:\FoxSuite\shimmer\include\HighPassFilter.h

; 39   : 		hpf_cutoffFreq = freq;

	mov	DWORD PTR [rax+4], 1183109120		; 4684d000H

; 40   : 		hpf_sampleRate = sampleRate;

	mov	DWORD PTR [rax+8], 44100		; 0000ac44H

; 41   : 		hpf_type = type;

	mov	DWORD PTR [rax], esi

; 42   : 		hpf_shelvingGaindB = DEFAULT_SHELVING_GAIN;

	mov	DWORD PTR [rax+12], -1061158912		; c0c00000H

; 43   : 		hpf_Q = DEFAULT_RESONANCE;

	mov	DWORD PTR [rax+16], 1060437492		; 3f34fdf4H

; 44   : 		hpf_xn_1 = 0.0;

	mov	QWORD PTR [rax+44], rsi

; 45   : 		hpf_xn_2 = 0.0;
; 46   : 		hpf_yn_1 = 0.0;

	mov	QWORD PTR [rax+52], rsi

; 47   : 		hpf_yn_2 = 0.0;
; 48   : 		updateGains();

	mov	rcx, rax
	call	?updateGains@HighPassFilter@@QEAAXXZ	; HighPassFilter::updateGains
; File E:\FoxSuite\shimmer\include\FDN.h

; 563  : 			fdn_HPFOutput.push_back(new HighPassFilter());

	mov	QWORD PTR $T19[rbp-48], rbx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 743  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [r15+8]
	cmp	rdx, QWORD PTR [r15+16]
	je	SHORT $LN82@constructF

; 726  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	QWORD PTR [rdx], rbx

; 727  :         _Orphan_range(_Mylast, _Mylast);
; 728  :         _Ty& _Result = *_Mylast;
; 729  :         ++_Mylast;

	add	QWORD PTR [r15+8], 8

; 744  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN58@constructF
$LN82@constructF:

; 745  :         }
; 746  : 
; 747  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T19[rbp-48]
	mov	rcx, r15
	call	??$_Emplace_reallocate@PEAVHighPassFilter@@@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEAAPEAPEAVHighPassFilter@@QEAPEAV2@$$QEAPEAV2@@Z ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::_Emplace_reallocate<HighPassFilter *>
$LN58@constructF:
; File E:\FoxSuite\shimmer\include\FDN.h

; 561  : 		for (int i = 0; i < fdn_outputChannels; i++) {

	inc	r12d
	cmp	r12d, DWORD PTR [rdi+176]
	jl	$LL60@constructF
$LN59@constructF:

; 569  : 		for (int i = 0; i < fdn_internalChannels; i++)

	cmp	DWORD PTR [rdi+172], esi
	jle	SHORT $LN88@constructF
$LL89@constructF:

; 570  : 			fdn_Modulation.push_back(new Modulation());

	mov	ecx, 176				; 000000b0H
	call	??2@YAPEAX_K@Z				; operator new
	mov	r14, rax
	mov	QWORD PTR $T20[rbp-48], rax
; File E:\FoxSuite\shimmer\include\Modulation.h

; 44   : 	Modulation() {}

	mov	rcx, rax
	call	??0ModDelay@@QEAA@XZ			; ModDelay::ModDelay
	lea	rax, OFFSET FLAT:??_7Modulation@@6B@
	mov	QWORD PTR [r14], rax
; File E:\FoxSuite\shimmer\include\FDN.h

; 570  : 			fdn_Modulation.push_back(new Modulation());

	mov	QWORD PTR $T22[rbp-48], r14
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 743  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rdi+112]
	cmp	rdx, QWORD PTR [rdi+120]
	je	SHORT $LN100@constructF

; 726  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	QWORD PTR [rdx], r14

; 727  :         _Orphan_range(_Mylast, _Mylast);
; 728  :         _Ty& _Result = *_Mylast;
; 729  :         ++_Mylast;

	add	QWORD PTR [rdi+112], 8

; 744  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN87@constructF
$LN100@constructF:

; 745  :         }
; 746  : 
; 747  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T22[rbp-48]
	lea	rcx, QWORD PTR [rdi+104]
	call	??$_Emplace_reallocate@PEAVModulation@@@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@QEAAPEAPEAVModulation@@QEAPEAV2@$$QEAPEAV2@@Z ; std::vector<Modulation *,std::allocator<Modulation *> >::_Emplace_reallocate<Modulation *>
$LN87@constructF:
; File E:\FoxSuite\shimmer\include\FDN.h

; 569  : 		for (int i = 0; i < fdn_internalChannels; i++)

	inc	esi
	cmp	esi, DWORD PTR [rdi+172]
	jl	SHORT $LL89@constructF
$LN88@constructF:

; 538  : 
; 539  : 		// Construct filters
; 540  : 		constructFilters();
; 541  : 		constructModulation();
; 542  : 
; 543  : 		// Construct mix matrix for output mixing after feedback stage
; 544  : 		fdn_MixMatrix = new Hadamard(fdn_internalChannels);

	mov	ecx, 16
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T23[rbp-48], rax
	mov	edx, DWORD PTR [rdi+172]
	mov	rcx, rax
	call	??0Hadamard@@QEAA@H@Z			; Hadamard::Hadamard
	npad	1
	mov	QWORD PTR [rdi+128], rax

; 632  : 		fdn_tmpDiffuser.resize(fdn_internalChannels, 0.0);

	and	DWORD PTR $T25[rbp-48], 0
	movsxd	rdx, DWORD PTR [rdi+172]
	lea	rcx, QWORD PTR [rdi+192]
	lea	r8, QWORD PTR $T25[rbp-48]
	call	?resize@?$vector@MV?$allocator@M@std@@@std@@QEAAX_KAEBM@Z ; std::vector<float,std::allocator<float> >::resize

; 633  : 		fdn_tmpFeedback.resize(fdn_internalChannels, 0.0);

	and	DWORD PTR $T26[rbp-48], 0
	movsxd	rdx, DWORD PTR [rdi+172]
	lea	rcx, QWORD PTR [rdi+216]
	lea	r8, QWORD PTR $T26[rbp-48]
	call	?resize@?$vector@MV?$allocator@M@std@@@std@@QEAAX_KAEBM@Z ; std::vector<float,std::allocator<float> >::resize

; 634  : 		fdn_outEarly.resize(fdn_internalChannels, 0.0);

	and	DWORD PTR $T27[rbp-48], 0
	movsxd	rdx, DWORD PTR [rdi+172]
	lea	rcx, QWORD PTR [rdi+240]
	lea	r8, QWORD PTR $T27[rbp-48]
	call	?resize@?$vector@MV?$allocator@M@std@@@std@@QEAAX_KAEBM@Z ; std::vector<float,std::allocator<float> >::resize

; 545  : 		
; 546  : 		// Init vectors for tmp storage
; 547  : 		initInternalArrays();
; 548  : 	}	

	mov	rbx, QWORD PTR [rsp+104]
	mov	rsi, QWORD PTR [rsp+112]
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rbp
	ret	0
?constructFDN@FDN@@AEAAXHHHHH@Z ENDP			; FDN::constructFDN
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T5 = 32
$T20 = 40
$T8 = 40
$T22 = 96
$T17 = 96
$T19 = 96
$T14 = 96
$T10 = 96
$T6 = 96
$T16 = 96
$T23 = 96
$T12 = 96
$T3 = 96
$T1 = 96
this$ = 96
numChIn$ = 104
numChInt$dead$ = 112
numChOut$dead$ = 120
$T26 = 120
$T27 = 120
$T25 = 120
numDiffStep$dead$ = 128
numModDiffuser$dead$ = 136
?dtor$2@?0??constructFDN@FDN@@AEAAXHHHHH@Z@4HA PROC	; `FDN::constructFDN'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 72					; 00000048H
	mov	rcx, QWORD PTR $T5[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0??constructFDN@FDN@@AEAAXHHHHH@Z@4HA ENDP	; `FDN::constructFDN'::`1'::dtor$2
$T5 = 32
$T20 = 40
$T8 = 40
$T22 = 96
$T17 = 96
$T19 = 96
$T14 = 96
$T10 = 96
$T6 = 96
$T16 = 96
$T23 = 96
$T12 = 96
$T3 = 96
$T1 = 96
this$ = 96
numChIn$ = 104
numChInt$dead$ = 112
numChOut$dead$ = 120
$T26 = 120
$T27 = 120
$T25 = 120
numDiffStep$dead$ = 128
numModDiffuser$dead$ = 136
?dtor$5@?0??constructFDN@FDN@@AEAAXHHHHH@Z@4HA PROC	; `FDN::constructFDN'::`1'::dtor$5
	mov	rcx, QWORD PTR $T5[rdx]
	add	rcx, 40					; 00000028H
	jmp	??1?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEAA@XZ ; std::vector<ModDelay *,std::allocator<ModDelay *> >::~vector<ModDelay *,std::allocator<ModDelay *> >
?dtor$5@?0??constructFDN@FDN@@AEAAXHHHHH@Z@4HA ENDP	; `FDN::constructFDN'::`1'::dtor$5
$T5 = 32
$T20 = 40
$T8 = 40
$T22 = 96
$T17 = 96
$T19 = 96
$T14 = 96
$T10 = 96
$T6 = 96
$T16 = 96
$T23 = 96
$T12 = 96
$T3 = 96
$T1 = 96
this$ = 96
numChIn$ = 104
numChInt$dead$ = 112
numChOut$dead$ = 120
$T26 = 120
$T27 = 120
$T25 = 120
numDiffStep$dead$ = 128
numModDiffuser$dead$ = 136
?dtor$7@?0??constructFDN@FDN@@AEAAXHHHHH@Z@4HA PROC	; `FDN::constructFDN'::`1'::dtor$7
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 144				; 00000090H
	mov	rcx, QWORD PTR $T8[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$7@?0??constructFDN@FDN@@AEAAXHHHHH@Z@4HA ENDP	; `FDN::constructFDN'::`1'::dtor$7
$T5 = 32
$T20 = 40
$T8 = 40
$T22 = 96
$T17 = 96
$T19 = 96
$T14 = 96
$T10 = 96
$T6 = 96
$T16 = 96
$T23 = 96
$T12 = 96
$T3 = 96
$T1 = 96
this$ = 96
numChIn$ = 104
numChInt$dead$ = 112
numChOut$dead$ = 120
$T26 = 120
$T27 = 120
$T25 = 120
numDiffStep$dead$ = 128
numModDiffuser$dead$ = 136
?dtor$3@?0??constructFDN@FDN@@AEAAXHHHHH@Z@4HA PROC	; `FDN::constructFDN'::`1'::dtor$3
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 48					; 00000030H
	mov	rcx, QWORD PTR $T12[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$3@?0??constructFDN@FDN@@AEAAXHHHHH@Z@4HA ENDP	; `FDN::constructFDN'::`1'::dtor$3
$T5 = 32
$T20 = 40
$T8 = 40
$T22 = 96
$T17 = 96
$T19 = 96
$T14 = 96
$T10 = 96
$T6 = 96
$T16 = 96
$T23 = 96
$T12 = 96
$T3 = 96
$T1 = 96
this$ = 96
numChIn$ = 104
numChInt$dead$ = 112
numChOut$dead$ = 120
$T26 = 120
$T27 = 120
$T25 = 120
numDiffStep$dead$ = 128
numModDiffuser$dead$ = 136
?dtor$10@?0??constructFDN@FDN@@AEAAXHHHHH@Z@4HA PROC	; `FDN::constructFDN'::`1'::dtor$10
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 176				; 000000b0H
	mov	rcx, QWORD PTR $T20[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$10@?0??constructFDN@FDN@@AEAAXHHHHH@Z@4HA ENDP	; `FDN::constructFDN'::`1'::dtor$10
$T5 = 32
$T20 = 40
$T8 = 40
$T22 = 96
$T17 = 96
$T19 = 96
$T14 = 96
$T10 = 96
$T6 = 96
$T16 = 96
$T23 = 96
$T12 = 96
$T3 = 96
$T1 = 96
this$ = 96
numChIn$ = 104
numChInt$dead$ = 112
numChOut$dead$ = 120
$T26 = 120
$T27 = 120
$T25 = 120
numDiffStep$dead$ = 128
numModDiffuser$dead$ = 136
?dtor$4@?0??constructFDN@FDN@@AEAAXHHHHH@Z@4HA PROC	; `FDN::constructFDN'::`1'::dtor$4
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 16
	mov	rcx, QWORD PTR $T23[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$4@?0??constructFDN@FDN@@AEAAXHHHHH@Z@4HA ENDP	; `FDN::constructFDN'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
$T5 = 32
$T20 = 40
$T8 = 40
$T22 = 96
$T17 = 96
$T19 = 96
$T14 = 96
$T10 = 96
$T6 = 96
$T16 = 96
$T23 = 96
$T12 = 96
$T3 = 96
$T1 = 96
this$ = 96
numChIn$ = 104
numChInt$dead$ = 112
numChOut$dead$ = 120
$T26 = 120
$T27 = 120
$T25 = 120
numDiffStep$dead$ = 128
numModDiffuser$dead$ = 136
?dtor$2@?0??constructFDN@FDN@@AEAAXHHHHH@Z@4HA PROC	; `FDN::constructFDN'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 72					; 00000048H
	mov	rcx, QWORD PTR $T5[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0??constructFDN@FDN@@AEAAXHHHHH@Z@4HA ENDP	; `FDN::constructFDN'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
$T5 = 32
$T20 = 40
$T8 = 40
$T22 = 96
$T17 = 96
$T19 = 96
$T14 = 96
$T10 = 96
$T6 = 96
$T16 = 96
$T23 = 96
$T12 = 96
$T3 = 96
$T1 = 96
this$ = 96
numChIn$ = 104
numChInt$dead$ = 112
numChOut$dead$ = 120
$T26 = 120
$T27 = 120
$T25 = 120
numDiffStep$dead$ = 128
numModDiffuser$dead$ = 136
?dtor$5@?0??constructFDN@FDN@@AEAAXHHHHH@Z@4HA PROC	; `FDN::constructFDN'::`1'::dtor$5
	mov	rcx, QWORD PTR $T5[rdx]
	add	rcx, 40					; 00000028H
	jmp	??1?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEAA@XZ ; std::vector<ModDelay *,std::allocator<ModDelay *> >::~vector<ModDelay *,std::allocator<ModDelay *> >
?dtor$5@?0??constructFDN@FDN@@AEAAXHHHHH@Z@4HA ENDP	; `FDN::constructFDN'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
$T5 = 32
$T20 = 40
$T8 = 40
$T22 = 96
$T17 = 96
$T19 = 96
$T14 = 96
$T10 = 96
$T6 = 96
$T16 = 96
$T23 = 96
$T12 = 96
$T3 = 96
$T1 = 96
this$ = 96
numChIn$ = 104
numChInt$dead$ = 112
numChOut$dead$ = 120
$T26 = 120
$T27 = 120
$T25 = 120
numDiffStep$dead$ = 128
numModDiffuser$dead$ = 136
?dtor$7@?0??constructFDN@FDN@@AEAAXHHHHH@Z@4HA PROC	; `FDN::constructFDN'::`1'::dtor$7
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 144				; 00000090H
	mov	rcx, QWORD PTR $T8[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$7@?0??constructFDN@FDN@@AEAAXHHHHH@Z@4HA ENDP	; `FDN::constructFDN'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
$T5 = 32
$T20 = 40
$T8 = 40
$T22 = 96
$T17 = 96
$T19 = 96
$T14 = 96
$T10 = 96
$T6 = 96
$T16 = 96
$T23 = 96
$T12 = 96
$T3 = 96
$T1 = 96
this$ = 96
numChIn$ = 104
numChInt$dead$ = 112
numChOut$dead$ = 120
$T26 = 120
$T27 = 120
$T25 = 120
numDiffStep$dead$ = 128
numModDiffuser$dead$ = 136
?dtor$3@?0??constructFDN@FDN@@AEAAXHHHHH@Z@4HA PROC	; `FDN::constructFDN'::`1'::dtor$3
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 48					; 00000030H
	mov	rcx, QWORD PTR $T12[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$3@?0??constructFDN@FDN@@AEAAXHHHHH@Z@4HA ENDP	; `FDN::constructFDN'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
$T5 = 32
$T20 = 40
$T8 = 40
$T22 = 96
$T17 = 96
$T19 = 96
$T14 = 96
$T10 = 96
$T6 = 96
$T16 = 96
$T23 = 96
$T12 = 96
$T3 = 96
$T1 = 96
this$ = 96
numChIn$ = 104
numChInt$dead$ = 112
numChOut$dead$ = 120
$T26 = 120
$T27 = 120
$T25 = 120
numDiffStep$dead$ = 128
numModDiffuser$dead$ = 136
?dtor$10@?0??constructFDN@FDN@@AEAAXHHHHH@Z@4HA PROC	; `FDN::constructFDN'::`1'::dtor$10
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 176				; 000000b0H
	mov	rcx, QWORD PTR $T20[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$10@?0??constructFDN@FDN@@AEAAXHHHHH@Z@4HA ENDP	; `FDN::constructFDN'::`1'::dtor$10
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
$T5 = 32
$T20 = 40
$T8 = 40
$T22 = 96
$T17 = 96
$T19 = 96
$T14 = 96
$T10 = 96
$T6 = 96
$T16 = 96
$T23 = 96
$T12 = 96
$T3 = 96
$T1 = 96
this$ = 96
numChIn$ = 104
numChInt$dead$ = 112
numChOut$dead$ = 120
$T26 = 120
$T27 = 120
$T25 = 120
numDiffStep$dead$ = 128
numModDiffuser$dead$ = 136
?dtor$4@?0??constructFDN@FDN@@AEAAXHHHHH@Z@4HA PROC	; `FDN::constructFDN'::`1'::dtor$4
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 16
	mov	rcx, QWORD PTR $T23[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$4@?0??constructFDN@FDN@@AEAAXHHHHH@Z@4HA ENDP	; `FDN::constructFDN'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
;	COMDAT ?constructDiffusionBlocks@FDN@@AEAAXXZ
_TEXT	SEGMENT
$T11 = 32
$T13 = 40
$T8 = 128
$T17 = 128
$T16 = 128
$T3 = 128
this$ = 128
$T4 = 136
$T1 = 136
$T5 = 144
$T6 = 152
?constructDiffusionBlocks@FDN@@AEAAXXZ PROC		; FDN::constructDiffusionBlocks, COMDAT

; 551  : 	void constructDiffusionBlocks() {		

$LN102:
	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	mov	rbp, rsp
	sub	rsp, 56					; 00000038H
	mov	rdi, rcx

; 552  : 		for (int i = 0; i < fdn_diffusionSteps-fdn_numModDiffuser; i++)

	xor	r13d, r13d
	mov	esi, r13d
	mov	ecx, DWORD PTR [rcx+184]
	mov	eax, DWORD PTR [rdi+180]
	sub	eax, ecx
	test	eax, eax
	jle	SHORT $LN3@constructD
$LL4@constructD:

; 553  : 			fdn_Diffuser.push_back(new MultiChannelDiffuser(fdn_internalChannels));		

	mov	ecx, 48					; 00000030H
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T1[rbp-56], rax
	mov	edx, DWORD PTR [rdi+172]
	mov	rcx, rax
	call	??0MultiChannelDiffuser@@QEAA@H@Z	; MultiChannelDiffuser::MultiChannelDiffuser
	npad	1
	mov	QWORD PTR $T3[rbp-56], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 743  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rdi+32]
	cmp	rdx, QWORD PTR [rdi+40]
	je	SHORT $LN21@constructD

; 726  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	QWORD PTR [rdx], rax

; 727  :         _Orphan_range(_Mylast, _Mylast);
; 728  :         _Ty& _Result = *_Mylast;
; 729  :         ++_Mylast;

	add	QWORD PTR [rdi+32], 8

; 744  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN2@constructD
$LN21@constructD:

; 745  :         }
; 746  : 
; 747  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T3[rbp-56]
	lea	rcx, QWORD PTR [rdi+24]
	call	??$_Emplace_reallocate@PEAVMultiChannelDiffuser@@@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEAAPEAPEAVMultiChannelDiffuser@@QEAPEAV2@$$QEAPEAV2@@Z ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::_Emplace_reallocate<MultiChannelDiffuser *>
$LN2@constructD:
; File E:\FoxSuite\shimmer\include\FDN.h

; 552  : 		for (int i = 0; i < fdn_diffusionSteps-fdn_numModDiffuser; i++)

	inc	esi
	mov	ecx, DWORD PTR [rdi+184]
	mov	eax, DWORD PTR [rdi+180]
	sub	eax, ecx
	cmp	esi, eax
	jl	SHORT $LL4@constructD
$LN3@constructD:

; 554  : 		for (int i = 0; i < fdn_numModDiffuser; i++)

	mov	r12d, r13d
	test	ecx, ecx
	jle	$LN6@constructD
$LL7@constructD:

; 555  : 			fdn_ModDiffuser.push_back(new ModMultiChannelDiffuser(fdn_internalChannels));

	mov	ecx, 48					; 00000030H
	call	??2@YAPEAX_K@Z				; operator new
	mov	r14, rax
	mov	QWORD PTR $T4[rbp-56], rax
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h

; 93   : 		mdiff_numberOfChannels = numCh;

	mov	ecx, DWORD PTR [rdi+172]
	mov	DWORD PTR [rax], ecx

; 121  : 		mdiff_outHadamard = nullptr;

	mov	QWORD PTR [rax+16], r13

; 122  : 		mdiff_outMultiChDel = nullptr;

	mov	QWORD PTR [rax+8], r13

; 132  : 		mdiff_MultiChDelay = new ModMultiChannelDelay(mdiff_numberOfChannels);

	mov	ecx, 56					; 00000038H
	call	??2@YAPEAX_K@Z				; operator new
	mov	rbx, rax
	mov	QWORD PTR $T5[rbp-56], rax
	mov	ecx, DWORD PTR [r14]
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 31   : 	ModMultiChannelDelay(int numCh) {

	lea	rsi, QWORD PTR [rax+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rsi], r13
	mov	QWORD PTR [rsi+8], r13
	mov	QWORD PTR [rsi+16], r13
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 163  : 		mdel_numberOfChannels = numCh;

	mov	DWORD PTR [rax], ecx

; 164  : 		mdel_minDelayMs = 0.0;

	and	QWORD PTR [rax+32], 0

; 158  : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	test	ecx, ecx
	jle	SHORT $LN55@constructD
$LL56@constructD:

; 159  : 			mdel_DelayLines.push_back(new ModDelay);

	mov	ecx, 144				; 00000090H
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T6[rbp-56], rax
	mov	rcx, rax
	call	??0ModDelay@@QEAA@XZ			; ModDelay::ModDelay
	npad	1
	mov	QWORD PTR $T8[rbp-56], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 743  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rsi+8]
	cmp	rdx, QWORD PTR [rsi+16]
	je	SHORT $LN64@constructD

; 726  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	QWORD PTR [rdx], rax

; 727  :         _Orphan_range(_Mylast, _Mylast);
; 728  :         _Ty& _Result = *_Mylast;
; 729  :         ++_Mylast;

	add	QWORD PTR [rsi+8], 8

; 744  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN54@constructD
$LN64@constructD:

; 745  :         }
; 746  : 
; 747  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T8[rbp-56]
	mov	rcx, rsi
	call	??$_Emplace_reallocate@PEAVModDelay@@@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEAAPEAPEAVModDelay@@QEAPEAV2@$$QEAPEAV2@@Z ; std::vector<ModDelay *,std::allocator<ModDelay *> >::_Emplace_reallocate<ModDelay *>
$LN54@constructD:
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 158  : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	inc	r13d
	cmp	r13d, DWORD PTR [rbx]
	jl	SHORT $LL56@constructD
$LN55@constructD:

; 98   : 		mdel_modValmsec = modVal;

	mov	r8d, 1106247680				; 41f00000H
	mov	DWORD PTR [rbx+48], r8d

; 99   : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	xor	r13d, r13d
	mov	edx, r13d
	cmp	DWORD PTR [rbx], r13d
	jle	SHORT $LN70@constructD

; 32   : 		constructMCDL(numCh);
; 33   : 	}
; 34   : 
; 35   : 	~ModMultiChannelDelay() { deleteDelayLines(); }
; 36   : 
; 37   : 	void initDelayLines(float bufferLengthMs, int sampleRate) {
; 38   : 		mdel_sampleRate = sampleRate;
; 39   : 		if (!mdel_DelayLines.empty()) {
; 40   : 			for (int i = 0; i < mdel_numberOfChannels; i++)
; 41   : 				mdel_DelayLines[i]->init(bufferLengthMs, sampleRate);
; 42   : 		}
; 43   : 	}
; 44   : 
; 45   : 	void setNumberOfChannels(int numCH) {
; 46   : 		float dlyBufferSize = mdel_DelayLines[0]->getBufferSizeMs();
; 47   : 		int sampleRate = mdel_DelayLines[0]->getSampleRate();
; 48   : 		deleteDelayLines();
; 49   : 		mdel_numberOfChannels = numCH;
; 50   : 		constructDelayObjects();
; 51   : 		initDelayLines(dlyBufferSize, sampleRate);
; 52   : 		setDelayLinesLength(mdel_minDelayMs, mdel_maxDelayMs, mdel_delayDistr);
; 53   : 	}
; 54   : 
; 55   : 	void setDelayLinesLength(float dlyMinLengthMs, float dlyMaxLengthMs, DelayDistribution distr = DelayDistribution::RandomInRange) {
; 56   : 		mdel_minDelayMs = dlyMinLengthMs;
; 57   : 		mdel_maxDelayMs = dlyMaxLengthMs;
; 58   : 		/*if (mdel_maxDelayMs / mdel_numberOfChannels < MINIMUM_DELAY_LENGTH_MCD)
; 59   : 			mdel_maxDelayMs = 2 * MINIMUM_DELAY_LENGTH_MCD;*/
; 60   : 		mdel_delayDistr = distr;
; 61   : 		switch (distr) {
; 62   : 		case DelayDistribution::RandomInRange: {
; 63   : 			setRandomInRangeDelayLines();
; 64   : 			break;
; 65   : 		}
; 66   : 		case DelayDistribution::Exponential: {
; 67   : 			setExponentialDelayLengths();
; 68   : 			break;
; 69   : 		}
; 70   : 		case DelayDistribution::Equal: {
; 71   : 			setEqualDelayLines();
; 72   : 			break;
; 73   : 		}
; 74   : 		}
; 75   : 	}
; 76   : 
; 77   : 	void setSpecificDelayLengthsMs(float* lenghts) {
; 78   : 		for (int i = 0; i < mdel_numberOfChannels; i++)
; 79   : 			mdel_DelayLines[i]->setDelayInmsec(lenghts[i]);
; 80   : 	}
; 81   : 
; 82   : 	void setMakeUpGaindB(float makeUpGain) {
; 83   : 		for (int i = 0; i < mdel_numberOfChannels; i++)
; 84   : 			mdel_DelayLines[i]->setMakeUpGaindB(makeUpGain);
; 85   : 	}
; 86   : 
; 87   : 	void setModDepth(float depth) {
; 88   : 		for (int i = 0; i < mdel_numberOfChannels; i++)
; 89   : 			mdel_DelayLines[i]->setDeltaDelayValue(depth*mdel_modValmsec);
; 90   : 	}
; 91   : 
; 92   : 	void setModRate(float freq) {
; 93   : 		for (int i = 0; i < mdel_numberOfChannels; i++)
; 94   : 			mdel_DelayLines[i]->setModRate(freq);
; 95   : 	}	
; 96   : 	
; 97   : 	void setModValueInMsec(float modVal) {
; 98   : 		mdel_modValmsec = modVal;

	mov	ecx, r13d
$LL71@constructD:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rsi]
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 100  : 			mdel_DelayLines[i]->setDeltaDelayValue(modVal);

	mov	rax, QWORD PTR [rcx+rax]
	mov	DWORD PTR [rax+124], r8d

; 99   : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	inc	edx
	lea	rcx, QWORD PTR [rcx+8]
	cmp	edx, DWORD PTR [rbx]
	jl	SHORT $LL71@constructD
$LN70@constructD:
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h

; 132  : 		mdiff_MultiChDelay = new ModMultiChannelDelay(mdiff_numberOfChannels);

	mov	QWORD PTR [r14+24], rbx

; 133  : 		mdiff_Hadamard = new Hadamard(mdiff_numberOfChannels);

	mov	ecx, 16
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T11[rbp-56], rax
	mov	edx, DWORD PTR [r14]
	mov	rcx, rax
	call	??0Hadamard@@QEAA@H@Z			; Hadamard::Hadamard
	npad	1
	mov	QWORD PTR [r14+32], rax

; 134  : 		mdiff_Polarity = new FlipPolarity(mdiff_numberOfChannels);

	mov	ecx, 32					; 00000020H
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T13[rbp-56], rax
	mov	edx, DWORD PTR [r14]
	mov	rcx, rax
	call	??0FlipPolarity@@QEAA@H@Z		; FlipPolarity::FlipPolarity
	npad	1
	mov	QWORD PTR [r14+40], rax

; 100  : 		int lenghtInBytes = mdiff_numberOfChannels * sizeof(float);

	mov	eax, DWORD PTR [r14]
	shl	eax, 2

; 101  : 		mdiff_outMultiChDel = (float*)malloc(lenghtInBytes);

	movsxd	rbx, eax
	mov	rcx, rbx
	call	QWORD PTR __imp_malloc
	mov	QWORD PTR [r14+8], rax

; 102  : 		mdiff_outHadamard = (float*)malloc(lenghtInBytes);

	mov	rcx, rbx
	call	QWORD PTR __imp_malloc
	mov	QWORD PTR [r14+16], rax

; 103  : 		memset(mdiff_outMultiChDel, 0, lenghtInBytes);

	mov	r8, rbx
	xor	edx, edx
	mov	rcx, QWORD PTR [r14+8]
	call	QWORD PTR __imp_memset

; 104  : 		memset(mdiff_outHadamard, 0, lenghtInBytes);

	mov	r8, rbx
	xor	edx, edx
	mov	rcx, QWORD PTR [r14+16]
	call	QWORD PTR __imp_memset
	npad	1
; File E:\FoxSuite\shimmer\include\FDN.h

; 555  : 			fdn_ModDiffuser.push_back(new ModMultiChannelDiffuser(fdn_internalChannels));

	mov	QWORD PTR $T16[rbp-56], r14
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 743  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rdi+56]
	cmp	rdx, QWORD PTR [rdi+64]
	je	SHORT $LN80@constructD

; 726  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	QWORD PTR [rdx], r14

; 727  :         _Orphan_range(_Mylast, _Mylast);
; 728  :         _Ty& _Result = *_Mylast;
; 729  :         ++_Mylast;

	add	QWORD PTR [rdi+56], 8

; 744  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN5@constructD
$LN80@constructD:

; 745  :         }
; 746  : 
; 747  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T16[rbp-56]
	lea	rcx, QWORD PTR [rdi+48]
	call	??$_Emplace_reallocate@PEAVModMultiChannelDiffuser@@@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEAAPEAPEAVModMultiChannelDiffuser@@QEAPEAV2@$$QEAPEAV2@@Z ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::_Emplace_reallocate<ModMultiChannelDiffuser *>
$LN5@constructD:
; File E:\FoxSuite\shimmer\include\FDN.h

; 554  : 		for (int i = 0; i < fdn_numModDiffuser; i++)

	inc	r12d
	cmp	r12d, DWORD PTR [rdi+184]
	jl	$LL7@constructD
$LN6@constructD:

; 556  : 		fdn_OutputDiffusion = new MultiChannelDiffuser(fdn_internalChannels);

	mov	ecx, 48					; 00000030H
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T17[rbp-56], rax
	mov	edx, DWORD PTR [rdi+172]
	mov	rcx, rax
	call	??0MultiChannelDiffuser@@QEAA@H@Z	; MultiChannelDiffuser::MultiChannelDiffuser
	npad	1
	mov	QWORD PTR [rdi+136], rax

; 557  : 	}	

	add	rsp, 56					; 00000038H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
?constructDiffusionBlocks@FDN@@AEAAXXZ ENDP		; FDN::constructDiffusionBlocks
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T11 = 32
$T13 = 40
$T8 = 128
$T17 = 128
$T16 = 128
$T3 = 128
this$ = 128
$T4 = 136
$T1 = 136
$T5 = 144
$T6 = 152
?dtor$0@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA PROC ; `FDN::constructDiffusionBlocks'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 48					; 00000030H
	mov	rcx, QWORD PTR $T1[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA ENDP ; `FDN::constructDiffusionBlocks'::`1'::dtor$0
$T11 = 32
$T13 = 40
$T8 = 128
$T17 = 128
$T16 = 128
$T3 = 128
this$ = 128
$T4 = 136
$T1 = 136
$T5 = 144
$T6 = 152
?dtor$1@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA PROC ; `FDN::constructDiffusionBlocks'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 48					; 00000030H
	mov	rcx, QWORD PTR $T4[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA ENDP ; `FDN::constructDiffusionBlocks'::`1'::dtor$1
$T11 = 32
$T13 = 40
$T8 = 128
$T17 = 128
$T16 = 128
$T3 = 128
this$ = 128
$T4 = 136
$T1 = 136
$T5 = 144
$T6 = 152
?dtor$3@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA PROC ; `FDN::constructDiffusionBlocks'::`1'::dtor$3
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 56					; 00000038H
	mov	rcx, QWORD PTR $T5[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$3@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA ENDP ; `FDN::constructDiffusionBlocks'::`1'::dtor$3
$T11 = 32
$T13 = 40
$T8 = 128
$T17 = 128
$T16 = 128
$T3 = 128
this$ = 128
$T4 = 136
$T1 = 136
$T5 = 144
$T6 = 152
?dtor$6@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA PROC ; `FDN::constructDiffusionBlocks'::`1'::dtor$6
	mov	rcx, QWORD PTR $T5[rdx]
	add	rcx, 8
	jmp	??1?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEAA@XZ ; std::vector<ModDelay *,std::allocator<ModDelay *> >::~vector<ModDelay *,std::allocator<ModDelay *> >
?dtor$6@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA ENDP ; `FDN::constructDiffusionBlocks'::`1'::dtor$6
$T11 = 32
$T13 = 40
$T8 = 128
$T17 = 128
$T16 = 128
$T3 = 128
this$ = 128
$T4 = 136
$T1 = 136
$T5 = 144
$T6 = 152
?dtor$7@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA PROC ; `FDN::constructDiffusionBlocks'::`1'::dtor$7
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 144				; 00000090H
	mov	rcx, QWORD PTR $T6[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$7@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA ENDP ; `FDN::constructDiffusionBlocks'::`1'::dtor$7
$T11 = 32
$T13 = 40
$T8 = 128
$T17 = 128
$T16 = 128
$T3 = 128
this$ = 128
$T4 = 136
$T1 = 136
$T5 = 144
$T6 = 152
?dtor$4@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA PROC ; `FDN::constructDiffusionBlocks'::`1'::dtor$4
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 16
	mov	rcx, QWORD PTR $T11[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$4@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA ENDP ; `FDN::constructDiffusionBlocks'::`1'::dtor$4
$T11 = 32
$T13 = 40
$T8 = 128
$T17 = 128
$T16 = 128
$T3 = 128
this$ = 128
$T4 = 136
$T1 = 136
$T5 = 144
$T6 = 152
?dtor$5@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA PROC ; `FDN::constructDiffusionBlocks'::`1'::dtor$5
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 32					; 00000020H
	mov	rcx, QWORD PTR $T13[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$5@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA ENDP ; `FDN::constructDiffusionBlocks'::`1'::dtor$5
$T11 = 32
$T13 = 40
$T8 = 128
$T17 = 128
$T16 = 128
$T3 = 128
this$ = 128
$T4 = 136
$T1 = 136
$T5 = 144
$T6 = 152
?dtor$2@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA PROC ; `FDN::constructDiffusionBlocks'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 48					; 00000030H
	mov	rcx, QWORD PTR $T17[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA ENDP ; `FDN::constructDiffusionBlocks'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
$T11 = 32
$T13 = 40
$T8 = 128
$T17 = 128
$T16 = 128
$T3 = 128
this$ = 128
$T4 = 136
$T1 = 136
$T5 = 144
$T6 = 152
?dtor$0@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA PROC ; `FDN::constructDiffusionBlocks'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 48					; 00000030H
	mov	rcx, QWORD PTR $T1[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA ENDP ; `FDN::constructDiffusionBlocks'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
$T11 = 32
$T13 = 40
$T8 = 128
$T17 = 128
$T16 = 128
$T3 = 128
this$ = 128
$T4 = 136
$T1 = 136
$T5 = 144
$T6 = 152
?dtor$1@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA PROC ; `FDN::constructDiffusionBlocks'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 48					; 00000030H
	mov	rcx, QWORD PTR $T4[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA ENDP ; `FDN::constructDiffusionBlocks'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
$T11 = 32
$T13 = 40
$T8 = 128
$T17 = 128
$T16 = 128
$T3 = 128
this$ = 128
$T4 = 136
$T1 = 136
$T5 = 144
$T6 = 152
?dtor$3@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA PROC ; `FDN::constructDiffusionBlocks'::`1'::dtor$3
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 56					; 00000038H
	mov	rcx, QWORD PTR $T5[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$3@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA ENDP ; `FDN::constructDiffusionBlocks'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
$T11 = 32
$T13 = 40
$T8 = 128
$T17 = 128
$T16 = 128
$T3 = 128
this$ = 128
$T4 = 136
$T1 = 136
$T5 = 144
$T6 = 152
?dtor$6@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA PROC ; `FDN::constructDiffusionBlocks'::`1'::dtor$6
	mov	rcx, QWORD PTR $T5[rdx]
	add	rcx, 8
	jmp	??1?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEAA@XZ ; std::vector<ModDelay *,std::allocator<ModDelay *> >::~vector<ModDelay *,std::allocator<ModDelay *> >
?dtor$6@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA ENDP ; `FDN::constructDiffusionBlocks'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
$T11 = 32
$T13 = 40
$T8 = 128
$T17 = 128
$T16 = 128
$T3 = 128
this$ = 128
$T4 = 136
$T1 = 136
$T5 = 144
$T6 = 152
?dtor$7@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA PROC ; `FDN::constructDiffusionBlocks'::`1'::dtor$7
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 144				; 00000090H
	mov	rcx, QWORD PTR $T6[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$7@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA ENDP ; `FDN::constructDiffusionBlocks'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
$T11 = 32
$T13 = 40
$T8 = 128
$T17 = 128
$T16 = 128
$T3 = 128
this$ = 128
$T4 = 136
$T1 = 136
$T5 = 144
$T6 = 152
?dtor$4@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA PROC ; `FDN::constructDiffusionBlocks'::`1'::dtor$4
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 16
	mov	rcx, QWORD PTR $T11[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$4@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA ENDP ; `FDN::constructDiffusionBlocks'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
$T11 = 32
$T13 = 40
$T8 = 128
$T17 = 128
$T16 = 128
$T3 = 128
this$ = 128
$T4 = 136
$T1 = 136
$T5 = 144
$T6 = 152
?dtor$5@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA PROC ; `FDN::constructDiffusionBlocks'::`1'::dtor$5
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 32					; 00000020H
	mov	rcx, QWORD PTR $T13[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$5@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA ENDP ; `FDN::constructDiffusionBlocks'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
$T11 = 32
$T13 = 40
$T8 = 128
$T17 = 128
$T16 = 128
$T3 = 128
this$ = 128
$T4 = 136
$T1 = 136
$T5 = 144
$T6 = 152
?dtor$2@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA PROC ; `FDN::constructDiffusionBlocks'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 48					; 00000030H
	mov	rcx, QWORD PTR $T17[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0??constructDiffusionBlocks@FDN@@AEAAXXZ@4HA ENDP ; `FDN::constructDiffusionBlocks'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\LowPassFilter.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\LowPassFilter.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\HighPassFilter.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\HighPassFilter.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
;	COMDAT ?constructFilters@FDN@@AEAAXXZ
_TEXT	SEGMENT
$T4 = 64
$T6 = 64
$T1 = 64
$T3 = 64
this$ = 64
?constructFilters@FDN@@AEAAXXZ PROC			; FDN::constructFilters, COMDAT

; 560  : 	void constructFilters() {

$LN36:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 561  : 		for (int i = 0; i < fdn_outputChannels; i++) {

	xor	esi, esi
	mov	rdi, rcx
	cmp	DWORD PTR [rcx+176], esi
	jle	$LN3@constructF
	lea	r14, QWORD PTR [rcx+144]
$LL4@constructF:

; 562  : 			fdn_LPFOutput.push_back(new LowPassFilter());

	mov	ecx, 60					; 0000003cH
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T1[rsp], rax
; File E:\FoxSuite\shimmer\include\LowPassFilter.h

; 48   : 			updateGains();

	mov	rcx, rax
; File E:\FoxSuite\shimmer\include\FDN.h

; 562  : 			fdn_LPFOutput.push_back(new LowPassFilter());

	mov	rbx, rax
; File E:\FoxSuite\shimmer\include\LowPassFilter.h

; 41   : 			lpf_type = type;

	and	DWORD PTR [rax], 0

; 42   : 			lpf_shelvingGaindB = DEFAULT_SHELVING_GAIN;
; 43   : 			lpf_Q = DEFAULT_RESONANCE;
; 44   : 			lpf_xn_1 = 0.0;

	and	DWORD PTR [rax+44], 0

; 45   : 			lpf_xn_2 = 0.0;

	and	DWORD PTR [rax+48], 0

; 46   : 			lpf_yn_1 = 0.0;

	and	DWORD PTR [rax+52], 0

; 47   : 			lpf_yn_2 = 0.0;

	and	DWORD PTR [rax+56], 0
	mov	DWORD PTR [rax+4], 1184645120		; 469c4000H
	mov	DWORD PTR [rax+8], 44100		; 0000ac44H
	mov	DWORD PTR [rax+12], -1061158912		; c0c00000H
	mov	DWORD PTR [rax+16], 1060437492		; 3f34fdf4H

; 48   : 			updateGains();

	call	?updateGains@LowPassFilter@@QEAAXXZ	; LowPassFilter::updateGains
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 743  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rdi+88]
; File E:\FoxSuite\shimmer\include\FDN.h

; 562  : 			fdn_LPFOutput.push_back(new LowPassFilter());

	mov	QWORD PTR $T3[rsp], rbx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 743  :         if (_Mylast != _My_data._Myend) {

	cmp	rdx, QWORD PTR [rdi+96]
	je	SHORT $LN17@constructF

; 726  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	QWORD PTR [rdx], rbx

; 727  :         _Orphan_range(_Mylast, _Mylast);
; 728  :         _Ty& _Result = *_Mylast;
; 729  :         ++_Mylast;

	add	QWORD PTR [rdi+88], 8

; 744  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN16@constructF
$LN17@constructF:

; 745  :         }
; 746  : 
; 747  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T3[rsp]
	lea	rcx, QWORD PTR [rdi+80]
	call	??$_Emplace_reallocate@PEAVLowPassFilter@@@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEAAPEAPEAVLowPassFilter@@QEAPEAV2@$$QEAPEAV2@@Z ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::_Emplace_reallocate<LowPassFilter *>
$LN16@constructF:
; File E:\FoxSuite\shimmer\include\FDN.h

; 563  : 			fdn_HPFOutput.push_back(new HighPassFilter());

	mov	ecx, 60					; 0000003cH
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T4[rsp], rax
; File E:\FoxSuite\shimmer\include\HighPassFilter.h

; 48   : 		updateGains();

	mov	rcx, rax
; File E:\FoxSuite\shimmer\include\FDN.h

; 563  : 			fdn_HPFOutput.push_back(new HighPassFilter());

	mov	rbx, rax
; File E:\FoxSuite\shimmer\include\HighPassFilter.h

; 41   : 		hpf_type = type;

	and	DWORD PTR [rax], 0

; 42   : 		hpf_shelvingGaindB = DEFAULT_SHELVING_GAIN;
; 43   : 		hpf_Q = DEFAULT_RESONANCE;
; 44   : 		hpf_xn_1 = 0.0;

	and	DWORD PTR [rax+44], 0

; 45   : 		hpf_xn_2 = 0.0;

	and	DWORD PTR [rax+48], 0

; 46   : 		hpf_yn_1 = 0.0;

	and	DWORD PTR [rax+52], 0

; 47   : 		hpf_yn_2 = 0.0;

	and	DWORD PTR [rax+56], 0
	mov	DWORD PTR [rax+4], 1183109120		; 4684d000H
	mov	DWORD PTR [rax+8], 44100		; 0000ac44H
	mov	DWORD PTR [rax+12], -1061158912		; c0c00000H
	mov	DWORD PTR [rax+16], 1060437492		; 3f34fdf4H

; 48   : 		updateGains();

	call	?updateGains@HighPassFilter@@QEAAXXZ	; HighPassFilter::updateGains
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 743  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [r14+8]
; File E:\FoxSuite\shimmer\include\FDN.h

; 563  : 			fdn_HPFOutput.push_back(new HighPassFilter());

	mov	QWORD PTR $T6[rsp], rbx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 743  :         if (_Mylast != _My_data._Myend) {

	cmp	rdx, QWORD PTR [r14+16]
	je	SHORT $LN26@constructF

; 726  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	QWORD PTR [rdx], rbx

; 727  :         _Orphan_range(_Mylast, _Mylast);
; 728  :         _Ty& _Result = *_Mylast;
; 729  :         ++_Mylast;

	add	QWORD PTR [r14+8], 8

; 744  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN2@constructF
$LN26@constructF:

; 745  :         }
; 746  : 
; 747  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T6[rsp]
	mov	rcx, r14
	call	??$_Emplace_reallocate@PEAVHighPassFilter@@@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEAAPEAPEAVHighPassFilter@@QEAPEAV2@$$QEAPEAV2@@Z ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::_Emplace_reallocate<HighPassFilter *>
$LN2@constructF:
; File E:\FoxSuite\shimmer\include\FDN.h

; 561  : 		for (int i = 0; i < fdn_outputChannels; i++) {

	inc	esi
	cmp	esi, DWORD PTR [rdi+176]
	jl	$LL4@constructF
$LN3@constructF:

; 564  : 		}
; 565  : 	}

	mov	rbx, QWORD PTR [rsp+72]
	mov	rbp, QWORD PTR [rsp+80]
	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
?constructFilters@FDN@@AEAAXXZ ENDP			; FDN::constructFilters
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\Modulation.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
;	COMDAT ?constructModulation@FDN@@AEAAXXZ
_TEXT	SEGMENT
$T3 = 64
this$ = 64
$T1 = 72
?constructModulation@FDN@@AEAAXXZ PROC			; FDN::constructModulation, COMDAT

; 568  : 	void constructModulation() {

$LN25:
	mov	QWORD PTR [rsp+24], rbx
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 32					; 00000020H
	mov	rsi, rcx

; 569  : 		for (int i = 0; i < fdn_internalChannels; i++)

	xor	ebx, ebx
	cmp	DWORD PTR [rcx+172], ebx
	jle	SHORT $LN3@constructM
$LL4@constructM:

; 570  : 			fdn_Modulation.push_back(new Modulation());

	mov	ecx, 176				; 000000b0H
	call	??2@YAPEAX_K@Z				; operator new
	mov	r14, rax
	mov	QWORD PTR $T1[rsp], rax
; File E:\FoxSuite\shimmer\include\Modulation.h

; 44   : 	Modulation() {}

	mov	rcx, rax
	call	??0ModDelay@@QEAA@XZ			; ModDelay::ModDelay
	lea	rax, OFFSET FLAT:??_7Modulation@@6B@
	mov	QWORD PTR [r14], rax
; File E:\FoxSuite\shimmer\include\FDN.h

; 570  : 			fdn_Modulation.push_back(new Modulation());

	mov	QWORD PTR $T3[rsp], r14
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 743  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rsi+112]
	cmp	rdx, QWORD PTR [rsi+120]
	je	SHORT $LN15@constructM

; 726  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	QWORD PTR [rdx], r14

; 727  :         _Orphan_range(_Mylast, _Mylast);
; 728  :         _Ty& _Result = *_Mylast;
; 729  :         ++_Mylast;

	add	QWORD PTR [rsi+112], 8

; 744  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN2@constructM
$LN15@constructM:

; 745  :         }
; 746  : 
; 747  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T3[rsp]
	lea	rcx, QWORD PTR [rsi+104]
	call	??$_Emplace_reallocate@PEAVModulation@@@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@QEAAPEAPEAVModulation@@QEAPEAV2@$$QEAPEAV2@@Z ; std::vector<Modulation *,std::allocator<Modulation *> >::_Emplace_reallocate<Modulation *>
$LN2@constructM:
; File E:\FoxSuite\shimmer\include\FDN.h

; 569  : 		for (int i = 0; i < fdn_internalChannels; i++)

	inc	ebx
	cmp	ebx, DWORD PTR [rsi+172]
	jl	SHORT $LL4@constructM
$LN3@constructM:

; 571  : 	}

	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
?constructModulation@FDN@@AEAAXXZ ENDP			; FDN::constructModulation
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T3 = 64
this$ = 64
$T1 = 72
?dtor$0@?0??constructModulation@FDN@@AEAAXXZ@4HA PROC	; `FDN::constructModulation'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 176				; 000000b0H
	mov	rcx, QWORD PTR $T1[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??constructModulation@FDN@@AEAAXXZ@4HA ENDP	; `FDN::constructModulation'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
$T3 = 64
this$ = 64
$T1 = 72
?dtor$0@?0??constructModulation@FDN@@AEAAXXZ@4HA PROC	; `FDN::constructModulation'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 176				; 000000b0H
	mov	rcx, QWORD PTR $T1[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??constructModulation@FDN@@AEAAXXZ@4HA ENDP	; `FDN::constructModulation'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\FDN.h
;	COMDAT ?deleteInterfaceBlocks@FDN@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?deleteInterfaceBlocks@FDN@@AEAAXXZ PROC		; FDN::deleteInterfaceBlocks, COMDAT

; 574  : 	void deleteInterfaceBlocks() {

$LN15:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 575  : 		delete fdn_Splitter;

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN8@deleteInte
	mov	edx, 8
	call	??3@YAXPEAX_K@Z				; operator delete
$LN8@deleteInte:

; 576  : 		delete fdn_Mixer;

	mov	rcx, QWORD PTR [rbx+8]
	test	rcx, rcx
	je	SHORT $LN11@deleteInte
	mov	edx, 12
	call	??3@YAXPEAX_K@Z				; operator delete
$LN11@deleteInte:

; 577  : 	}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?deleteInterfaceBlocks@FDN@@AEAAXXZ ENDP		; FDN::deleteInterfaceBlocks
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
;	COMDAT ?deleteDiffusionBlocks@FDN@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?deleteDiffusionBlocks@FDN@@AEAAXXZ PROC		; FDN::deleteDiffusionBlocks, COMDAT

; 580  : 	void deleteDiffusionBlocks() {

$LN48:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	push	r14
	sub	rsp, 32					; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1544 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	rdx, QWORD PTR [rcx+24]
; File E:\FoxSuite\shimmer\include\FDN.h

; 580  : 	void deleteDiffusionBlocks() {

	mov	rbx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1544 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	rax, QWORD PTR [rcx+32]
	mov	r14d, 48				; 00000030H
	cmp	rdx, rax
; File E:\FoxSuite\shimmer\include\FDN.h

; 582  : 		if (!fdn_Diffuser.empty()) {

	je	SHORT $LN8@deleteDiff
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	rax, rdx
; File E:\FoxSuite\shimmer\include\FDN.h

; 584  : 			for (int i = 0; i < fdn_Diffuser.size(); i++) 

	xor	ebp, ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	rax, 3
; File E:\FoxSuite\shimmer\include\FDN.h

; 584  : 			for (int i = 0; i < fdn_Diffuser.size(); i++) 

	test	rax, rax
	je	SHORT $LN3@deleteDiff
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1548 :         auto& _My_data = _Mypair._Myval2;

	xor	esi, esi
$LL4@deleteDiff:
; File E:\FoxSuite\shimmer\include\FDN.h

; 585  : 				delete fdn_Diffuser[i];

	mov	rdi, QWORD PTR [rsi+rdx]
	test	rdi, rdi
	je	SHORT $LN2@deleteDiff
	mov	rcx, rdi
	call	??1MultiChannelDiffuser@@QEAA@XZ	; MultiChannelDiffuser::~MultiChannelDiffuser
	mov	rdx, r14
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN2@deleteDiff:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR [rbx+24]
; File E:\FoxSuite\shimmer\include\FDN.h

; 584  : 			for (int i = 0; i < fdn_Diffuser.size(); i++) 

	inc	ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rbx+32]
; File E:\FoxSuite\shimmer\include\FDN.h

; 584  : 			for (int i = 0; i < fdn_Diffuser.size(); i++) 

	add	rsi, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	rcx, rdx
; File E:\FoxSuite\shimmer\include\FDN.h

; 584  : 			for (int i = 0; i < fdn_Diffuser.size(); i++) 

	movsxd	rax, ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	rcx, 3
; File E:\FoxSuite\shimmer\include\FDN.h

; 584  : 			for (int i = 0; i < fdn_Diffuser.size(); i++) 

	cmp	rax, rcx
	jb	SHORT $LL4@deleteDiff
$LN3@deleteDiff:

; 586  : 
; 587  : 			// "clear" calls distructors as well (if present)
; 588  : 			fdn_Diffuser.clear();

	mov	QWORD PTR [rbx+32], rdx
$LN8@deleteDiff:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1544 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	rdx, QWORD PTR [rbx+48]
	mov	rax, QWORD PTR [rbx+56]
	cmp	rdx, rax
; File E:\FoxSuite\shimmer\include\FDN.h

; 592  : 		if (!fdn_ModDiffuser.empty()) {

	je	SHORT $LN9@deleteDiff
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	rax, rdx
; File E:\FoxSuite\shimmer\include\FDN.h

; 593  : 			for (int i = 0; i < fdn_ModDiffuser.size(); i++)

	xor	ebp, ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	rax, 3
; File E:\FoxSuite\shimmer\include\FDN.h

; 593  : 			for (int i = 0; i < fdn_ModDiffuser.size(); i++)

	test	rax, rax
	je	SHORT $LN6@deleteDiff
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1548 :         auto& _My_data = _Mypair._Myval2;

	xor	esi, esi
$LL7@deleteDiff:
; File E:\FoxSuite\shimmer\include\FDN.h

; 594  : 				delete fdn_ModDiffuser[i];

	mov	rdi, QWORD PTR [rsi+rdx]
	test	rdi, rdi
	je	SHORT $LN5@deleteDiff
	mov	rcx, rdi
	call	??1ModMultiChannelDiffuser@@QEAA@XZ	; ModMultiChannelDiffuser::~ModMultiChannelDiffuser
	mov	rdx, r14
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN5@deleteDiff:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR [rbx+48]
; File E:\FoxSuite\shimmer\include\FDN.h

; 593  : 			for (int i = 0; i < fdn_ModDiffuser.size(); i++)

	inc	ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rbx+56]
; File E:\FoxSuite\shimmer\include\FDN.h

; 593  : 			for (int i = 0; i < fdn_ModDiffuser.size(); i++)

	add	rsi, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	rcx, rdx
; File E:\FoxSuite\shimmer\include\FDN.h

; 593  : 			for (int i = 0; i < fdn_ModDiffuser.size(); i++)

	movsxd	rax, ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	rcx, 3
; File E:\FoxSuite\shimmer\include\FDN.h

; 593  : 			for (int i = 0; i < fdn_ModDiffuser.size(); i++)

	cmp	rax, rcx
	jb	SHORT $LL7@deleteDiff
$LN6@deleteDiff:

; 595  : 			fdn_ModDiffuser.clear();

	mov	QWORD PTR [rbx+56], rdx
$LN9@deleteDiff:

; 596  : 		}
; 597  : 
; 598  : 		// Delete output diffuser
; 599  : 		delete fdn_OutputDiffusion;

	mov	rbx, QWORD PTR [rbx+136]
	test	rbx, rbx
	je	SHORT $LN36@deleteDiff
	mov	rcx, rbx
	call	??1MultiChannelDiffuser@@QEAA@XZ	; MultiChannelDiffuser::~MultiChannelDiffuser
	mov	rdx, r14
	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
$LN36@deleteDiff:

; 600  : 	}

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
?deleteDiffusionBlocks@FDN@@AEAAXXZ ENDP		; FDN::deleteDiffusionBlocks
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\FDN.h
;	COMDAT ?deleteFeedbackBlock@FDN@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?deleteFeedbackBlock@FDN@@AEAAXXZ PROC			; FDN::deleteFeedbackBlock, COMDAT

; 603  : 	void deleteFeedbackBlock() {

$LN10:
	push	rbx
	sub	rsp, 32					; 00000020H

; 604  : 		delete fdn_Feedback;

	mov	rbx, QWORD PTR [rcx+72]
	test	rbx, rbx
	je	SHORT $LN6@deleteFeed
	mov	rcx, rbx
	call	??1ModMultiChannelFeedback@@QEAA@XZ	; ModMultiChannelFeedback::~ModMultiChannelFeedback
	mov	edx, 72					; 00000048H
	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
$LN6@deleteFeed:

; 605  : 	}	

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?deleteFeedbackBlock@FDN@@AEAAXXZ ENDP			; FDN::deleteFeedbackBlock
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
;	COMDAT ?deleteFilters@FDN@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?deleteFilters@FDN@@AEAAXXZ PROC			; FDN::deleteFilters, COMDAT

; 608  : 	void deleteFilters() {

$LN43:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1544 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	rdx, QWORD PTR [rcx+80]
; File E:\FoxSuite\shimmer\include\FDN.h

; 608  : 	void deleteFilters() {

	mov	rbx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1544 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	rax, QWORD PTR [rcx+88]
	cmp	rdx, rax
; File E:\FoxSuite\shimmer\include\FDN.h

; 609  : 		if (!fdn_LPFOutput.empty()) {

	je	SHORT $LN8@deleteFilt
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	rax, rdx
; File E:\FoxSuite\shimmer\include\FDN.h

; 610  : 			for (int i = 0; i < fdn_LPFOutput.size(); i++)

	xor	esi, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	rax, 3
; File E:\FoxSuite\shimmer\include\FDN.h

; 610  : 			for (int i = 0; i < fdn_LPFOutput.size(); i++)

	test	rax, rax
	je	SHORT $LN3@deleteFilt
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1548 :         auto& _My_data = _Mypair._Myval2;

	xor	edi, edi
$LL4@deleteFilt:
; File E:\FoxSuite\shimmer\include\FDN.h

; 611  : 				delete fdn_LPFOutput[i];

	mov	rcx, QWORD PTR [rdi+rdx]
	test	rcx, rcx
	je	SHORT $LN2@deleteFilt
	mov	edx, 60					; 0000003cH
	call	??3@YAXPEAX_K@Z				; operator delete
$LN2@deleteFilt:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR [rbx+80]
; File E:\FoxSuite\shimmer\include\FDN.h

; 610  : 			for (int i = 0; i < fdn_LPFOutput.size(); i++)

	inc	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rbx+88]
; File E:\FoxSuite\shimmer\include\FDN.h

; 610  : 			for (int i = 0; i < fdn_LPFOutput.size(); i++)

	add	rdi, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	rcx, rdx
; File E:\FoxSuite\shimmer\include\FDN.h

; 610  : 			for (int i = 0; i < fdn_LPFOutput.size(); i++)

	movsxd	rax, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	rcx, 3
; File E:\FoxSuite\shimmer\include\FDN.h

; 610  : 			for (int i = 0; i < fdn_LPFOutput.size(); i++)

	cmp	rax, rcx
	jb	SHORT $LL4@deleteFilt
$LN3@deleteFilt:

; 612  : 			fdn_LPFOutput.clear();

	mov	QWORD PTR [rbx+88], rdx
$LN8@deleteFilt:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1544 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	rdx, QWORD PTR [rbx+144]
	mov	rax, QWORD PTR [rbx+152]
	cmp	rdx, rax
; File E:\FoxSuite\shimmer\include\FDN.h

; 614  : 		if (!fdn_HPFOutput.empty()) {

	je	SHORT $LN9@deleteFilt
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	rax, rdx
; File E:\FoxSuite\shimmer\include\FDN.h

; 615  : 			for (int i = 0; i < fdn_HPFOutput.size(); i++)

	xor	esi, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	rax, 3
; File E:\FoxSuite\shimmer\include\FDN.h

; 615  : 			for (int i = 0; i < fdn_HPFOutput.size(); i++)

	test	rax, rax
	je	SHORT $LN6@deleteFilt
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1548 :         auto& _My_data = _Mypair._Myval2;

	xor	edi, edi
$LL7@deleteFilt:
; File E:\FoxSuite\shimmer\include\FDN.h

; 616  : 				delete fdn_HPFOutput[i];

	mov	rcx, QWORD PTR [rdi+rdx]
	test	rcx, rcx
	je	SHORT $LN5@deleteFilt
	mov	edx, 60					; 0000003cH
	call	??3@YAXPEAX_K@Z				; operator delete
$LN5@deleteFilt:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR [rbx+144]
; File E:\FoxSuite\shimmer\include\FDN.h

; 615  : 			for (int i = 0; i < fdn_HPFOutput.size(); i++)

	inc	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rbx+152]
; File E:\FoxSuite\shimmer\include\FDN.h

; 615  : 			for (int i = 0; i < fdn_HPFOutput.size(); i++)

	add	rdi, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	rcx, rdx
; File E:\FoxSuite\shimmer\include\FDN.h

; 615  : 			for (int i = 0; i < fdn_HPFOutput.size(); i++)

	movsxd	rax, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	rcx, 3
; File E:\FoxSuite\shimmer\include\FDN.h

; 615  : 			for (int i = 0; i < fdn_HPFOutput.size(); i++)

	cmp	rax, rcx
	jb	SHORT $LL7@deleteFilt
$LN6@deleteFilt:

; 617  : 			fdn_HPFOutput.clear();

	mov	QWORD PTR [rbx+152], rdx
$LN9@deleteFilt:

; 618  : 		}
; 619  : 	}

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?deleteFilters@FDN@@AEAAXXZ ENDP			; FDN::deleteFilters
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
;	COMDAT ?deleteChorus@FDN@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?deleteChorus@FDN@@AEAAXXZ PROC				; FDN::deleteChorus, COMDAT

; 622  : 	void deleteChorus() {

$LN35:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	push	r14
	sub	rsp, 32					; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1544 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	rdx, QWORD PTR [rcx+104]
; File E:\FoxSuite\shimmer\include\FDN.h

; 622  : 	void deleteChorus() {

	mov	rbx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1544 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	rax, QWORD PTR [rcx+112]
	cmp	rdx, rax
; File E:\FoxSuite\shimmer\include\FDN.h

; 623  : 		if (!fdn_Modulation.empty()) {

	je	SHORT $LN5@deleteChor
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	rax, rdx
; File E:\FoxSuite\shimmer\include\FDN.h

; 624  : 			for (int i = 0; i < fdn_Modulation.size(); i++)

	xor	ebp, ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	rax, 3
; File E:\FoxSuite\shimmer\include\FDN.h

; 624  : 			for (int i = 0; i < fdn_Modulation.size(); i++)

	test	rax, rax
	je	SHORT $LN3@deleteChor
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1548 :         auto& _My_data = _Mypair._Myval2;

	xor	r14d, r14d
$LL4@deleteChor:
; File E:\FoxSuite\shimmer\include\FDN.h

; 625  : 				delete fdn_Modulation[i];

	mov	rdi, QWORD PTR [r14+rdx]
	test	rdi, rdi
	je	SHORT $LN2@deleteChor
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 51   : 		delete mdly_LFO;

	mov	rsi, QWORD PTR [rdi+104]
	lea	rax, OFFSET FLAT:??_7ModDelay@@6B@
	mov	QWORD PTR [rdi], rax
	test	rsi, rsi
	je	SHORT $LN27@deleteChor
	mov	rcx, rsi
	call	??1LFO@@QEAA@XZ				; LFO::~LFO
	mov	edx, 56					; 00000038H
	mov	rcx, rsi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN27@deleteChor:

; 52   : 	}

	mov	rcx, rdi
	call	??1LPCombFilter@@QEAA@XZ		; LPCombFilter::~LPCombFilter
	mov	edx, 176				; 000000b0H
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN2@deleteChor:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR [rbx+104]
; File E:\FoxSuite\shimmer\include\FDN.h

; 624  : 			for (int i = 0; i < fdn_Modulation.size(); i++)

	inc	ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rbx+112]
; File E:\FoxSuite\shimmer\include\FDN.h

; 624  : 			for (int i = 0; i < fdn_Modulation.size(); i++)

	add	r14, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	rcx, rdx
; File E:\FoxSuite\shimmer\include\FDN.h

; 624  : 			for (int i = 0; i < fdn_Modulation.size(); i++)

	movsxd	rax, ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	rcx, 3
; File E:\FoxSuite\shimmer\include\FDN.h

; 624  : 			for (int i = 0; i < fdn_Modulation.size(); i++)

	cmp	rax, rcx
	jb	SHORT $LL4@deleteChor
$LN3@deleteChor:

; 626  : 			fdn_Modulation.clear();

	mov	QWORD PTR [rbx+112], rdx
$LN5@deleteChor:

; 627  : 		}
; 628  : 	}

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
?deleteChorus@FDN@@AEAAXXZ ENDP				; FDN::deleteChorus
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\FDN.h
;	COMDAT ?initInternalArrays@FDN@@AEAAXXZ
_TEXT	SEGMENT
$T3 = 48
$T2 = 48
$T1 = 48
this$ = 48
?initInternalArrays@FDN@@AEAAXXZ PROC			; FDN::initInternalArrays, COMDAT

; 631  : 	void initInternalArrays() {

$LN4:
	push	rbx
	sub	rsp, 32					; 00000020H

; 632  : 		fdn_tmpDiffuser.resize(fdn_internalChannels, 0.0);

	movsxd	rdx, DWORD PTR [rcx+172]
	lea	r8, QWORD PTR $T1[rsp]
	and	DWORD PTR $T1[rsp], 0
	mov	rbx, rcx
	add	rcx, 192				; 000000c0H
	call	?resize@?$vector@MV?$allocator@M@std@@@std@@QEAAX_KAEBM@Z ; std::vector<float,std::allocator<float> >::resize

; 633  : 		fdn_tmpFeedback.resize(fdn_internalChannels, 0.0);

	movsxd	rdx, DWORD PTR [rbx+172]
	lea	rcx, QWORD PTR [rbx+216]
	and	DWORD PTR $T2[rsp], 0
	lea	r8, QWORD PTR $T2[rsp]
	call	?resize@?$vector@MV?$allocator@M@std@@@std@@QEAAX_KAEBM@Z ; std::vector<float,std::allocator<float> >::resize

; 634  : 		fdn_outEarly.resize(fdn_internalChannels, 0.0);

	movsxd	rdx, DWORD PTR [rbx+172]
	lea	rcx, QWORD PTR [rbx+240]
	and	DWORD PTR $T3[rsp], 0
	lea	r8, QWORD PTR $T3[rsp]
	call	?resize@?$vector@MV?$allocator@M@std@@@std@@QEAAX_KAEBM@Z ; std::vector<float,std::allocator<float> >::resize

; 635  : 	}	

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?initInternalArrays@FDN@@AEAAXXZ ENDP			; FDN::initInternalArrays
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
;	COMDAT ?deleteInternalArrays@FDN@@AEAAXXZ
_TEXT	SEGMENT
this$ = 8
?deleteInternalArrays@FDN@@AEAAXXZ PROC			; FDN::deleteInternalArrays, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1544 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	rax, QWORD PTR [rcx+192]
	cmp	rax, QWORD PTR [rcx+200]
; File E:\FoxSuite\shimmer\include\FDN.h

; 639  : 		if (!fdn_tmpDiffuser.empty())

	je	SHORT $LN2@deleteInte

; 640  : 			fdn_tmpDiffuser.clear();

	mov	QWORD PTR [rcx+200], rax
$LN2@deleteInte:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1544 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	rax, QWORD PTR [rcx+216]
	cmp	rax, QWORD PTR [rcx+224]
; File E:\FoxSuite\shimmer\include\FDN.h

; 641  : 		if (!fdn_tmpFeedback.empty())

	je	SHORT $LN3@deleteInte

; 642  : 			fdn_tmpFeedback.clear();

	mov	QWORD PTR [rcx+224], rax
$LN3@deleteInte:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1544 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	rax, QWORD PTR [rcx+240]
	cmp	rax, QWORD PTR [rcx+248]
; File E:\FoxSuite\shimmer\include\FDN.h

; 643  : 		if (!fdn_outEarly.empty())		

	je	SHORT $LN4@deleteInte

; 644  : 			fdn_outEarly.clear();				

	mov	QWORD PTR [rcx+248], rax
$LN4@deleteInte:

; 645  : 	}

	ret	0
?deleteInternalArrays@FDN@@AEAAXXZ ENDP			; FDN::deleteInternalArrays
_TEXT	ENDS
; Function compile flags: /Ogspy
;	COMDAT ??_GChannelSplitter@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$dead$ = 56
??_GChannelSplitter@@QEAAPEAXI@Z PROC			; ChannelSplitter::`scalar deleting destructor', COMDAT
$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	edx, 8
	mov	rbx, rcx
	call	??3@YAXPEAX_K@Z				; operator delete
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??_GChannelSplitter@@QEAAPEAXI@Z ENDP			; ChannelSplitter::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogspy
;	COMDAT ??_GChannelMixer@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$dead$ = 56
??_GChannelMixer@@QEAAPEAXI@Z PROC			; ChannelMixer::`scalar deleting destructor', COMDAT
$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	edx, 12
	mov	rbx, rcx
	call	??3@YAXPEAX_K@Z				; operator delete
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??_GChannelMixer@@QEAAPEAXI@Z ENDP			; ChannelMixer::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogspy
;	COMDAT ??_GMultiChannelDiffuser@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$dead$ = 56
??_GMultiChannelDiffuser@@QEAAPEAXI@Z PROC		; MultiChannelDiffuser::`scalar deleting destructor', COMDAT
$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	call	??1MultiChannelDiffuser@@QEAA@XZ	; MultiChannelDiffuser::~MultiChannelDiffuser
	mov	edx, 48					; 00000030H
	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??_GMultiChannelDiffuser@@QEAAPEAXI@Z ENDP		; MultiChannelDiffuser::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogspy
;	COMDAT ??_GModMultiChannelDiffuser@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$dead$ = 56
??_GModMultiChannelDiffuser@@QEAAPEAXI@Z PROC		; ModMultiChannelDiffuser::`scalar deleting destructor', COMDAT
$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	call	??1ModMultiChannelDiffuser@@QEAA@XZ	; ModMultiChannelDiffuser::~ModMultiChannelDiffuser
	mov	edx, 48					; 00000030H
	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??_GModMultiChannelDiffuser@@QEAAPEAXI@Z ENDP		; ModMultiChannelDiffuser::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogspy
;	COMDAT ??_GModMultiChannelFeedback@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$dead$ = 56
??_GModMultiChannelFeedback@@QEAAPEAXI@Z PROC		; ModMultiChannelFeedback::`scalar deleting destructor', COMDAT
$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	call	??1ModMultiChannelFeedback@@QEAA@XZ	; ModMultiChannelFeedback::~ModMultiChannelFeedback
	mov	edx, 72					; 00000048H
	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??_GModMultiChannelFeedback@@QEAAPEAXI@Z ENDP		; ModMultiChannelFeedback::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogspy
;	COMDAT ??_GHighPassFilter@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$dead$ = 56
??_GHighPassFilter@@QEAAPEAXI@Z PROC			; HighPassFilter::`scalar deleting destructor', COMDAT
$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	edx, 60					; 0000003cH
	mov	rbx, rcx
	call	??3@YAXPEAX_K@Z				; operator delete
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??_GHighPassFilter@@QEAAPEAXI@Z ENDP			; HighPassFilter::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\ModDelay.h
;	COMDAT ??_GModulation@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$dead$ = 56
??_GModulation@@QEAAPEAXI@Z PROC			; Modulation::`scalar deleting destructor', COMDAT
$LN17:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 51   : 		delete mdly_LFO;

	mov	rdi, QWORD PTR [rcx+104]
	lea	rax, OFFSET FLAT:??_7ModDelay@@6B@
	mov	QWORD PTR [rcx], rax
	mov	rbx, rcx
	test	rdi, rdi
	je	SHORT $LN13@scalar
	mov	rcx, rdi
	call	??1LFO@@QEAA@XZ				; LFO::~LFO
	mov	edx, 56					; 00000038H
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN13@scalar:

; 52   : 	}

	mov	rcx, rbx
	call	??1LPCombFilter@@QEAA@XZ		; LPCombFilter::~LPCombFilter
	mov	edx, 176				; 000000b0H
	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??_GModulation@@QEAAPEAXI@Z ENDP			; Modulation::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\guiconstants.h
;	COMDAT ??__EkCTCorrFactorZero@@YAXXZ
text$di	SEGMENT
??__EkCTCorrFactorZero@@YAXXZ PROC			; `dynamic initializer for 'kCTCorrFactorZero'', COMDAT

; 142  : const double kCTCorrFactorZero = pow(10.0, (-1.0/kCTCoefficient));

	sub	rsp, 40					; 00000028H
	movsd	xmm1, QWORD PTR __real@c003333333333333
	movsd	xmm0, QWORD PTR __real@4024000000000000
	call	QWORD PTR __imp_pow
	movsd	QWORD PTR ?kCTCorrFactorZero@@3NB, xmm0
	add	rsp, 40					; 00000028H
	ret	0
??__EkCTCorrFactorZero@@YAXXZ ENDP			; `dynamic initializer for 'kCTCorrFactorZero''
text$di	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\guiconstants.h
;	COMDAT ??__EkCTCorrFactorUnity@@YAXXZ
text$di	SEGMENT
??__EkCTCorrFactorUnity@@YAXXZ PROC			; `dynamic initializer for 'kCTCorrFactorUnity'', COMDAT

; 156  : const double kCTCorrFactorUnity = 1.0 / (1.0 + kCTCoefficient*log10(1.0 + kCTCorrFactorZero));

	movsd	xmm0, QWORD PTR ?kCTCorrFactorZero@@3NB
	addsd	xmm0, QWORD PTR __real@3ff0000000000000
	rex_jmp	QWORD PTR __imp_log10
??__EkCTCorrFactorUnity@@YAXXZ ENDP			; `dynamic initializer for 'kCTCorrFactorUnity''
text$di	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\guiconstants.h
;	COMDAT ??__EkCTCorrFactorAntiUnity@@YAXXZ
text$di	SEGMENT
??__EkCTCorrFactorAntiUnity@@YAXXZ PROC			; `dynamic initializer for 'kCTCorrFactorAntiUnity'', COMDAT

; 163  : const double kCTCorrFactorAntiUnity = 1.0 / (1.0 + (-pow(10.0, (-1.0/kCTCoefficient))));

	movsd	xmm1, QWORD PTR __real@c003333333333333
	movsd	xmm0, QWORD PTR __real@4024000000000000
	rex_jmp	QWORD PTR __imp_pow
??__EkCTCorrFactorAntiUnity@@YAXXZ ENDP			; `dynamic initializer for 'kCTCorrFactorAntiUnity''
text$di	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\guiconstants.h
;	COMDAT ??__EkCTCorrFactorAntiLog@@YAXXZ
text$di	SEGMENT
??__EkCTCorrFactorAntiLog@@YAXXZ PROC			; `dynamic initializer for 'kCTCorrFactorAntiLog'', COMDAT

; 170  : const double kCTCorrFactorAntiLog = kCTCoefficient*log10(1.0 + kCTCorrFactorZero);

	sub	rsp, 40					; 00000028H
	movsd	xmm0, QWORD PTR ?kCTCorrFactorZero@@3NB
	addsd	xmm0, QWORD PTR __real@3ff0000000000000
	call	QWORD PTR __imp_log10
	mulsd	xmm0, QWORD PTR __real@3fdaaaaaaaaaaaab
	movsd	QWORD PTR ?kCTCorrFactorAntiLog@@3NB, xmm0
	add	rsp, 40					; 00000028H
	ret	0
??__EkCTCorrFactorAntiLog@@YAXXZ ENDP			; `dynamic initializer for 'kCTCorrFactorAntiLog''
text$di	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\guiconstants.h
;	COMDAT ??__EkCTCorrFactorAntiLogScale@@YAXXZ
text$di	SEGMENT
??__EkCTCorrFactorAntiLogScale@@YAXXZ PROC		; `dynamic initializer for 'kCTCorrFactorAntiLogScale'', COMDAT

; 177  : const double kCTCorrFactorAntiLogScale = 1.0 / (-kCTCoefficient*log10(kCTCorrFactorZero) + kCTCorrFactorAntiLog);

	movsd	xmm0, QWORD PTR ?kCTCorrFactorZero@@3NB
	rex_jmp	QWORD PTR __imp_log10
??__EkCTCorrFactorAntiLogScale@@YAXXZ ENDP		; `dynamic initializer for 'kCTCorrFactorAntiLogScale''
text$di	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\PSMVocoder.h
;	COMDAT ?getMagnitude@@YANNN@Z
_TEXT	SEGMENT
re$ = 8
im$ = 16
?getMagnitude@@YANNN@Z PROC				; getMagnitude, COMDAT

; 22   : 	return sqrt((re * re) + (im * im));

	mulsd	xmm0, xmm0
	mulsd	xmm1, xmm1
	addsd	xmm0, xmm1
	rex_jmp	QWORD PTR __imp_sqrt
?getMagnitude@@YANNN@Z ENDP				; getMagnitude
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\PSMVocoder.h
;	COMDAT ?getPhase@@YANNN@Z
_TEXT	SEGMENT
re$ = 8
im$ = 16
?getPhase@@YANNN@Z PROC					; getPhase, COMDAT

; 36   : {

	movaps	xmm2, xmm1

; 37   : 	return atan2(im, re);

	movaps	xmm1, xmm0
	movaps	xmm0, xmm2
	rex_jmp	QWORD PTR __imp_atan2
?getPhase@@YANNN@Z ENDP					; getPhase
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\PSMVocoder.h
;	COMDAT ?principalArg@@YANN@Z
_TEXT	SEGMENT
phaseIn$ = 48
?principalArg@@YANN@Z PROC				; principalArg, COMDAT

; 51   : {

$LN6:
	sub	rsp, 40					; 00000028H

; 52   : 	if (phaseIn >= 0)

	comisd	xmm0, QWORD PTR __real@0000000000000000
	movaps	xmm2, xmm0
	addsd	xmm2, QWORD PTR __real@400921fb54442d18
	movaps	xmm0, xmm2
	jb	SHORT $LN2@principalA

; 53   : 		return fmod(phaseIn + kPi, kTwoPi) - kPi;

	movsd	xmm1, QWORD PTR __real@401921fb54442d18
	call	QWORD PTR __imp_fmod
	subsd	xmm0, QWORD PTR __real@400921fb54442d18
	jmp	SHORT $LN3@principalA
$LN2@principalA:

; 54   : 	else
; 55   : 		return fmod(phaseIn + kPi, -kTwoPi) + kPi;

	movsd	xmm1, QWORD PTR __real@c01921fb54442d18
	call	QWORD PTR __imp_fmod
	addsd	xmm0, QWORD PTR __real@400921fb54442d18
$LN3@principalA:

; 56   : }

	add	rsp, 40					; 00000028H
	ret	0
?principalArg@@YANN@Z ENDP				; principalArg
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\PSMVocoder.h
;	COMDAT ?doLinearInterpolation@@YANNNN@Z
_TEXT	SEGMENT
y1$ = 8
y2$ = 16
fractional_X$ = 24
?doLinearInterpolation@@YANNNN@Z PROC			; doLinearInterpolation, COMDAT

; 75   : {

	movaps	xmm3, xmm0

; 76   : 	// --- check invalid condition
; 77   : 	if (fractional_X >= 1.0) return y2;

	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	comisd	xmm2, xmm0
	jb	SHORT $LN2@doLinearIn
	movaps	xmm0, xmm1

; 81   : }

	ret	0
$LN2@doLinearIn:

; 78   : 
; 79   : 	// --- use weighted sum method of interpolating
; 80   : 	return fractional_X * y2 + (1.0 - fractional_X) * y1;

	subsd	xmm0, xmm2
	mulsd	xmm1, xmm2
	mulsd	xmm0, xmm3
	addsd	xmm0, xmm1

; 81   : }

	ret	0
?doLinearInterpolation@@YANNNN@Z ENDP			; doLinearInterpolation
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\PSMVocoder.h
;	COMDAT ?doLagrangeInterpolation@@YANPEAN0HN@Z
_TEXT	SEGMENT
x$ = 8
y$ = 16
n$dead$ = 24
xbar$ = 32
?doLagrangeInterpolation@@YANPEAN0HN@Z PROC		; doLagrangeInterpolation, COMDAT

; 96   : {

	xor	r8d, r8d

; 97   : 	int i, j;
; 98   : 	double fx = 0.0;

	mov	r9, rcx
	sub	r9, rdx
	xorps	xmm4, xmm4
$LL4@doLagrange:

; 99   : 	double l = 1.0;
; 100  : 	for (i = 0; i < n; i++)
; 101  : 	{
; 102  : 		l = 1.0;

	movsd	xmm2, QWORD PTR __real@3ff0000000000000
	xor	eax, eax
$LL7@doLagrange:

; 104  : 		{
; 105  : 			if (j != i)

	cmp	rax, r8
	je	SHORT $LN5@doLagrange

; 106  : 				l *= (xbar - x[j]) / (x[i] - x[j]);

	movsd	xmm0, QWORD PTR [r9+rdx]
	movaps	xmm1, xmm3
	subsd	xmm1, QWORD PTR [rcx+rax*8]
	subsd	xmm0, QWORD PTR [rcx+rax*8]
	divsd	xmm1, xmm0
	mulsd	xmm2, xmm1
$LN5@doLagrange:

; 103  : 		for (j = 0; j < n; j++)

	inc	rax
	cmp	rax, 4
	jl	SHORT $LL7@doLagrange

; 107  : 		}
; 108  : 		fx += l * y[i];

	mulsd	xmm2, QWORD PTR [rdx]
	inc	r8
	add	rdx, 8
	addsd	xmm4, xmm2
	cmp	r8, 4
	jl	SHORT $LL4@doLagrange

; 109  : 	}
; 110  : 	return (fx);

	movaps	xmm0, xmm4

; 111  : }

	ret	0
?doLagrangeInterpolation@@YANPEAN0HN@Z ENDP		; doLagrangeInterpolation
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\PSMVocoder.h
;	COMDAT ?resample@@YA_NPEAN0IIW4interpolation@@N0@Z
_TEXT	SEGMENT
input$ = 8
output$ = 16
inLength$dead$ = 24
outLength$ = 32
interpType$dead$ = 40
scalar$ = 48
outWindow$ = 56
?resample@@YA_NPEAN0IIW4interpolation@@N0@Z PROC	; resample, COMDAT

; 133  : {

$LN94:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], rdi
	mov	r11d, r9d
	mov	r10, rcx

; 134  : 	if (inLength <= 1 || outLength <= 1) return false;

	cmp	r9d, 1
	jbe	$LN9@resample

; 135  : 	if (!input || !output) return false;

	test	rcx, rcx
	je	$LN9@resample
	test	rdx, rdx
	je	$LN9@resample

; 136  : 
; 137  : 	double x[4] = { 0.0, 0.0, 0.0, 0.0 };
; 138  : 	double y[4] = { 0.0, 0.0, 0.0, 0.0 };
; 139  : 
; 140  : 	// --- inc
; 141  : 	double inc = (double)(inLength - 1) / (double)(outLength - 1);

	movsd	xmm5, QWORD PTR __real@40affe0000000000
	lea	ecx, DWORD PTR [r9-1]

; 142  : 
; 143  : 	// --- first point
; 144  : 	if (outWindow)

	mov	rdi, QWORD PTR outWindow$[rsp]
	xorps	xmm0, xmm0
	movsd	xmm3, QWORD PTR scalar$[rsp]
	mov	rax, rdx
	cvtsi2sd xmm0, rcx
	divsd	xmm5, xmm0
	movaps	xmm0, xmm3
	test	rdi, rdi
	je	SHORT $LN12@resample

; 145  : 		output[0] = outWindow[0] * scalar * input[0];

	mulsd	xmm0, QWORD PTR [rdi]
$LN12@resample:

; 146  : 	else
; 147  : 		output[0] = scalar * input[0];

	mulsd	xmm0, QWORD PTR [r10]
	lea	r9, QWORD PTR [rdx+8]
	mov	rsi, rdi
	mov	ebx, 1
	sub	rsi, rdx
	movsd	QWORD PTR [rax], xmm0
	movsd	xmm4, QWORD PTR __real@3ff0000000000000
$LL7@resample:

; 195  : 		{
; 196  : 			double xInterp = i * inc;

	xorps	xmm1, xmm1
	mov	eax, ebx
	xorps	xmm0, xmm0
	cvtsi2sd xmm1, rax
	mulsd	xmm1, xmm5
	cvttsd2si r8, xmm1

; 197  : 			uint32_t x1 = (uint32_t)xInterp; // floor?
; 198  : 			uint32_t x2 = x1 + 1;
; 199  : 			if (x2 >= outLength)
; 200  : 				x2 = x1;
; 201  : 			double y1 = input[x1];

	mov	ecx, r8d
	mov	eax, r8d
	lea	edx, DWORD PTR [r8+1]
	cmp	edx, r11d
	cmovb	ecx, edx

; 202  : 			double y2 = input[x2];

	movsd	xmm2, QWORD PTR [r10+rcx*8]
	mov	ecx, r8d
	cvtsi2sd xmm0, rcx
	subsd	xmm1, xmm0

; 203  : 
; 204  : 			if (outWindow)

	test	rdi, rdi
	je	SHORT $LN24@resample

; 77   : 	if (fractional_X >= 1.0) return y2;

	comisd	xmm1, xmm4
	jae	SHORT $LN51@resample

; 78   : 
; 79   : 	// --- use weighted sum method of interpolating
; 80   : 	return fractional_X * y2 + (1.0 - fractional_X) * y1;

	movaps	xmm0, xmm4
	subsd	xmm0, xmm1
	mulsd	xmm1, xmm2
	mulsd	xmm0, QWORD PTR [r10+rax*8]
	movaps	xmm2, xmm0
	addsd	xmm2, xmm1
$LN51@resample:

; 205  : 				output[i] = outWindow[i] * scalar * doLinearInterpolation(y1, y2, xInterp - x1);

	movaps	xmm0, xmm3
	mulsd	xmm0, QWORD PTR [rsi+r9]
	mulsd	xmm0, xmm2
	jmp	SHORT $LN5@resample
$LN24@resample:

; 77   : 	if (fractional_X >= 1.0) return y2;

	comisd	xmm1, xmm4
	jb	SHORT $LN55@resample
	movaps	xmm0, xmm2
	jmp	SHORT $LN54@resample
$LN55@resample:

; 78   : 
; 79   : 	// --- use weighted sum method of interpolating
; 80   : 	return fractional_X * y2 + (1.0 - fractional_X) * y1;

	movaps	xmm0, xmm4
	subsd	xmm0, xmm1
	mulsd	xmm1, xmm2
	mulsd	xmm0, QWORD PTR [r10+rax*8]
	addsd	xmm0, xmm1
$LN54@resample:

; 206  : 			else
; 207  : 				output[i] = scalar * doLinearInterpolation(y1, y2, xInterp - x1);

	mulsd	xmm0, xmm3
$LN5@resample:

; 148  : 
; 149  : 	if (interpType == interpolation::kLagrange4)
; 150  : 	{
; 151  : 		for (unsigned int i = 1; i < outLength; i++)
; 152  : 		{
; 153  : 			// --- find interpolation location
; 154  : 			double xInterp = i * inc;
; 155  : 			uint32_t x1 = (uint32_t)xInterp; // floor?
; 156  : 
; 157  : 			if (xInterp > 1.0 && x1 < inLength - 2)
; 158  : 			{
; 159  : 				x[0] = x1 - 1;
; 160  : 				y[0] = input[(int)x[0]];
; 161  : 
; 162  : 				x[1] = x1;
; 163  : 				y[1] = input[(int)x[1]];
; 164  : 
; 165  : 				x[2] = x1 + 1;
; 166  : 				y[2] = input[(int)x[2]];
; 167  : 
; 168  : 				x[3] = x1 + 2;
; 169  : 				y[3] = input[(int)x[3]];
; 170  : 
; 171  : 				if (outWindow)
; 172  : 					output[i] = outWindow[i] * scalar * doLagrangeInterpolation(x, y, 4, xInterp);
; 173  : 				else
; 174  : 					output[i] = scalar * doLagrangeInterpolation(x, y, 4, xInterp);
; 175  : 			}
; 176  : 			else // --- linear for outer 2 end pts
; 177  : 			{
; 178  : 				uint32_t x2 = x1 + 1;
; 179  : 				if (x2 >= outLength)
; 180  : 					x2 = x1;
; 181  : 				double y1 = input[x1];
; 182  : 				double y2 = input[x2];
; 183  : 
; 184  : 				if (outWindow)
; 185  : 					output[i] = outWindow[i] * scalar * doLinearInterpolation(y1, y2, xInterp - x1);
; 186  : 				else
; 187  : 					output[i] = scalar * doLinearInterpolation(y1, y2, xInterp - x1);
; 188  : 			}
; 189  : 		}
; 190  : 	}
; 191  : 	else // must be linear
; 192  : 	{
; 193  : 		// --- LINEAR INTERP
; 194  : 		for (uint32_t i = 1; i < outLength; i++)

	movsd	QWORD PTR [r9], xmm0
	inc	ebx
	add	r9, 8
	cmp	ebx, r11d
	jb	$LL7@resample

; 208  : 		}
; 209  : 	}
; 210  : 
; 211  : 	return true;

	mov	al, 1
	jmp	SHORT $LN1@resample
$LN9@resample:

; 134  : 	if (inLength <= 1 || outLength <= 1) return false;

	xor	al, al
$LN1@resample:

; 212  : }

	mov	rbx, QWORD PTR [rsp+8]
	mov	rsi, QWORD PTR [rsp+16]
	mov	rdi, QWORD PTR [rsp+24]
	ret	0
?resample@@YA_NPEAN0IIW4interpolation@@N0@Z ENDP	; resample
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\PSMVocoder.h
;	COMDAT ?setSampleRate@IAudioSignalProcessor@@UEAAXN@Z
_TEXT	SEGMENT
this$ = 8
_sampleRate$ = 16
?setSampleRate@IAudioSignalProcessor@@UEAAXN@Z PROC	; IAudioSignalProcessor::setSampleRate, COMDAT

; 248  : 	virtual void setSampleRate(double _sampleRate) {}

	ret	0
?setSampleRate@IAudioSignalProcessor@@UEAAXN@Z ENDP	; IAudioSignalProcessor::setSampleRate
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\PSMVocoder.h
;	COMDAT ?enableAuxInput@IAudioSignalProcessor@@UEAAX_N@Z
_TEXT	SEGMENT
this$ = 8
enableAuxInput$ = 16
?enableAuxInput@IAudioSignalProcessor@@UEAAX_N@Z PROC	; IAudioSignalProcessor::enableAuxInput, COMDAT

; 251  : 	virtual void enableAuxInput(bool enableAuxInput) {}

	ret	0
?enableAuxInput@IAudioSignalProcessor@@UEAAX_N@Z ENDP	; IAudioSignalProcessor::enableAuxInput
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\PSMVocoder.h
;	COMDAT ?processAuxInputAudioSample@IAudioSignalProcessor@@UEAANN@Z
_TEXT	SEGMENT
this$ = 8
xn$ = 16
?processAuxInputAudioSample@IAudioSignalProcessor@@UEAANN@Z PROC ; IAudioSignalProcessor::processAuxInputAudioSample, COMDAT

; 257  : 		// --- do nothing
; 258  : 		return xn;

	movaps	xmm0, xmm1

; 259  : 	}

	ret	0
?processAuxInputAudioSample@IAudioSignalProcessor@@UEAANN@Z ENDP ; IAudioSignalProcessor::processAuxInputAudioSample
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\PSMVocoder.h
;	COMDAT ?processAudioFrame@IAudioSignalProcessor@@UEAA_NPEBMPEAMII@Z
_TEXT	SEGMENT
this$ = 8
inputFrame$ = 16
outputFrame$ = 24
inputChannels$ = 32
outputChannels$ = 40
?processAudioFrame@IAudioSignalProcessor@@UEAA_NPEBMPEAMII@Z PROC ; IAudioSignalProcessor::processAudioFrame, COMDAT

; 270  : 		// --- do nothing
; 271  : 		return false; // NOT handled

	xor	al, al

; 272  : 	}

	ret	0
?processAudioFrame@IAudioSignalProcessor@@UEAA_NPEBMPEAMII@Z ENDP ; IAudioSignalProcessor::processAudioFrame
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\PSMVocoder.h
;	COMDAT ??0PSMVocoderParameters@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0PSMVocoderParameters@@QEAA@XZ PROC			; PSMVocoderParameters::PSMVocoderParameters, COMDAT

; 427  : 	/** all FXObjects parameter objects require overloaded= operator so remember to add new entries if you add new variables. */
; 428  : 	PSMVocoderParameters& operator=(const PSMVocoderParameters& params)	// need this override for collections to work
; 429  : 	{
; 430  : 		if (this == &params)
; 431  : 			return *this;
; 432  : 
; 433  : 		pitchShiftSemitones = params.pitchShiftSemitones;
; 434  : 		enablePeakPhaseLocking = params.enablePeakPhaseLocking;
; 435  : 		enablePeakTracking = params.enablePeakTracking;
; 436  : 
; 437  : 		return *this;
; 438  : 	}
; 439  : 
; 440  : 	// --- params
; 441  : 	double pitchShiftSemitones = 0.0;	///< pitch shift in half-steps

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 442  : 	bool enablePeakPhaseLocking = false;///< flag to enable phase lock

	mov	WORD PTR [rcx+8], ax
	mov	rax, rcx
	ret	0
??0PSMVocoderParameters@@QEAA@XZ ENDP			; PSMVocoderParameters::PSMVocoderParameters
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\PSMVocoder.h
;	COMDAT ??4PSMVocoderParameters@@QEAAAEAU0@AEBU0@@Z
_TEXT	SEGMENT
this$ = 8
params$ = 16
??4PSMVocoderParameters@@QEAAAEAU0@AEBU0@@Z PROC	; PSMVocoderParameters::operator=, COMDAT

; 430  : 		if (this == &params)

	cmp	rcx, rdx
	je	SHORT $LN4@operator

; 431  : 			return *this;
; 432  : 
; 433  : 		pitchShiftSemitones = params.pitchShiftSemitones;

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax

; 434  : 		enablePeakPhaseLocking = params.enablePeakPhaseLocking;

	mov	al, BYTE PTR [rdx+8]
	mov	BYTE PTR [rcx+8], al

; 435  : 		enablePeakTracking = params.enablePeakTracking;

	mov	al, BYTE PTR [rdx+9]
	mov	BYTE PTR [rcx+9], al
$LN4@operator:

; 436  : 
; 437  : 		return *this;
; 438  : 	}

	mov	rax, rcx
	ret	0
??4PSMVocoderParameters@@QEAAAEAU0@AEBU0@@Z ENDP	; PSMVocoderParameters::operator=
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\PSMVocoder.h
;	COMDAT ??0BinData@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0BinData@@QEAA@XZ PROC				; BinData::BinData, COMDAT

; 462  : 	/** all FXObjects parameter objects require overloaded= operator so remember to add new entries if you add new variables. */
; 463  : 	BinData& operator=(const BinData& params)	// need this override for collections to work
; 464  : 	{
; 465  : 		if (this == &params)
; 466  : 			return *this;
; 467  : 
; 468  : 		isPeak = params.isPeak;
; 469  : 		magnitude = params.magnitude;
; 470  : 		phi = params.phi;
; 471  : 
; 472  : 		psi = params.psi;
; 473  : 		localPeakBin = params.localPeakBin;
; 474  : 		previousPeakBin = params.previousPeakBin;
; 475  : 		updatedPhase = params.updatedPhase;
; 476  : 
; 477  : 		return *this;
; 478  : 	}
; 479  : 
; 480  : 	/** reset all variables to 0.0 */
; 481  : 	void reset()
; 482  : 	{
; 483  : 		isPeak = false;
; 484  : 		magnitude = 0.0;
; 485  : 		phi = 0.0;
; 486  : 
; 487  : 		psi = 0.0;
; 488  : 		localPeakBin = 0;
; 489  : 		previousPeakBin = -1; // -1 is flag
; 490  : 		updatedPhase = 0.0;
; 491  : 	}
; 492  : 
; 493  : 	bool isPeak = false;	///< flag for peak bins
; 494  : 	double magnitude = 0.0; ///< bin magnitude angle
; 495  : 	double phi = 0.0;		///< bin phase angle
; 496  : 	double psi = 0.0;		///< bin phase correction
; 497  : 	unsigned int localPeakBin = 0; ///< index of peak-boss
; 498  : 	int previousPeakBin = -1; ///< index of peak bin in previous FFT

	or	DWORD PTR [rcx+36], -1
	xor	eax, eax
	mov	BYTE PTR [rcx], al
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	QWORD PTR [rcx+24], rax
	mov	DWORD PTR [rcx+32], eax

; 499  : 	double updatedPhase = 0.0; ///< phase update value

	mov	QWORD PTR [rcx+40], rax
	mov	rax, rcx
	ret	0
??0BinData@@QEAA@XZ ENDP				; BinData::BinData
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\PSMVocoder.h
;	COMDAT ??4BinData@@QEAAAEAU0@AEBU0@@Z
_TEXT	SEGMENT
this$ = 8
params$ = 16
??4BinData@@QEAAAEAU0@AEBU0@@Z PROC			; BinData::operator=, COMDAT

; 465  : 		if (this == &params)

	cmp	rcx, rdx
	je	SHORT $LN4@operator

; 466  : 			return *this;
; 467  : 
; 468  : 		isPeak = params.isPeak;

	mov	al, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al

; 469  : 		magnitude = params.magnitude;

	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR [rcx+8], rax

; 470  : 		phi = params.phi;

	mov	rax, QWORD PTR [rdx+16]
	mov	QWORD PTR [rcx+16], rax

; 471  : 
; 472  : 		psi = params.psi;

	mov	rax, QWORD PTR [rdx+24]
	mov	QWORD PTR [rcx+24], rax

; 473  : 		localPeakBin = params.localPeakBin;

	mov	eax, DWORD PTR [rdx+32]
	mov	DWORD PTR [rcx+32], eax

; 474  : 		previousPeakBin = params.previousPeakBin;

	mov	eax, DWORD PTR [rdx+36]
	mov	DWORD PTR [rcx+36], eax

; 475  : 		updatedPhase = params.updatedPhase;

	mov	rax, QWORD PTR [rdx+40]
	mov	QWORD PTR [rcx+40], rax
$LN4@operator:

; 476  : 
; 477  : 		return *this;
; 478  : 	}

	mov	rax, rcx
	ret	0
??4BinData@@QEAAAEAU0@AEBU0@@Z ENDP			; BinData::operator=
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\PSMVocoder.h
;	COMDAT ?reset@BinData@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?reset@BinData@@QEAAXXZ PROC				; BinData::reset, COMDAT

; 483  : 		isPeak = false;
; 484  : 		magnitude = 0.0;
; 485  : 		phi = 0.0;
; 486  : 
; 487  : 		psi = 0.0;
; 488  : 		localPeakBin = 0;
; 489  : 		previousPeakBin = -1; // -1 is flag

	or	DWORD PTR [rcx+36], -1
	xor	eax, eax
	mov	BYTE PTR [rcx], al
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	QWORD PTR [rcx+24], rax
	mov	DWORD PTR [rcx+32], eax

; 490  : 		updatedPhase = 0.0;

	mov	QWORD PTR [rcx+40], rax

; 491  : 	}

	ret	0
?reset@BinData@@QEAAXXZ ENDP				; BinData::reset
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\PSMVocoder.h
;	COMDAT ??0PhaseVocoder@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0PhaseVocoder@@QEAA@XZ PROC				; PhaseVocoder::PhaseVocoder, COMDAT

; 527  : 	~PhaseVocoder() {
; 528  : 		if (inputBuffer) delete[] inputBuffer;
; 529  : 		if (outputBuffer) delete[] outputBuffer;
; 530  : 		if (windowBuffer) delete[] windowBuffer;
; 531  : 		destroyFFTW();
; 532  : 	}	/* D-TOR */
; 533  : 
; 534  : 	/** setup the FFT for a given framelength and window type*/
; 535  : 	void initialize(unsigned int _frameLength, unsigned int _hopSize, windowType _window);
; 536  : 
; 537  : 	/** destroy FFTW objects and plans */
; 538  : 	void destroyFFTW();
; 539  : 
; 540  : 	/** process audio sample through vocode; check fftReady flag to access FFT output */
; 541  : 	double processAudioSample(double input, bool& fftReady);
; 542  : 
; 543  : 	/** add zero-padding without advancing output read location, for fast convolution */
; 544  : 	bool addZeroPad(unsigned int count);
; 545  : 
; 546  : 	/** increment the FFT counter and do the FFT if it is ready */
; 547  : 	bool advanceAndCheckFFT();
; 548  : 
; 549  : 	/** get FFT data for manipulation (yes, naked pointer so you can manipulate) */
; 550  : 	fftw_complex* getFFTData() { return fft_result; }
; 551  : 
; 552  : 	/** get IFFT data for manipulation (yes, naked pointer so you can manipulate) */
; 553  : 	fftw_complex* getIFFTData() { return ifft_result; }
; 554  : 
; 555  : 	/** do the inverse FFT (optional; will be called automatically if not used) */
; 556  : 	void doInverseFFT();
; 557  : 
; 558  : 	/** do the overlap-add operation */
; 559  : 	void doOverlapAdd(double* outputData = nullptr, int length = 0);
; 560  : 
; 561  : 	/** get current FFT length */
; 562  : 	unsigned int getFrameLength() { return frameLength; }
; 563  : 
; 564  : 	/** get current hop size ha = hs */
; 565  : 	unsigned int getHopSize() { return hopSize; }
; 566  : 
; 567  : 	/** get current overlap as a raw value (75% = 0.75) */
; 568  : 	double getOverlap() { return overlap; }
; 569  : 
; 570  : 	/** set the vocoder for overlap add only without hop-size */
; 571  : 	// --- for fast convolution and other overlap-add algorithms
; 572  : 	//     that are not hop-size dependent
; 573  : 	void setOverlapAddOnly(bool b) { bool overlapAddOnly = b; }
; 574  : 
; 575  : protected:
; 576  : 	// --- setup FFTW
; 577  : 	fftw_complex* fft_input = nullptr;		///< array for FFT input

	xor	edx, edx

; 578  : 	fftw_complex* fft_result = nullptr;		///< array for FFT output
; 579  : 	fftw_complex* ifft_result = nullptr;		///< array for IFFT output
; 580  : 	fftw_plan       plan_forward = nullptr;		///< FFTW plan for FFT
; 581  : 	fftw_plan		plan_backward = nullptr;	///< FFTW plan for IFFT
; 582  : 
; 583  : 	// --- linear buffer for window
; 584  : 	double* windowBuffer = nullptr;		///< array for window
; 585  : 
; 586  : 	// --- circular buffers for input and output
; 587  : 	double* inputBuffer = nullptr;		///< input timeline (x)
; 588  : 	double* outputBuffer = nullptr;		///< output timeline (y)
; 589  : 
; 590  : 	// --- index and wrap masks for input and output buffers
; 591  : 	unsigned int inputWriteIndex = 0;			///< circular buffer index: input write
; 592  : 	unsigned int outputWriteIndex = 0;			///< circular buffer index: output write
; 593  : 	unsigned int inputReadIndex = 0;			///< circular buffer index: input read
; 594  : 	unsigned int outputReadIndex = 0;			///< circular buffer index: output read
; 595  : 	unsigned int wrapMask = 0;					///< input wrap mask
; 596  : 	unsigned int wrapMaskOut = 0;				///< output wrap mask
; 597  : 
; 598  : 	// --- amplitude correction factor, aking into account both hopsize (overlap)
; 599  : 	//     and the window power itself
; 600  : 	double windowHopCorrection = 1.0;			///< window correction including hop/overlap
; 601  : 
; 602  : 	// --- these allow a more robust combination of user interaction
; 603  : 	bool needInverseFFT = false;				///< internal flag to signal IFFT required
; 604  : 	bool needOverlapAdd = false;				///< internal flag to signal overlap/add required
; 605  : 
; 606  : 	// --- our window type; you can add more windows if you like
; 607  : 	windowType window = windowType::kHannWindow;///< window type

	mov	QWORD PTR [rcx+100], 2
	mov	rax, 4607182418800017408		; 3ff0000000000000H
	mov	QWORD PTR [rcx], rdx
	mov	QWORD PTR [rcx+88], rax

; 608  : 
; 609  : 	// --- counters
; 610  : 	unsigned int frameLength = 0;				///< current FFT length
; 611  : 	unsigned int fftCounter = 0;				///< FFT sample counter
; 612  : 
; 613  : 	// --- hop-size and overlap (mathematically related)
; 614  : 	unsigned int hopSize = 0;					///< hop: ha = hs
; 615  : 	double overlap = 1.0;						///< overlap as raw value (75% = 0.75)

	mov	QWORD PTR [rcx+120], rax
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], rdx
	mov	QWORD PTR [rcx+24], rdx
	mov	QWORD PTR [rcx+32], rdx
	mov	QWORD PTR [rcx+40], rdx
	mov	QWORD PTR [rcx+48], rdx
	mov	QWORD PTR [rcx+56], rdx
	mov	QWORD PTR [rcx+64], rdx
	mov	QWORD PTR [rcx+72], rdx
	mov	QWORD PTR [rcx+80], rdx
	mov	WORD PTR [rcx+96], dx
	mov	QWORD PTR [rcx+108], rdx

; 616  : 
; 617  : 	// --- flag for overlap-add algorithms that do not involve hop-size, other
; 618  : 	//     than setting the overlap
; 619  : 	bool overlapAddOnly = false;				///< flag for overlap-add-only algorithms

	mov	BYTE PTR [rcx+128], dl
	ret	0
??0PhaseVocoder@@QEAA@XZ ENDP				; PhaseVocoder::PhaseVocoder
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\PSMVocoder.h
;	COMDAT ??1PhaseVocoder@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1PhaseVocoder@@QEAA@XZ PROC				; PhaseVocoder::~PhaseVocoder, COMDAT

; 527  : 	~PhaseVocoder() {

$LN8:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 528  : 		if (inputBuffer) delete[] inputBuffer;

	mov	rcx, QWORD PTR [rcx+48]
	test	rcx, rcx
	je	SHORT $LN2@PhaseVocod
	call	??_V@YAXPEAX@Z				; operator delete[]
$LN2@PhaseVocod:

; 529  : 		if (outputBuffer) delete[] outputBuffer;

	mov	rcx, QWORD PTR [rbx+56]
	test	rcx, rcx
	je	SHORT $LN3@PhaseVocod
	call	??_V@YAXPEAX@Z				; operator delete[]
$LN3@PhaseVocod:

; 530  : 		if (windowBuffer) delete[] windowBuffer;

	mov	rcx, QWORD PTR [rbx+40]
	test	rcx, rcx
	je	SHORT $LN4@PhaseVocod
	call	??_V@YAXPEAX@Z				; operator delete[]
$LN4@PhaseVocod:

; 531  : 		destroyFFTW();

	mov	rcx, rbx

; 532  : 	}	/* D-TOR */

	add	rsp, 32					; 00000020H
	pop	rbx

; 531  : 		destroyFFTW();

	jmp	?destroyFFTW@PhaseVocoder@@QEAAXXZ	; PhaseVocoder::destroyFFTW
??1PhaseVocoder@@QEAA@XZ ENDP				; PhaseVocoder::~PhaseVocoder
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\PSMVocoder.h
;	COMDAT ?getFFTData@PhaseVocoder@@QEAAPEAY01NXZ
_TEXT	SEGMENT
this$ = 8
?getFFTData@PhaseVocoder@@QEAAPEAY01NXZ PROC		; PhaseVocoder::getFFTData, COMDAT

; 550  : 	fftw_complex* getFFTData() { return fft_result; }

	mov	rax, QWORD PTR [rcx+8]
	ret	0
?getFFTData@PhaseVocoder@@QEAAPEAY01NXZ ENDP		; PhaseVocoder::getFFTData
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\PSMVocoder.h
;	COMDAT ?getIFFTData@PhaseVocoder@@QEAAPEAY01NXZ
_TEXT	SEGMENT
this$ = 8
?getIFFTData@PhaseVocoder@@QEAAPEAY01NXZ PROC		; PhaseVocoder::getIFFTData, COMDAT

; 553  : 	fftw_complex* getIFFTData() { return ifft_result; }

	mov	rax, QWORD PTR [rcx+16]
	ret	0
?getIFFTData@PhaseVocoder@@QEAAPEAY01NXZ ENDP		; PhaseVocoder::getIFFTData
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\PSMVocoder.h
;	COMDAT ??0PSMVocoder@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0PSMVocoder@@QEAA@XZ PROC				; PSMVocoder::PSMVocoder, COMDAT

; 645  : 	PSMVocoder() {

$LN34:
	mov	rax, rsp
	mov	QWORD PTR [rax+16], rbx
	mov	QWORD PTR [rax+24], rbp
	mov	QWORD PTR [rax+32], rsi
	mov	QWORD PTR [rax+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	lea	rax, OFFSET FLAT:??_7PSMVocoder@@6B@
	mov	QWORD PTR [rcx], rax

; 441  : 	double pitchShiftSemitones = 0.0;	///< pitch shift in half-steps

	xor	ebp, ebp
	mov	QWORD PTR [rcx+8], rbp

; 442  : 	bool enablePeakPhaseLocking = false;///< flag to enable phase lock

	mov	WORD PTR [rcx+16], bp

; 577  : 	fftw_complex* fft_input = nullptr;		///< array for FFT input

	mov	QWORD PTR [rcx+24], rbp

; 578  : 	fftw_complex* fft_result = nullptr;		///< array for FFT output

	mov	QWORD PTR [rcx+32], rbp

; 579  : 	fftw_complex* ifft_result = nullptr;		///< array for IFFT output

	mov	QWORD PTR [rcx+40], rbp

; 580  : 	fftw_plan       plan_forward = nullptr;		///< FFTW plan for FFT

	mov	QWORD PTR [rcx+48], rbp

; 581  : 	fftw_plan		plan_backward = nullptr;	///< FFTW plan for IFFT

	mov	QWORD PTR [rcx+56], rbp

; 582  : 
; 583  : 	// --- linear buffer for window
; 584  : 	double* windowBuffer = nullptr;		///< array for window

	mov	QWORD PTR [rcx+64], rbp

; 585  : 
; 586  : 	// --- circular buffers for input and output
; 587  : 	double* inputBuffer = nullptr;		///< input timeline (x)

	mov	QWORD PTR [rcx+72], rbp

; 588  : 	double* outputBuffer = nullptr;		///< output timeline (y)

	mov	QWORD PTR [rcx+80], rbp

; 589  : 
; 590  : 	// --- index and wrap masks for input and output buffers
; 591  : 	unsigned int inputWriteIndex = 0;			///< circular buffer index: input write

	mov	QWORD PTR [rcx+88], rbp

; 592  : 	unsigned int outputWriteIndex = 0;			///< circular buffer index: output write
; 593  : 	unsigned int inputReadIndex = 0;			///< circular buffer index: input read

	mov	QWORD PTR [rcx+96], rbp

; 594  : 	unsigned int outputReadIndex = 0;			///< circular buffer index: output read
; 595  : 	unsigned int wrapMask = 0;					///< input wrap mask

	mov	QWORD PTR [rcx+104], rbp

; 596  : 	unsigned int wrapMaskOut = 0;				///< output wrap mask
; 597  : 
; 598  : 	// --- amplitude correction factor, aking into account both hopsize (overlap)
; 599  : 	//     and the window power itself
; 600  : 	double windowHopCorrection = 1.0;			///< window correction including hop/overlap

	mov	rax, 4607182418800017408		; 3ff0000000000000H
	mov	QWORD PTR [rcx+112], rax

; 601  : 
; 602  : 	// --- these allow a more robust combination of user interaction
; 603  : 	bool needInverseFFT = false;				///< internal flag to signal IFFT required

	mov	WORD PTR [rcx+120], bp

; 604  : 	bool needOverlapAdd = false;				///< internal flag to signal overlap/add required
; 605  : 
; 606  : 	// --- our window type; you can add more windows if you like
; 607  : 	windowType window = windowType::kHannWindow;///< window type

	mov	QWORD PTR [rcx+124], 2

; 608  : 
; 609  : 	// --- counters
; 610  : 	unsigned int frameLength = 0;				///< current FFT length
; 611  : 	unsigned int fftCounter = 0;				///< FFT sample counter

	mov	QWORD PTR [rcx+132], rbp

; 612  : 
; 613  : 	// --- hop-size and overlap (mathematically related)
; 614  : 	unsigned int hopSize = 0;					///< hop: ha = hs
; 615  : 	double overlap = 1.0;						///< overlap as raw value (75% = 0.75)

	mov	QWORD PTR [rcx+144], rax

; 616  : 
; 617  : 	// --- flag for overlap-add algorithms that do not involve hop-size, other
; 618  : 	//     than setting the overlap
; 619  : 	bool overlapAddOnly = false;				///< flag for overlap-add-only algorithms

	mov	BYTE PTR [rcx+152], bpl

; 648  : 	~PSMVocoder() {
; 649  : 		if (windowBuff) delete[] windowBuff;
; 650  : 		if (outputBuff) delete[] outputBuff;
; 651  : 
; 652  : 	}	/* D-TOR */
; 653  : 
; 654  : 	/** reset members to initialized state */
; 655  : 	virtual bool reset(double _sampleRate)
; 656  : 	{
; 657  : 		memset(&phi[0], 0, sizeof(double) * PSM_FFT_LEN);
; 658  : 		memset(&psi[0], 0, sizeof(double) * PSM_FFT_LEN);
; 659  : 		if (outputBuff)
; 660  : 			memset(outputBuff, 0, sizeof(double) * outputBufferLength);
; 661  : 
; 662  : 		for (uint32_t i = 0; i < PSM_FFT_LEN; i++)
; 663  : 		{
; 664  : 			binData[i].reset();
; 665  : 			binDataPrevious[i].reset();
; 666  : 
; 667  : 			peakBins[i] = -1;
; 668  : 			peakBinsPrevious[i] = -1;
; 669  : 		}
; 670  : 
; 671  : 		return true;
; 672  : 	}
; 673  : 
; 674  : 	/** return false: this object only processes samples */
; 675  : 	virtual bool canProcessAudioFrame() { return false; }
; 676  : 
; 677  : 	/** set the pitch shift in semitones (note that this can be fractional too)*/
; 678  : 	void setPitchShift(double semitones)
; 679  : 	{
; 680  : 		// --- this is costly so only update when things changed
; 681  : 		double newAlpha = pow(2.0, semitones / 12.0);
; 682  : 		double newOutputBufferLength = round((1.0 / newAlpha) * (double)PSM_FFT_LEN);
; 683  : 
; 684  : 		// --- check for change
; 685  : 		if (newOutputBufferLength == outputBufferLength)
; 686  : 			return;
; 687  : 
; 688  : 		// --- new stuff
; 689  : 		alphaStretchRatio = newAlpha;
; 690  : 		ha = hs / alphaStretchRatio;
; 691  : 
; 692  : 		// --- set output resample buffer
; 693  : 		outputBufferLength = newOutputBufferLength;
; 694  : 
; 695  : 		// --- create Hann window
; 696  : 		if (windowBuff) delete[] windowBuff;
; 697  : 		windowBuff = new double[outputBufferLength];
; 698  : 		windowCorrection = 0.0;
; 699  : 		for (unsigned int i = 0; i < outputBufferLength; i++)
; 700  : 		{
; 701  : 			windowBuff[i] = 0.5 * (1.0 - cos((i * 2.0 * kPi) / (outputBufferLength)));
; 702  : 			windowCorrection += windowBuff[i];
; 703  : 		}
; 704  : 		windowCorrection = 1.0 / windowCorrection;
; 705  : 
; 706  : 		// --- create output buffer
; 707  : 		if (outputBuff) delete[] outputBuff;
; 708  : 		outputBuff = new double[outputBufferLength];
; 709  : 		memset(outputBuff, 0, sizeof(double) * outputBufferLength);
; 710  : 	}
; 711  : 
; 712  : 	/** find bin index of nearest peak bin in previous FFT frame */
; 713  : 	int findPreviousNearestPeak(int peakIndex)
; 714  : 	{
; 715  : 		if (peakBinsPrevious[0] == -1) // first run, there is no peak
; 716  : 			return -1;
; 717  : 
; 718  : 		int delta = -1;
; 719  : 		int previousPeak = -1;
; 720  : 		for (uint32_t i = 0; i < PSM_FFT_LEN; i++)
; 721  : 		{
; 722  : 			if (peakBinsPrevious[i] < 0)
; 723  : 				break;
; 724  : 
; 725  : 			int dist = abs(peakIndex - peakBinsPrevious[i]);
; 726  : 			if (dist > PSM_FFT_LEN / 4)
; 727  : 				break;
; 728  : 
; 729  : 			if (i == 0)
; 730  : 			{
; 731  : 				previousPeak = i;
; 732  : 				delta = dist;
; 733  : 			}
; 734  : 			else if (dist < delta)
; 735  : 			{
; 736  : 				previousPeak = i;
; 737  : 				delta = dist;
; 738  : 			}
; 739  : 		}
; 740  : 
; 741  : 		return previousPeak;
; 742  : 	}
; 743  : 
; 744  : 	/** identify peak bins and tag their respective regions of influence */
; 745  : 	void findPeaksAndRegionsOfInfluence()
; 746  : 	{
; 747  : 		// --- FIND PEAKS --- //
; 748  : 		//
; 749  : 		// --- find local maxima in 4-sample window
; 750  : 		double localWindow[4] = { 0.0, 0.0, 0.0, 0.0 };
; 751  : 		int m = 0;
; 752  : 		for (uint32_t i = 0; i < PSM_FFT_LEN; i++)
; 753  : 		{
; 754  : 			if (i == 0)
; 755  : 			{
; 756  : 				localWindow[0] = 0.0;
; 757  : 				localWindow[1] = 0.0;
; 758  : 				localWindow[2] = binData[i + 1].magnitude;
; 759  : 				localWindow[3] = binData[i + 2].magnitude;
; 760  : 			}
; 761  : 			else  if (i == 1)
; 762  : 			{
; 763  : 				localWindow[0] = 0.0;
; 764  : 				localWindow[1] = binData[i - 1].magnitude;
; 765  : 				localWindow[2] = binData[i + 1].magnitude;
; 766  : 				localWindow[3] = binData[i + 2].magnitude;
; 767  : 			}
; 768  : 			else  if (i == PSM_FFT_LEN - 1)
; 769  : 			{
; 770  : 				localWindow[0] = binData[i - 2].magnitude;
; 771  : 				localWindow[1] = binData[i - 1].magnitude;
; 772  : 				localWindow[2] = 0.0;
; 773  : 				localWindow[3] = 0.0;
; 774  : 			}
; 775  : 			else  if (i == PSM_FFT_LEN - 2)
; 776  : 			{
; 777  : 				localWindow[0] = binData[i - 2].magnitude;
; 778  : 				localWindow[1] = binData[i - 1].magnitude;
; 779  : 				localWindow[2] = binData[i + 1].magnitude;
; 780  : 				localWindow[3] = 0.0;
; 781  : 			}
; 782  : 			else
; 783  : 			{
; 784  : 				localWindow[0] = binData[i - 2].magnitude;
; 785  : 				localWindow[1] = binData[i - 1].magnitude;
; 786  : 				localWindow[2] = binData[i + 1].magnitude;
; 787  : 				localWindow[3] = binData[i + 2].magnitude;
; 788  : 			}
; 789  : 
; 790  : 			// --- found peak bin!
; 791  : 			if (binData[i].magnitude > 0.00001 &&
; 792  : 				binData[i].magnitude > localWindow[0]
; 793  : 				&& binData[i].magnitude > localWindow[1]
; 794  : 				&& binData[i].magnitude > localWindow[2]
; 795  : 				&& binData[i].magnitude > localWindow[3])
; 796  : 			{
; 797  : 				binData[i].isPeak = true;
; 798  : 				peakBins[m++] = i;
; 799  : 
; 800  : 				// --- for peak bins, assume that it is part of a previous, moving peak
; 801  : 				if (parameters.enablePeakTracking)
; 802  : 					binData[i].previousPeakBin = findPreviousNearestPeak(i);
; 803  : 				else
; 804  : 					binData[i].previousPeakBin = -1;
; 805  : 			}
; 806  : 		}
; 807  : 
; 808  : 		// --- assign peak bosses
; 809  : 		if (m > 0)
; 810  : 		{
; 811  : 			int n = 0;
; 812  : 			int bossPeakBin = peakBins[n];
; 813  : 			double nextPeak = peakBins[++n];
; 814  : 			int midBoundary = (nextPeak - (double)bossPeakBin) / 2.0 + bossPeakBin;
; 815  : 
; 816  : 			if (nextPeak >= 0)
; 817  : 			{
; 818  : 				for (uint32_t i = 0; i < PSM_FFT_LEN; i++)
; 819  : 				{
; 820  : 					if (i <= bossPeakBin)
; 821  : 					{
; 822  : 						binData[i].localPeakBin = bossPeakBin;
; 823  : 					}
; 824  : 					else if (i < midBoundary)
; 825  : 					{
; 826  : 						binData[i].localPeakBin = bossPeakBin;
; 827  : 					}
; 828  : 					else // > boundary, calc next set
; 829  : 					{
; 830  : 						bossPeakBin = nextPeak;
; 831  : 						nextPeak = peakBins[++n];
; 832  : 						if (nextPeak > bossPeakBin)
; 833  : 							midBoundary = (nextPeak - (double)bossPeakBin) / 2.0 + bossPeakBin;
; 834  : 						else // nextPeak == -1
; 835  : 							midBoundary = PSM_FFT_LEN;
; 836  : 
; 837  : 						binData[i].localPeakBin = bossPeakBin;
; 838  : 					}
; 839  : 				}
; 840  : 			}
; 841  : 		}
; 842  : 	}
; 843  : 
; 844  : 	/** process input sample through PSM vocoder */
; 845  : 	/**
; 846  : 	\param xn input
; 847  : 	\return the processed sample
; 848  : 	*/
; 849  : 	virtual double processAudioSample(double input)
; 850  : 	{
; 851  : 		bool fftReady = false;
; 852  : 		double output = 0.0;
; 853  : 
; 854  : 		// --- normal processing
; 855  : 		output = vocoder.processAudioSample(input, fftReady);
; 856  : 
; 857  : 		// --- if FFT is here, GO!
; 858  : 		if (fftReady)
; 859  : 		{
; 860  : 			// --- get the FFT data
; 861  : 			fftw_complex* fftData = vocoder.getFFTData();
; 862  : 
; 863  : 			if (parameters.enablePeakPhaseLocking)
; 864  : 			{
; 865  : 				// --- get the magnitudes for searching
; 866  : 				for (uint32_t i = 0; i < PSM_FFT_LEN; i++)
; 867  : 				{
; 868  : 					binData[i].reset();
; 869  : 					peakBins[i] = -1;
; 870  : 
; 871  : 					// --- store mag and phase
; 872  : 					binData[i].magnitude = getMagnitude(fftData[i][0], fftData[i][1]);
; 873  : 					binData[i].phi = getPhase(fftData[i][0], fftData[i][1]);
; 874  : 				}
; 875  : 
; 876  : 				findPeaksAndRegionsOfInfluence();
; 877  : 
; 878  : 				// --- each bin data should now know its local boss-peak
; 879  : 				//
; 880  : 				// --- now propagate phases accordingly
; 881  : 				//
; 882  : 				//     FIRST: set PSI angles of bosses
; 883  : 				for (uint32_t i = 0; i < PSM_FFT_LEN; i++)
; 884  : 				{
; 885  : 					double mag_k = binData[i].magnitude;
; 886  : 					double phi_k = binData[i].phi;
; 887  : 
; 888  : 					// --- horizontal phase propagation
; 889  : 					//
; 890  : 					// --- omega_k = bin frequency(k)
; 891  : 					double omega_k = kTwoPi * i / PSM_FFT_LEN;
; 892  : 
; 893  : 					// --- phase deviation is actual - expected phase
; 894  : 					//     = phi_k -(phi(last frame) + wk*ha
; 895  : 					double phaseDev = phi_k - phi[i] - omega_k * ha;
; 896  : 
; 897  : 					// --- unwrapped phase increment
; 898  : 					double deltaPhi = omega_k * ha + principalArg(phaseDev);
; 899  : 
; 900  : 					// --- save for next frame
; 901  : 					phi[i] = phi_k;
; 902  : 
; 903  : 					// --- if peak, assume it could have hopped from a different bin
; 904  : 					if (binData[i].isPeak)
; 905  : 					{
; 906  : 						// --- calculate new phase based on stretch factor; save phase for next time
; 907  : 						if (binData[i].previousPeakBin < 0)
; 908  : 							psi[i] = principalArg(psi[i] + deltaPhi * alphaStretchRatio);
; 909  : 						else
; 910  : 							psi[i] = principalArg(psi[binDataPrevious[i].previousPeakBin] + deltaPhi * alphaStretchRatio);
; 911  : 					}
; 912  : 
; 913  : 					// --- save peak PSI (new angle)
; 914  : 					binData[i].psi = psi[i];
; 915  : 
; 916  : 					// --- for IFFT
; 917  : 					binData[i].updatedPhase = binData[i].psi;
; 918  : 				}
; 919  : 
; 920  : 				// --- now set non-peaks
; 921  : 				for (uint32_t i = 0; i < PSM_FFT_LEN; i++)
; 922  : 				{
; 923  : 					if (!binData[i].isPeak)
; 924  : 					{
; 925  : 						int myPeakBin = binData[i].localPeakBin;
; 926  : 
; 927  : 						double PSI_kp = binData[myPeakBin].psi;
; 928  : 						double phi_kp = binData[myPeakBin].phi;
; 929  : 
; 930  : 						// --- save for next frame
; 931  : 						// phi[i] = binData[myPeakBin].phi;
; 932  : 
; 933  : 						// --- calculate new phase, locked to boss peak
; 934  : 						psi[i] = principalArg(PSI_kp - phi_kp - binData[i].phi);
; 935  : 						binData[i].updatedPhase = psi[i];// principalArg(PSI_kp - phi_kp - binData[i].phi);
; 936  : 					}
; 937  : 				}
; 938  : 
; 939  : 				for (uint32_t i = 0; i < PSM_FFT_LEN; i++)
; 940  : 				{
; 941  : 					double mag_k = binData[i].magnitude;
; 942  : 
; 943  : 					// --- convert back
; 944  : 					fftData[i][0] = mag_k * cos(binData[i].updatedPhase);
; 945  : 					fftData[i][1] = mag_k * sin(binData[i].updatedPhase);
; 946  : 
; 947  : 					// --- save for next frame
; 948  : 					binDataPrevious[i] = binData[i];
; 949  : 					peakBinsPrevious[i] = peakBins[i];
; 950  : 
; 951  : 				}
; 952  : 			}// end if peak locking
; 953  : 
; 954  : 			else // ---> old school
; 955  : 			{
; 956  : 				for (uint32_t i = 0; i < PSM_FFT_LEN; i++)
; 957  : 				{
; 958  : 					double mag_k = getMagnitude(fftData[i][0], fftData[i][1]);
; 959  : 					double phi_k = getPhase(fftData[i][0], fftData[i][1]);
; 960  : 
; 961  : 					// --- horizontal phase propagation
; 962  : 					//
; 963  : 					// --- omega_k = bin frequency(k)
; 964  : 					double omega_k = kTwoPi * i / PSM_FFT_LEN;
; 965  : 
; 966  : 					// --- phase deviation is actual - expected phase
; 967  : 					//     = phi_k -(phi(last frame) + wk*ha
; 968  : 					double phaseDev = phi_k - phi[i] - omega_k * ha;
; 969  : 
; 970  : 					// --- unwrapped phase increment
; 971  : 					double deltaPhi = omega_k * ha + principalArg(phaseDev);
; 972  : 
; 973  : 					// --- save for next frame
; 974  : 					phi[i] = phi_k;
; 975  : 
; 976  : 					// --- calculate new phase based on stretch factor; save phase for next time
; 977  : 					psi[i] = principalArg(psi[i] + deltaPhi * alphaStretchRatio);
; 978  : 
; 979  : 					// --- convert back
; 980  : 					fftData[i][0] = mag_k * cos(psi[i]);
; 981  : 					fftData[i][1] = mag_k * sin(psi[i]);
; 982  : 				}
; 983  : 			}
; 984  : 
; 985  : 
; 986  : 			// --- manually so the IFFT (OPTIONAL)
; 987  : 			vocoder.doInverseFFT();
; 988  : 
; 989  : 			// --- can get the iFFT buffers
; 990  : 			fftw_complex* inv_fftData = vocoder.getIFFTData();
; 991  : 
; 992  : 			// --- make copy (can speed this up)
; 993  : 			double ifft[PSM_FFT_LEN] = { 0.0 };
; 994  : 			for (uint32_t i = 0; i < PSM_FFT_LEN; i++)
; 995  : 				ifft[i] = inv_fftData[i][0];
; 996  : 
; 997  : 			// --- resample the audio as if it were stretched
; 998  : 			resample(&ifft[0], outputBuff, PSM_FFT_LEN, outputBufferLength, interpolation::kLinear, windowCorrection, windowBuff);
; 999  : 
; 1000 : 			// --- overlap-add the interpolated buffer to complete the operation
; 1001 : 			vocoder.doOverlapAdd(&outputBuff[0], outputBufferLength);
; 1002 : 		}
; 1003 : 
; 1004 : 		return output;
; 1005 : 	}
; 1006 : 
; 1007 : 	/** get parameters: note use of custom structure for passing param data */
; 1008 : 	/**
; 1009 : 	\return PSMVocoderParameters custom data structure
; 1010 : 	*/
; 1011 : 	PSMVocoderParameters getParameters()
; 1012 : 	{
; 1013 : 		return parameters;
; 1014 : 	}
; 1015 : 
; 1016 : 	/** set parameters: note use of custom structure for passing param data */
; 1017 : 	/**
; 1018 : 	\param PSMVocoderParameters custom data structure
; 1019 : 	*/
; 1020 : 	void setParameters(const PSMVocoderParameters& params)
; 1021 : 	{
; 1022 : 		if (params.pitchShiftSemitones != parameters.pitchShiftSemitones)
; 1023 : 		{
; 1024 : 			setPitchShift(params.pitchShiftSemitones);
; 1025 : 		}
; 1026 : 
; 1027 : 		// --- save
; 1028 : 		parameters = params;
; 1029 : 	}
; 1030 : 
; 1031 : protected:
; 1032 : 	PSMVocoderParameters parameters;	///< object parameters
; 1033 : 	PhaseVocoder vocoder;				///< vocoder to perform PSM
; 1034 : 	double alphaStretchRatio = 1.0;		///< alpha stretch ratio = hs/ha

	mov	QWORD PTR [rcx+160], rax

; 1035 : 
; 1036 : 	// --- FFT is 4096 with 75% overlap
; 1037 : 	const double hs = PSM_FFT_LEN / 4;	///< hs = N/4 --- 75% overlap

	mov	rax, 4652218415073722368		; 4090000000000000H
	mov	QWORD PTR [rcx+168], rax

; 1038 : 	double ha = PSM_FFT_LEN / 4;		///< ha = N/4 --- 75% overlap

	mov	QWORD PTR [rcx+176], rax

; 1039 : 	double phi[PSM_FFT_LEN] = { 0.0 };	///< array of phase values for classic algorithm

	mov	QWORD PTR [rcx+184], rbp
	add	rcx, 192				; 000000c0H
	mov	esi, 32760				; 00007ff8H
	mov	r8d, esi
	xor	edx, edx
	call	memset

; 1040 : 	double psi[PSM_FFT_LEN] = { 0.0 };	///< array of phase correction values for classic algorithm

	mov	QWORD PTR [rbx+32952], rbp
	lea	rcx, QWORD PTR [rbx+32960]
	mov	r8d, esi
	xor	edx, edx
	call	memset
	lea	rax, QWORD PTR [rbx+65720]

; 645  : 	PSMVocoder() {

	mov	ecx, 4096				; 00001000H
	mov	edx, ecx
$LL11@PSMVocoder:

; 493  : 	bool isPeak = false;	///< flag for peak bins

	mov	BYTE PTR [rax], bpl

; 494  : 	double magnitude = 0.0; ///< bin magnitude angle

	mov	QWORD PTR [rax+8], rbp

; 495  : 	double phi = 0.0;		///< bin phase angle

	mov	QWORD PTR [rax+16], rbp

; 496  : 	double psi = 0.0;		///< bin phase correction

	mov	QWORD PTR [rax+24], rbp

; 497  : 	unsigned int localPeakBin = 0; ///< index of peak-boss

	mov	DWORD PTR [rax+32], ebp

; 498  : 	int previousPeakBin = -1; ///< index of peak bin in previous FFT

	or	DWORD PTR [rax+36], -1

; 499  : 	double updatedPhase = 0.0; ///< phase update value

	mov	QWORD PTR [rax+40], rbp
	lea	rax, QWORD PTR [rax+48]
	sub	rdx, 1
	jne	SHORT $LL11@PSMVocoder

; 1040 : 	double psi[PSM_FFT_LEN] = { 0.0 };	///< array of phase correction values for classic algorithm

	lea	rax, QWORD PTR [rbx+262328]
$LL17@PSMVocoder:

; 493  : 	bool isPeak = false;	///< flag for peak bins

	mov	BYTE PTR [rax], bpl

; 494  : 	double magnitude = 0.0; ///< bin magnitude angle

	mov	QWORD PTR [rax+8], rbp

; 495  : 	double phi = 0.0;		///< bin phase angle

	mov	QWORD PTR [rax+16], rbp

; 496  : 	double psi = 0.0;		///< bin phase correction

	mov	QWORD PTR [rax+24], rbp

; 497  : 	unsigned int localPeakBin = 0; ///< index of peak-boss

	mov	DWORD PTR [rax+32], ebp

; 498  : 	int previousPeakBin = -1; ///< index of peak bin in previous FFT

	or	DWORD PTR [rax+36], -1

; 499  : 	double updatedPhase = 0.0; ///< phase update value

	mov	QWORD PTR [rax+40], rbp
	lea	rax, QWORD PTR [rax+48]
	sub	rcx, 1
	jne	SHORT $LL17@PSMVocoder

; 1041 : 
; 1042 : 	// --- for peak-locking
; 1043 : 	BinData binData[PSM_FFT_LEN];			///< array of BinData structures for current FFT frame
; 1044 : 	BinData binDataPrevious[PSM_FFT_LEN];	///< array of BinData structures for previous FFT frame
; 1045 : 
; 1046 : 	int peakBins[PSM_FFT_LEN] = { -1 };		///< array of current peak bin index values (-1 = not peak)

	or	DWORD PTR [rbx+458936], -1
	lea	rcx, QWORD PTR [rbx+458940]
	mov	esi, 16380				; 00003ffcH
	mov	r8d, esi
	xor	edx, edx
	call	memset

; 1047 : 	int peakBinsPrevious[PSM_FFT_LEN] = { -1 }; ///< array of previous peak bin index values (-1 = not peak)

	or	DWORD PTR [rbx+475320], -1
	lea	rcx, QWORD PTR [rbx+475324]
	mov	r8d, esi
	xor	edx, edx
	call	memset

; 1048 : 
; 1049 : 	double* windowBuff = nullptr;			///< buffer for window

	mov	QWORD PTR [rbx+491704], rbp

; 1050 : 	double* outputBuff = nullptr;			///< buffer for resampled output

	mov	QWORD PTR [rbx+491712], rbp

; 1051 : 	double windowCorrection = 0.0;			///< window correction value

	mov	QWORD PTR [rbx+491720], rbp

; 1052 : 	unsigned int outputBufferLength = 0;	///< lenght of resampled output array

	mov	DWORD PTR [rbx+491728], ebp

; 646  : 		vocoder.initialize(PSM_FFT_LEN, PSM_FFT_LEN / 4, windowType::kHannWindow);  // 75% overlap

	lea	rcx, QWORD PTR [rbx+24]
	call	?initialize@PhaseVocoder@@QEAAXIIW4windowType@@@Z ; PhaseVocoder::initialize
	npad	1

; 647  : 	}		/* C-TOR */

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+56]
	mov	rbp, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0PSMVocoder@@QEAA@XZ ENDP				; PSMVocoder::PSMVocoder
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???0PSMVocoder@@QEAA@XZ@4HA PROC		; `PSMVocoder::PSMVocoder'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 24
	jmp	??1PhaseVocoder@@QEAA@XZ		; PhaseVocoder::~PhaseVocoder
?dtor$0@?0???0PSMVocoder@@QEAA@XZ@4HA ENDP		; `PSMVocoder::PSMVocoder'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???0PSMVocoder@@QEAA@XZ@4HA PROC		; `PSMVocoder::PSMVocoder'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 24
	jmp	??1PhaseVocoder@@QEAA@XZ		; PhaseVocoder::~PhaseVocoder
?dtor$0@?0???0PSMVocoder@@QEAA@XZ@4HA ENDP		; `PSMVocoder::PSMVocoder'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\PSMVocoder.h
;	COMDAT ??1PSMVocoder@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1PSMVocoder@@QEAA@XZ PROC				; PSMVocoder::~PSMVocoder, COMDAT

; 648  : 	~PSMVocoder() {

$LN12:
	push	rbx
	sub	rsp, 32					; 00000020H
	lea	rax, OFFSET FLAT:??_7PSMVocoder@@6B@
	mov	rbx, rcx
	mov	QWORD PTR [rcx], rax

; 649  : 		if (windowBuff) delete[] windowBuff;

	mov	rcx, QWORD PTR [rcx+491704]
	test	rcx, rcx
	je	SHORT $LN2@PSMVocoder
	call	??_V@YAXPEAX@Z				; operator delete[]
$LN2@PSMVocoder:

; 650  : 		if (outputBuff) delete[] outputBuff;

	mov	rcx, QWORD PTR [rbx+491712]
	test	rcx, rcx
	je	SHORT $LN3@PSMVocoder
	call	??_V@YAXPEAX@Z				; operator delete[]
$LN3@PSMVocoder:

; 528  : 		if (inputBuffer) delete[] inputBuffer;

	mov	rcx, QWORD PTR [rbx+72]
	test	rcx, rcx
	je	SHORT $LN6@PSMVocoder
	call	??_V@YAXPEAX@Z				; operator delete[]
$LN6@PSMVocoder:

; 529  : 		if (outputBuffer) delete[] outputBuffer;

	mov	rcx, QWORD PTR [rbx+80]
	test	rcx, rcx
	je	SHORT $LN7@PSMVocoder
	call	??_V@YAXPEAX@Z				; operator delete[]
$LN7@PSMVocoder:

; 530  : 		if (windowBuffer) delete[] windowBuffer;

	mov	rcx, QWORD PTR [rbx+64]
	test	rcx, rcx
	je	SHORT $LN8@PSMVocoder
	call	??_V@YAXPEAX@Z				; operator delete[]
$LN8@PSMVocoder:

; 531  : 		destroyFFTW();

	lea	rcx, QWORD PTR [rbx+24]

; 651  : 
; 652  : 	}	/* D-TOR */

	add	rsp, 32					; 00000020H
	pop	rbx

; 531  : 		destroyFFTW();

	jmp	?destroyFFTW@PhaseVocoder@@QEAAXXZ	; PhaseVocoder::destroyFFTW
??1PSMVocoder@@QEAA@XZ ENDP				; PSMVocoder::~PSMVocoder
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\PSMVocoder.h
;	COMDAT ?reset@PSMVocoder@@UEAA_NN@Z
_TEXT	SEGMENT
this$ = 48
_sampleRate$ = 56
?reset@PSMVocoder@@UEAA_NN@Z PROC			; PSMVocoder::reset, COMDAT

; 656  : 	{

$LN16:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 657  : 		memset(&phi[0], 0, sizeof(double) * PSM_FFT_LEN);

	mov	edi, 32768				; 00008000H
	mov	r8d, edi
	add	rcx, 184				; 000000b8H
	xor	edx, edx
	call	QWORD PTR __imp_memset

; 658  : 		memset(&psi[0], 0, sizeof(double) * PSM_FFT_LEN);

	lea	rcx, QWORD PTR [rbx+32952]
	mov	r8d, edi
	xor	edx, edx
	call	QWORD PTR __imp_memset

; 659  : 		if (outputBuff)

	mov	rcx, QWORD PTR [rbx+491712]
	xor	edi, edi
	test	rcx, rcx
	je	SHORT $LN5@reset

; 660  : 			memset(outputBuff, 0, sizeof(double) * outputBufferLength);

	mov	r8d, DWORD PTR [rbx+491728]
	xor	edx, edx
	shl	r8, 3
	call	QWORD PTR __imp_memset
$LN5@reset:

; 661  : 
; 662  : 		for (uint32_t i = 0; i < PSM_FFT_LEN; i++)

	lea	rdx, QWORD PTR [rbx+475320]
	mov	r8d, 4096				; 00001000H
	lea	rcx, QWORD PTR [rbx+65736]
	or	r9d, -1
$LL4@reset:

; 483  : 		isPeak = false;

	mov	BYTE PTR [rcx-16], dil

; 484  : 		magnitude = 0.0;

	mov	QWORD PTR [rcx-8], rdi

; 485  : 		phi = 0.0;

	mov	QWORD PTR [rcx], rdi

; 486  : 
; 487  : 		psi = 0.0;

	mov	QWORD PTR [rcx+8], rdi

; 488  : 		localPeakBin = 0;

	mov	DWORD PTR [rcx+16], edi

; 489  : 		previousPeakBin = -1; // -1 is flag

	mov	DWORD PTR [rcx+20], r9d

; 490  : 		updatedPhase = 0.0;

	mov	QWORD PTR [rcx+24], rdi

; 483  : 		isPeak = false;

	mov	BYTE PTR [rcx+196592], dil

; 484  : 		magnitude = 0.0;

	mov	QWORD PTR [rcx+196600], rdi

; 485  : 		phi = 0.0;

	mov	QWORD PTR [rcx+196608], rdi

; 486  : 
; 487  : 		psi = 0.0;

	mov	QWORD PTR [rcx+196616], rdi

; 488  : 		localPeakBin = 0;

	mov	DWORD PTR [rcx+196624], edi

; 489  : 		previousPeakBin = -1; // -1 is flag

	mov	DWORD PTR [rcx+196628], r9d

; 490  : 		updatedPhase = 0.0;

	mov	QWORD PTR [rcx+196632], rdi

; 661  : 
; 662  : 		for (uint32_t i = 0; i < PSM_FFT_LEN; i++)

	lea	rcx, QWORD PTR [rcx+48]

; 663  : 		{
; 664  : 			binData[i].reset();
; 665  : 			binDataPrevious[i].reset();
; 666  : 
; 667  : 			peakBins[i] = -1;

	mov	DWORD PTR [rdx-16384], r9d

; 668  : 			peakBinsPrevious[i] = -1;

	mov	DWORD PTR [rdx], r9d
	lea	rdx, QWORD PTR [rdx+4]
	sub	r8, 1
	jne	SHORT $LL4@reset

; 669  : 		}
; 670  : 
; 671  : 		return true;
; 672  : 	}

	mov	rbx, QWORD PTR [rsp+48]
	mov	al, 1
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?reset@PSMVocoder@@UEAA_NN@Z ENDP			; PSMVocoder::reset
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\PSMVocoder.h
;	COMDAT ?canProcessAudioFrame@PSMVocoder@@UEAA_NXZ
_TEXT	SEGMENT
this$ = 8
?canProcessAudioFrame@PSMVocoder@@UEAA_NXZ PROC		; PSMVocoder::canProcessAudioFrame, COMDAT

; 675  : 	virtual bool canProcessAudioFrame() { return false; }

	xor	al, al
	ret	0
?canProcessAudioFrame@PSMVocoder@@UEAA_NXZ ENDP		; PSMVocoder::canProcessAudioFrame
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\PSMVocoder.h
;	COMDAT ?setPitchShift@PSMVocoder@@QEAAXN@Z
_TEXT	SEGMENT
this$ = 96
semitones$ = 104
?setPitchShift@PSMVocoder@@QEAAXN@Z PROC		; PSMVocoder::setPitchShift, COMDAT

; 679  : 	{

$LN14:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	push	rdi
	sub	rsp, 80					; 00000050H

; 680  : 		// --- this is costly so only update when things changed
; 681  : 		double newAlpha = pow(2.0, semitones / 12.0);

	mulsd	xmm1, QWORD PTR __real@3fb5555555555555
	mov	rbx, rcx
	movsd	xmm0, QWORD PTR __real@4000000000000000
	movaps	XMMWORD PTR [rax-24], xmm6
	movaps	XMMWORD PTR [rax-40], xmm7
	movaps	XMMWORD PTR [rax-56], xmm8
	call	QWORD PTR __imp_pow

; 682  : 		double newOutputBufferLength = round((1.0 / newAlpha) * (double)PSM_FFT_LEN);

	movsd	xmm7, QWORD PTR __real@3ff0000000000000
	movaps	xmm8, xmm0
	movaps	xmm6, xmm7
	divsd	xmm6, xmm0
	movaps	xmm0, xmm6
	mulsd	xmm0, QWORD PTR __real@40b0000000000000
	call	QWORD PTR __imp_round

; 683  : 
; 684  : 		// --- check for change
; 685  : 		if (newOutputBufferLength == outputBufferLength)

	mov	eax, DWORD PTR [rbx+491728]
	xorps	xmm1, xmm1
	cvtsi2sd xmm1, rax
	ucomisd	xmm0, xmm1
	je	$LN1@setPitchSh

; 686  : 			return;
; 687  : 
; 688  : 		// --- new stuff
; 689  : 		alphaStretchRatio = newAlpha;
; 690  : 		ha = hs / alphaStretchRatio;

	mulsd	xmm6, QWORD PTR [rbx+168]

; 691  : 
; 692  : 		// --- set output resample buffer
; 693  : 		outputBufferLength = newOutputBufferLength;
; 694  : 
; 695  : 		// --- create Hann window
; 696  : 		if (windowBuff) delete[] windowBuff;

	mov	rcx, QWORD PTR [rbx+491704]
	movsd	QWORD PTR [rbx+160], xmm8
	cvttsd2si rax, xmm0
	movsd	QWORD PTR [rbx+176], xmm6
	mov	DWORD PTR [rbx+491728], eax
	test	rcx, rcx
	je	SHORT $LN6@setPitchSh
	call	??_V@YAXPEAX@Z				; operator delete[]
	mov	eax, DWORD PTR [rbx+491728]
$LN6@setPitchSh:

; 697  : 		windowBuff = new double[outputBufferLength];

	mov	ecx, eax
	mov	rbp, -1
	mov	eax, 8
	mul	rcx
	cmovo	rax, rbp
	mov	rcx, rax
	call	??_U@YAPEAX_K@Z				; operator new[]

; 698  : 		windowCorrection = 0.0;

	and	QWORD PTR [rbx+491720], 0

; 699  : 		for (unsigned int i = 0; i < outputBufferLength; i++)

	xor	edi, edi
	mov	QWORD PTR [rbx+491704], rax
	xorps	xmm0, xmm0
	mov	eax, DWORD PTR [rbx+491728]
	test	eax, eax
	je	SHORT $LN3@setPitchSh
$LL4@setPitchSh:
	xorps	xmm0, xmm0

; 700  : 		{
; 701  : 			windowBuff[i] = 0.5 * (1.0 - cos((i * 2.0 * kPi) / (outputBufferLength)));

	mov	eax, edi
	xorps	xmm1, xmm1
	cvtsi2sd xmm0, rax
	mov	eax, DWORD PTR [rbx+491728]
	cvtsi2sd xmm1, rax
	mulsd	xmm0, QWORD PTR __real@401921fb54442d18
	divsd	xmm0, xmm1
	call	QWORD PTR __imp_cos
	mov	rax, QWORD PTR [rbx+491704]
	movaps	xmm1, xmm7
	subsd	xmm1, xmm0
	mulsd	xmm1, QWORD PTR __real@3fe0000000000000
	movsd	QWORD PTR [rax+rdi*8], xmm1

; 702  : 			windowCorrection += windowBuff[i];

	mov	rax, QWORD PTR [rbx+491704]
	movsd	xmm0, QWORD PTR [rax+rdi*8]
	inc	edi
	addsd	xmm0, QWORD PTR [rbx+491720]
	movsd	QWORD PTR [rbx+491720], xmm0
	mov	eax, DWORD PTR [rbx+491728]
	cmp	edi, eax
	jb	SHORT $LL4@setPitchSh
$LN3@setPitchSh:

; 703  : 		}
; 704  : 		windowCorrection = 1.0 / windowCorrection;
; 705  : 
; 706  : 		// --- create output buffer
; 707  : 		if (outputBuff) delete[] outputBuff;

	mov	rcx, QWORD PTR [rbx+491712]
	divsd	xmm7, xmm0
	movsd	QWORD PTR [rbx+491720], xmm7
	test	rcx, rcx
	je	SHORT $LN7@setPitchSh
	call	??_V@YAXPEAX@Z				; operator delete[]
	mov	eax, DWORD PTR [rbx+491728]
$LN7@setPitchSh:

; 708  : 		outputBuff = new double[outputBufferLength];

	mov	ecx, eax
	mov	eax, 8
	mul	rcx
	cmovo	rax, rbp
	mov	rcx, rax
	call	??_U@YAPEAX_K@Z				; operator new[]

; 709  : 		memset(outputBuff, 0, sizeof(double) * outputBufferLength);

	mov	r8d, DWORD PTR [rbx+491728]
	xor	edx, edx
	shl	r8, 3
	mov	rcx, rax
	mov	QWORD PTR [rbx+491712], rax
	call	QWORD PTR __imp_memset
$LN1@setPitchSh:

; 710  : 	}

	mov	rbx, QWORD PTR [rsp+96]
	mov	rbp, QWORD PTR [rsp+104]
	movaps	xmm6, XMMWORD PTR [rsp+64]
	movaps	xmm7, XMMWORD PTR [rsp+48]
	movaps	xmm8, XMMWORD PTR [rsp+32]
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
?setPitchShift@PSMVocoder@@QEAAXN@Z ENDP		; PSMVocoder::setPitchShift
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\PSMVocoder.h
;	COMDAT ?findPreviousNearestPeak@PSMVocoder@@QEAAHH@Z
_TEXT	SEGMENT
this$ = 48
peakIndex$ = 56
?findPreviousNearestPeak@PSMVocoder@@QEAAHH@Z PROC	; PSMVocoder::findPreviousNearestPeak, COMDAT

; 714  : 	{

$LN20:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 715  : 		if (peakBinsPrevious[0] == -1) // first run, there is no peak

	lea	rsi, QWORD PTR [rcx+475320]
	or	ebx, -1
	mov	r14d, edx
	cmp	DWORD PTR [rsi], ebx
	jne	SHORT $LN5@findPrevio

; 716  : 			return -1;

	mov	eax, ebx
	jmp	SHORT $LN1@findPrevio
$LN5@findPrevio:

; 717  : 
; 718  : 		int delta = -1;
; 719  : 		int previousPeak = -1;

	mov	ebp, ebx

; 720  : 		for (uint32_t i = 0; i < PSM_FFT_LEN; i++)

	xor	edi, edi
$LL4@findPrevio:

; 721  : 		{
; 722  : 			if (peakBinsPrevious[i] < 0)

	cmp	DWORD PTR [rsi], 0
	jl	SHORT $LN13@findPrevio

; 723  : 				break;
; 724  : 
; 725  : 			int dist = abs(peakIndex - peakBinsPrevious[i]);

	mov	ecx, r14d
	sub	ecx, DWORD PTR [rsi]
	call	QWORD PTR __imp_abs

; 726  : 			if (dist > PSM_FFT_LEN / 4)

	cmp	eax, 1024				; 00000400H
	ja	SHORT $LN13@findPrevio

; 727  : 				break;
; 728  : 
; 729  : 			if (i == 0)

	test	edi, edi
	jne	SHORT $LN8@findPrevio

; 730  : 			{
; 731  : 				previousPeak = i;

	xor	ebp, ebp

; 732  : 				delta = dist;
; 733  : 			}

	jmp	SHORT $LN18@findPrevio
$LN8@findPrevio:

; 734  : 			else if (dist < delta)

	cmp	eax, ebx
	jge	SHORT $LN2@findPrevio

; 735  : 			{
; 736  : 				previousPeak = i;

	mov	ebp, edi
$LN18@findPrevio:

; 720  : 		for (uint32_t i = 0; i < PSM_FFT_LEN; i++)

	mov	ebx, eax
$LN2@findPrevio:
	inc	edi
	add	rsi, 4
	cmp	edi, 4096				; 00001000H
	jb	SHORT $LL4@findPrevio
$LN13@findPrevio:

; 737  : 				delta = dist;
; 738  : 			}
; 739  : 		}
; 740  : 
; 741  : 		return previousPeak;

	mov	eax, ebp
$LN1@findPrevio:

; 742  : 	}

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
?findPreviousNearestPeak@PSMVocoder@@QEAAHH@Z ENDP	; PSMVocoder::findPreviousNearestPeak
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\PSMVocoder.h
;	COMDAT ?findPeaksAndRegionsOfInfluence@PSMVocoder@@QEAAXXZ
_TEXT	SEGMENT
localWindow$ = 32
this$ = 144
m$1$ = 152
tv1518 = 160
tv1517 = 168
?findPeaksAndRegionsOfInfluence@PSMVocoder@@QEAAXXZ PROC ; PSMVocoder::findPeaksAndRegionsOfInfluence, COMDAT

; 746  : 	{

$LN88:
	mov	QWORD PTR [rsp+8], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	mov	rbp, rsp
	sub	rsp, 80					; 00000050H

; 747  : 		// --- FIND PEAKS --- //
; 748  : 		//
; 749  : 		// --- find local maxima in 4-sample window
; 750  : 		double localWindow[4] = { 0.0, 0.0, 0.0, 0.0 };
; 751  : 		int m = 0;

	xor	ebx, ebx
	movaps	XMMWORD PTR [rsp+64], xmm6
	xorps	xmm6, xmm6
	lea	r8, QWORD PTR [rcx+65756]
	xorps	xmm0, xmm0
	movsd	QWORD PTR localWindow$[rbp-56], xmm6
	mov	rdi, rcx
	mov	QWORD PTR tv1518[rbp-80], r8
	movups	XMMWORD PTR localWindow$[rbp-72], xmm0
	mov	r9d, ebx
	lea	r10, QWORD PTR [rcx+458936]
	mov	esi, ebx
	or	r11d, -1
	mov	r14d, 4096				; 00001000H
$LL4@findPeaksA:

; 753  : 		{
; 754  : 			if (i == 0)

	test	esi, esi
	jne	SHORT $LN8@findPeaksA

; 755  : 			{
; 756  : 				localWindow[0] = 0.0;
; 757  : 				localWindow[1] = 0.0;
; 758  : 				localWindow[2] = binData[i + 1].magnitude;

	xorps	xmm0, xmm0
	lea	edx, QWORD PTR [rsi+1]
	movups	XMMWORD PTR localWindow$[rbp-80], xmm0
	mov	rcx, rbx
$LL49@findPeaksA:
	mov	eax, edx
	inc	edx
	lea	rax, QWORD PTR [rax+rax*2]
	add	rax, rax
	mov	rax, QWORD PTR [rdi+rax*8+65728]
	mov	QWORD PTR localWindow$[rbp+rcx*8-64], rax
	inc	rcx
	cmp	rcx, 2
	jl	SHORT $LL49@findPeaksA

; 759  : 				localWindow[3] = binData[i + 2].magnitude;
; 760  : 			}

	jmp	$LN85@findPeaksA
$LN8@findPeaksA:

; 761  : 			else  if (i == 1)

	lea	eax, DWORD PTR [rsi-1]
	mov	edx, eax
	cmp	esi, 1
	jne	SHORT $LN10@findPeaksA

; 762  : 			{
; 763  : 				localWindow[0] = 0.0;
; 764  : 				localWindow[1] = binData[i - 1].magnitude;

	lea	rax, QWORD PTR [rax+rax*2]
	movsd	QWORD PTR localWindow$[rbp-80], xmm6
	add	rax, rax
	lea	edx, QWORD PTR [rsi+1]
	mov	rcx, rbx
	movsd	xmm0, QWORD PTR [rdi+rax*8+65728]
	movsd	QWORD PTR localWindow$[rbp-72], xmm0
$LL51@findPeaksA:

; 765  : 				localWindow[2] = binData[i + 1].magnitude;

	mov	eax, edx
	inc	edx
	lea	rax, QWORD PTR [rax+rax*2]
	add	rax, rax
	mov	rax, QWORD PTR [rdi+rax*8+65728]
	mov	QWORD PTR localWindow$[rbp+rcx*8-64], rax
	inc	rcx
	cmp	rcx, 2
	jl	SHORT $LL51@findPeaksA

; 766  : 				localWindow[3] = binData[i + 2].magnitude;
; 767  : 			}

	jmp	SHORT $LN85@findPeaksA
$LN10@findPeaksA:

; 768  : 			else  if (i == PSM_FFT_LEN - 1)

	lea	eax, DWORD PTR [rsi-2]
	lea	rax, QWORD PTR [rax+rax*2]
	add	rax, rax
	movsd	xmm1, QWORD PTR [rdi+rax*8+65728]
	lea	rax, QWORD PTR [rdx+rdx*2]
	add	rax, rax
	movsd	xmm2, QWORD PTR [rdi+rax*8+65728]
	cmp	esi, 4095				; 00000fffH
	jne	SHORT $LN12@findPeaksA

; 769  : 			{
; 770  : 				localWindow[0] = binData[i - 2].magnitude;

	xorps	xmm0, xmm0
	movups	XMMWORD PTR localWindow$[rbp-64], xmm0

; 771  : 				localWindow[1] = binData[i - 1].magnitude;
; 772  : 				localWindow[2] = 0.0;
; 773  : 				localWindow[3] = 0.0;
; 774  : 			}

	jmp	SHORT $LN56@findPeaksA
$LN12@findPeaksA:

; 775  : 			else  if (i == PSM_FFT_LEN - 2)

	cmp	esi, 4094				; 00000ffeH
	jne	SHORT $LN14@findPeaksA

; 776  : 			{
; 777  : 				localWindow[0] = binData[i - 2].magnitude;
; 778  : 				localWindow[1] = binData[i - 1].magnitude;
; 779  : 				localWindow[2] = binData[i + 1].magnitude;

	movsd	xmm0, QWORD PTR [rdi+262288]
	movsd	QWORD PTR localWindow$[rbp-64], xmm0

; 780  : 				localWindow[3] = 0.0;

	movsd	QWORD PTR localWindow$[rbp-56], xmm6

; 781  : 			}

	jmp	SHORT $LN56@findPeaksA
$LN14@findPeaksA:

; 782  : 			else
; 783  : 			{
; 784  : 				localWindow[0] = binData[i - 2].magnitude;

	movsd	QWORD PTR localWindow$[rbp-80], xmm1
	lea	edx, DWORD PTR [rsi+1]

; 785  : 				localWindow[1] = binData[i - 1].magnitude;

	movsd	QWORD PTR localWindow$[rbp-72], xmm2
	mov	rcx, rbx
$LL55@findPeaksA:

; 786  : 				localWindow[2] = binData[i + 1].magnitude;

	lea	rax, QWORD PTR [rdx+rdx*2]
	inc	edx
	add	rax, rax
	mov	rax, QWORD PTR [rdi+rax*8+65728]
	mov	QWORD PTR localWindow$[rbp+rcx*8-64], rax
	inc	rcx
	cmp	rcx, 2
	jl	SHORT $LL55@findPeaksA
$LN85@findPeaksA:

; 787  : 				localWindow[3] = binData[i + 2].magnitude;
; 788  : 			}
; 789  : 
; 790  : 			// --- found peak bin!
; 791  : 			if (binData[i].magnitude > 0.00001 &&
; 792  : 				binData[i].magnitude > localWindow[0]
; 793  : 				&& binData[i].magnitude > localWindow[1]
; 794  : 				&& binData[i].magnitude > localWindow[2]
; 795  : 				&& binData[i].magnitude > localWindow[3])

	movsd	xmm2, QWORD PTR localWindow$[rbp-72]
	movsd	xmm1, QWORD PTR localWindow$[rbp-80]
$LN56@findPeaksA:
	movsd	xmm0, QWORD PTR [r8-28]
	comisd	xmm0, QWORD PTR __real@3ee4f8b588e368f1
	jbe	$LN2@findPeaksA
	comisd	xmm0, xmm1
	jbe	$LN2@findPeaksA
	comisd	xmm0, xmm2
	jbe	$LN2@findPeaksA
	comisd	xmm0, QWORD PTR localWindow$[rbp-64]
	jbe	$LN2@findPeaksA
	comisd	xmm0, QWORD PTR localWindow$[rbp-56]
	jbe	$LN2@findPeaksA

; 796  : 			{
; 797  : 				binData[i].isPeak = true;

	mov	BYTE PTR [r8-36], 1

; 798  : 				peakBins[m++] = i;

	inc	r9d
	mov	DWORD PTR [r10], esi
	add	r10, 4
	mov	DWORD PTR m$1$[rbp-80], r9d
	mov	QWORD PTR tv1517[rbp-80], r10

; 799  : 
; 800  : 				// --- for peak bins, assume that it is part of a previous, moving peak
; 801  : 				if (parameters.enablePeakTracking)

	cmp	BYTE PTR [rdi+17], bl
	je	SHORT $LN17@findPeaksA

; 715  : 		if (peakBinsPrevious[0] == -1) // first run, there is no peak

	lea	r12, QWORD PTR [rdi+475320]
	mov	r15d, r11d
	cmp	DWORD PTR [r12], r11d
	je	SHORT $LN28@findPeaksA

; 716  : 			return -1;
; 717  : 
; 718  : 		int delta = -1;

	mov	r13d, r11d

; 719  : 		int previousPeak = -1;
; 720  : 		for (uint32_t i = 0; i < PSM_FFT_LEN; i++)

	mov	r14d, ebx
$LL31@findPeaksA:

; 721  : 		{
; 722  : 			if (peakBinsPrevious[i] < 0)

	cmp	DWORD PTR [r12], ebx
	jl	SHORT $LN42@findPeaksA

; 723  : 				break;
; 724  : 
; 725  : 			int dist = abs(peakIndex - peakBinsPrevious[i]);

	mov	ecx, esi
	sub	ecx, DWORD PTR [r12]
	call	QWORD PTR __imp_abs

; 726  : 			if (dist > PSM_FFT_LEN / 4)

	cmp	eax, 1024				; 00000400H
	ja	SHORT $LN42@findPeaksA

; 727  : 				break;
; 728  : 
; 729  : 			if (i == 0)

	test	r14d, r14d
	jne	SHORT $LN35@findPeaksA

; 730  : 			{
; 731  : 				previousPeak = i;

	mov	r15d, ebx

; 732  : 				delta = dist;
; 733  : 			}

	jmp	SHORT $LN86@findPeaksA
$LN35@findPeaksA:

; 734  : 			else if (dist < delta)

	cmp	eax, r13d
	jge	SHORT $LN29@findPeaksA

; 735  : 			{
; 736  : 				previousPeak = i;

	mov	r15d, r14d
$LN86@findPeaksA:

; 719  : 		int previousPeak = -1;
; 720  : 		for (uint32_t i = 0; i < PSM_FFT_LEN; i++)

	mov	r13d, eax
$LN29@findPeaksA:
	inc	r14d
	add	r12, 4
	cmp	r14d, 4096				; 00001000H
	jb	SHORT $LL31@findPeaksA
$LN42@findPeaksA:
	mov	r8, QWORD PTR tv1518[rbp-80]

; 737  : 				delta = dist;
; 738  : 			}
; 739  : 		}
; 740  : 
; 741  : 		return previousPeak;

	or	r11d, -1
	mov	r9d, DWORD PTR m$1$[rbp-80]
	mov	r14d, 4096				; 00001000H
	mov	r10, QWORD PTR tv1517[rbp-80]
$LN28@findPeaksA:

; 802  : 					binData[i].previousPeakBin = findPreviousNearestPeak(i);

	mov	DWORD PTR [r8], r15d
	jmp	SHORT $LN2@findPeaksA
$LN17@findPeaksA:

; 803  : 				else
; 804  : 					binData[i].previousPeakBin = -1;

	mov	DWORD PTR [r8], r11d
$LN2@findPeaksA:

; 752  : 		for (uint32_t i = 0; i < PSM_FFT_LEN; i++)

	add	r8, 48					; 00000030H
	inc	esi
	mov	QWORD PTR tv1518[rbp-80], r8
	cmp	esi, r14d
	jb	$LL4@findPeaksA

; 805  : 			}
; 806  : 		}
; 807  : 
; 808  : 		// --- assign peak bosses
; 809  : 		if (m > 0)

	test	r9d, r9d
	jle	$LN6@findPeaksA

; 810  : 		{
; 811  : 			int n = 0;
; 812  : 			int bossPeakBin = peakBins[n];

	mov	eax, DWORD PTR [rdi+458936]

; 813  : 			double nextPeak = peakBins[++n];

	lea	rcx, QWORD PTR [rdi+458940]
	movd	xmm2, DWORD PTR [rcx]

; 814  : 			int midBoundary = (nextPeak - (double)bossPeakBin) / 2.0 + bossPeakBin;

	movsd	xmm3, QWORD PTR __real@3fe0000000000000
	cvtdq2pd xmm2, xmm2
	movd	xmm0, eax

; 815  : 
; 816  : 			if (nextPeak >= 0)

	comisd	xmm2, xmm6
	cvtdq2pd xmm0, xmm0
	movaps	xmm1, xmm2
	subsd	xmm1, xmm0
	mulsd	xmm1, xmm3
	addsd	xmm1, xmm0
	cvttsd2si r8d, xmm1
	jb	SHORT $LN6@findPeaksA

; 817  : 			{
; 818  : 				for (uint32_t i = 0; i < PSM_FFT_LEN; i++)

	lea	rdx, QWORD PTR [rdi+65752]
$LL7@findPeaksA:

; 819  : 				{
; 820  : 					if (i <= bossPeakBin)

	cmp	ebx, eax
	jbe	SHORT $LN5@findPeaksA

; 821  : 					{
; 822  : 						binData[i].localPeakBin = bossPeakBin;
; 823  : 					}
; 824  : 					else if (i < midBoundary)

	cmp	ebx, r8d
	jb	SHORT $LN5@findPeaksA

; 825  : 					{
; 826  : 						binData[i].localPeakBin = bossPeakBin;
; 827  : 					}
; 828  : 					else // > boundary, calc next set
; 829  : 					{
; 830  : 						bossPeakBin = nextPeak;

	cvttsd2si eax, xmm2

; 831  : 						nextPeak = peakBins[++n];

	add	rcx, 4
	movd	xmm2, DWORD PTR [rcx]
	cvtdq2pd xmm2, xmm2
	movd	xmm1, eax

; 832  : 						if (nextPeak > bossPeakBin)

	cvtdq2pd xmm1, xmm1
	comisd	xmm2, xmm1
	jbe	SHORT $LN25@findPeaksA

; 833  : 							midBoundary = (nextPeak - (double)bossPeakBin) / 2.0 + bossPeakBin;

	movaps	xmm0, xmm2
	subsd	xmm0, xmm1
	mulsd	xmm0, xmm3
	addsd	xmm0, xmm1
	cvttsd2si r8d, xmm0
	jmp	SHORT $LN5@findPeaksA
$LN25@findPeaksA:

; 834  : 						else // nextPeak == -1
; 835  : 							midBoundary = PSM_FFT_LEN;

	mov	r8d, r14d
$LN5@findPeaksA:

; 817  : 			{
; 818  : 				for (uint32_t i = 0; i < PSM_FFT_LEN; i++)

	mov	DWORD PTR [rdx], eax
	inc	ebx
	add	rdx, 48					; 00000030H
	cmp	ebx, r14d
	jb	SHORT $LL7@findPeaksA
$LN6@findPeaksA:

; 836  : 
; 837  : 						binData[i].localPeakBin = bossPeakBin;
; 838  : 					}
; 839  : 				}
; 840  : 			}
; 841  : 		}
; 842  : 	}

	mov	rbx, QWORD PTR [rsp+144]
	movaps	xmm6, XMMWORD PTR [rsp+64]
	add	rsp, 80					; 00000050H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
?findPeaksAndRegionsOfInfluence@PSMVocoder@@QEAAXXZ ENDP ; PSMVocoder::findPeaksAndRegionsOfInfluence
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\PSMVocoder.h
; File E:\FoxSuite\shimmer\include\src\PSMVocoder.cpp
; File E:\FoxSuite\shimmer\include\PSMVocoder.h
; File E:\FoxSuite\shimmer\include\src\PSMVocoder.cpp
; File E:\FoxSuite\shimmer\include\PSMVocoder.h
; File E:\FoxSuite\shimmer\include\src\PSMVocoder.cpp
; File E:\FoxSuite\shimmer\include\PSMVocoder.h
; File E:\FoxSuite\shimmer\include\src\PSMVocoder.cpp
; File E:\FoxSuite\shimmer\include\PSMVocoder.h
;	COMDAT ?processAudioSample@PSMVocoder@@UEAANN@Z
_TEXT	SEGMENT
ifft$11 = 32
this$ = 32976
input$ = 32984
?processAudioSample@PSMVocoder@@UEAANN@Z PROC		; PSMVocoder::processAudioSample, COMDAT

; 850  : 	{

$LN161:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	mov	eax, 32928				; 000080a0H
	call	__chkstk
	sub	rsp, rax
	movaps	XMMWORD PTR [rsp+32912], xmm6

; 851  : 		bool fftReady = false;
; 852  : 		double output = 0.0;
; 853  : 
; 854  : 		// --- normal processing
; 855  : 		output = vocoder.processAudioSample(input, fftReady);

	lea	rsi, QWORD PTR [rcx+24]
	movaps	XMMWORD PTR [rsp+32896], xmm7
; File E:\FoxSuite\shimmer\include\src\PSMVocoder.cpp

; 440  : 	if (needInverseFFT)

	xor	r12d, r12d
; File E:\FoxSuite\shimmer\include\PSMVocoder.h

; 850  : 	{

	movaps	xmm6, xmm1
	movaps	XMMWORD PTR [rsp+32880], xmm8
	mov	rbx, rcx
	movaps	XMMWORD PTR [rsp+32864], xmm9
	movaps	XMMWORD PTR [rsp+32848], xmm10
	movaps	XMMWORD PTR [rsp+32832], xmm11
	movaps	XMMWORD PTR [rsp+32816], xmm12
	movaps	XMMWORD PTR [rsp+32800], xmm13
; File E:\FoxSuite\shimmer\include\src\PSMVocoder.cpp

; 440  : 	if (needInverseFFT)

	cmp	BYTE PTR [rsi+96], r12b
	je	SHORT $LN29@processAud

; 479  : 	fftw_execute(plan_backward);

	mov	rcx, QWORD PTR [rsi+32]
	call	fftw_execute

; 482  : 	needInverseFFT = false;

	mov	BYTE PTR [rsi+96], r12b
$LN29@processAud:

; 442  : 	if (needOverlapAdd)

	cmp	BYTE PTR [rsi+97], r12b
	je	SHORT $LN30@processAud

; 443  : 		doOverlapAdd();

	xor	r8d, r8d
	xor	edx, edx
	mov	rcx, rsi
	call	?doOverlapAdd@PhaseVocoder@@QEAAXPEANH@Z ; PhaseVocoder::doOverlapAdd
$LN30@processAud:

; 444  : 
; 445  : 	fftReady = false;
; 446  : 
; 447  : 	// --- get the current output sample first
; 448  : 	double currentOutput = outputBuffer[outputReadIndex];

	mov	ecx, DWORD PTR [rsi+76]
	mov	rax, QWORD PTR [rsi+56]
	movsd	xmm13, QWORD PTR [rax+rcx*8]

; 449  : 
; 450  : 	// --- set the buffer to 0.0 in preparation for the next overlap/add process
; 451  : 	outputBuffer[outputReadIndex++] = 0.0;

	mov	QWORD PTR [rax+rcx*8], r12
	mov	ecx, DWORD PTR [rsi+76]

; 452  : 
; 453  : 	// --- wrap
; 454  : 	outputReadIndex &= wrapMaskOut;

	mov	eax, DWORD PTR [rsi+84]
	inc	ecx
	and	eax, ecx

; 455  : 
; 456  : 	// --- push into buffer
; 457  : 	inputBuffer[inputWriteIndex++] = (double)input;

	mov	ecx, DWORD PTR [rsi+64]
	mov	DWORD PTR [rsi+76], eax
	mov	rax, QWORD PTR [rsi+48]
	movsd	QWORD PTR [rax+rcx*8], xmm6
	mov	ecx, DWORD PTR [rsi+64]

; 458  : 
; 459  : 	// --- wrap
; 460  : 	inputWriteIndex &= wrapMask;

	mov	eax, DWORD PTR [rsi+80]
	inc	ecx
	and	eax, ecx

; 461  : 
; 462  : 	// --- check the FFT
; 463  : 	fftReady = advanceAndCheckFFT();

	mov	rcx, rsi
	mov	DWORD PTR [rsi+64], eax
	call	?advanceAndCheckFFT@PhaseVocoder@@QEAA_NXZ ; PhaseVocoder::advanceAndCheckFFT
; File E:\FoxSuite\shimmer\include\PSMVocoder.h

; 858  : 		if (fftReady)

	test	al, al
	je	$LN20@processAud

; 859  : 		{
; 860  : 			// --- get the FFT data
; 861  : 			fftw_complex* fftData = vocoder.getFFTData();
; 862  : 
; 863  : 			if (parameters.enablePeakPhaseLocking)

	mov	r15d, 4096				; 00001000H
	mov	r14, QWORD PTR [rbx+32]
	cmp	BYTE PTR [rbx+16], r12b
	je	$LN21@processAud

; 864  : 			{
; 865  : 				// --- get the magnitudes for searching
; 866  : 				for (uint32_t i = 0; i < PSM_FFT_LEN; i++)

	mov	rbp, r14
	lea	r12, QWORD PTR [rbx+458936]
	lea	rdi, QWORD PTR [rbx+65736]
	mov	r13d, r15d
$LL4@processAud:

; 489  : 		previousPeakBin = -1; // -1 is flag

	or	DWORD PTR [rdi+20], -1
	xor	eax, eax
	mov	BYTE PTR [rdi-16], al
	mov	QWORD PTR [rdi-8], rax
	mov	QWORD PTR [rdi], rax
	mov	QWORD PTR [rdi+8], rax
	mov	DWORD PTR [rdi+16], eax

; 490  : 		updatedPhase = 0.0;

	mov	QWORD PTR [rdi+24], rax

; 867  : 				{
; 868  : 					binData[i].reset();
; 869  : 					peakBins[i] = -1;

	or	DWORD PTR [r12], -1

; 870  : 
; 871  : 					// --- store mag and phase
; 872  : 					binData[i].magnitude = getMagnitude(fftData[i][0], fftData[i][1]);

	movsd	xmm0, QWORD PTR [rbp+8]
	movsd	xmm1, QWORD PTR [rbp]

; 22   : 	return sqrt((re * re) + (im * im));

	mulsd	xmm1, xmm1
	mulsd	xmm0, xmm0
	addsd	xmm0, xmm1
	call	QWORD PTR __imp_sqrt

; 870  : 
; 871  : 					// --- store mag and phase
; 872  : 					binData[i].magnitude = getMagnitude(fftData[i][0], fftData[i][1]);

	movsd	QWORD PTR [rdi-8], xmm0

; 37   : 	return atan2(im, re);

	movsd	xmm1, QWORD PTR [rbp]
	movsd	xmm0, QWORD PTR [rbp+8]
	call	QWORD PTR __imp_atan2

; 873  : 					binData[i].phi = getPhase(fftData[i][0], fftData[i][1]);

	movsd	QWORD PTR [rdi], xmm0
	add	r12, 4
	add	rdi, 48					; 00000030H
	add	rbp, 16
	sub	r13, 1
	jne	SHORT $LL4@processAud

; 874  : 				}
; 875  : 
; 876  : 				findPeaksAndRegionsOfInfluence();

	mov	rcx, rbx
	call	?findPeaksAndRegionsOfInfluence@PSMVocoder@@QEAAXXZ ; PSMVocoder::findPeaksAndRegionsOfInfluence
	movsd	xmm7, QWORD PTR __real@400921fb54442d18
	lea	r13, QWORD PTR [rbx+32952]
	movsd	xmm8, QWORD PTR __real@401921fb54442d18
	lea	rbp, QWORD PTR [rbx+65720]
	movsd	xmm9, QWORD PTR __real@c01921fb54442d18
	mov	rdi, r13
	xor	r12d, r12d
	xorps	xmm11, xmm11
$LL7@processAud:

; 877  : 
; 878  : 				// --- each bin data should now know its local boss-peak
; 879  : 				//
; 880  : 				// --- now propagate phases accordingly
; 881  : 				//
; 882  : 				//     FIRST: set PSI angles of bosses
; 883  : 				for (uint32_t i = 0; i < PSM_FFT_LEN; i++)
; 884  : 				{
; 885  : 					double mag_k = binData[i].magnitude;
; 886  : 					double phi_k = binData[i].phi;

	movsd	xmm10, QWORD PTR [rbp+16]
	xorps	xmm6, xmm6

; 887  : 
; 888  : 					// --- horizontal phase propagation
; 889  : 					//
; 890  : 					// --- omega_k = bin frequency(k)
; 891  : 					double omega_k = kTwoPi * i / PSM_FFT_LEN;
; 892  : 
; 893  : 					// --- phase deviation is actual - expected phase
; 894  : 					//     = phi_k -(phi(last frame) + wk*ha
; 895  : 					double phaseDev = phi_k - phi[i] - omega_k * ha;

	movaps	xmm1, xmm10
	mov	eax, r12d
	subsd	xmm1, QWORD PTR [rdi-32768]
	cvtsi2sd xmm6, rax
	mulsd	xmm6, QWORD PTR __real@3f5921fb54442d18
	movaps	xmm0, xmm6
	mulsd	xmm0, QWORD PTR [rbx+176]
	subsd	xmm1, xmm0

; 52   : 	if (phaseIn >= 0)

	comisd	xmm1, xmm11

; 887  : 
; 888  : 					// --- horizontal phase propagation
; 889  : 					//
; 890  : 					// --- omega_k = bin frequency(k)
; 891  : 					double omega_k = kTwoPi * i / PSM_FFT_LEN;
; 892  : 
; 893  : 					// --- phase deviation is actual - expected phase
; 894  : 					//     = phi_k -(phi(last frame) + wk*ha
; 895  : 					double phaseDev = phi_k - phi[i] - omega_k * ha;

	movaps	xmm0, xmm1
	addsd	xmm0, xmm7

; 52   : 	if (phaseIn >= 0)

	jb	SHORT $LN41@processAud

; 53   : 		return fmod(phaseIn + kPi, kTwoPi) - kPi;

	movaps	xmm1, xmm8
	call	QWORD PTR __imp_fmod
	subsd	xmm0, xmm7
	jmp	SHORT $LN42@processAud
$LN41@processAud:

; 54   : 	else
; 55   : 		return fmod(phaseIn + kPi, -kTwoPi) + kPi;

	movaps	xmm1, xmm9
	call	QWORD PTR __imp_fmod
	addsd	xmm0, xmm7
$LN42@processAud:

; 896  : 
; 897  : 					// --- unwrapped phase increment
; 898  : 					double deltaPhi = omega_k * ha + principalArg(phaseDev);

	mulsd	xmm6, QWORD PTR [rbx+176]

; 899  : 
; 900  : 					// --- save for next frame
; 901  : 					phi[i] = phi_k;

	movsd	QWORD PTR [rdi-32768], xmm10

; 902  : 
; 903  : 					// --- if peak, assume it could have hopped from a different bin
; 904  : 					if (binData[i].isPeak)

	cmp	BYTE PTR [rbp], 0
	addsd	xmm6, xmm0
	je	SHORT $LN25@processAud

; 905  : 					{
; 906  : 						// --- calculate new phase based on stretch factor; save phase for next time
; 907  : 						if (binData[i].previousPeakBin < 0)

	cmp	DWORD PTR [rbp+36], 0
	mulsd	xmm6, QWORD PTR [rbx+160]
	jge	SHORT $LN24@processAud

; 908  : 							psi[i] = principalArg(psi[i] + deltaPhi * alphaStretchRatio);

	addsd	xmm6, QWORD PTR [rdi]

; 53   : 		return fmod(phaseIn + kPi, kTwoPi) - kPi;

	jmp	SHORT $LN159@processAud
$LN24@processAud:

; 909  : 						else
; 910  : 							psi[i] = principalArg(psi[binDataPrevious[i].previousPeakBin] + deltaPhi * alphaStretchRatio);

	movsxd	rax, DWORD PTR [rbp+196644]
	addsd	xmm6, QWORD PTR [rbx+rax*8+32952]
$LN159@processAud:

; 911  : 					}
; 912  : 
; 913  : 					// --- save peak PSI (new angle)
; 914  : 					binData[i].psi = psi[i];

	comisd	xmm6, xmm11
	movaps	xmm0, xmm6
	addsd	xmm0, xmm7
	jb	SHORT $LN49@processAud
	movaps	xmm1, xmm8
	call	QWORD PTR __imp_fmod
	subsd	xmm0, xmm7
	jmp	SHORT $LN50@processAud
$LN49@processAud:
	movaps	xmm1, xmm9
	call	QWORD PTR __imp_fmod
	addsd	xmm0, xmm7
$LN50@processAud:
	movsd	QWORD PTR [rdi], xmm0
$LN25@processAud:
	movsd	xmm0, QWORD PTR [rdi]
	inc	r12d
	movsd	QWORD PTR [rbp+24], xmm0
	add	rdi, 8

; 915  : 
; 916  : 					// --- for IFFT
; 917  : 					binData[i].updatedPhase = binData[i].psi;

	movsd	QWORD PTR [rbp+40], xmm0
	add	rbp, 48					; 00000030H
	cmp	r12d, r15d
	jb	$LL7@processAud

; 918  : 				}
; 919  : 
; 920  : 				// --- now set non-peaks
; 921  : 				for (uint32_t i = 0; i < PSM_FFT_LEN; i++)

	lea	rdi, QWORD PTR [rbx+65752]
	mov	rbp, r15
$LL10@processAud:

; 922  : 				{
; 923  : 					if (!binData[i].isPeak)

	cmp	BYTE PTR [rdi-32], 0
	jne	SHORT $LN8@processAud

; 924  : 					{
; 925  : 						int myPeakBin = binData[i].localPeakBin;
; 926  : 
; 927  : 						double PSI_kp = binData[myPeakBin].psi;

	movsxd	rax, DWORD PTR [rdi]
	lea	rcx, QWORD PTR [rax+rax*2]
	add	rcx, rcx

; 928  : 						double phi_kp = binData[myPeakBin].phi;
; 929  : 
; 930  : 						// --- save for next frame
; 931  : 						// phi[i] = binData[myPeakBin].phi;
; 932  : 
; 933  : 						// --- calculate new phase, locked to boss peak
; 934  : 						psi[i] = principalArg(PSI_kp - phi_kp - binData[i].phi);

	movsd	xmm1, QWORD PTR [rbx+rcx*8+65744]
	subsd	xmm1, QWORD PTR [rbx+rcx*8+65736]
	subsd	xmm1, QWORD PTR [rdi-16]

; 52   : 	if (phaseIn >= 0)

	comisd	xmm1, xmm11

; 928  : 						double phi_kp = binData[myPeakBin].phi;
; 929  : 
; 930  : 						// --- save for next frame
; 931  : 						// phi[i] = binData[myPeakBin].phi;
; 932  : 
; 933  : 						// --- calculate new phase, locked to boss peak
; 934  : 						psi[i] = principalArg(PSI_kp - phi_kp - binData[i].phi);

	movaps	xmm0, xmm1
	addsd	xmm0, xmm7

; 52   : 	if (phaseIn >= 0)

	jb	SHORT $LN53@processAud

; 53   : 		return fmod(phaseIn + kPi, kTwoPi) - kPi;

	movaps	xmm1, xmm8
	call	QWORD PTR __imp_fmod
	subsd	xmm0, xmm7
	jmp	SHORT $LN54@processAud
$LN53@processAud:

; 54   : 	else
; 55   : 		return fmod(phaseIn + kPi, -kTwoPi) + kPi;

	movaps	xmm1, xmm9
	call	QWORD PTR __imp_fmod
	addsd	xmm0, xmm7
$LN54@processAud:

; 928  : 						double phi_kp = binData[myPeakBin].phi;
; 929  : 
; 930  : 						// --- save for next frame
; 931  : 						// phi[i] = binData[myPeakBin].phi;
; 932  : 
; 933  : 						// --- calculate new phase, locked to boss peak
; 934  : 						psi[i] = principalArg(PSI_kp - phi_kp - binData[i].phi);

	movsd	QWORD PTR [r13], xmm0

; 935  : 						binData[i].updatedPhase = psi[i];// principalArg(PSI_kp - phi_kp - binData[i].phi);

	movsd	QWORD PTR [rdi+8], xmm0
$LN8@processAud:

; 918  : 				}
; 919  : 
; 920  : 				// --- now set non-peaks
; 921  : 				for (uint32_t i = 0; i < PSM_FFT_LEN; i++)

	add	r13, 8
	add	rdi, 48					; 00000030H
	sub	rbp, 1
	jne	SHORT $LL10@processAud

; 936  : 					}
; 937  : 				}
; 938  : 
; 939  : 				for (uint32_t i = 0; i < PSM_FFT_LEN; i++)

	lea	rbp, QWORD PTR [rbx+475320]
	mov	r12, r15
	lea	rdi, QWORD PTR [rbx+262336]
$LL13@processAud:

; 940  : 				{
; 941  : 					double mag_k = binData[i].magnitude;
; 942  : 
; 943  : 					// --- convert back
; 944  : 					fftData[i][0] = mag_k * cos(binData[i].updatedPhase);

	movsd	xmm0, QWORD PTR [rdi-196576]
	movsd	xmm6, QWORD PTR [rdi-196608]
	call	QWORD PTR __imp_cos
	mulsd	xmm0, xmm6
	movsd	QWORD PTR [r14], xmm0

; 945  : 					fftData[i][1] = mag_k * sin(binData[i].updatedPhase);

	movsd	xmm0, QWORD PTR [rdi-196576]
	call	QWORD PTR __imp_sin
	mulsd	xmm0, xmm6

; 465  : 		if (this == &params)

	lea	rax, QWORD PTR [rdi-196616]
	lea	rcx, QWORD PTR [rdi-8]

; 945  : 					fftData[i][1] = mag_k * sin(binData[i].updatedPhase);

	movsd	QWORD PTR [r14+8], xmm0

; 465  : 		if (this == &params)

	cmp	rcx, rax
	je	SHORT $LN157@processAud

; 466  : 			return *this;
; 467  : 
; 468  : 		isPeak = params.isPeak;

	mov	al, BYTE PTR [rax]
	mov	BYTE PTR [rcx], al

; 469  : 		magnitude = params.magnitude;

	mov	rax, QWORD PTR [rdi-196608]
	mov	QWORD PTR [rdi], rax

; 470  : 		phi = params.phi;

	mov	rax, QWORD PTR [rdi-196600]
	mov	QWORD PTR [rdi+8], rax

; 471  : 
; 472  : 		psi = params.psi;

	mov	rax, QWORD PTR [rdi-196592]
	mov	QWORD PTR [rdi+16], rax

; 473  : 		localPeakBin = params.localPeakBin;

	mov	eax, DWORD PTR [rdi-196584]
	mov	DWORD PTR [rdi+24], eax

; 474  : 		previousPeakBin = params.previousPeakBin;

	mov	eax, DWORD PTR [rdi-196580]
	mov	DWORD PTR [rdi+28], eax

; 475  : 		updatedPhase = params.updatedPhase;

	mov	rax, QWORD PTR [rdi-196576]
	mov	QWORD PTR [rdi+32], rax
$LN157@processAud:

; 946  : 
; 947  : 					// --- save for next frame
; 948  : 					binDataPrevious[i] = binData[i];
; 949  : 					peakBinsPrevious[i] = peakBins[i];

	mov	eax, DWORD PTR [rbp-16384]
	add	r14, 16
	mov	DWORD PTR [rbp], eax
	add	rdi, 48					; 00000030H
	add	rbp, 4
	sub	r12, 1
	jne	$LL13@processAud

; 950  : 
; 951  : 				}
; 952  : 			}// end if peak locking

	jmp	$LN15@processAud
$LN21@processAud:

; 953  : 
; 954  : 			else // ---> old school
; 955  : 			{
; 956  : 				for (uint32_t i = 0; i < PSM_FFT_LEN; i++)

	movsd	xmm7, QWORD PTR __real@400921fb54442d18
	lea	rdi, QWORD PTR [rbx+32952]
	movsd	xmm8, QWORD PTR __real@401921fb54442d18
	mov	ebp, r12d
	movsd	xmm9, QWORD PTR __real@c01921fb54442d18
	xorps	xmm10, xmm10
$LL16@processAud:

; 957  : 				{
; 958  : 					double mag_k = getMagnitude(fftData[i][0], fftData[i][1]);

	movsd	xmm1, QWORD PTR [r14+8]
	movsd	xmm0, QWORD PTR [r14]

; 22   : 	return sqrt((re * re) + (im * im));

	mulsd	xmm0, xmm0
	mulsd	xmm1, xmm1
	addsd	xmm0, xmm1
	call	QWORD PTR __imp_sqrt

; 37   : 	return atan2(im, re);

	movsd	xmm1, QWORD PTR [r14]

; 22   : 	return sqrt((re * re) + (im * im));

	movaps	xmm11, xmm0

; 37   : 	return atan2(im, re);

	movsd	xmm0, QWORD PTR [r14+8]
	call	QWORD PTR __imp_atan2
	xorps	xmm6, xmm6

; 959  : 					double phi_k = getPhase(fftData[i][0], fftData[i][1]);
; 960  : 
; 961  : 					// --- horizontal phase propagation
; 962  : 					//
; 963  : 					// --- omega_k = bin frequency(k)
; 964  : 					double omega_k = kTwoPi * i / PSM_FFT_LEN;

	mov	eax, ebp

; 965  : 
; 966  : 					// --- phase deviation is actual - expected phase
; 967  : 					//     = phi_k -(phi(last frame) + wk*ha
; 968  : 					double phaseDev = phi_k - phi[i] - omega_k * ha;

	movaps	xmm1, xmm0

; 37   : 	return atan2(im, re);

	movaps	xmm12, xmm0

; 965  : 
; 966  : 					// --- phase deviation is actual - expected phase
; 967  : 					//     = phi_k -(phi(last frame) + wk*ha
; 968  : 					double phaseDev = phi_k - phi[i] - omega_k * ha;

	subsd	xmm1, QWORD PTR [rdi-32768]
	cvtsi2sd xmm6, rax
	mulsd	xmm6, QWORD PTR __real@3f5921fb54442d18
	movaps	xmm0, xmm6
	mulsd	xmm0, QWORD PTR [rbx+176]
	subsd	xmm1, xmm0

; 52   : 	if (phaseIn >= 0)

	comisd	xmm1, xmm10

; 965  : 
; 966  : 					// --- phase deviation is actual - expected phase
; 967  : 					//     = phi_k -(phi(last frame) + wk*ha
; 968  : 					double phaseDev = phi_k - phi[i] - omega_k * ha;

	movaps	xmm0, xmm1
	addsd	xmm0, xmm7

; 52   : 	if (phaseIn >= 0)

	jb	SHORT $LN64@processAud

; 53   : 		return fmod(phaseIn + kPi, kTwoPi) - kPi;

	movaps	xmm1, xmm8
	call	QWORD PTR __imp_fmod
	subsd	xmm0, xmm7
	jmp	SHORT $LN65@processAud
$LN64@processAud:

; 54   : 	else
; 55   : 		return fmod(phaseIn + kPi, -kTwoPi) + kPi;

	movaps	xmm1, xmm9
	call	QWORD PTR __imp_fmod
	addsd	xmm0, xmm7
$LN65@processAud:

; 969  : 
; 970  : 					// --- unwrapped phase increment
; 971  : 					double deltaPhi = omega_k * ha + principalArg(phaseDev);

	mulsd	xmm6, QWORD PTR [rbx+176]

; 972  : 
; 973  : 					// --- save for next frame
; 974  : 					phi[i] = phi_k;

	movsd	QWORD PTR [rdi-32768], xmm12
	addsd	xmm6, xmm0

; 975  : 
; 976  : 					// --- calculate new phase based on stretch factor; save phase for next time
; 977  : 					psi[i] = principalArg(psi[i] + deltaPhi * alphaStretchRatio);

	mulsd	xmm6, QWORD PTR [rbx+160]
	addsd	xmm6, QWORD PTR [rdi]

; 52   : 	if (phaseIn >= 0)

	comisd	xmm6, xmm10

; 975  : 
; 976  : 					// --- calculate new phase based on stretch factor; save phase for next time
; 977  : 					psi[i] = principalArg(psi[i] + deltaPhi * alphaStretchRatio);

	movaps	xmm0, xmm6
	addsd	xmm0, xmm7

; 52   : 	if (phaseIn >= 0)

	jb	SHORT $LN68@processAud

; 53   : 		return fmod(phaseIn + kPi, kTwoPi) - kPi;

	movaps	xmm1, xmm8
	call	QWORD PTR __imp_fmod
	subsd	xmm0, xmm7
	jmp	SHORT $LN69@processAud
$LN68@processAud:

; 54   : 	else
; 55   : 		return fmod(phaseIn + kPi, -kTwoPi) + kPi;

	movaps	xmm1, xmm9
	call	QWORD PTR __imp_fmod
	addsd	xmm0, xmm7
$LN69@processAud:

; 975  : 
; 976  : 					// --- calculate new phase based on stretch factor; save phase for next time
; 977  : 					psi[i] = principalArg(psi[i] + deltaPhi * alphaStretchRatio);

	movsd	QWORD PTR [rdi], xmm0

; 978  : 
; 979  : 					// --- convert back
; 980  : 					fftData[i][0] = mag_k * cos(psi[i]);

	call	QWORD PTR __imp_cos
	mulsd	xmm0, xmm11
	movsd	QWORD PTR [r14], xmm0

; 981  : 					fftData[i][1] = mag_k * sin(psi[i]);

	movsd	xmm0, QWORD PTR [rdi]
	call	QWORD PTR __imp_sin
	mulsd	xmm0, xmm11
	inc	ebp
	add	rdi, 8
	movsd	QWORD PTR [r14+8], xmm0
	add	r14, 16
	cmp	ebp, r15d
	jb	$LL16@processAud
$LN15@processAud:
; File E:\FoxSuite\shimmer\include\src\PSMVocoder.cpp

; 479  : 	fftw_execute(plan_backward);

	mov	rcx, QWORD PTR [rbx+56]
	call	fftw_execute
; File E:\FoxSuite\shimmer\include\PSMVocoder.h

; 993  : 			double ifft[PSM_FFT_LEN] = { 0.0 };

	xor	edx, edx
; File E:\FoxSuite\shimmer\include\src\PSMVocoder.cpp

; 482  : 	needInverseFFT = false;

	mov	BYTE PTR [rbx+120], r12b
; File E:\FoxSuite\shimmer\include\PSMVocoder.h

; 990  : 			fftw_complex* inv_fftData = vocoder.getIFFTData();

	mov	rdi, QWORD PTR [rbx+40]

; 993  : 			double ifft[PSM_FFT_LEN] = { 0.0 };

	lea	rcx, QWORD PTR ifft$11[rsp+8]
	mov	r8d, 32760				; 00007ff8H
	call	memset
	lea	rcx, QWORD PTR ifft$11[rsp]
$LL19@processAud:

; 994  : 			for (uint32_t i = 0; i < PSM_FFT_LEN; i++)
; 995  : 				ifft[i] = inv_fftData[i][0];

	mov	rax, QWORD PTR [rdi]
	lea	rdi, QWORD PTR [rdi+16]
	mov	QWORD PTR [rcx], rax
	lea	rcx, QWORD PTR [rcx+8]
	sub	r15, 1
	jne	SHORT $LL19@processAud

; 996  : 
; 997  : 			// --- resample the audio as if it were stretched
; 998  : 			resample(&ifft[0], outputBuff, PSM_FFT_LEN, outputBufferLength, interpolation::kLinear, windowCorrection, windowBuff);

	mov	edi, DWORD PTR [rbx+491728]
	mov	rbp, QWORD PTR [rbx+491704]
	movsd	xmm3, QWORD PTR [rbx+491720]
	mov	r9, QWORD PTR [rbx+491712]

; 134  : 	if (inLength <= 1 || outLength <= 1) return false;

	cmp	edi, 1
	jbe	$LN83@processAud

; 135  : 	if (!input || !output) return false;

	test	r9, r9
	je	$LN83@processAud

; 136  : 
; 137  : 	double x[4] = { 0.0, 0.0, 0.0, 0.0 };
; 138  : 	double y[4] = { 0.0, 0.0, 0.0, 0.0 };
; 139  : 
; 140  : 	// --- inc
; 141  : 	double inc = (double)(inLength - 1) / (double)(outLength - 1);

	movsd	xmm5, QWORD PTR __real@40affe0000000000
	xorps	xmm0, xmm0
	lea	ecx, DWORD PTR [rdi-1]

; 142  : 
; 143  : 	// --- first point
; 144  : 	if (outWindow)

	mov	rax, r9
	cvtsi2sd xmm0, rcx
	divsd	xmm5, xmm0
	movaps	xmm0, xmm3
	test	rbp, rbp
	je	SHORT $LN84@processAud

; 145  : 		output[0] = outWindow[0] * scalar * input[0];

	mulsd	xmm0, QWORD PTR [rbp]
$LN84@processAud:

; 475  : 		updatedPhase = params.updatedPhase;

	mulsd	xmm0, QWORD PTR ifft$11[rsp]
	mov	r10d, 8
	lea	r11d, QWORD PTR [r10-7]
	movsd	QWORD PTR [rax], xmm0
	movsd	xmm4, QWORD PTR __real@3ff0000000000000
$LL79@processAud:
	xorps	xmm1, xmm1

; 196  : 			double xInterp = i * inc;

	mov	eax, r11d
	xorps	xmm0, xmm0
	cvtsi2sd xmm1, rax
	mulsd	xmm1, xmm5
	cvttsd2si r8, xmm1

; 197  : 			uint32_t x1 = (uint32_t)xInterp; // floor?
; 198  : 			uint32_t x2 = x1 + 1;
; 199  : 			if (x2 >= outLength)
; 200  : 				x2 = x1;
; 201  : 			double y1 = input[x1];

	mov	ecx, r8d
	mov	eax, r8d
	lea	edx, DWORD PTR [r8+1]
	cmp	edx, edi
	cmovb	ecx, edx

; 202  : 			double y2 = input[x2];

	movsd	xmm2, QWORD PTR ifft$11[rsp+rcx*8]
	mov	ecx, r8d
	cvtsi2sd xmm0, rcx
	subsd	xmm1, xmm0

; 203  : 
; 204  : 			if (outWindow)

	test	rbp, rbp
	je	SHORT $LN96@processAud

; 77   : 	if (fractional_X >= 1.0) return y2;

	comisd	xmm1, xmm4
	jae	SHORT $LN123@processAud

; 78   : 
; 79   : 	// --- use weighted sum method of interpolating
; 80   : 	return fractional_X * y2 + (1.0 - fractional_X) * y1;

	movaps	xmm0, xmm4
	subsd	xmm0, xmm1
	mulsd	xmm1, xmm2
	mulsd	xmm0, QWORD PTR ifft$11[rsp+rax*8]
	movaps	xmm2, xmm0
	addsd	xmm2, xmm1
$LN123@processAud:

; 205  : 				output[i] = outWindow[i] * scalar * doLinearInterpolation(y1, y2, xInterp - x1);

	movaps	xmm0, xmm3
	mulsd	xmm0, QWORD PTR [r10+rbp]
	mulsd	xmm0, xmm2
	jmp	SHORT $LN77@processAud
$LN96@processAud:

; 77   : 	if (fractional_X >= 1.0) return y2;

	comisd	xmm1, xmm4
	jb	SHORT $LN127@processAud
	movaps	xmm0, xmm2
	jmp	SHORT $LN126@processAud
$LN127@processAud:

; 78   : 
; 79   : 	// --- use weighted sum method of interpolating
; 80   : 	return fractional_X * y2 + (1.0 - fractional_X) * y1;

	movaps	xmm0, xmm4
	subsd	xmm0, xmm1
	mulsd	xmm1, xmm2
	mulsd	xmm0, QWORD PTR ifft$11[rsp+rax*8]
	addsd	xmm0, xmm1
$LN126@processAud:

; 207  : 				output[i] = scalar * doLinearInterpolation(y1, y2, xInterp - x1);

	mulsd	xmm0, xmm3
$LN77@processAud:

; 146  : 	else
; 147  : 		output[0] = scalar * input[0];
; 148  : 
; 149  : 	if (interpType == interpolation::kLagrange4)
; 150  : 	{
; 151  : 		for (unsigned int i = 1; i < outLength; i++)
; 152  : 		{
; 153  : 			// --- find interpolation location
; 154  : 			double xInterp = i * inc;
; 155  : 			uint32_t x1 = (uint32_t)xInterp; // floor?
; 156  : 
; 157  : 			if (xInterp > 1.0 && x1 < inLength - 2)
; 158  : 			{
; 159  : 				x[0] = x1 - 1;
; 160  : 				y[0] = input[(int)x[0]];
; 161  : 
; 162  : 				x[1] = x1;
; 163  : 				y[1] = input[(int)x[1]];
; 164  : 
; 165  : 				x[2] = x1 + 1;
; 166  : 				y[2] = input[(int)x[2]];
; 167  : 
; 168  : 				x[3] = x1 + 2;
; 169  : 				y[3] = input[(int)x[3]];
; 170  : 
; 171  : 				if (outWindow)
; 172  : 					output[i] = outWindow[i] * scalar * doLagrangeInterpolation(x, y, 4, xInterp);
; 173  : 				else
; 174  : 					output[i] = scalar * doLagrangeInterpolation(x, y, 4, xInterp);
; 175  : 			}
; 176  : 			else // --- linear for outer 2 end pts
; 177  : 			{
; 178  : 				uint32_t x2 = x1 + 1;
; 179  : 				if (x2 >= outLength)
; 180  : 					x2 = x1;
; 181  : 				double y1 = input[x1];
; 182  : 				double y2 = input[x2];
; 183  : 
; 184  : 				if (outWindow)
; 185  : 					output[i] = outWindow[i] * scalar * doLinearInterpolation(y1, y2, xInterp - x1);
; 186  : 				else
; 187  : 					output[i] = scalar * doLinearInterpolation(y1, y2, xInterp - x1);
; 188  : 			}
; 189  : 		}
; 190  : 	}
; 191  : 	else // must be linear
; 192  : 	{
; 193  : 		// --- LINEAR INTERP
; 194  : 		for (uint32_t i = 1; i < outLength; i++)

	movsd	QWORD PTR [r9+r10], xmm0
	inc	r11d
	add	r10, 8
	cmp	r11d, edi
	jb	$LL79@processAud
$LN83@processAud:

; 999  : 
; 1000 : 			// --- overlap-add the interpolated buffer to complete the operation
; 1001 : 			vocoder.doOverlapAdd(&outputBuff[0], outputBufferLength);

	mov	r8d, DWORD PTR [rbx+491728]
	mov	rcx, rsi
	mov	rdx, QWORD PTR [rbx+491712]
	call	?doOverlapAdd@PhaseVocoder@@QEAAXPEANH@Z ; PhaseVocoder::doOverlapAdd
$LN20@processAud:

; 1002 : 		}
; 1003 : 
; 1004 : 		return output;
; 1005 : 	}

	lea	r11, QWORD PTR [rsp+32928]
	movaps	xmm0, xmm13
	mov	rbx, QWORD PTR [r11+48]
	mov	rbp, QWORD PTR [r11+56]
	mov	rsi, QWORD PTR [r11+64]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
?processAudioSample@PSMVocoder@@UEAANN@Z ENDP		; PSMVocoder::processAudioSample
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\PSMVocoder.h
;	COMDAT ?getParameters@PSMVocoder@@QEAA?AUPSMVocoderParameters@@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?getParameters@PSMVocoder@@QEAA?AUPSMVocoderParameters@@XZ PROC ; PSMVocoder::getParameters, COMDAT

; 1013 : 		return parameters;

	movups	xmm0, XMMWORD PTR [rcx+8]
	mov	rax, rdx
	movdqu	XMMWORD PTR [rdx], xmm0

; 1014 : 	}

	ret	0
?getParameters@PSMVocoder@@QEAA?AUPSMVocoderParameters@@XZ ENDP ; PSMVocoder::getParameters
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\include\PSMVocoder.h
;	COMDAT ?setParameters@PSMVocoder@@QEAAXAEBUPSMVocoderParameters@@@Z
_TEXT	SEGMENT
this$ = 48
params$ = 56
?setParameters@PSMVocoder@@QEAAXAEBUPSMVocoderParameters@@@Z PROC ; PSMVocoder::setParameters, COMDAT

; 1021 : 	{

$LN8:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1022 : 		if (params.pitchShiftSemitones != parameters.pitchShiftSemitones)

	movsd	xmm1, QWORD PTR [rdx]
	lea	rdi, QWORD PTR [rcx+8]
	ucomisd	xmm1, QWORD PTR [rdi]
	mov	rbx, rdx
	je	SHORT $LN2@setParamet

; 1023 : 		{
; 1024 : 			setPitchShift(params.pitchShiftSemitones);

	call	?setPitchShift@PSMVocoder@@QEAAXN@Z	; PSMVocoder::setPitchShift
$LN2@setParamet:

; 430  : 		if (this == &params)

	cmp	rdi, rbx
	je	SHORT $LN4@setParamet

; 431  : 			return *this;
; 432  : 
; 433  : 		pitchShiftSemitones = params.pitchShiftSemitones;

	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR [rdi], rax

; 434  : 		enablePeakPhaseLocking = params.enablePeakPhaseLocking;

	mov	al, BYTE PTR [rbx+8]
	mov	BYTE PTR [rdi+8], al

; 435  : 		enablePeakTracking = params.enablePeakTracking;

	mov	al, BYTE PTR [rbx+9]
	mov	BYTE PTR [rdi+9], al
$LN4@setParamet:

; 1025 : 		}
; 1026 : 
; 1027 : 		// --- save
; 1028 : 		parameters = params;
; 1029 : 	}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?setParameters@PSMVocoder@@QEAAXAEBUPSMVocoderParameters@@@Z ENDP ; PSMVocoder::setParameters
_TEXT	ENDS
; Function compile flags: /Ogspy
;	COMDAT ??0IAudioSignalProcessor@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0IAudioSignalProcessor@@QEAA@XZ PROC			; IAudioSignalProcessor::IAudioSignalProcessor, COMDAT
	lea	rax, OFFSET FLAT:??_7IAudioSignalProcessor@@6B@
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx
	ret	0
??0IAudioSignalProcessor@@QEAA@XZ ENDP			; IAudioSignalProcessor::IAudioSignalProcessor
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\Shimmer.cpp
;	COMDAT ??__EMIN_DAMPING_FREQUENCY_LOG@@YAXXZ
text$di	SEGMENT
??__EMIN_DAMPING_FREQUENCY_LOG@@YAXXZ PROC		; `dynamic initializer for 'MIN_DAMPING_FREQUENCY_LOG'', COMDAT

; 42   : const float MIN_DAMPING_FREQUENCY_LOG = log(MIN_DAMPING_FREQUENCY);

	sub	rsp, 40					; 00000028H
	movsd	xmm0, QWORD PTR __real@4069000000000000
	call	QWORD PTR __imp_log
	xorps	xmm1, xmm1
	cvtsd2ss xmm1, xmm0
	movss	DWORD PTR ?MIN_DAMPING_FREQUENCY_LOG@@3MB, xmm1
	add	rsp, 40					; 00000028H
	ret	0
??__EMIN_DAMPING_FREQUENCY_LOG@@YAXXZ ENDP		; `dynamic initializer for 'MIN_DAMPING_FREQUENCY_LOG''
text$di	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\Shimmer.cpp
;	COMDAT ??__EMAX_DAMPING_FREQUENCY_LOG@@YAXXZ
text$di	SEGMENT
??__EMAX_DAMPING_FREQUENCY_LOG@@YAXXZ PROC		; `dynamic initializer for 'MAX_DAMPING_FREQUENCY_LOG'', COMDAT

; 43   : const float MAX_DAMPING_FREQUENCY_LOG = log(MAX_DAMPING_FREQUENCY);

	sub	rsp, 40					; 00000028H
	movsd	xmm0, QWORD PTR __real@40d3880000000000
	call	QWORD PTR __imp_log
	xorps	xmm1, xmm1
	cvtsd2ss xmm1, xmm0
	movss	DWORD PTR ?MAX_DAMPING_FREQUENCY_LOG@@3MB, xmm1
	add	rsp, 40					; 00000028H
	ret	0
??__EMAX_DAMPING_FREQUENCY_LOG@@YAXXZ ENDP		; `dynamic initializer for 'MAX_DAMPING_FREQUENCY_LOG''
text$di	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\Shimmer.cpp
;	COMDAT ??__ELPF_FILTER_MAX_FREQ_LOG@@YAXXZ
text$di	SEGMENT
??__ELPF_FILTER_MAX_FREQ_LOG@@YAXXZ PROC		; `dynamic initializer for 'LPF_FILTER_MAX_FREQ_LOG'', COMDAT

; 44   : const float LPF_FILTER_MAX_FREQ_LOG = log(LPF_FILTER_MAX_FREQ);

	sub	rsp, 40					; 00000028H
	movsd	xmm0, QWORD PTR __real@40d3880000000000
	call	QWORD PTR __imp_log
	xorps	xmm1, xmm1
	cvtsd2ss xmm1, xmm0
	movss	DWORD PTR ?LPF_FILTER_MAX_FREQ_LOG@@3MB, xmm1
	add	rsp, 40					; 00000028H
	ret	0
??__ELPF_FILTER_MAX_FREQ_LOG@@YAXXZ ENDP		; `dynamic initializer for 'LPF_FILTER_MAX_FREQ_LOG''
text$di	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\Shimmer.cpp
;	COMDAT ??__ELPF_FILTER_MIN_FREQ_LOG@@YAXXZ
text$di	SEGMENT
??__ELPF_FILTER_MIN_FREQ_LOG@@YAXXZ PROC		; `dynamic initializer for 'LPF_FILTER_MIN_FREQ_LOG'', COMDAT

; 45   : const float LPF_FILTER_MIN_FREQ_LOG = log(LPF_FILTER_MIN_FREQ);

	sub	rsp, 40					; 00000028H
	movsd	xmm0, QWORD PTR __real@4059000000000000
	call	QWORD PTR __imp_log
	xorps	xmm1, xmm1
	cvtsd2ss xmm1, xmm0
	movss	DWORD PTR ?LPF_FILTER_MIN_FREQ_LOG@@3MB, xmm1
	add	rsp, 40					; 00000028H
	ret	0
??__ELPF_FILTER_MIN_FREQ_LOG@@YAXXZ ENDP		; `dynamic initializer for 'LPF_FILTER_MIN_FREQ_LOG''
text$di	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\Shimmer.cpp
;	COMDAT ?updateMix@Shimmer@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?updateMix@Shimmer@@AEAAXXZ PROC			; Shimmer::updateMix, COMDAT

; 60   : void Shimmer::updateMix() {

$LN4:
	push	rbx
	sub	rsp, 32					; 00000020H
	movss	xmm0, DWORD PTR [rcx+248]
	mov	rbx, rcx

; 61   :     _wet = sin(shim_mix * M_PI * 0.5);

	cvtps2pd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3ff921fb54442d18
	call	QWORD PTR __imp_sin
	xorps	xmm1, xmm1
	cvtsd2ss xmm1, xmm0
	movss	xmm0, DWORD PTR [rbx+248]

; 62   :     _dry = cos(shim_mix * M_PI * 0.5);

	cvtps2pd xmm0, xmm0
	movss	DWORD PTR [rbx+328], xmm1
	mulsd	xmm0, QWORD PTR __real@3ff921fb54442d18
	call	QWORD PTR __imp_cos
	xorps	xmm1, xmm1
	cvtsd2ss xmm1, xmm0
	movss	DWORD PTR [rbx+332], xmm1

; 63   : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?updateMix@Shimmer@@AEAAXXZ ENDP			; Shimmer::updateMix
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\Shimmer.cpp
;	COMDAT ?updateMixPitchShifters@Shimmer@@AEAAXM@Z
_TEXT	SEGMENT
this$ = 8
pitch2$ = 16
?updateMixPitchShifters@Shimmer@@AEAAXM@Z PROC		; Shimmer::updateMixPitchShifters, COMDAT

; 67   :     _mixP1 = 1.0;
; 68   :     _mixP2 = 0.0;

	and	DWORD PTR [rcx+340], 0

; 69   :     if (pitch2 != 0.0) {

	ucomiss	xmm1, DWORD PTR __real@00000000
	mov	DWORD PTR [rcx+336], 1065353216		; 3f800000H
	je	SHORT $LN2@updateMixP

; 70   :         _mixP1 = 0.5;

	mov	eax, 1056964608				; 3f000000H
	mov	DWORD PTR [rcx+336], eax

; 71   :         _mixP2 = 0.5;

	mov	DWORD PTR [rcx+340], eax
$LN2@updateMixP:

; 72   :     }
; 73   : }

	ret	0
?updateMixPitchShifters@Shimmer@@AEAAXM@Z ENDP		; Shimmer::updateMixPitchShifters
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\Shimmer.cpp
; File E:\FoxSuite\shimmer\vst-2.4-sdk\vstsdk2.4\public.sdk\source\vst2.x\audioeffect.cpp
; File E:\FoxSuite\shimmer\Shimmer.cpp
;	COMDAT ??0Shimmer@@QEAA@P6A_JPEAUAEffect@@HH_JPEAXM@Z@Z
_TEXT	SEGMENT
this$ = 48
audioMaster$ = 56
??0Shimmer@@QEAA@P6A_JPEAUAEffect@@HH_JPEAXM@Z@Z PROC	; Shimmer::Shimmer, COMDAT

; 79   : {

$LN14:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx
; File E:\FoxSuite\shimmer\vst-2.4-sdk\vstsdk2.4\public.sdk\source\vst2.x\audioeffect.cpp

; 107  : {

	lea	rax, OFFSET FLAT:??_7AudioEffect@@6B@
	mov	QWORD PTR [rcx], rax

; 100  : : audioMaster (audioMaster)

	mov	QWORD PTR [rcx+8], rdx

; 101  : , editor (0)

	and	QWORD PTR [rcx+16], 0

; 102  : , sampleRate (44100.f)

	mov	DWORD PTR [rcx+24], 1194083328		; 472c4400H

; 103  : , blockSize (1024)

	mov	DWORD PTR [rcx+28], 1024		; 00000400H

; 104  : , numPrograms (numPrograms)

	mov	DWORD PTR [rcx+32], 5

; 105  : , numParams (numParams)

	mov	DWORD PTR [rcx+36], 11

; 106  : , curProgram (0)

	and	DWORD PTR [rcx+40], 0

; 108  : 	memset (&cEffect, 0, sizeof (cEffect));

	xor	edx, edx
	mov	r8d, 192				; 000000c0H
	add	rcx, 48					; 00000030H
	call	QWORD PTR __imp_memset

; 109  : 
; 110  : 	cEffect.magic = kEffectMagic;

	mov	DWORD PTR [rdi+48], 1450406992		; 56737450H

; 111  : 	cEffect.dispatcher = dispatchEffectClass;

	lea	rax, OFFSET FLAT:?dispatchEffectClass@AudioEffect@@KA_JPEAUAEffect@@HH_JPEAXM@Z ; AudioEffect::dispatchEffectClass
	mov	QWORD PTR [rdi+56], rax

; 112  : 	cEffect.DECLARE_VST_DEPRECATED (process) = DECLARE_VST_DEPRECATED (processClass);

	lea	rax, OFFSET FLAT:?__processClassDeprecated@AudioEffect@@KAXPEAUAEffect@@PEAPEAM1H@Z ; AudioEffect::__processClassDeprecated
	mov	QWORD PTR [rdi+64], rax

; 113  : 	cEffect.setParameter = setParameterClass;

	lea	rax, OFFSET FLAT:?setParameterClass@AudioEffect@@KAXPEAUAEffect@@HM@Z ; AudioEffect::setParameterClass
	mov	QWORD PTR [rdi+72], rax

; 114  : 	cEffect.getParameter = getParameterClass;

	lea	rax, OFFSET FLAT:?getParameterClass@AudioEffect@@KAMPEAUAEffect@@H@Z ; AudioEffect::getParameterClass
	mov	QWORD PTR [rdi+80], rax

; 115  : 	cEffect.numPrograms  = numPrograms;

	mov	DWORD PTR [rdi+88], 5

; 116  : 	cEffect.numParams    = numParams;

	mov	DWORD PTR [rdi+92], 11

; 117  : 	cEffect.numInputs  = 1;		// mono input
; 118  : 	cEffect.numOutputs = 2;		// stereo output
; 119  : 	cEffect.DECLARE_VST_DEPRECATED (ioRatio) = 1.f;

	mov	DWORD PTR [rdi+140], 1065353216		; 3f800000H

; 120  : 	cEffect.object = this;

	mov	QWORD PTR [rdi+144], rdi

; 121  : 	cEffect.uniqueID = CCONST ('N', 'o', 'E', 'f');
; 122  : 	cEffect.version  = 1;

	mov	DWORD PTR [rdi+164], 1

; 123  : 	cEffect.processReplacing = processClassReplacing;

	lea	rax, OFFSET FLAT:?processClassReplacing@AudioEffect@@KAXPEAUAEffect@@PEAPEAM1H@Z ; AudioEffect::processClassReplacing
	mov	QWORD PTR [rdi+168], rax

; 309  : 		cEffect.flags |= effFlagsCanReplacing;

	or	DWORD PTR [rdi+104], 16

; 127  : 	cEffect.processDoubleReplacing = processClassDoubleReplacing;

	lea	rax, OFFSET FLAT:?processClassDoubleReplacing@AudioEffect@@KAXPEAUAEffect@@PEAPEAN1H@Z ; AudioEffect::processClassDoubleReplacing
	mov	QWORD PTR [rdi+176], rax
; File E:\FoxSuite\shimmer\Shimmer.cpp

; 79   : {

	lea	rax, OFFSET FLAT:??_7Shimmer@@6B@
	mov	QWORD PTR [rdi], rax

; 80   :     setNumInputs(2);		// stereo in

	mov	eax, 2
	mov	DWORD PTR [rdi+96], eax

; 81   :     setNumOutputs(2);		// stereo out

	mov	DWORD PTR [rdi+100], eax

; 82   :     setUniqueID('Fox');	    // identify    

	mov	DWORD PTR [rdi+160], 4616056		; 00466f78H

; 83   :     InitPlugin();

	mov	rcx, rdi
	call	?InitPlugin@Shimmer@@AEAAXXZ		; Shimmer::InitPlugin
	npad	1

; 84   : }

	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0Shimmer@@QEAA@P6A_JPEAUAEffect@@HH_JPEAXM@Z@Z ENDP	; Shimmer::Shimmer
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
audioMaster$ = 56
?dtor$0@?0???0Shimmer@@QEAA@P6A_JPEAUAEffect@@HH_JPEAXM@Z@Z@4HA PROC ; `Shimmer::Shimmer'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1AudioEffectX@@UEAA@XZ
?dtor$0@?0???0Shimmer@@QEAA@P6A_JPEAUAEffect@@HH_JPEAXM@Z@Z@4HA ENDP ; `Shimmer::Shimmer'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
audioMaster$ = 56
?dtor$0@?0???0Shimmer@@QEAA@P6A_JPEAUAEffect@@HH_JPEAXM@Z@Z@4HA PROC ; `Shimmer::Shimmer'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1AudioEffectX@@UEAA@XZ
?dtor$0@?0???0Shimmer@@QEAA@P6A_JPEAUAEffect@@HH_JPEAXM@Z@Z@4HA ENDP ; `Shimmer::Shimmer'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT ??_GShimmer@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_GShimmer@@UEAAPEAXI@Z PROC				; Shimmer::`scalar deleting destructor', COMDAT
$LN6:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	ebx, edx
	mov	rdi, rcx
	call	??1Shimmer@@UEAA@XZ			; Shimmer::~Shimmer
	test	bl, 1
	je	SHORT $LN2@scalar
	mov	edx, 344				; 00000158H
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN2@scalar:
	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??_GShimmer@@UEAAPEAXI@Z ENDP				; Shimmer::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\Shimmer.cpp
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\Shimmer.cpp
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\include\src\LPCombFilter.cpp
; File E:\FoxSuite\shimmer\include\LowPassFilter.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\LowPassFilter.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\HighPassFilter.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\Shimmer.cpp
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\Shimmer.cpp
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\include\src\LPCombFilter.cpp
; File E:\FoxSuite\shimmer\include\LowPassFilter.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\LowPassFilter.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\HighPassFilter.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\Shimmer.cpp
; File E:\FoxSuite\shimmer\include\PSMVocoder.h
; File E:\FoxSuite\shimmer\Shimmer.cpp
; File E:\FoxSuite\shimmer\include\PSMVocoder.h
; File E:\FoxSuite\shimmer\Shimmer.cpp
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\LowPassFilter.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\HighPassFilter.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\Modulation.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\Modulation.h
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File E:\FoxSuite\shimmer\include\LFO.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\Shimmer.cpp
;	COMDAT ?InitPlugin@Shimmer@@AEAAXXZ
_TEXT	SEGMENT
params2$ = 48
params1$ = 64
$T13 = 144
$T11 = 144
$T6 = 144
$T1 = 144
this$ = 144
?InitPlugin@Shimmer@@AEAAXXZ PROC			; Shimmer::InitPlugin, COMDAT

; 97   : {

$LN206:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	push	rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 96					; 00000060H
	movaps	XMMWORD PTR [rsp+80], xmm6
	mov	rdi, rcx

; 98   :     // get current sample rate
; 99   :     int sampleRate = getSampleRate();

	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+248]
	cvttss2si r14d, xmm0

; 100  : 
; 101  :     /*.......................................*/
; 102  :     // Create FDN Branch Reverb
; 103  :     BranchReverb = new FDN(1, DEFAULT_NUMBER_OF_INTERNAL_CHANNELS_FDN, 2, NUMBER_OF_DIFFUSION_STEPS, 1);

	mov	ecx, 320				; 00000140H
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	r12d, 1
	mov	edx, r12d
	mov	rcx, rax
	call	??0FDN@@QEAA@HHHHH@Z			; FDN::FDN
	npad	1
	mov	QWORD PTR [rdi+296], rax

; 104  : 
; 105  :     // Initialize objects (allocate delay lines)
; 106  :     BranchReverb->initialize(DIFFUSER_DELAY_BUFFER_SIZE_MS, FEEDBACK_DELAY_BUFFER_SIZE_MS, sampleRate);

	mov	r9d, r14d
	mov	rcx, rax
	call	?initialize@FDN@@QEAAXMMHM@Z		; FDN::initialize

; 107  :     
; 108  :     // output mixing mode
; 109  :     BranchReverb->setMixMode(MixMode::First);

	mov	rax, QWORD PTR [rdi+296]
; File E:\FoxSuite\shimmer\include\FDN.h

; 421  : 		fdn_Mixer->setMixMode(mode); 

	mov	rcx, QWORD PTR [rax+8]
	mov	DWORD PTR [rcx+8], r12d
; File E:\FoxSuite\shimmer\Shimmer.cpp

; 112  :     BranchReverb->setDampingType(DAMPING_LPF_TYPE);

	mov	rbx, QWORD PTR [rdi+296]
; File E:\FoxSuite\shimmer\include\FDN.h

; 263  : 		fdn_Feedback->setFilterType(type);

	mov	rbp, QWORD PTR [rbx+72]
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 93   : 		for (int i = 0; i < mcf_numberOfChannels; i++)

	xor	r15d, r15d
	mov	esi, r15d
	cmp	DWORD PTR [rbp], r15d
	jle	SHORT $LN21@InitPlugin
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1563 :         auto& _My_data = _Mypair._Myval2;

	mov	ebx, r15d
$LL22@InitPlugin:

; 1569 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rbp+40]
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 94   : 			mcf_DelayLines[i]->setFilterType(type);

	mov	rax, QWORD PTR [rbx+rax]
; File E:\FoxSuite\shimmer\include\src\LPCombFilter.cpp

; 32   : 	lpcf_feedbackLPF->setFilterType(type);

	mov	rcx, QWORD PTR [rax+88]
; File E:\FoxSuite\shimmer\include\LowPassFilter.h

; 76   : 		lpf_type = type;

	mov	DWORD PTR [rcx], 6

; 77   : 
; 78   : 		// update lpf gains
; 79   : 		updateGains();

	call	?updateGains@LowPassFilter@@QEAAXXZ	; LowPassFilter::updateGains
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 93   : 		for (int i = 0; i < mcf_numberOfChannels; i++)

	add	esi, r12d
	lea	rbx, QWORD PTR [rbx+8]
	cmp	esi, DWORD PTR [rbp]
	jl	SHORT $LL22@InitPlugin
	mov	rbx, QWORD PTR [rdi+296]
$LN21@InitPlugin:
; File E:\FoxSuite\shimmer\include\FDN.h

; 280  : 		for (int i = 0; i < fdn_outputChannels; i++)

	mov	ebp, r15d
	cmp	DWORD PTR [rbx+176], r15d
	jle	SHORT $LN32@InitPlugin
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1563 :         auto& _My_data = _Mypair._Myval2;

	mov	rsi, r15
$LL33@InitPlugin:

; 1569 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rbx+80]
; File E:\FoxSuite\shimmer\include\FDN.h

; 281  : 			fdn_LPFOutput[i]->setFilterType(type);

	mov	rcx, QWORD PTR [rsi+rax]
; File E:\FoxSuite\shimmer\include\LowPassFilter.h

; 76   : 		lpf_type = type;

	mov	DWORD PTR [rcx], 2

; 77   : 
; 78   : 		// update lpf gains
; 79   : 		updateGains();

	call	?updateGains@LowPassFilter@@QEAAXXZ	; LowPassFilter::updateGains
; File E:\FoxSuite\shimmer\include\FDN.h

; 280  : 		for (int i = 0; i < fdn_outputChannels; i++)

	add	ebp, r12d
	lea	rsi, QWORD PTR [rsi+8]
	cmp	ebp, DWORD PTR [rbx+176]
	jl	SHORT $LL33@InitPlugin
	mov	rbx, QWORD PTR [rdi+296]
$LN32@InitPlugin:

; 286  : 		for (int i = 0; i < fdn_outputChannels; i++)

	mov	ebp, r15d
	cmp	DWORD PTR [rbx+176], r15d
	jle	SHORT $LN41@InitPlugin
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1563 :         auto& _My_data = _Mypair._Myval2;

	mov	rsi, r15
$LL42@InitPlugin:

; 1569 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rbx+144]
; File E:\FoxSuite\shimmer\include\FDN.h

; 287  : 			fdn_HPFOutput[i]->setFilterType(type);

	mov	rcx, QWORD PTR [rsi+rax]
; File E:\FoxSuite\shimmer\include\HighPassFilter.h

; 76   : 		hpf_type = type;

	mov	DWORD PTR [rcx], 2

; 77   : 
; 78   : 		// update hpf gains
; 79   : 		updateGains();

	call	?updateGains@HighPassFilter@@QEAAXXZ	; HighPassFilter::updateGains
; File E:\FoxSuite\shimmer\include\FDN.h

; 286  : 		for (int i = 0; i < fdn_outputChannels; i++)

	add	ebp, r12d
	lea	rsi, QWORD PTR [rsi+8]
	cmp	ebp, DWORD PTR [rbx+176]
	jl	SHORT $LL42@InitPlugin
$LN41@InitPlugin:
; File E:\FoxSuite\shimmer\Shimmer.cpp

; 118  :     MasterReverb = new FDN(2, DEFAULT_NUMBER_OF_INTERNAL_CHANNELS_FDN, 2, NUMBER_OF_DIFFUSION_STEPS, 1);

	mov	ecx, 320				; 00000140H
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T6[rsp], rax
	mov	edx, 2
	mov	rcx, rax
	call	??0FDN@@QEAA@HHHHH@Z			; FDN::FDN
	npad	1
	mov	QWORD PTR [rdi+304], rax

; 119  : 
; 120  :     // Initialize objects (allocate delay lines)
; 121  :     MasterReverb->initialize(DIFFUSER_DELAY_BUFFER_SIZE_MS, FEEDBACK_DELAY_BUFFER_SIZE_MS, sampleRate);

	mov	r9d, r14d
	mov	rcx, rax
	call	?initialize@FDN@@QEAAXMMHM@Z		; FDN::initialize

; 122  : 
; 123  :     // output mixing mode
; 124  :     MasterReverb->setMixMode(MixMode::First);

	mov	rax, QWORD PTR [rdi+304]
; File E:\FoxSuite\shimmer\include\FDN.h

; 421  : 		fdn_Mixer->setMixMode(mode); 

	mov	rcx, QWORD PTR [rax+8]
	mov	DWORD PTR [rcx+8], r12d
; File E:\FoxSuite\shimmer\Shimmer.cpp

; 127  :     MasterReverb->setDampingType(DAMPING_LPF_TYPE);

	mov	rbx, QWORD PTR [rdi+304]
; File E:\FoxSuite\shimmer\include\FDN.h

; 263  : 		fdn_Feedback->setFilterType(type);

	mov	rbp, QWORD PTR [rbx+72]
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 93   : 		for (int i = 0; i < mcf_numberOfChannels; i++)

	mov	esi, r15d
	cmp	DWORD PTR [rbp], r15d
	jle	SHORT $LN54@InitPlugin
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1563 :         auto& _My_data = _Mypair._Myval2;

	mov	rbx, r15
$LL55@InitPlugin:

; 1569 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rbp+40]
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 94   : 			mcf_DelayLines[i]->setFilterType(type);

	mov	rax, QWORD PTR [rbx+rax]
; File E:\FoxSuite\shimmer\include\src\LPCombFilter.cpp

; 32   : 	lpcf_feedbackLPF->setFilterType(type);

	mov	rcx, QWORD PTR [rax+88]
; File E:\FoxSuite\shimmer\include\LowPassFilter.h

; 76   : 		lpf_type = type;

	mov	DWORD PTR [rcx], 6

; 77   : 
; 78   : 		// update lpf gains
; 79   : 		updateGains();

	call	?updateGains@LowPassFilter@@QEAAXXZ	; LowPassFilter::updateGains
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 93   : 		for (int i = 0; i < mcf_numberOfChannels; i++)

	add	esi, r12d
	lea	rbx, QWORD PTR [rbx+8]
	cmp	esi, DWORD PTR [rbp]
	jl	SHORT $LL55@InitPlugin
	mov	rbx, QWORD PTR [rdi+304]
$LN54@InitPlugin:
; File E:\FoxSuite\shimmer\include\FDN.h

; 280  : 		for (int i = 0; i < fdn_outputChannels; i++)

	mov	ebp, r15d
	cmp	DWORD PTR [rbx+176], r15d
	jle	SHORT $LN65@InitPlugin
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1563 :         auto& _My_data = _Mypair._Myval2;

	mov	rsi, r15
$LL66@InitPlugin:

; 1569 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rbx+80]
; File E:\FoxSuite\shimmer\include\FDN.h

; 281  : 			fdn_LPFOutput[i]->setFilterType(type);

	mov	rcx, QWORD PTR [rsi+rax]
; File E:\FoxSuite\shimmer\include\LowPassFilter.h

; 76   : 		lpf_type = type;

	mov	DWORD PTR [rcx], 2

; 77   : 
; 78   : 		// update lpf gains
; 79   : 		updateGains();

	call	?updateGains@LowPassFilter@@QEAAXXZ	; LowPassFilter::updateGains
; File E:\FoxSuite\shimmer\include\FDN.h

; 280  : 		for (int i = 0; i < fdn_outputChannels; i++)

	add	ebp, r12d
	lea	rsi, QWORD PTR [rsi+8]
	cmp	ebp, DWORD PTR [rbx+176]
	jl	SHORT $LL66@InitPlugin
	mov	rbx, QWORD PTR [rdi+304]
$LN65@InitPlugin:

; 286  : 		for (int i = 0; i < fdn_outputChannels; i++)

	mov	ebp, r15d
	cmp	DWORD PTR [rbx+176], r15d
	jle	SHORT $LN74@InitPlugin
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1563 :         auto& _My_data = _Mypair._Myval2;

	mov	rsi, r15
$LL75@InitPlugin:

; 1569 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rbx+144]
; File E:\FoxSuite\shimmer\include\FDN.h

; 287  : 			fdn_HPFOutput[i]->setFilterType(type);

	mov	rcx, QWORD PTR [rsi+rax]
; File E:\FoxSuite\shimmer\include\HighPassFilter.h

; 76   : 		hpf_type = type;

	mov	DWORD PTR [rcx], 2

; 77   : 
; 78   : 		// update hpf gains
; 79   : 		updateGains();

	call	?updateGains@HighPassFilter@@QEAAXXZ	; HighPassFilter::updateGains
; File E:\FoxSuite\shimmer\include\FDN.h

; 286  : 		for (int i = 0; i < fdn_outputChannels; i++)

	add	ebp, r12d
	lea	rsi, QWORD PTR [rsi+8]
	cmp	ebp, DWORD PTR [rbx+176]
	jl	SHORT $LL75@InitPlugin
$LN74@InitPlugin:
; File E:\FoxSuite\shimmer\Shimmer.cpp

; 133  :     PitchShift_1oct = new PSMVocoder();

	mov	ebx, 491736				; 000780d8H
	mov	ecx, ebx
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T11[rsp], rax
	mov	rcx, rax
	call	??0PSMVocoder@@QEAA@XZ			; PSMVocoder::PSMVocoder
	npad	1
	mov	QWORD PTR [rdi+312], rax

; 134  :     PitchShift_2oct = new PSMVocoder();

	mov	ecx, ebx
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T13[rsp], rax
	mov	rcx, rax
	call	??0PSMVocoder@@QEAA@XZ			; PSMVocoder::PSMVocoder
	npad	1
	mov	QWORD PTR [rdi+320], rax

; 135  : 
; 136  :     // set sample rate
; 137  :     PitchShift_1oct->reset((double)sampleRate);

	mov	rcx, QWORD PTR [rdi+312]
	movd	xmm6, r14d
	cvtdq2pd xmm6, xmm6
	mov	rax, QWORD PTR [rcx]
	movaps	xmm1, xmm6
	call	QWORD PTR [rax]

; 138  :     PitchShift_2oct->reset((double)sampleRate);

	mov	rcx, QWORD PTR [rdi+320]
	mov	rax, QWORD PTR [rcx]
	movaps	xmm1, xmm6
	call	QWORD PTR [rax]
; File E:\FoxSuite\shimmer\include\PSMVocoder.h

; 1013 : 		return parameters;

	mov	rcx, QWORD PTR [rdi+312]
	movups	xmm6, XMMWORD PTR [rcx+8]
	mov	rax, QWORD PTR [rdi+320]
	movups	xmm0, XMMWORD PTR [rax+8]
	movdqu	XMMWORD PTR params2$[rsp], xmm0

; 1022 : 		if (params.pitchShiftSemitones != parameters.pitchShiftSemitones)

	lea	rbx, QWORD PTR [rcx+8]
	ucomisd	xmm6, QWORD PTR [rbx]
	je	SHORT $LN86@InitPlugin

; 1023 : 		{
; 1024 : 			setPitchShift(params.pitchShiftSemitones);

	movaps	xmm1, xmm6
	call	?setPitchShift@PSMVocoder@@QEAAXN@Z	; PSMVocoder::setPitchShift
$LN86@InitPlugin:

; 430  : 		if (this == &params)

	lea	rax, QWORD PTR params1$[rsp]
	cmp	rbx, rax
	je	SHORT $LN88@InitPlugin

; 431  : 			return *this;
; 432  : 
; 433  : 		pitchShiftSemitones = params.pitchShiftSemitones;

	movsd	QWORD PTR [rbx], xmm6

; 434  : 		enablePeakPhaseLocking = params.enablePeakPhaseLocking;

	mov	WORD PTR [rbx+8], 257			; 00000101H
$LN88@InitPlugin:
; File E:\FoxSuite\shimmer\Shimmer.cpp

; 150  :     PitchShift_2oct->setParameters(params2);

	mov	rcx, QWORD PTR [rdi+320]
; File E:\FoxSuite\shimmer\include\PSMVocoder.h

; 1022 : 		if (params.pitchShiftSemitones != parameters.pitchShiftSemitones)

	lea	rbx, QWORD PTR [rcx+8]
	movsd	xmm6, QWORD PTR params2$[rsp]
	ucomisd	xmm6, QWORD PTR [rbx]
	je	SHORT $LN92@InitPlugin

; 1023 : 		{
; 1024 : 			setPitchShift(params.pitchShiftSemitones);

	movaps	xmm1, xmm6
	call	?setPitchShift@PSMVocoder@@QEAAXN@Z	; PSMVocoder::setPitchShift
$LN92@InitPlugin:

; 430  : 		if (this == &params)

	lea	rax, QWORD PTR params2$[rsp]
	cmp	rbx, rax
	je	SHORT $LN94@InitPlugin

; 431  : 			return *this;
; 432  : 
; 433  : 		pitchShiftSemitones = params.pitchShiftSemitones;

	movsd	QWORD PTR [rbx], xmm6

; 434  : 		enablePeakPhaseLocking = params.enablePeakPhaseLocking;

	mov	WORD PTR [rbx+8], 257			; 00000101H
$LN94@InitPlugin:
; File E:\FoxSuite\shimmer\Shimmer.cpp

; 154  :     InitPresets();  

	mov	rcx, rdi
	call	?InitPresets@Shimmer@@AEAAXXZ		; Shimmer::InitPresets

; 155  :     
; 156  :     /*.......................................*/
; 157  :     // set fixed parameters for BranchReverb
; 158  :     BranchReverb->setLowPassFrequency(LPF_FILTER_MAX_FREQ);

	mov	rbx, QWORD PTR [rdi+296]
; File E:\FoxSuite\shimmer\include\FDN.h

; 268  : 		for (int i = 0; i < fdn_outputChannels; i++)

	mov	ebp, r15d
	cmp	DWORD PTR [rbx+176], r15d
	jle	SHORT $LN99@InitPlugin
	mov	rsi, r15
$LL100@InitPlugin:

; 269  : 			fdn_LPFOutput[i]->setCutoffFrequency(freq);

	mov	rax, QWORD PTR [rbx+80]
	mov	rcx, QWORD PTR [rsi+rax]
; File E:\FoxSuite\shimmer\include\LowPassFilter.h

; 68   : 		lpf_cutoffFreq = cutoffFreq;

	mov	DWORD PTR [rcx+4], 1184645120		; 469c4000H

; 69   : 
; 70   : 		// update lpf gains
; 71   : 		updateGains();

	call	?updateGains@LowPassFilter@@QEAAXXZ	; LowPassFilter::updateGains
; File E:\FoxSuite\shimmer\include\FDN.h

; 268  : 		for (int i = 0; i < fdn_outputChannels; i++)

	add	ebp, r12d
	lea	rsi, QWORD PTR [rsi+8]
	cmp	ebp, DWORD PTR [rbx+176]
	jl	SHORT $LL100@InitPlugin
	mov	rbx, QWORD PTR [rdi+296]
$LN99@InitPlugin:

; 274  : 		for (int i = 0; i < fdn_outputChannels; i++)

	mov	ebp, r15d
	cmp	DWORD PTR [rbx+176], r15d
	jle	SHORT $LN108@InitPlugin
	mov	rsi, r15
$LL109@InitPlugin:

; 275  : 			fdn_HPFOutput[i]->setCutoffFrequency(freq);

	mov	rax, QWORD PTR [rbx+144]
	mov	rcx, QWORD PTR [rsi+rax]
; File E:\FoxSuite\shimmer\include\HighPassFilter.h

; 68   : 		hpf_cutoffFreq = cutoffFreq;

	mov	DWORD PTR [rcx+4], 1109393408		; 42200000H

; 69   : 
; 70   : 		// update hpf gains
; 71   : 		updateGains();

	call	?updateGains@HighPassFilter@@QEAAXXZ	; HighPassFilter::updateGains
; File E:\FoxSuite\shimmer\include\FDN.h

; 274  : 		for (int i = 0; i < fdn_outputChannels; i++)

	add	ebp, r12d
	lea	rsi, QWORD PTR [rsi+8]
	cmp	ebp, DWORD PTR [rbx+176]
	jl	SHORT $LL109@InitPlugin
	mov	rbx, QWORD PTR [rdi+296]
$LN108@InitPlugin:

; 235  : 		for (int i = 0; i < fdn_internalChannels; i++)

	mov	r8d, r15d
	cmp	DWORD PTR [rbx+172], r15d
	jle	SHORT $LN117@InitPlugin
	mov	rdx, r15
$LL118@InitPlugin:

; 236  : 			fdn_Modulation[i]->setModDepth(depth);	

	mov	rax, QWORD PTR [rbx+104]
	mov	rcx, QWORD PTR [rdx+rax]
; File E:\FoxSuite\shimmer\include\Modulation.h

; 62   : 		mod_depth = depth;

	mov	DWORD PTR [rcx+168], r15d

; 63   : 		ModDelay::setDeltaDelayValue(mod_modValue * mod_depth);

	mov	DWORD PTR [rcx+124], r15d
; File E:\FoxSuite\shimmer\include\FDN.h

; 235  : 		for (int i = 0; i < fdn_internalChannels; i++)

	add	r8d, r12d
	lea	rdx, QWORD PTR [rdx+8]
	cmp	r8d, DWORD PTR [rbx+172]
	jl	SHORT $LL118@InitPlugin
	mov	rbx, QWORD PTR [rdi+296]
$LN117@InitPlugin:

; 229  : 		for (int i = 0; i < fdn_internalChannels; i++)

	mov	edx, r15d
	cmp	DWORD PTR [rbx+172], r15d
	jle	SHORT $LN126@InitPlugin
	mov	rcx, r15
$LL127@InitPlugin:

; 230  : 			fdn_Modulation[i]->setModRate(rate);

	mov	rax, QWORD PTR [rbx+104]
	mov	rax, QWORD PTR [rcx+rax]
; File E:\FoxSuite\shimmer\include\Modulation.h

; 67   : 		mod_rate = rate;

	mov	DWORD PTR [rax+164], r15d
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 89   : 		mdly_rate = modRate;

	mov	DWORD PTR [rax+136], r15d

; 90   : 		mdly_LFO->setLFOfrequency(mdly_rate);

	mov	rax, QWORD PTR [rax+104]
; File E:\FoxSuite\shimmer\include\LFO.h

; 71   : 		lfo_frequency = frequency;

	mov	DWORD PTR [rax], r15d

; 122  : 		lfo_inc = WAVETABLE_SIZE * lfo_frequency / (float)lfo_sampleRate;

	mov	DWORD PTR [rax+20], r15d
; File E:\FoxSuite\shimmer\include\FDN.h

; 229  : 		for (int i = 0; i < fdn_internalChannels; i++)

	add	edx, r12d
	lea	rcx, QWORD PTR [rcx+8]
	cmp	edx, DWORD PTR [rbx+172]
	jl	SHORT $LL127@InitPlugin
	mov	rbx, QWORD PTR [rdi+296]
$LN126@InitPlugin:

; 292  : 		fdn_stereoSpread = spread;

	mov	DWORD PTR [rbx+308], 1056964608		; 3f000000H

; 293  : 		for (int i = 0; i < fdn_numModDiffuser; i++)

	mov	r8d, r15d
	cmp	DWORD PTR [rbx+184], r15d
	jle	SHORT $LN141@InitPlugin
	mov	r9, r15
$LL142@InitPlugin:
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h

; 60   : 		mdiff_MultiChDelay->setModDepth(depth);

	mov	rax, QWORD PTR [rbx+48]
	mov	rcx, QWORD PTR [rax+r9]
	mov	rdx, QWORD PTR [rcx+24]
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 88   : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	mov	r11d, r15d
	cmp	DWORD PTR [rdx], r15d
	jle	SHORT $LN140@InitPlugin
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

	mov	r10, r15
$LL151@InitPlugin:
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 89   : 			mdel_DelayLines[i]->setDeltaDelayValue(depth*mdel_modValmsec);

	movss	xmm0, DWORD PTR [rdx+48]
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	rax, QWORD PTR [rdx+8]
	mov	rcx, QWORD PTR [r10+rax]
	movss	DWORD PTR [rcx+124], xmm0

; 88   : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	add	r11d, r12d
	lea	r10, QWORD PTR [r10+8]
	cmp	r11d, DWORD PTR [rdx]
	jl	SHORT $LL151@InitPlugin
$LN140@InitPlugin:
; File E:\FoxSuite\shimmer\include\FDN.h

; 293  : 		for (int i = 0; i < fdn_numModDiffuser; i++)

	add	r8d, r12d
	add	r9, 8
	cmp	r8d, DWORD PTR [rbx+184]
	jl	SHORT $LL142@InitPlugin
$LN141@InitPlugin:
; File E:\FoxSuite\shimmer\Shimmer.cpp

; 168  : }

	lea	r11, QWORD PTR [rsp+96]
	mov	rbx, QWORD PTR [r11+56]
	mov	rbp, QWORD PTR [r11+64]
	movaps	xmm6, XMMWORD PTR [rsp+80]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	ret	0
?InitPlugin@Shimmer@@AEAAXXZ ENDP			; Shimmer::InitPlugin
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
params2$ = 48
params1$ = 64
$T13 = 144
$T11 = 144
$T6 = 144
$T1 = 144
this$ = 144
?dtor$0@?0??InitPlugin@Shimmer@@AEAAXXZ@4HA PROC	; `Shimmer::InitPlugin'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 320				; 00000140H
	mov	rcx, QWORD PTR $T1[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??InitPlugin@Shimmer@@AEAAXXZ@4HA ENDP	; `Shimmer::InitPlugin'::`1'::dtor$0
params2$ = 48
params1$ = 64
$T13 = 144
$T11 = 144
$T6 = 144
$T1 = 144
this$ = 144
?dtor$1@?0??InitPlugin@Shimmer@@AEAAXXZ@4HA PROC	; `Shimmer::InitPlugin'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 320				; 00000140H
	mov	rcx, QWORD PTR $T6[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??InitPlugin@Shimmer@@AEAAXXZ@4HA ENDP	; `Shimmer::InitPlugin'::`1'::dtor$1
params2$ = 48
params1$ = 64
$T13 = 144
$T11 = 144
$T6 = 144
$T1 = 144
this$ = 144
?dtor$2@?0??InitPlugin@Shimmer@@AEAAXXZ@4HA PROC	; `Shimmer::InitPlugin'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 491736				; 000780d8H
	mov	rcx, QWORD PTR $T11[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0??InitPlugin@Shimmer@@AEAAXXZ@4HA ENDP	; `Shimmer::InitPlugin'::`1'::dtor$2
params2$ = 48
params1$ = 64
$T13 = 144
$T11 = 144
$T6 = 144
$T1 = 144
this$ = 144
?dtor$3@?0??InitPlugin@Shimmer@@AEAAXXZ@4HA PROC	; `Shimmer::InitPlugin'::`1'::dtor$3
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 491736				; 000780d8H
	mov	rcx, QWORD PTR $T13[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$3@?0??InitPlugin@Shimmer@@AEAAXXZ@4HA ENDP	; `Shimmer::InitPlugin'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
params2$ = 48
params1$ = 64
$T13 = 144
$T11 = 144
$T6 = 144
$T1 = 144
this$ = 144
?dtor$0@?0??InitPlugin@Shimmer@@AEAAXXZ@4HA PROC	; `Shimmer::InitPlugin'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 320				; 00000140H
	mov	rcx, QWORD PTR $T1[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??InitPlugin@Shimmer@@AEAAXXZ@4HA ENDP	; `Shimmer::InitPlugin'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
params2$ = 48
params1$ = 64
$T13 = 144
$T11 = 144
$T6 = 144
$T1 = 144
this$ = 144
?dtor$1@?0??InitPlugin@Shimmer@@AEAAXXZ@4HA PROC	; `Shimmer::InitPlugin'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 320				; 00000140H
	mov	rcx, QWORD PTR $T6[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??InitPlugin@Shimmer@@AEAAXXZ@4HA ENDP	; `Shimmer::InitPlugin'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
params2$ = 48
params1$ = 64
$T13 = 144
$T11 = 144
$T6 = 144
$T1 = 144
this$ = 144
?dtor$2@?0??InitPlugin@Shimmer@@AEAAXXZ@4HA PROC	; `Shimmer::InitPlugin'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 491736				; 000780d8H
	mov	rcx, QWORD PTR $T11[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0??InitPlugin@Shimmer@@AEAAXXZ@4HA ENDP	; `Shimmer::InitPlugin'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogspy
;	COMDAT text$x
text$x	SEGMENT
params2$ = 48
params1$ = 64
$T13 = 144
$T11 = 144
$T6 = 144
$T1 = 144
this$ = 144
?dtor$3@?0??InitPlugin@Shimmer@@AEAAXXZ@4HA PROC	; `Shimmer::InitPlugin'::`1'::dtor$3
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 491736				; 000780d8H
	mov	rcx, QWORD PTR $T13[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$3@?0??InitPlugin@Shimmer@@AEAAXXZ@4HA ENDP	; `Shimmer::InitPlugin'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\Shimmer.cpp
;	COMDAT ?setSampleRate@Shimmer@@UEAAXM@Z
_TEXT	SEGMENT
this$ = 64
sampleRate$ = 72
?setSampleRate@Shimmer@@UEAAXM@Z PROC			; Shimmer::setSampleRate, COMDAT

; 174  : {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rcx
	movaps	XMMWORD PTR [rsp+32], xmm6
	movaps	xmm6, xmm1

; 175  :     // Call AudioEffect "setSampleRate" method
; 176  :     AudioEffect::setSampleRate(sampleRate);

	movss	DWORD PTR [rcx+24], xmm6

; 177  : 
; 178  :     // Call setSampleRate on every needed module
; 179  :     BranchReverb->setSampleRate(sampleRate);

	mov	rcx, QWORD PTR [rcx+296]
	cvttss2si ebx, xmm6
	mov	edx, ebx
	call	?setSampleRate@FDN@@QEAAXH@Z		; FDN::setSampleRate

; 180  :     MasterReverb->setSampleRate(sampleRate);

	mov	rcx, QWORD PTR [rdi+304]
	mov	edx, ebx
	call	?setSampleRate@FDN@@QEAAXH@Z		; FDN::setSampleRate

; 181  :     PitchShift_1oct->reset(sampleRate);

	mov	rcx, QWORD PTR [rdi+312]
	cvtss2sd xmm6, xmm6
	mov	rax, QWORD PTR [rcx]
	movaps	xmm1, xmm6
	call	QWORD PTR [rax]

; 182  :     PitchShift_2oct->reset(sampleRate);

	mov	rcx, QWORD PTR [rdi+320]
	movaps	xmm1, xmm6
	mov	rax, QWORD PTR [rcx]

; 183  : }

	mov	rbx, QWORD PTR [rsp+64]
	movaps	xmm6, XMMWORD PTR [rsp+32]
	add	rsp, 48					; 00000030H
	pop	rdi

; 182  :     PitchShift_2oct->reset(sampleRate);

	rex_jmp	QWORD PTR [rax]
?setSampleRate@Shimmer@@UEAAXM@Z ENDP			; Shimmer::setSampleRate
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\Shimmer.cpp
;	COMDAT ?processReplacing@Shimmer@@UEAAXPEAPEAM0H@Z
_TEXT	SEGMENT
mast_rev_in$1 = 32
this$ = 144
bran_rev_out$2 = 152
inputs$ = 152
mast_rev_out$3 = 160
outputs$ = 160
pitchOut$4 = 168
sampleFrames$ = 168
?processReplacing@Shimmer@@UEAAXPEAPEAM0H@Z PROC	; Shimmer::processReplacing, COMDAT

; 190  : {

$LN12:

; 197  : 
; 198  :     // write input to file
; 199  :     //string pre = "test_input.txt";
; 200  :     //WriteBufferToFile(inputs, sampleFrames, pre); 
; 201  :     
; 202  :     // Cycle over the sample frames number
; 203  :     for (int i = 0; i < sampleFrames; i++) {

	test	r9d, r9d
	jle	$LN10@processRep
	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r13
	push	r14
	push	r15
	mov	rbp, rsp
	sub	rsp, 80					; 00000050H

; 191  :     // Extract input and output buffers
; 192  :     float* inL = inputs[0]; // buffer input left

	mov	rbx, QWORD PTR [rdx]
	mov	r13, rcx

; 193  :     float* inR = inputs[1]; // buffer input right

	mov	rdi, QWORD PTR [rdx+8]

; 194  : 
; 195  :     float* outL = outputs[0]; // buffer output left

	mov	rsi, QWORD PTR [r8]
	sub	rdi, rbx

; 196  :     float* outR = outputs[1]; // buffer output right

	mov	r14, QWORD PTR [r8+8]
	sub	rsi, rbx
	movaps	XMMWORD PTR [rsp+64], xmm6

; 204  : 
; 205  :         // Create tmp arrays for processing
; 206  :         float pitchIn = (inL[i] + inR[i]) / 2;

	sub	r14, rbx
	movaps	XMMWORD PTR [rsp+48], xmm7
	movsxd	r15, r9d
$LL4@processRep:
	movss	xmm0, DWORD PTR [rbx]
	addss	xmm0, DWORD PTR [rdi+rbx]

; 207  :         double pitchOut1 = 0.0;
; 208  :         double pitchOut2 = 0.0;
; 209  :         float pitchOut;
; 210  :         float bran_rev_out[2] = { 0.0, 0.0 };
; 211  :         float mast_rev_out[2] = { 0.0, 0.0 };
; 212  :         float mast_rev_in[2];
; 213  : 
; 214  :         // --- Pitch Shifting        
; 215  :         // Process pitch shifting 1 octave
; 216  :         pitchOut1 = PitchShift_1oct->processAudioSample(pitchIn);

	mov	rcx, QWORD PTR [r13+312]
	and	DWORD PTR bran_rev_out$2[rbp-80], 0
	and	DWORD PTR bran_rev_out$2[rbp-76], 0
	and	DWORD PTR mast_rev_out$3[rbp-80], 0
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	rax, QWORD PTR [rcx]
	and	DWORD PTR mast_rev_out$3[rbp-76], 0
	cvtps2pd xmm6, xmm0
	movaps	xmm1, xmm6
	call	QWORD PTR [rax+8]

; 217  : 
; 218  :         // Process pitch shifting 2 octaves
; 219  :         pitchOut2 = PitchShift_2oct->processAudioSample(pitchIn);

	mov	rcx, QWORD PTR [r13+320]
	movaps	xmm1, xmm6
	movaps	xmm7, xmm0
	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+8]

; 220  : 
; 221  :         // Sum outputs
; 222  :         pitchOut = _mixP1 * (float)pitchOut1 + _mixP2 * (float)pitchOut2;
; 223  :               
; 224  :         // --- Branch Reverb        
; 225  :         BranchReverb->processAudio(&pitchOut, bran_rev_out);

	mov	rcx, QWORD PTR [r13+296]
	lea	r8, QWORD PTR bran_rev_out$2[rbp-80]
	xorps	xmm2, xmm2
	lea	rdx, QWORD PTR pitchOut$4[rbp-80]
	xorps	xmm1, xmm1
	cvtsd2ss xmm2, xmm0
	cvtsd2ss xmm1, xmm7
	mulss	xmm2, DWORD PTR [r13+340]
	mulss	xmm1, DWORD PTR [r13+336]
	addss	xmm2, xmm1
	movss	DWORD PTR pitchOut$4[rbp-80], xmm2
	call	?processAudio@FDN@@QEAAXPEAM0@Z		; FDN::processAudio

; 226  : 
; 227  :         // --- Master Reverb        
; 228  :         // Mix branch reverb output with dry input
; 229  :         mast_rev_in[0] = shim_shimmer * bran_rev_out[0] + (1 - shim_shimmer) * inL[i];

	movss	xmm2, DWORD PTR [r13+256]

; 230  :         mast_rev_in[1] = shim_shimmer * bran_rev_out[1] + (1 - shim_shimmer) * inR[i];
; 231  : 
; 232  :         // Process master reverb        
; 233  :         MasterReverb->processAudio(mast_rev_in, mast_rev_out);        

	lea	r8, QWORD PTR mast_rev_out$3[rbp-80]
	movss	xmm3, DWORD PTR __real@3f800000
	lea	rdx, QWORD PTR mast_rev_in$1[rbp-80]
	mov	rcx, QWORD PTR [r13+304]
	subss	xmm3, xmm2
	movaps	xmm0, xmm2
	mulss	xmm2, DWORD PTR bran_rev_out$2[rbp-76]
	mulss	xmm0, DWORD PTR bran_rev_out$2[rbp-80]
	movaps	xmm1, xmm3
	mulss	xmm3, DWORD PTR [rdi+rbx]
	mulss	xmm1, DWORD PTR [rbx]
	addss	xmm3, xmm2
	addss	xmm1, xmm0
	movss	DWORD PTR mast_rev_in$1[rbp-76], xmm3
	movss	DWORD PTR mast_rev_in$1[rbp-80], xmm1
	call	?processAudio@FDN@@QEAAXPEAM0@Z		; FDN::processAudio

; 234  : 
; 235  :         // Stereo spread processing + output allocation
; 236  :         outL[i] = _wet * mast_rev_out[0] + _dry * inL[i];

	movss	xmm1, DWORD PTR [rbx]
	mulss	xmm1, DWORD PTR [r13+332]
	movss	xmm0, DWORD PTR mast_rev_out$3[rbp-80]
	mulss	xmm0, DWORD PTR [r13+328]

; 237  :         outR[i] = _wet * mast_rev_out[1] + _dry * inR[i];

	movss	xmm2, DWORD PTR mast_rev_out$3[rbp-76]
	addss	xmm1, xmm0
	movss	DWORD PTR [rsi+rbx], xmm1
	movss	xmm0, DWORD PTR [r13+332]
	mulss	xmm0, DWORD PTR [rdi+rbx]
	mulss	xmm2, DWORD PTR [r13+328]
	addss	xmm2, xmm0
	movss	DWORD PTR [r14+rbx], xmm2
	add	rbx, 4
	sub	r15, 1
	jne	$LL4@processRep

; 238  :     }
; 239  : 
; 240  :    // Write samples to file
; 241  :    //string post = "test_output.txt";
; 242  :    //WriteBufferToFile(outputs, sampleFrames, post);
; 243  : 
; 244  : }

	movaps	xmm6, XMMWORD PTR [rsp+64]
	movaps	xmm7, XMMWORD PTR [rsp+48]
	add	rsp, 80					; 00000050H
	pop	r15
	pop	r14
	pop	r13
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
$LN10@processRep:
	ret	0
?processReplacing@Shimmer@@UEAAXPEAPEAM0H@Z ENDP	; Shimmer::processReplacing
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\Shimmer.cpp
; File E:\FoxSuite\shimmer\include\utils.h
; File E:\FoxSuite\shimmer\Shimmer.cpp
; File E:\FoxSuite\shimmer\include\utils.h
; File E:\FoxSuite\shimmer\Shimmer.cpp
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\Shimmer.cpp
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\Shimmer.cpp
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\include\src\LPCombFilter.cpp
; File E:\FoxSuite\shimmer\include\LowPassFilter.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\include\src\LPCombFilter.cpp
; File E:\FoxSuite\shimmer\include\LowPassFilter.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h
; File E:\FoxSuite\shimmer\Shimmer.cpp
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\Shimmer.cpp
; File E:\FoxSuite\shimmer\include\utils.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\HighPassFilter.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\Shimmer.cpp
; File E:\FoxSuite\shimmer\include\utils.h
; File E:\FoxSuite\shimmer\Shimmer.cpp
; File E:\FoxSuite\shimmer\include\utils.h
; File E:\FoxSuite\shimmer\Shimmer.cpp
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\Shimmer.cpp
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\LowPassFilter.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\Shimmer.cpp
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\Shimmer.cpp
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\LFO.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File E:\FoxSuite\shimmer\include\Modulation.h
; File E:\FoxSuite\shimmer\include\ModDelay.h
; File E:\FoxSuite\shimmer\include\LFO.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\Shimmer.cpp
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\Shimmer.cpp
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\Modulation.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\Modulation.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\Shimmer.cpp
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\Shimmer.cpp
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h
; File E:\FoxSuite\shimmer\include\FDN.h
; File E:\FoxSuite\shimmer\Shimmer.cpp
;	COMDAT ?setParameter@Shimmer@@UEAAXHM@Z
_TEXT	SEGMENT
this$ = 80
index$ = 88
value$ = 96
?setParameter@Shimmer@@UEAAXHM@Z PROC			; Shimmer::setParameter, COMDAT

; 254  : {

$LN150:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	push	r14
	sub	rsp, 64					; 00000040H
	movaps	XMMWORD PTR [rax-24], xmm6
	movaps	xmm6, xmm2
	mov	rsi, rcx

; 255  :     switch (index) {

	cmp	edx, 5
	jg	$LN18@setParamet
	je	$LN8@setParamet
	test	edx, edx
	je	$LN4@setParamet
	sub	edx, 1
	je	$LN5@setParamet
	sub	edx, 1
	je	$LN7@setParamet
	sub	edx, 1
	je	$LN6@setParamet
	cmp	edx, 1
	jne	$LN51@setParamet

; 287  :         break;
; 288  :     }
; 289  :     case Param_intervals: {        
; 290  :         if (value == 1)

	ucomiss	xmm6, DWORD PTR __real@3f800000
	jne	SHORT $LN11@setParamet

; 291  :             value = 0.99; // if value = 1, then pitIdx = NUM_OF_PITCH_INTRVL_ALLOWED + 1 -> outside of array boundaries

	movss	xmm6, DWORD PTR __real@3f7d70a4
$LN11@setParamet:

; 292  :         shim_intervals = value;

	movss	DWORD PTR [rcx+260], xmm6

; 293  :         int pitIdx = shim_intervals / DELTA_PARAMETER_BETWEEN_INTERVALS;
; 294  :         PitchShift_1oct->setPitchShift(INTERVALS_IN_SEMITONES_PITCH1[pitIdx]);

	lea	rbp, OFFSET FLAT:__ImageBase
	mulss	xmm6, DWORD PTR __real@41200000
	mov	rcx, QWORD PTR [rcx+312]
	cvttss2si eax, xmm6
	movsxd	rbx, eax
	movss	xmm1, DWORD PTR ?INTERVALS_IN_SEMITONES_PITCH1@@3QBMB[rbp+rbx*4]
	cvtps2pd xmm1, xmm1
	call	?setPitchShift@PSMVocoder@@QEAAXN@Z	; PSMVocoder::setPitchShift
	movss	xmm1, DWORD PTR ?INTERVALS_IN_SEMITONES_PITCH2@@3QBMB[rbp+rbx*4]

; 295  :         PitchShift_2oct->setPitchShift(INTERVALS_IN_SEMITONES_PITCH2[pitIdx]);

	mov	rcx, QWORD PTR [rsi+320]
	cvtps2pd xmm1, xmm1
	call	?setPitchShift@PSMVocoder@@QEAAXN@Z	; PSMVocoder::setPitchShift
	xorps	xmm0, xmm0

; 67   :     _mixP1 = 1.0;

	mov	QWORD PTR [rsi+336], 1065353216		; 3f800000H

; 68   :     _mixP2 = 0.0;
; 69   :     if (pitch2 != 0.0) {

	ucomiss	xmm0, DWORD PTR ?INTERVALS_IN_SEMITONES_PITCH2@@3QBMB[rbp+rbx*4]
	je	$LN51@setParamet

; 70   :         _mixP1 = 0.5;

	mov	eax, 1056964608				; 3f000000H
	mov	DWORD PTR [rsi+336], eax

; 71   :         _mixP2 = 0.5;

	mov	DWORD PTR [rsi+340], eax

; 296  :         updateMixPitchShifters(INTERVALS_IN_SEMITONES_PITCH2[pitIdx]);
; 297  :         break;

	jmp	$LN51@setParamet
$LN6@setParamet:

; 266  :     }
; 267  :     case Param_shimmer: {
; 268  :         shim_shimmer = value;

	movss	DWORD PTR [rcx+256], xmm6

; 269  :         break;

	jmp	$LN51@setParamet
$LN7@setParamet:

; 270  :     }
; 271  :     case Param_decay: {
; 272  :         shim_decay = value;

	movss	DWORD PTR [rcx+264], xmm6

; 273  :         BranchReverb->setDecayInSeconds(0.25 * shim_decay * MAX_REVERB_DECAY_IN_SECONDS);

	mulss	xmm6, DWORD PTR __real@40f00000
	mov	rcx, QWORD PTR [rcx+296]
	movaps	xmm1, xmm6
	call	?setDecayInSeconds@FDN@@QEAAXM@Z	; FDN::setDecayInSeconds

; 274  :         MasterReverb->setDecayInSeconds(shim_decay * MAX_REVERB_DECAY_IN_SECONDS);

	movss	xmm1, DWORD PTR [rsi+264]
	mulss	xmm1, DWORD PTR __real@41f00000
	mov	rcx, QWORD PTR [rsi+304]
	call	?setDecayInSeconds@FDN@@QEAAXM@Z	; FDN::setDecayInSeconds

; 275  :         break;

	jmp	$LN51@setParamet
$LN5@setParamet:

; 260  :     }
; 261  :     case Param_roomSize: {
; 262  :         shim_roomSize = value;

	movss	DWORD PTR [rcx+252], xmm6

; 263  :         BranchReverb->setRoomSize(shim_roomSize);

	movaps	xmm1, xmm6
	mov	rcx, QWORD PTR [rcx+296]
	call	?setRoomSize@FDN@@QEAAXMW4DiffuserDelayLogic@@W4DelayDistribution@@1@Z ; FDN::setRoomSize

; 264  :         MasterReverb->setRoomSize(shim_roomSize);

	movss	xmm1, DWORD PTR [rsi+252]
	mov	rcx, QWORD PTR [rsi+304]
	call	?setRoomSize@FDN@@QEAAXMW4DiffuserDelayLogic@@W4DelayDistribution@@1@Z ; FDN::setRoomSize

; 265  :         break;

	jmp	$LN51@setParamet
$LN4@setParamet:

; 61   :     _wet = sin(shim_mix * M_PI * 0.5);

	xorps	xmm0, xmm0

; 256  :     case Param_mix: {
; 257  :         shim_mix = value;        

	movss	DWORD PTR [rcx+248], xmm6

; 61   :     _wet = sin(shim_mix * M_PI * 0.5);

	cvtss2sd xmm0, xmm6
	mulsd	xmm0, QWORD PTR __real@3ff921fb54442d18
	call	QWORD PTR __imp_sin
	xorps	xmm1, xmm1
	cvtsd2ss xmm1, xmm0
	movss	xmm0, DWORD PTR [rsi+248]

; 62   :     _dry = cos(shim_mix * M_PI * 0.5);

	cvtps2pd xmm0, xmm0
	movss	DWORD PTR [rsi+328], xmm1
	mulsd	xmm0, QWORD PTR __real@3ff921fb54442d18
	call	QWORD PTR __imp_cos
	xorps	xmm1, xmm1
	cvtsd2ss xmm1, xmm0
	movss	DWORD PTR [rsi+332], xmm1

; 258  :         updateMix();
; 259  :         break;

	jmp	$LN51@setParamet
$LN8@setParamet:
; File E:\FoxSuite\shimmer\include\utils.h

; 61   :     return minvalue + value * (maxValue - minvalue);

	movss	xmm2, DWORD PTR ?MAX_DAMPING_FREQUENCY_LOG@@3MB
	subss	xmm2, DWORD PTR ?MIN_DAMPING_FREQUENCY_LOG@@3MB
; File E:\FoxSuite\shimmer\Shimmer.cpp

; 279  :         float freq = exp(mapValueIntoRange(1.0 - shim_damping, MIN_DAMPING_FREQUENCY_LOG, MAX_DAMPING_FREQUENCY_LOG));

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, xmm6
	movss	DWORD PTR [rcx+268], xmm6
; File E:\FoxSuite\shimmer\include\utils.h

; 61   :     return minvalue + value * (maxValue - minvalue);

	mulss	xmm2, xmm0
	addss	xmm2, DWORD PTR ?MIN_DAMPING_FREQUENCY_LOG@@3MB
; File E:\FoxSuite\shimmer\Shimmer.cpp

; 279  :         float freq = exp(mapValueIntoRange(1.0 - shim_damping, MIN_DAMPING_FREQUENCY_LOG, MAX_DAMPING_FREQUENCY_LOG));

	cvtps2pd xmm0, xmm2
	call	QWORD PTR __imp_exp
; File E:\FoxSuite\shimmer\include\FDN.h

; 258  : 		fdn_Feedback->setDampingFrequency(freq);

	mov	rax, QWORD PTR [rsi+296]
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 88   : 		for (int i = 0; i < mcf_numberOfChannels; i++)

	xor	edi, edi
; File E:\FoxSuite\shimmer\Shimmer.cpp

; 279  :         float freq = exp(mapValueIntoRange(1.0 - shim_damping, MIN_DAMPING_FREQUENCY_LOG, MAX_DAMPING_FREQUENCY_LOG));

	xorps	xmm6, xmm6
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 88   : 		for (int i = 0; i < mcf_numberOfChannels; i++)

	mov	ebp, edi
; File E:\FoxSuite\shimmer\Shimmer.cpp

; 279  :         float freq = exp(mapValueIntoRange(1.0 - shim_damping, MIN_DAMPING_FREQUENCY_LOG, MAX_DAMPING_FREQUENCY_LOG));

	cvtsd2ss xmm6, xmm0
; File E:\FoxSuite\shimmer\include\FDN.h

; 258  : 		fdn_Feedback->setDampingFrequency(freq);

	mov	r14, QWORD PTR [rax+72]
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 88   : 		for (int i = 0; i < mcf_numberOfChannels; i++)

	cmp	DWORD PTR [r14], edi
	jle	SHORT $LN27@setParamet
	mov	ebx, edi
$LL28@setParamet:

; 89   : 			mcf_DelayLines[i]->setCutoffFrequency(freq);

	mov	rax, QWORD PTR [r14+40]
	mov	rcx, QWORD PTR [rbx+rax]
; File E:\FoxSuite\shimmer\include\src\LPCombFilter.cpp

; 25   : 	lpcf_cutoffFreq = cutoffFreq;

	movss	DWORD PTR [rcx+96], xmm6

; 26   : 
; 27   : 	// set LPF cutoff frequency to the inserted value
; 28   : 	lpcf_feedbackLPF->setCutoffFrequency(lpcf_cutoffFreq);

	mov	rcx, QWORD PTR [rcx+88]
; File E:\FoxSuite\shimmer\include\LowPassFilter.h

; 68   : 		lpf_cutoffFreq = cutoffFreq;

	movss	DWORD PTR [rcx+4], xmm6

; 69   : 
; 70   : 		// update lpf gains
; 71   : 		updateGains();

	call	?updateGains@LowPassFilter@@QEAAXXZ	; LowPassFilter::updateGains
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 88   : 		for (int i = 0; i < mcf_numberOfChannels; i++)

	inc	ebp
	lea	rbx, QWORD PTR [rbx+8]
	cmp	ebp, DWORD PTR [r14]
	jl	SHORT $LL28@setParamet
$LN27@setParamet:
; File E:\FoxSuite\shimmer\include\FDN.h

; 258  : 		fdn_Feedback->setDampingFrequency(freq);

	mov	rax, QWORD PTR [rsi+304]
	mov	rbx, QWORD PTR [rax+72]
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 88   : 		for (int i = 0; i < mcf_numberOfChannels; i++)

	cmp	DWORD PTR [rbx], edi
	jle	$LN51@setParamet
	mov	rsi, rdi
$LL41@setParamet:

; 89   : 			mcf_DelayLines[i]->setCutoffFrequency(freq);

	mov	rax, QWORD PTR [rbx+40]
	mov	rcx, QWORD PTR [rsi+rax]
; File E:\FoxSuite\shimmer\include\src\LPCombFilter.cpp

; 25   : 	lpcf_cutoffFreq = cutoffFreq;

	movss	DWORD PTR [rcx+96], xmm6

; 26   : 
; 27   : 	// set LPF cutoff frequency to the inserted value
; 28   : 	lpcf_feedbackLPF->setCutoffFrequency(lpcf_cutoffFreq);

	mov	rcx, QWORD PTR [rcx+88]
; File E:\FoxSuite\shimmer\include\LowPassFilter.h

; 68   : 		lpf_cutoffFreq = cutoffFreq;

	movss	DWORD PTR [rcx+4], xmm6

; 69   : 
; 70   : 		// update lpf gains
; 71   : 		updateGains();

	call	?updateGains@LowPassFilter@@QEAAXXZ	; LowPassFilter::updateGains
; File E:\FoxSuite\shimmer\include\ModMultiChannelFeedback.h

; 88   : 		for (int i = 0; i < mcf_numberOfChannels; i++)

	inc	edi
	lea	rsi, QWORD PTR [rsi+8]
	cmp	edi, DWORD PTR [rbx]
	jl	SHORT $LL41@setParamet
; File E:\FoxSuite\shimmer\Shimmer.cpp

; 282  :         break;

	jmp	$LN51@setParamet
$LN18@setParamet:

; 255  :     switch (index) {

	sub	edx, 6
	je	$LN9@setParamet
	sub	edx, 1
	je	$LN12@setParamet
	sub	edx, 1
	je	$LN13@setParamet
	sub	edx, 1
	je	SHORT $LN14@setParamet
	cmp	edx, 1
	jne	$LN51@setParamet

; 317  :         float hpf = mapValueIntoRange(value, HPF_FILTER_MIN_FREQ, HPF_FILTER_MAX_FREQ);
; 318  :         MasterReverb->setHighPassFrequency(hpf);

	mov	rsi, QWORD PTR [rcx+304]
; File E:\FoxSuite\shimmer\include\FDN.h

; 274  : 		for (int i = 0; i < fdn_outputChannels; i++)

	xor	edi, edi
; File E:\FoxSuite\shimmer\Shimmer.cpp

; 316  :         shim_hpf = value;

	movss	DWORD PTR [rcx+288], xmm6
; File E:\FoxSuite\shimmer\include\utils.h

; 61   :     return minvalue + value * (maxValue - minvalue);

	mulss	xmm6, DWORD PTR __real@45d98000
	addss	xmm6, DWORD PTR __real@42200000
; File E:\FoxSuite\shimmer\include\FDN.h

; 274  : 		for (int i = 0; i < fdn_outputChannels; i++)

	cmp	DWORD PTR [rsi+176], edi
	jle	$LN51@setParamet
	mov	ebx, edi
$LL108@setParamet:

; 275  : 			fdn_HPFOutput[i]->setCutoffFrequency(freq);

	mov	rax, QWORD PTR [rsi+144]
	mov	rcx, QWORD PTR [rbx+rax]
; File E:\FoxSuite\shimmer\include\HighPassFilter.h

; 68   : 		hpf_cutoffFreq = cutoffFreq;

	movss	DWORD PTR [rcx+4], xmm6

; 69   : 
; 70   : 		// update hpf gains
; 71   : 		updateGains();

	call	?updateGains@HighPassFilter@@QEAAXXZ	; HighPassFilter::updateGains
; File E:\FoxSuite\shimmer\include\FDN.h

; 274  : 		for (int i = 0; i < fdn_outputChannels; i++)

	inc	edi
	lea	rbx, QWORD PTR [rbx+8]
	cmp	edi, DWORD PTR [rsi+176]
	jl	SHORT $LL108@setParamet
; File E:\FoxSuite\shimmer\Shimmer.cpp

; 319  :         break;

	jmp	$LN51@setParamet
$LN14@setParamet:
; File E:\FoxSuite\shimmer\include\utils.h

; 61   :     return minvalue + value * (maxValue - minvalue);

	movss	xmm1, DWORD PTR ?LPF_FILTER_MAX_FREQ_LOG@@3MB
	subss	xmm1, DWORD PTR ?LPF_FILTER_MIN_FREQ_LOG@@3MB
; File E:\FoxSuite\shimmer\Shimmer.cpp

; 310  :         shim_lpf = value;

	movss	DWORD PTR [rcx+284], xmm6
; File E:\FoxSuite\shimmer\include\utils.h

; 61   :     return minvalue + value * (maxValue - minvalue);

	mulss	xmm1, xmm6
	addss	xmm1, DWORD PTR ?LPF_FILTER_MIN_FREQ_LOG@@3MB
; File E:\FoxSuite\shimmer\Shimmer.cpp

; 311  :         float lpf = exp(mapValueIntoRange(value, LPF_FILTER_MIN_FREQ_LOG, LPF_FILTER_MAX_FREQ_LOG));

	cvtps2pd xmm0, xmm1
	call	QWORD PTR __imp_exp

; 312  :         MasterReverb->setLowPassFrequency(lpf);

	mov	rsi, QWORD PTR [rsi+304]
; File E:\FoxSuite\shimmer\include\FDN.h

; 268  : 		for (int i = 0; i < fdn_outputChannels; i++)

	xor	edi, edi
; File E:\FoxSuite\shimmer\Shimmer.cpp

; 311  :         float lpf = exp(mapValueIntoRange(value, LPF_FILTER_MIN_FREQ_LOG, LPF_FILTER_MAX_FREQ_LOG));

	xorps	xmm6, xmm6
	cvtsd2ss xmm6, xmm0
; File E:\FoxSuite\shimmer\include\FDN.h

; 268  : 		for (int i = 0; i < fdn_outputChannels; i++)

	cmp	DWORD PTR [rsi+176], edi
	jle	$LN51@setParamet
	mov	ebx, edi
$LL97@setParamet:

; 269  : 			fdn_LPFOutput[i]->setCutoffFrequency(freq);

	mov	rax, QWORD PTR [rsi+80]
	mov	rcx, QWORD PTR [rbx+rax]
; File E:\FoxSuite\shimmer\include\LowPassFilter.h

; 68   : 		lpf_cutoffFreq = cutoffFreq;

	movss	DWORD PTR [rcx+4], xmm6

; 69   : 
; 70   : 		// update lpf gains
; 71   : 		updateGains();

	call	?updateGains@LowPassFilter@@QEAAXXZ	; LowPassFilter::updateGains
; File E:\FoxSuite\shimmer\include\FDN.h

; 268  : 		for (int i = 0; i < fdn_outputChannels; i++)

	inc	edi
	lea	rbx, QWORD PTR [rbx+8]
	cmp	edi, DWORD PTR [rsi+176]
	jl	SHORT $LL97@setParamet
; File E:\FoxSuite\shimmer\Shimmer.cpp

; 313  :         break;

	jmp	$LN51@setParamet
$LN13@setParamet:

; 306  :         MasterReverb->setModRate(shim_modRate * MAX_MOD_RATE);

	mov	rdx, QWORD PTR [rcx+304]
; File E:\FoxSuite\shimmer\include\FDN.h

; 229  : 		for (int i = 0; i < fdn_internalChannels; i++)

	xor	edi, edi
; File E:\FoxSuite\shimmer\Shimmer.cpp

; 305  :         shim_modRate = value;

	movss	DWORD PTR [rcx+276], xmm6

; 306  :         MasterReverb->setModRate(shim_modRate * MAX_MOD_RATE);

	mulss	xmm6, DWORD PTR __real@40a00000
; File E:\FoxSuite\shimmer\include\FDN.h

; 229  : 		for (int i = 0; i < fdn_internalChannels; i++)

	cmp	DWORD PTR [rdx+172], edi
	jle	$LN51@setParamet
	movaps	xmm2, xmm6
	mov	r8d, edi
	mulss	xmm2, DWORD PTR __real@45800000
$LL80@setParamet:

; 230  : 			fdn_Modulation[i]->setModRate(rate);

	mov	rax, QWORD PTR [rdx+104]
; File E:\FoxSuite\shimmer\include\LFO.h

; 122  : 		lfo_inc = WAVETABLE_SIZE * lfo_frequency / (float)lfo_sampleRate;

	movaps	xmm1, xmm2
; File E:\FoxSuite\shimmer\include\FDN.h

; 229  : 		for (int i = 0; i < fdn_internalChannels; i++)

	inc	edi

; 230  : 			fdn_Modulation[i]->setModRate(rate);

	mov	rcx, QWORD PTR [r8+rax]
	lea	r8, QWORD PTR [r8+8]
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 90   : 		mdly_LFO->setLFOfrequency(mdly_rate);

	mov	rax, QWORD PTR [rcx+104]
; File E:\FoxSuite\shimmer\include\Modulation.h

; 67   : 		mod_rate = rate;

	movss	DWORD PTR [rcx+164], xmm6
; File E:\FoxSuite\shimmer\include\ModDelay.h

; 89   : 		mdly_rate = modRate;

	movss	DWORD PTR [rcx+136], xmm6
	movd	xmm0, DWORD PTR [rax+4]
; File E:\FoxSuite\shimmer\include\LFO.h

; 122  : 		lfo_inc = WAVETABLE_SIZE * lfo_frequency / (float)lfo_sampleRate;

	cvtdq2ps xmm0, xmm0

; 71   : 		lfo_frequency = frequency;

	movss	DWORD PTR [rax], xmm6

; 122  : 		lfo_inc = WAVETABLE_SIZE * lfo_frequency / (float)lfo_sampleRate;

	divss	xmm1, xmm0
	movss	DWORD PTR [rax+20], xmm1
; File E:\FoxSuite\shimmer\include\FDN.h

; 229  : 		for (int i = 0; i < fdn_internalChannels; i++)

	cmp	edi, DWORD PTR [rdx+172]
	jl	SHORT $LL80@setParamet
; File E:\FoxSuite\shimmer\Shimmer.cpp

; 307  :         break;

	jmp	$LN51@setParamet
$LN12@setParamet:

; 301  :         MasterReverb->setModDepth(shim_modDepth);

	mov	rdx, QWORD PTR [rcx+304]
; File E:\FoxSuite\shimmer\include\FDN.h

; 235  : 		for (int i = 0; i < fdn_internalChannels; i++)

	xor	edi, edi
; File E:\FoxSuite\shimmer\Shimmer.cpp

; 300  :         shim_modDepth = value;

	movss	DWORD PTR [rcx+280], xmm6
; File E:\FoxSuite\shimmer\include\FDN.h

; 235  : 		for (int i = 0; i < fdn_internalChannels; i++)

	cmp	DWORD PTR [rdx+172], edi
	jle	$LN51@setParamet
	mov	r8d, edi
$LL71@setParamet:

; 236  : 			fdn_Modulation[i]->setModDepth(depth);	

	mov	rax, QWORD PTR [rdx+104]
; File E:\FoxSuite\shimmer\include\Modulation.h

; 63   : 		ModDelay::setDeltaDelayValue(mod_modValue * mod_depth);

	movaps	xmm0, xmm6
; File E:\FoxSuite\shimmer\include\FDN.h

; 235  : 		for (int i = 0; i < fdn_internalChannels; i++)

	inc	edi

; 236  : 			fdn_Modulation[i]->setModDepth(depth);	

	mov	rcx, QWORD PTR [r8+rax]
	lea	r8, QWORD PTR [r8+8]
; File E:\FoxSuite\shimmer\include\Modulation.h

; 63   : 		ModDelay::setDeltaDelayValue(mod_modValue * mod_depth);

	mulss	xmm0, DWORD PTR [rcx+172]
	movss	DWORD PTR [rcx+168], xmm6
	movss	DWORD PTR [rcx+124], xmm0
; File E:\FoxSuite\shimmer\include\FDN.h

; 235  : 		for (int i = 0; i < fdn_internalChannels; i++)

	cmp	edi, DWORD PTR [rdx+172]
	jl	SHORT $LL71@setParamet
; File E:\FoxSuite\shimmer\Shimmer.cpp

; 302  :         break;

	jmp	SHORT $LN51@setParamet
$LN9@setParamet:

; 286  :         MasterReverb->setStereoSpread(shim_space);

	mov	rdx, QWORD PTR [rcx+304]
; File E:\FoxSuite\shimmer\include\FDN.h

; 293  : 		for (int i = 0; i < fdn_numModDiffuser; i++)

	xor	edi, edi
; File E:\FoxSuite\shimmer\Shimmer.cpp

; 285  :         shim_space = value;

	movss	DWORD PTR [rcx+272], xmm6
; File E:\FoxSuite\shimmer\include\FDN.h

; 293  : 		for (int i = 0; i < fdn_numModDiffuser; i++)

	mov	r8d, edi
	movss	DWORD PTR [rdx+308], xmm6
	cmp	DWORD PTR [rdx+184], edi
	jle	SHORT $LN51@setParamet
	mov	r9d, edi
$LL52@setParamet:
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h

; 60   : 		mdiff_MultiChDelay->setModDepth(depth);

	mov	rax, QWORD PTR [rdx+48]
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 88   : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	mov	ebx, edi
; File E:\FoxSuite\shimmer\include\ModMultiChannelDiffuser.h

; 60   : 		mdiff_MultiChDelay->setModDepth(depth);

	mov	rcx, QWORD PTR [rax+r9]
	mov	r10, QWORD PTR [rcx+24]
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 88   : 		for (int i = 0; i < mdel_numberOfChannels; i++)

	cmp	DWORD PTR [r10], edi
	jle	SHORT $LN50@setParamet
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1569 :         return _My_data._Myfirst[_Pos];

	mov	r11, rdi
$LL61@setParamet:
; File E:\FoxSuite\shimmer\include\ModMultiChannelDelay.h

; 89   : 			mdel_DelayLines[i]->setDeltaDelayValue(depth*mdel_modValmsec);

	mov	rax, QWORD PTR [r10+8]
	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR [r10+48]
	inc	ebx
	mov	rcx, QWORD PTR [rax+r11]
	lea	r11, QWORD PTR [r11+8]
	movss	DWORD PTR [rcx+124], xmm0
	cmp	ebx, DWORD PTR [r10]
	jl	SHORT $LL61@setParamet
$LN50@setParamet:
; File E:\FoxSuite\shimmer\include\FDN.h

; 293  : 		for (int i = 0; i < fdn_numModDiffuser; i++)

	inc	r8d
	add	r9, 8
	cmp	r8d, DWORD PTR [rdx+184]
	jl	SHORT $LL52@setParamet
$LN51@setParamet:
; File E:\FoxSuite\shimmer\Shimmer.cpp

; 324  : }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]
	mov	rdi, QWORD PTR [rsp+104]
	movaps	xmm6, XMMWORD PTR [rsp+48]
	add	rsp, 64					; 00000040H
	pop	r14
	ret	0
?setParameter@Shimmer@@UEAAXHM@Z ENDP			; Shimmer::setParameter
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\Shimmer.cpp
;	COMDAT ?getParameter@Shimmer@@UEAAMH@Z
_TEXT	SEGMENT
this$ = 8
index$ = 16
?getParameter@Shimmer@@UEAAMH@Z PROC			; Shimmer::getParameter, COMDAT

; 330  : {

	xorps	xmm0, xmm0

; 331  :     float param = 0;
; 332  :     switch (index) {

	cmp	edx, 5
	jg	SHORT $LN17@getParamet
	je	SHORT $LN8@getParamet
	test	edx, edx
	je	SHORT $LN4@getParamet
	sub	edx, 1
	je	SHORT $LN5@getParamet
	sub	edx, 1
	je	SHORT $LN7@getParamet
	sub	edx, 1
	je	SHORT $LN6@getParamet
	cmp	edx, 1
	jne	SHORT $LN15@getParamet

; 361  :         break;
; 362  :     }
; 363  :     case Param_intervals:
; 364  :     {
; 365  :         param = shim_intervals;

	movss	xmm0, DWORD PTR [rcx+260]

; 388  :         break;
; 389  :     }    
; 390  :     default:
; 391  :         break;
; 392  :     }
; 393  :     return param;
; 394  : }

	ret	0
$LN6@getParamet:

; 341  :         break;
; 342  :     }
; 343  :     case Param_shimmer:
; 344  :     {
; 345  :         param = shim_shimmer;

	movss	xmm0, DWORD PTR [rcx+256]

; 388  :         break;
; 389  :     }    
; 390  :     default:
; 391  :         break;
; 392  :     }
; 393  :     return param;
; 394  : }

	ret	0
$LN7@getParamet:

; 346  :         break;
; 347  :     }
; 348  :     case Param_decay:
; 349  :     {
; 350  :         param = shim_decay;

	movss	xmm0, DWORD PTR [rcx+264]

; 388  :         break;
; 389  :     }    
; 390  :     default:
; 391  :         break;
; 392  :     }
; 393  :     return param;
; 394  : }

	ret	0
$LN5@getParamet:

; 336  :         break;
; 337  :     }
; 338  :     case Param_roomSize: 
; 339  :     {
; 340  :         param = shim_roomSize;

	movss	xmm0, DWORD PTR [rcx+252]

; 388  :         break;
; 389  :     }    
; 390  :     default:
; 391  :         break;
; 392  :     }
; 393  :     return param;
; 394  : }

	ret	0
$LN4@getParamet:

; 333  :     case Param_mix:
; 334  :     {
; 335  :         param = shim_mix;

	movss	xmm0, DWORD PTR [rcx+248]

; 388  :         break;
; 389  :     }    
; 390  :     default:
; 391  :         break;
; 392  :     }
; 393  :     return param;
; 394  : }

	ret	0
$LN8@getParamet:

; 351  :         break;
; 352  :     }    
; 353  :     case Param_damping:
; 354  :     {
; 355  :         param = shim_damping;

	movss	xmm0, DWORD PTR [rcx+268]

; 388  :         break;
; 389  :     }    
; 390  :     default:
; 391  :         break;
; 392  :     }
; 393  :     return param;
; 394  : }

	ret	0
$LN17@getParamet:

; 331  :     float param = 0;
; 332  :     switch (index) {

	sub	edx, 6
	je	SHORT $LN9@getParamet
	sub	edx, 1
	je	SHORT $LN11@getParamet
	sub	edx, 1
	je	SHORT $LN12@getParamet
	sub	edx, 1
	je	SHORT $LN13@getParamet
	cmp	edx, 1
	jne	SHORT $LN15@getParamet

; 382  :         break;
; 383  :     }
; 384  :     case Param_hpf: 
; 385  :     {        
; 386  :         //param = mapValueOutsideRange(shim_hpf, HPF_FILTER_MIN_FREQ, HPF_FILTER_MAX_FREQ);
; 387  :         param = shim_hpf;

	movss	xmm0, DWORD PTR [rcx+288]

; 388  :         break;
; 389  :     }    
; 390  :     default:
; 391  :         break;
; 392  :     }
; 393  :     return param;
; 394  : }

	ret	0
$LN13@getParamet:

; 376  :         break;
; 377  :     }
; 378  :     case Param_lpf: 
; 379  :     {
; 380  :         //param = mapValueOutsideRange(log(shim_lpf), MIN_LPF_FREQUENCY_LOG, MAX_LPF_FREQUENCY_LOG);
; 381  :         param = shim_lpf;

	movss	xmm0, DWORD PTR [rcx+284]

; 388  :         break;
; 389  :     }    
; 390  :     default:
; 391  :         break;
; 392  :     }
; 393  :     return param;
; 394  : }

	ret	0
$LN12@getParamet:

; 371  :         break;
; 372  :     }
; 373  :     case Param_modRate: 
; 374  :     {
; 375  :         param = shim_modRate;

	movss	xmm0, DWORD PTR [rcx+276]

; 388  :         break;
; 389  :     }    
; 390  :     default:
; 391  :         break;
; 392  :     }
; 393  :     return param;
; 394  : }

	ret	0
$LN11@getParamet:

; 366  :         break;
; 367  :     }
; 368  :     case Param_modDepth: 
; 369  :     {
; 370  :         param = shim_modDepth;

	movss	xmm0, DWORD PTR [rcx+280]

; 388  :         break;
; 389  :     }    
; 390  :     default:
; 391  :         break;
; 392  :     }
; 393  :     return param;
; 394  : }

	ret	0
$LN9@getParamet:

; 356  :         break;
; 357  :     }    
; 358  :     case Param_space:
; 359  :     {
; 360  :         param = shim_space;

	movss	xmm0, DWORD PTR [rcx+272]
$LN15@getParamet:

; 388  :         break;
; 389  :     }    
; 390  :     default:
; 391  :         break;
; 392  :     }
; 393  :     return param;
; 394  : }

	ret	0
?getParameter@Shimmer@@UEAAMH@Z ENDP			; Shimmer::getParameter
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\Shimmer.cpp
; File E:\FoxSuite\shimmer\vst-2.4-sdk\vstsdk2.4\pluginterfaces\vst2.x\aeffect.h
; File E:\FoxSuite\shimmer\Shimmer.cpp
; File E:\FoxSuite\shimmer\vst-2.4-sdk\vstsdk2.4\pluginterfaces\vst2.x\aeffect.h
; File E:\FoxSuite\shimmer\Shimmer.cpp
; File E:\FoxSuite\shimmer\vst-2.4-sdk\vstsdk2.4\pluginterfaces\vst2.x\aeffect.h
; File E:\FoxSuite\shimmer\Shimmer.cpp
;	COMDAT ?getParameterLabel@Shimmer@@UEAAXHPEAD@Z
_TEXT	SEGMENT
this$ = 48
index$ = 56
label$ = 64
?getParameterLabel@Shimmer@@UEAAXHPEAD@Z PROC		; Shimmer::getParameterLabel, COMDAT

; 400  : {

$LN42:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, r8

; 401  :     switch (index) {

	cmp	edx, 5
	jg	SHORT $LN17@getParamet
	je	SHORT $LN9@getParamet
	test	edx, edx
	je	SHORT $LN9@getParamet
	sub	edx, 1
	je	SHORT $LN9@getParamet
	sub	edx, 1
	je	SHORT $LN7@getParamet
	sub	edx, 1
	je	SHORT $LN9@getParamet
	cmp	edx, 1
	jne	SHORT $LN15@getParamet
$LN9@getParamet:
; File E:\FoxSuite\shimmer\vst-2.4-sdk\vstsdk2.4\pluginterfaces\vst2.x\aeffect.h

; 296  : 	char* result = strncpy (dst, src, maxLen);

	lea	rdx, OFFSET FLAT:??_C@_00CNPNBAHC@@
$LN40@getParamet:
; File E:\FoxSuite\shimmer\Shimmer.cpp

; 450  : }

	mov	r8d, 8
	mov	rcx, rbx
	call	QWORD PTR __imp_strncpy
	mov	BYTE PTR [rbx+8], 0
$LN15@getParamet:
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN7@getParamet:
; File E:\FoxSuite\shimmer\vst-2.4-sdk\vstsdk2.4\pluginterfaces\vst2.x\aeffect.h

; 296  : 	char* result = strncpy (dst, src, maxLen);

	lea	rdx, OFFSET FLAT:??_C@_01LKDEMHDF@s@
; File E:\FoxSuite\shimmer\Shimmer.cpp

; 416  :         break;

	jmp	SHORT $LN40@getParamet
$LN17@getParamet:

; 401  :     switch (index) {

	sub	edx, 6
	je	SHORT $LN9@getParamet
	sub	edx, 1
	je	SHORT $LN9@getParamet
	sub	edx, 1
	je	SHORT $LN11@getParamet
	sub	edx, 1
	je	SHORT $LN11@getParamet
	cmp	edx, 1
	jne	SHORT $LN15@getParamet
$LN11@getParamet:
; File E:\FoxSuite\shimmer\vst-2.4-sdk\vstsdk2.4\pluginterfaces\vst2.x\aeffect.h

; 296  : 	char* result = strncpy (dst, src, maxLen);

	lea	rdx, OFFSET FLAT:??_C@_02KLOHGLOJ@Hz@
; File E:\FoxSuite\shimmer\Shimmer.cpp

; 432  :         break;

	jmp	SHORT $LN40@getParamet
?getParameterLabel@Shimmer@@UEAAXHPEAD@Z ENDP		; Shimmer::getParameterLabel
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\Shimmer.cpp
; File E:\FoxSuite\shimmer\vst-2.4-sdk\vstsdk2.4\pluginterfaces\vst2.x\aeffect.h
; File E:\FoxSuite\shimmer\Shimmer.cpp
; File E:\FoxSuite\shimmer\vst-2.4-sdk\vstsdk2.4\pluginterfaces\vst2.x\aeffect.h
; File E:\FoxSuite\shimmer\Shimmer.cpp
; File E:\FoxSuite\shimmer\vst-2.4-sdk\vstsdk2.4\pluginterfaces\vst2.x\aeffect.h
; File E:\FoxSuite\shimmer\Shimmer.cpp
; File E:\FoxSuite\shimmer\include\utils.h
; File E:\FoxSuite\shimmer\Shimmer.cpp
; File E:\FoxSuite\shimmer\include\utils.h
; File E:\FoxSuite\shimmer\Shimmer.cpp
;	COMDAT ?getParameterDisplay@Shimmer@@UEAAXHPEAD@Z
_TEXT	SEGMENT
this$ = 48
index$ = 56
text$ = 64
?getParameterDisplay@Shimmer@@UEAAXHPEAD@Z PROC		; Shimmer::getParameterDisplay, COMDAT

; 456  : {    

$LN28:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, r8
	mov	rbx, rcx

; 457  :     switch (index) {

	cmp	edx, 5
	jg	$LN17@getParamet
	je	$LN8@getParamet
	test	edx, edx
	je	$LN4@getParamet
	sub	edx, 1
	je	SHORT $LN5@getParamet
	sub	edx, 1
	je	SHORT $LN7@getParamet
	sub	edx, 1
	je	SHORT $LN6@getParamet
	cmp	edx, 1
	jne	$LN15@getParamet

; 483  :         int pitIdx = shim_intervals / DELTA_PARAMETER_BETWEEN_INTERVALS;

	movss	xmm0, DWORD PTR [rcx+260]
; File E:\FoxSuite\shimmer\vst-2.4-sdk\vstsdk2.4\pluginterfaces\vst2.x\aeffect.h

; 296  : 	char* result = strncpy (dst, src, maxLen);

	mov	r8d, 8
; File E:\FoxSuite\shimmer\Shimmer.cpp

; 483  :         int pitIdx = shim_intervals / DELTA_PARAMETER_BETWEEN_INTERVALS;

	mulss	xmm0, DWORD PTR __real@41200000
; File E:\FoxSuite\shimmer\vst-2.4-sdk\vstsdk2.4\pluginterfaces\vst2.x\aeffect.h

; 296  : 	char* result = strncpy (dst, src, maxLen);

	mov	rcx, rdi
; File E:\FoxSuite\shimmer\Shimmer.cpp

; 483  :         int pitIdx = shim_intervals / DELTA_PARAMETER_BETWEEN_INTERVALS;

	cvttss2si eax, xmm0

; 484  :         vst_strncpy(text, INTERVALS_NAMES_STRING[pitIdx], kVstMaxParamStrLen);

	movsxd	rdx, eax
	lea	rax, OFFSET FLAT:?INTERVALS_NAMES_STRING@@3PAPEADA ; INTERVALS_NAMES_STRING
; File E:\FoxSuite\shimmer\vst-2.4-sdk\vstsdk2.4\pluginterfaces\vst2.x\aeffect.h

; 296  : 	char* result = strncpy (dst, src, maxLen);

	mov	rdx, QWORD PTR [rax+rdx*8]
	call	QWORD PTR __imp_strncpy

; 297  : 	dst[maxLen] = 0;

	mov	BYTE PTR [rdi+8], 0
; File E:\FoxSuite\shimmer\Shimmer.cpp

; 485  :         break; 

	jmp	$LN15@getParamet
$LN6@getParamet:

; 465  :     }
; 466  :     case Param_shimmer: {
; 467  :         float2string(shim_shimmer * 10, text, kVstMaxParamStrLen);

	movss	xmm1, DWORD PTR [rcx+256]

; 468  :         break;

	jmp	$LN24@getParamet
$LN7@getParamet:

; 469  :     }
; 470  :     case Param_decay: {
; 471  :         float2string(shim_decay * MAX_REVERB_DECAY_IN_SECONDS, text, kVstMaxParamStrLen);

	movss	xmm1, DWORD PTR [rcx+264]
	mulss	xmm1, DWORD PTR __real@41f00000

; 472  :         break;

	jmp	$LN25@getParamet
$LN5@getParamet:

; 461  :     }
; 462  :     case Param_roomSize: {
; 463  :         float2string(shim_roomSize * 10, text, kVstMaxParamStrLen);

	movss	xmm1, DWORD PTR [rcx+252]

; 464  :         break;

	jmp	$LN24@getParamet
$LN4@getParamet:

; 458  :     case Param_mix: {
; 459  :         float2string(shim_mix * 10, text, kVstMaxParamStrLen);

	movss	xmm1, DWORD PTR [rcx+248]

; 460  :         break;

	jmp	$LN24@getParamet
$LN8@getParamet:

; 473  :     }
; 474  :     case Param_damping: {
; 475  :         float2string(shim_damping * 10, text, kVstMaxParamStrLen);

	movss	xmm1, DWORD PTR [rcx+268]

; 476  :         break;

	jmp	$LN24@getParamet
$LN17@getParamet:

; 457  :     switch (index) {

	sub	edx, 6
	je	$LN9@getParamet
	sub	edx, 1
	je	SHORT $LN12@getParamet
	sub	edx, 1
	je	SHORT $LN11@getParamet
	sub	edx, 1
	je	SHORT $LN13@getParamet
	cmp	edx, 1
	jne	$LN15@getParamet
; File E:\FoxSuite\shimmer\include\utils.h

; 61   :     return minvalue + value * (maxValue - minvalue);

	movss	xmm1, DWORD PTR [rcx+288]
	mulss	xmm1, DWORD PTR __real@45d98000
	addss	xmm1, DWORD PTR __real@42200000
; File E:\FoxSuite\shimmer\Shimmer.cpp

; 503  :         break;

	jmp	SHORT $LN25@getParamet
$LN13@getParamet:
; File E:\FoxSuite\shimmer\include\utils.h

; 61   :     return minvalue + value * (maxValue - minvalue);

	movss	xmm1, DWORD PTR ?LPF_FILTER_MAX_FREQ_LOG@@3MB
	subss	xmm1, DWORD PTR ?LPF_FILTER_MIN_FREQ_LOG@@3MB
	mulss	xmm1, DWORD PTR [rcx+284]
	addss	xmm1, DWORD PTR ?LPF_FILTER_MIN_FREQ_LOG@@3MB
; File E:\FoxSuite\shimmer\Shimmer.cpp

; 496  :         float lpf = exp(mapValueIntoRange(shim_lpf, LPF_FILTER_MIN_FREQ_LOG, LPF_FILTER_MAX_FREQ_LOG));

	cvtps2pd xmm0, xmm1
	call	QWORD PTR __imp_exp

; 497  :         float2string(lpf, text, kVstMaxParamStrLen);

	mov	rax, QWORD PTR [rbx]
	xorps	xmm1, xmm1
	cvtsd2ss xmm1, xmm0
	mov	r8, rdi
	mov	rcx, rbx

; 498  :         break;

	jmp	SHORT $LN26@getParamet
$LN11@getParamet:

; 486  :     }
; 487  :     case Param_modRate: {
; 488  :         float2string(shim_modRate * MAX_MOD_RATE, text, kVstMaxParamStrLen);

	movss	xmm1, DWORD PTR [rcx+276]
	mulss	xmm1, DWORD PTR __real@40a00000

; 489  :         break;

	jmp	SHORT $LN25@getParamet
$LN12@getParamet:

; 490  :     }
; 491  :     case Param_modDepth: {
; 492  :         float2string(shim_modDepth * 10, text, kVstMaxParamStrLen);

	movss	xmm1, DWORD PTR [rcx+280]

; 493  :         break;

	jmp	SHORT $LN24@getParamet
$LN9@getParamet:

; 477  :     }
; 478  :     case Param_space: {
; 479  :         float2string(shim_space * 10, text, kVstMaxParamStrLen);

	movss	xmm1, DWORD PTR [rcx+272]
$LN24@getParamet:

; 504  :     }      
; 505  :     default: {
; 506  :         break;
; 507  :     }
; 508  :     }
; 509  : }

	mulss	xmm1, DWORD PTR __real@41200000
$LN25@getParamet:
	mov	rax, QWORD PTR [rcx]
$LN26@getParamet:
	mov	r9d, 8
	call	QWORD PTR [rax+312]
$LN15@getParamet:
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?getParameterDisplay@Shimmer@@UEAAXHPEAD@Z ENDP		; Shimmer::getParameterDisplay
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\Shimmer.cpp
; File E:\FoxSuite\shimmer\vst-2.4-sdk\vstsdk2.4\pluginterfaces\vst2.x\aeffect.h
; File E:\FoxSuite\shimmer\Shimmer.cpp
; File E:\FoxSuite\shimmer\vst-2.4-sdk\vstsdk2.4\pluginterfaces\vst2.x\aeffect.h
; File E:\FoxSuite\shimmer\Shimmer.cpp
; File E:\FoxSuite\shimmer\vst-2.4-sdk\vstsdk2.4\pluginterfaces\vst2.x\aeffect.h
; File E:\FoxSuite\shimmer\Shimmer.cpp
; File E:\FoxSuite\shimmer\vst-2.4-sdk\vstsdk2.4\pluginterfaces\vst2.x\aeffect.h
; File E:\FoxSuite\shimmer\Shimmer.cpp
; File E:\FoxSuite\shimmer\vst-2.4-sdk\vstsdk2.4\pluginterfaces\vst2.x\aeffect.h
; File E:\FoxSuite\shimmer\Shimmer.cpp
; File E:\FoxSuite\shimmer\vst-2.4-sdk\vstsdk2.4\pluginterfaces\vst2.x\aeffect.h
; File E:\FoxSuite\shimmer\Shimmer.cpp
; File E:\FoxSuite\shimmer\vst-2.4-sdk\vstsdk2.4\pluginterfaces\vst2.x\aeffect.h
; File E:\FoxSuite\shimmer\Shimmer.cpp
; File E:\FoxSuite\shimmer\vst-2.4-sdk\vstsdk2.4\pluginterfaces\vst2.x\aeffect.h
; File E:\FoxSuite\shimmer\Shimmer.cpp
; File E:\FoxSuite\shimmer\vst-2.4-sdk\vstsdk2.4\pluginterfaces\vst2.x\aeffect.h
; File E:\FoxSuite\shimmer\Shimmer.cpp
; File E:\FoxSuite\shimmer\vst-2.4-sdk\vstsdk2.4\pluginterfaces\vst2.x\aeffect.h
; File E:\FoxSuite\shimmer\Shimmer.cpp
; File E:\FoxSuite\shimmer\vst-2.4-sdk\vstsdk2.4\pluginterfaces\vst2.x\aeffect.h
; File E:\FoxSuite\shimmer\Shimmer.cpp
;	COMDAT ?getParameterName@Shimmer@@UEAAXHPEAD@Z
_TEXT	SEGMENT
this$ = 48
index$ = 56
text$ = 64
?getParameterName@Shimmer@@UEAAXHPEAD@Z PROC		; Shimmer::getParameterName, COMDAT

; 515  : {

$LN42:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, r8

; 516  :     switch (index) {

	cmp	edx, 5
	jg	SHORT $LN17@getParamet
	je	SHORT $LN8@getParamet
	test	edx, edx
	je	SHORT $LN4@getParamet
	sub	edx, 1
	je	SHORT $LN5@getParamet
	sub	edx, 1
	je	SHORT $LN7@getParamet
	sub	edx, 1
	je	SHORT $LN6@getParamet
	cmp	edx, 1
	jne	$LN15@getParamet
; File E:\FoxSuite\shimmer\vst-2.4-sdk\vstsdk2.4\pluginterfaces\vst2.x\aeffect.h

; 296  : 	char* result = strncpy (dst, src, maxLen);

	lea	rdx, OFFSET FLAT:??_C@_09ONNCCMEP@Intervals@
; File E:\FoxSuite\shimmer\Shimmer.cpp

; 543  :         break;

	jmp	SHORT $LN40@getParamet
$LN6@getParamet:
; File E:\FoxSuite\shimmer\vst-2.4-sdk\vstsdk2.4\pluginterfaces\vst2.x\aeffect.h

; 296  : 	char* result = strncpy (dst, src, maxLen);

	lea	rdx, OFFSET FLAT:??_C@_07CNCNAGDO@Shimmer@
; File E:\FoxSuite\shimmer\Shimmer.cpp

; 527  :         break;

	jmp	SHORT $LN40@getParamet
$LN7@getParamet:
; File E:\FoxSuite\shimmer\vst-2.4-sdk\vstsdk2.4\pluginterfaces\vst2.x\aeffect.h

; 296  : 	char* result = strncpy (dst, src, maxLen);

	lea	rdx, OFFSET FLAT:??_C@_05BFFNNFFO@Decay@
; File E:\FoxSuite\shimmer\Shimmer.cpp

; 531  :         break;

	jmp	SHORT $LN40@getParamet
$LN5@getParamet:
; File E:\FoxSuite\shimmer\vst-2.4-sdk\vstsdk2.4\pluginterfaces\vst2.x\aeffect.h

; 296  : 	char* result = strncpy (dst, src, maxLen);

	lea	rdx, OFFSET FLAT:??_C@_04EBKMHHBE@Size@
; File E:\FoxSuite\shimmer\Shimmer.cpp

; 523  :         break;

	jmp	SHORT $LN40@getParamet
$LN4@getParamet:
; File E:\FoxSuite\shimmer\vst-2.4-sdk\vstsdk2.4\pluginterfaces\vst2.x\aeffect.h

; 296  : 	char* result = strncpy (dst, src, maxLen);

	lea	rdx, OFFSET FLAT:??_C@_03BHCFKDFC@Mix@
; File E:\FoxSuite\shimmer\Shimmer.cpp

; 519  :         break;

	jmp	SHORT $LN40@getParamet
$LN8@getParamet:
; File E:\FoxSuite\shimmer\vst-2.4-sdk\vstsdk2.4\pluginterfaces\vst2.x\aeffect.h

; 296  : 	char* result = strncpy (dst, src, maxLen);

	lea	rdx, OFFSET FLAT:??_C@_07HJKIPEFI@Damping@
; File E:\FoxSuite\shimmer\Shimmer.cpp

; 535  :         break;

	jmp	SHORT $LN40@getParamet
$LN17@getParamet:

; 516  :     switch (index) {

	sub	edx, 6
	je	SHORT $LN9@getParamet
	sub	edx, 1
	je	SHORT $LN12@getParamet
	sub	edx, 1
	je	SHORT $LN11@getParamet
	sub	edx, 1
	je	SHORT $LN13@getParamet
	cmp	edx, 1
	jne	SHORT $LN15@getParamet
; File E:\FoxSuite\shimmer\vst-2.4-sdk\vstsdk2.4\pluginterfaces\vst2.x\aeffect.h

; 296  : 	char* result = strncpy (dst, src, maxLen);

	lea	rdx, OFFSET FLAT:??_C@_03EKIEJGAC@HPF@
; File E:\FoxSuite\shimmer\Shimmer.cpp

; 559  :         break;

	jmp	SHORT $LN40@getParamet
$LN13@getParamet:
; File E:\FoxSuite\shimmer\vst-2.4-sdk\vstsdk2.4\pluginterfaces\vst2.x\aeffect.h

; 296  : 	char* result = strncpy (dst, src, maxLen);

	lea	rdx, OFFSET FLAT:??_C@_03MFOGABFF@LPF@
; File E:\FoxSuite\shimmer\Shimmer.cpp

; 555  :         break;

	jmp	SHORT $LN40@getParamet
$LN11@getParamet:
; File E:\FoxSuite\shimmer\vst-2.4-sdk\vstsdk2.4\pluginterfaces\vst2.x\aeffect.h

; 296  : 	char* result = strncpy (dst, src, maxLen);

	lea	rdx, OFFSET FLAT:??_C@_08MNIOIDHF@Mod?5Rate@
; File E:\FoxSuite\shimmer\Shimmer.cpp

; 547  :         break;

	jmp	SHORT $LN40@getParamet
$LN12@getParamet:
; File E:\FoxSuite\shimmer\vst-2.4-sdk\vstsdk2.4\pluginterfaces\vst2.x\aeffect.h

; 296  : 	char* result = strncpy (dst, src, maxLen);

	lea	rdx, OFFSET FLAT:??_C@_09DPAPPDMJ@Mod?5Depth@
; File E:\FoxSuite\shimmer\Shimmer.cpp

; 551  :         break;

	jmp	SHORT $LN40@getParamet
$LN9@getParamet:
; File E:\FoxSuite\shimmer\vst-2.4-sdk\vstsdk2.4\pluginterfaces\vst2.x\aeffect.h

; 296  : 	char* result = strncpy (dst, src, maxLen);

	lea	rdx, OFFSET FLAT:??_C@_05OMHELODH@Space@
$LN40@getParamet:
; File E:\FoxSuite\shimmer\Shimmer.cpp

; 565  : }

	mov	r8d, 8
	mov	rcx, rbx
	call	QWORD PTR __imp_strncpy
	mov	BYTE PTR [rbx+8], 0
$LN15@getParamet:
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?getParameterName@Shimmer@@UEAAXHPEAD@Z ENDP		; Shimmer::getParameterName
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\Shimmer.cpp
; File E:\FoxSuite\shimmer\include\utils.h
; File E:\FoxSuite\shimmer\Shimmer.cpp
; File E:\FoxSuite\shimmer\include\utils.h
; File E:\FoxSuite\shimmer\Shimmer.cpp
; File E:\FoxSuite\shimmer\include\utils.h
; File E:\FoxSuite\shimmer\Shimmer.cpp
; File E:\FoxSuite\shimmer\include\utils.h
; File E:\FoxSuite\shimmer\Shimmer.cpp
;	COMDAT ?InitPresets@Shimmer@@AEAAXXZ
_TEXT	SEGMENT
this$ = 80
?InitPresets@Shimmer@@AEAAXXZ PROC			; Shimmer::InitPresets, COMDAT

; 576  : {

$LN10:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rsi
	mov	QWORD PTR [rax+24], rdi
	push	r15
	sub	rsp, 64					; 00000040H
	movaps	XMMWORD PTR [rax-24], xmm6

; 577  :     // Instruction to allow the DAW to save parameters as currently shown on the UI
; 578  :     programsAreChunks(true);

	mov	dl, 1
	movaps	XMMWORD PTR [rax-40], xmm7
	mov	rbx, rcx
	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+216]

; 579  : 
; 580  :     // Create object for presets
; 581  :     shim_presets = new ShimmerPresets[NUM_PRESETS];

	mov	ecx, 340				; 00000154H
	call	??_U@YAPEAX_K@Z				; operator new[]

; 582  : 
; 583  :     /*----------------------------------------------------*/
; 584  :     // "Default" preset
; 585  :     strcpy(shim_presets[0].name, "Default");    

	lea	rdx, OFFSET FLAT:??_C@_07MCAEODGB@Default@
	mov	QWORD PTR [rbx+240], rax
	lea	rcx, QWORD PTR [rax+44]
	call	QWORD PTR __imp_strcpy

; 586  :     shim_presets[0].shim_mix = 0.5;

	mov	rax, QWORD PTR [rbx+240]

; 587  :     shim_presets[0].shim_roomSize = 0.4;
; 588  :     shim_presets[0].shim_decay = 0.2;
; 589  :     shim_presets[0].shim_damping = 0.5;
; 590  :     shim_presets[0].shim_space = 0.5;
; 591  :     shim_presets[0].shim_shimmer = 0.5;
; 592  :     shim_presets[0].shim_intervals = 0.71;
; 593  :     shim_presets[0].shim_modRate = 0.0;
; 594  :     shim_presets[0].shim_modDepth = 0.0;
; 595  :     shim_presets[0].shim_lpf = 1.0;
; 596  :     shim_presets[0].shim_hpf = 0.0;
; 597  : 
; 598  :     /*----------------------------------------------------*/
; 599  :     // "Small Room" 
; 600  :     strcpy(shim_presets[1].name, "Small Room");

	lea	rdx, OFFSET FLAT:??_C@_0L@GEJFJLEL@Small?5Room@
	mov	edi, 1056964608				; 3f000000H
	xor	esi, esi
	mov	r15d, 1065353216			; 3f800000H
	mov	DWORD PTR [rax], edi
	mov	rax, QWORD PTR [rbx+240]
	mov	DWORD PTR [rax+4], 1053609165		; 3ecccccdH
	mov	rax, QWORD PTR [rbx+240]
	mov	DWORD PTR [rax+16], 1045220557		; 3e4ccccdH
	mov	rax, QWORD PTR [rbx+240]
	mov	DWORD PTR [rax+20], edi
	mov	rax, QWORD PTR [rbx+240]
	mov	DWORD PTR [rax+24], edi
	mov	rax, QWORD PTR [rbx+240]
	mov	DWORD PTR [rax+8], edi
	mov	rax, QWORD PTR [rbx+240]
	mov	DWORD PTR [rax+12], 1060487823		; 3f35c28fH
	mov	rax, QWORD PTR [rbx+240]
	mov	DWORD PTR [rax+28], esi
	mov	rax, QWORD PTR [rbx+240]
	mov	DWORD PTR [rax+32], esi
	mov	rax, QWORD PTR [rbx+240]
	mov	DWORD PTR [rax+36], r15d
	mov	rax, QWORD PTR [rbx+240]
	mov	DWORD PTR [rax+40], esi
	mov	rcx, QWORD PTR [rbx+240]
	add	rcx, 112				; 00000070H
	call	QWORD PTR __imp_strcpy

; 601  :     shim_presets[1].shim_mix = 0.5;

	mov	rax, QWORD PTR [rbx+240]

; 602  :     shim_presets[1].shim_roomSize = 0.1;
; 603  :     shim_presets[1].shim_decay = 0.1;
; 604  :     shim_presets[1].shim_damping = 0.15;
; 605  :     shim_presets[1].shim_space = 0.25;
; 606  :     shim_presets[1].shim_shimmer = 0.0;
; 607  :     shim_presets[1].shim_intervals = 0.1;
; 608  :     shim_presets[1].shim_modRate = 0.0;
; 609  :     shim_presets[1].shim_modDepth = 0.0;
; 610  :     shim_presets[1].shim_lpf = 1.0;
; 611  :     shim_presets[1].shim_hpf = 0.0;
; 612  :      
; 613  :     // "Hall" 
; 614  :     strcpy(shim_presets[2].name, "Hall");

	lea	rdx, OFFSET FLAT:??_C@_04FKEBJNOD@Hall@
	mov	DWORD PTR [rax+68], edi
	mov	edi, 1036831949				; 3dcccccdH
	mov	rax, QWORD PTR [rbx+240]
	mov	DWORD PTR [rax+72], edi
	mov	rax, QWORD PTR [rbx+240]
	mov	DWORD PTR [rax+84], edi
	mov	rax, QWORD PTR [rbx+240]
	mov	DWORD PTR [rax+88], 1041865114		; 3e19999aH
	mov	rax, QWORD PTR [rbx+240]
	mov	DWORD PTR [rax+92], 1048576000		; 3e800000H
	mov	rax, QWORD PTR [rbx+240]
	mov	DWORD PTR [rax+76], esi
	mov	rax, QWORD PTR [rbx+240]
	mov	DWORD PTR [rax+80], edi
	mov	rax, QWORD PTR [rbx+240]
	mov	DWORD PTR [rax+96], esi
	mov	rax, QWORD PTR [rbx+240]
	mov	DWORD PTR [rax+100], esi
	mov	rax, QWORD PTR [rbx+240]
	mov	DWORD PTR [rax+104], r15d
	mov	rax, QWORD PTR [rbx+240]
	mov	DWORD PTR [rax+108], esi
	mov	rcx, QWORD PTR [rbx+240]
	add	rcx, 180				; 000000b4H
	call	QWORD PTR __imp_strcpy

; 615  :     shim_presets[2].shim_mix = 0.7;

	mov	rax, QWORD PTR [rbx+240]

; 616  :     shim_presets[2].shim_roomSize = 0.6;

	mov	esi, 1058642330				; 3f19999aH

; 617  :     shim_presets[2].shim_decay = 0.4;
; 618  :     shim_presets[2].shim_damping = 0.3;
; 619  :     shim_presets[2].shim_space = 0.6;
; 620  :     shim_presets[2].shim_shimmer = 0.0;

	xor	ecx, ecx
	mov	DWORD PTR [rax+136], 1060320051		; 3f333333H
	mov	rax, QWORD PTR [rbx+240]
	mov	DWORD PTR [rax+140], esi
	mov	rax, QWORD PTR [rbx+240]
	mov	DWORD PTR [rax+152], 1053609165		; 3ecccccdH
	mov	rax, QWORD PTR [rbx+240]
	mov	DWORD PTR [rax+156], 1050253722		; 3e99999aH
	mov	rax, QWORD PTR [rbx+240]
	mov	DWORD PTR [rax+160], esi
	mov	rax, QWORD PTR [rbx+240]

; 624  :     shim_presets[2].shim_lpf = mapValueOutsideRange(log(16000.0), MIN_LPF_FREQUENCY_LOG, MAX_LPF_FREQUENCY_LOG);

	movsd	xmm0, QWORD PTR __real@40cf400000000000
	movss	xmm7, DWORD PTR ?MAX_LPF_FREQUENCY_LOG@@3MB
	movss	xmm6, DWORD PTR ?MIN_LPF_FREQUENCY_LOG@@3MB
	mov	DWORD PTR [rax+144], ecx
	mov	rax, QWORD PTR [rbx+240]
	mov	DWORD PTR [rax+148], edi
	mov	rax, QWORD PTR [rbx+240]
	mov	DWORD PTR [rax+164], ecx
	mov	rax, QWORD PTR [rbx+240]
	mov	DWORD PTR [rax+168], ecx
	call	QWORD PTR __imp_log
	mov	rax, QWORD PTR [rbx+240]
; File E:\FoxSuite\shimmer\include\utils.h

; 69   :     return (value - minValue) / (maxValue - minValue);

	subss	xmm7, xmm6
; File E:\FoxSuite\shimmer\Shimmer.cpp

; 624  :     shim_presets[2].shim_lpf = mapValueOutsideRange(log(16000.0), MIN_LPF_FREQUENCY_LOG, MAX_LPF_FREQUENCY_LOG);

	xorps	xmm1, xmm1

; 626  : 
; 627  :     // "Ambience Damped" 
; 628  :     strcpy(shim_presets[3].name, "Ambience Damped");

	lea	rdx, OFFSET FLAT:??_C@_0BA@JIEKPJGJ@Ambience?5Damped@
	cvtsd2ss xmm1, xmm0
; File E:\FoxSuite\shimmer\include\utils.h

; 69   :     return (value - minValue) / (maxValue - minValue);

	subss	xmm1, xmm6
	divss	xmm1, xmm7
; File E:\FoxSuite\shimmer\Shimmer.cpp

; 624  :     shim_presets[2].shim_lpf = mapValueOutsideRange(log(16000.0), MIN_LPF_FREQUENCY_LOG, MAX_LPF_FREQUENCY_LOG);

	movss	DWORD PTR [rax+172], xmm1

; 625  :     shim_presets[2].shim_hpf = 0.0;

	mov	rax, QWORD PTR [rbx+240]
	and	DWORD PTR [rax+176], 0

; 626  : 
; 627  :     // "Ambience Damped" 
; 628  :     strcpy(shim_presets[3].name, "Ambience Damped");

	mov	rcx, QWORD PTR [rbx+240]
	add	rcx, 248				; 000000f8H
	call	QWORD PTR __imp_strcpy

; 629  :     shim_presets[3].shim_mix = 0.8;

	mov	rax, QWORD PTR [rbx+240]

; 630  :     shim_presets[3].shim_roomSize = 0.6;
; 631  :     shim_presets[3].shim_decay = 0.6;
; 632  :     shim_presets[3].shim_damping = 0.8;
; 633  :     shim_presets[3].shim_space = 0.7;
; 634  :     shim_presets[3].shim_shimmer = 1.0;
; 635  :     shim_presets[3].shim_intervals = 0.71;
; 636  :     shim_presets[3].shim_modRate = 0.0;
; 637  :     shim_presets[3].shim_modDepth = 0.0;
; 638  :     shim_presets[3].shim_lpf = 1.0;
; 639  :     shim_presets[3].shim_hpf = mapValueOutsideRange(150.0, MIN_HPF_FREQUENCY, MAX_HPF_FREQUENCY);
; 640  : 
; 641  :     // "Ambience Modulated" 
; 642  :     strcpy(shim_presets[4].name, "Ambience Modulated");

	lea	rdx, OFFSET FLAT:??_C@_0BD@CJOOIIIC@Ambience?5Modulated@
	mov	edi, 1061997773				; 3f4ccccdH
	mov	DWORD PTR [rax+204], edi
	mov	rax, QWORD PTR [rbx+240]
	mov	DWORD PTR [rax+208], esi
	mov	rax, QWORD PTR [rbx+240]
	mov	DWORD PTR [rax+220], esi
	mov	rax, QWORD PTR [rbx+240]
	mov	DWORD PTR [rax+224], edi
	mov	rax, QWORD PTR [rbx+240]
	mov	DWORD PTR [rax+228], 1060320051		; 3f333333H
	mov	rax, QWORD PTR [rbx+240]
	mov	DWORD PTR [rax+212], r15d
	mov	rax, QWORD PTR [rbx+240]
	mov	DWORD PTR [rax+216], 1060487823		; 3f35c28fH
	mov	rax, QWORD PTR [rbx+240]
	and	DWORD PTR [rax+232], 0
	mov	rax, QWORD PTR [rbx+240]
	and	DWORD PTR [rax+236], 0
	mov	rax, QWORD PTR [rbx+240]
	mov	DWORD PTR [rax+240], r15d
	mov	rax, QWORD PTR [rbx+240]
	mov	DWORD PTR [rax+244], 1006297021		; 3bfadfbdH
	mov	rcx, QWORD PTR [rbx+240]
	add	rcx, 316				; 0000013cH
	call	QWORD PTR __imp_strcpy

; 643  :     shim_presets[4].shim_mix = 0.8;

	mov	rax, QWORD PTR [rbx+240]

; 652  :     shim_presets[4].shim_lpf = mapValueOutsideRange(log(17000.0), MIN_LPF_FREQUENCY_LOG, MAX_LPF_FREQUENCY_LOG);;

	movsd	xmm0, QWORD PTR __real@40d09a0000000000
	movss	xmm7, DWORD PTR ?MAX_LPF_FREQUENCY_LOG@@3MB
	movss	xmm6, DWORD PTR ?MIN_LPF_FREQUENCY_LOG@@3MB
	mov	DWORD PTR [rax+272], edi
	mov	rax, QWORD PTR [rbx+240]
	mov	DWORD PTR [rax+276], esi
	mov	rax, QWORD PTR [rbx+240]
	mov	DWORD PTR [rax+288], 1060320051		; 3f333333H
	mov	rax, QWORD PTR [rbx+240]
	mov	DWORD PTR [rax+292], 1045220557		; 3e4ccccdH
	mov	rax, QWORD PTR [rbx+240]
	mov	DWORD PTR [rax+296], 1060320051		; 3f333333H
	mov	rax, QWORD PTR [rbx+240]
	mov	DWORD PTR [rax+280], r15d
	mov	rax, QWORD PTR [rbx+240]
	mov	DWORD PTR [rax+284], 1062165545		; 3f4f5c29H
	mov	rax, QWORD PTR [rbx+240]
	mov	DWORD PTR [rax+300], 1053609165		; 3ecccccdH
	mov	rax, QWORD PTR [rbx+240]
	mov	DWORD PTR [rax+304], 1056964608		; 3f000000H
	call	QWORD PTR __imp_log
	mov	rax, QWORD PTR [rbx+240]
; File E:\FoxSuite\shimmer\include\utils.h

; 69   :     return (value - minValue) / (maxValue - minValue);

	subss	xmm7, xmm6
; File E:\FoxSuite\shimmer\Shimmer.cpp

; 652  :     shim_presets[4].shim_lpf = mapValueOutsideRange(log(17000.0), MIN_LPF_FREQUENCY_LOG, MAX_LPF_FREQUENCY_LOG);;

	xorps	xmm1, xmm1
	cvtsd2ss xmm1, xmm0
; File E:\FoxSuite\shimmer\include\utils.h

; 69   :     return (value - minValue) / (maxValue - minValue);

	subss	xmm1, xmm6
	divss	xmm1, xmm7
; File E:\FoxSuite\shimmer\Shimmer.cpp

; 652  :     shim_presets[4].shim_lpf = mapValueOutsideRange(log(17000.0), MIN_LPF_FREQUENCY_LOG, MAX_LPF_FREQUENCY_LOG);;

	movss	DWORD PTR [rax+308], xmm1

; 653  :     shim_presets[4].shim_hpf = 0.0;    

	mov	rax, QWORD PTR [rbx+240]
	and	DWORD PTR [rax+312], 0

; 654  : 
; 655  :     // Set the program when creating a new plugin instance
; 656  :     int initIdx = 0;
; 657  :     Shimmer::setProgram(initIdx);

	xor	edx, edx
	mov	rcx, rbx
	call	?setProgram@Shimmer@@UEAAXH@Z		; Shimmer::setProgram

; 658  :     shim_mix = shim_presets[initIdx].shim_mix;

	mov	rcx, QWORD PTR [rbx+240]

; 659  :     shim_roomSize = shim_presets[initIdx].shim_roomSize;
; 660  :     shim_decay = shim_presets[initIdx].shim_decay;
; 661  :     shim_damping = shim_presets[initIdx].shim_damping;
; 662  :     shim_space = shim_presets[initIdx].shim_space;
; 663  :     shim_shimmer = shim_presets[initIdx].shim_shimmer;
; 664  :     shim_intervals = shim_presets[initIdx].shim_intervals;
; 665  :     shim_modRate = shim_presets[initIdx].shim_modRate;
; 666  :     shim_modDepth = shim_presets[initIdx].shim_modDepth;
; 667  :     shim_lpf = shim_presets[initIdx].shim_lpf;
; 668  :     shim_hpf = shim_presets[initIdx].shim_hpf;
; 669  : }

	mov	rsi, QWORD PTR [rsp+88]
	mov	rdi, QWORD PTR [rsp+96]
	movaps	xmm6, XMMWORD PTR [rsp+48]
	mov	eax, DWORD PTR [rcx]
	movaps	xmm7, XMMWORD PTR [rsp+32]
	mov	DWORD PTR [rbx+248], eax
	mov	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR [rbx+252], eax
	mov	eax, DWORD PTR [rcx+16]
	mov	DWORD PTR [rbx+264], eax
	mov	eax, DWORD PTR [rcx+20]
	mov	DWORD PTR [rbx+268], eax
	mov	eax, DWORD PTR [rcx+24]
	mov	DWORD PTR [rbx+272], eax
	mov	eax, DWORD PTR [rcx+8]
	mov	DWORD PTR [rbx+256], eax
	mov	eax, DWORD PTR [rcx+12]
	mov	DWORD PTR [rbx+260], eax
	mov	eax, DWORD PTR [rcx+28]
	mov	DWORD PTR [rbx+276], eax
	mov	eax, DWORD PTR [rcx+32]
	mov	DWORD PTR [rbx+280], eax
	mov	eax, DWORD PTR [rcx+36]
	mov	DWORD PTR [rbx+284], eax
	mov	eax, DWORD PTR [rcx+40]
	mov	DWORD PTR [rbx+288], eax
	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 64					; 00000040H
	pop	r15
	ret	0
?InitPresets@Shimmer@@AEAAXXZ ENDP			; Shimmer::InitPresets
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\Shimmer.cpp
;	COMDAT ?setProgram@Shimmer@@UEAAXH@Z
_TEXT	SEGMENT
this$ = 48
program$ = 56
?setProgram@Shimmer@@UEAAXH@Z PROC			; Shimmer::setProgram, COMDAT

; 674  : {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 675  :     // Call the current implementation of "setProgram"
; 676  :     AudioEffect::setProgram(program);
; 677  : 
; 678  :     // Create an instante of ShimmerPresets with current preset
; 679  :     ShimmerPresets* cp = &shim_presets[program];

	movsxd	rax, edx
	mov	rdi, rcx
	imul	rbx, rax, 68				; 00000044H

; 680  : 
; 681  :     // Set each parameter
; 682  :     setParameter(Param_mix, cp->shim_mix);

	mov	rax, QWORD PTR [rcx]
	add	rbx, QWORD PTR [rcx+240]
	mov	DWORD PTR [rcx+40], edx
	xor	edx, edx
	movss	xmm2, DWORD PTR [rbx]
	call	QWORD PTR [rax+80]

; 683  :     setParameter(Param_roomSize, cp->shim_roomSize);

	mov	rax, QWORD PTR [rdi]
	mov	edx, 1
	movss	xmm2, DWORD PTR [rbx+4]
	mov	rcx, rdi
	call	QWORD PTR [rax+80]

; 684  :     setParameter(Param_decay, cp->shim_decay);

	mov	rax, QWORD PTR [rdi]
	mov	edx, 2
	movss	xmm2, DWORD PTR [rbx+16]
	mov	rcx, rdi
	call	QWORD PTR [rax+80]

; 685  :     setParameter(Param_damping, cp->shim_damping);

	mov	rax, QWORD PTR [rdi]
	mov	edx, 5
	movss	xmm2, DWORD PTR [rbx+20]
	mov	rcx, rdi
	call	QWORD PTR [rax+80]

; 686  :     setParameter(Param_space, cp->shim_space);

	mov	rax, QWORD PTR [rdi]
	mov	edx, 6
	movss	xmm2, DWORD PTR [rbx+24]
	mov	rcx, rdi
	call	QWORD PTR [rax+80]

; 687  :     setParameter(Param_shimmer, cp->shim_shimmer);

	mov	rax, QWORD PTR [rdi]
	mov	edx, 3
	movss	xmm2, DWORD PTR [rbx+8]
	mov	rcx, rdi
	call	QWORD PTR [rax+80]

; 688  :     setParameter(Param_intervals, cp->shim_intervals);

	mov	rax, QWORD PTR [rdi]
	mov	edx, 4
	movss	xmm2, DWORD PTR [rbx+12]
	mov	rcx, rdi
	call	QWORD PTR [rax+80]

; 689  :     setParameter(Param_modRate, cp->shim_modRate);

	mov	rax, QWORD PTR [rdi]
	mov	edx, 8
	movss	xmm2, DWORD PTR [rbx+28]
	mov	rcx, rdi
	call	QWORD PTR [rax+80]

; 690  :     setParameter(Param_modDepth, cp->shim_modDepth);

	mov	rax, QWORD PTR [rdi]
	mov	edx, 7
	movss	xmm2, DWORD PTR [rbx+32]
	mov	rcx, rdi
	call	QWORD PTR [rax+80]

; 691  :     setParameter(Param_lpf, cp->shim_lpf);

	mov	rax, QWORD PTR [rdi]
	mov	edx, 9
	movss	xmm2, DWORD PTR [rbx+36]
	mov	rcx, rdi
	call	QWORD PTR [rax+80]

; 692  :     setParameter(Param_hpf, cp->shim_hpf);

	mov	rax, QWORD PTR [rdi]
	mov	edx, 10
	movss	xmm2, DWORD PTR [rbx+40]
	mov	rcx, rdi

; 693  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi

; 692  :     setParameter(Param_hpf, cp->shim_hpf);

	rex_jmp	QWORD PTR [rax+80]
?setProgram@Shimmer@@UEAAXH@Z ENDP			; Shimmer::setProgram
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\Shimmer.cpp
;	COMDAT ?getProgramName@Shimmer@@UEAAXPEAD@Z
_TEXT	SEGMENT
this$ = 8
name$ = 16
?getProgramName@Shimmer@@UEAAXPEAD@Z PROC		; Shimmer::getProgramName, COMDAT

; 700  :     strcpy(name, shim_presets[curProgram].name);

	movsxd	rax, DWORD PTR [rcx+40]
	mov	r9, rdx
	mov	rdx, QWORD PTR [rcx+240]
	mov	rcx, r9
	imul	r8, rax, 68				; 00000044H
	add	rdx, 44					; 0000002cH
	add	rdx, r8
	rex_jmp	QWORD PTR __imp_strcpy
?getProgramName@Shimmer@@UEAAXPEAD@Z ENDP		; Shimmer::getProgramName
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\Shimmer.cpp
;	COMDAT ?getProgramNameIndexed@Shimmer@@UEAA_NHHPEAD@Z
_TEXT	SEGMENT
this$ = 48
category$ = 56
index$ = 64
text$ = 72
?getProgramNameIndexed@Shimmer@@UEAA_NHHPEAD@Z PROC	; Shimmer::getProgramNameIndexed, COMDAT

; 707  : {

$LN5:
	sub	rsp, 40					; 00000028H

; 708  :     if (index < NUM_PRESETS)

	cmp	r8d, 5
	jge	SHORT $LN2@getProgram

; 709  :     {
; 710  :         strcpy(text, shim_presets[index].name);

	movsxd	rax, r8d
	imul	rdx, rax, 68				; 00000044H
	mov	rax, QWORD PTR [rcx+240]
	mov	rcx, r9
	add	rax, 44					; 0000002cH
	add	rdx, rax
	call	QWORD PTR __imp_strcpy

; 711  :         return true;

	mov	al, 1
	jmp	SHORT $LN1@getProgram
$LN2@getProgram:

; 712  :     }
; 713  :     return false;

	xor	al, al
$LN1@getProgram:

; 714  : }

	add	rsp, 40					; 00000028H
	ret	0
?getProgramNameIndexed@Shimmer@@UEAA_NHHPEAD@Z ENDP	; Shimmer::getProgramNameIndexed
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\Shimmer.cpp
;	COMDAT ?getChunk@Shimmer@@UEAAHPEAPEAX_N@Z
_TEXT	SEGMENT
params$ = 0
this$ = 64
data$ = 72
isPreset$ = 80
?getChunk@Shimmer@@UEAAHPEAPEAX_N@Z PROC		; Shimmer::getChunk, COMDAT

; 723  : {    

$LN4:
	sub	rsp, 56					; 00000038H

; 724  :     ShimmerParameters params;
; 725  :     params.mix = this->shim_mix;
; 726  :     params.size = this->shim_roomSize;
; 727  :     params.decay = shim_decay;
; 728  :     params.shimmer = shim_shimmer;
; 729  :     params.interval = shim_intervals;
; 730  :     params.damping = shim_damping;
; 731  :     params.rate = shim_modRate;
; 732  :     params.depth = shim_modDepth;
; 733  :     params.space = shim_space;
; 734  :     params.lpf = shim_lpf;
; 735  :     params.hpf = shim_hpf;   
; 736  : 
; 737  :     *data = &params;

	lea	rax, QWORD PTR params$[rsp]
	mov	QWORD PTR [rdx], rax

; 738  : 
; 739  :     return sizeof(params);    

	mov	eax, 44					; 0000002cH

; 740  : }

	add	rsp, 56					; 00000038H
	ret	0
?getChunk@Shimmer@@UEAAHPEAPEAX_N@Z ENDP		; Shimmer::getChunk
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\Shimmer.cpp
;	COMDAT ?setChunk@Shimmer@@UEAAHPEAXH_N@Z
_TEXT	SEGMENT
this$ = 48
data$ = 56
byteSize$ = 64
isPreset$ = 72
?setChunk@Shimmer@@UEAAHPEAXH_N@Z PROC			; Shimmer::setChunk, COMDAT

; 744  : {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 745  :     ShimmerParameters* cp = (ShimmerParameters*)data;
; 746  :     setParameter(Param_mix, cp->mix);

	movss	xmm2, DWORD PTR [rdx]
	mov	rbx, rdx
	mov	rax, QWORD PTR [rcx]
	xor	edx, edx
	mov	rdi, rcx
	call	QWORD PTR [rax+80]

; 747  :     setParameter(Param_roomSize, cp->size);

	mov	rax, QWORD PTR [rdi]
	mov	edx, 1
	movss	xmm2, DWORD PTR [rbx+4]
	mov	rcx, rdi
	call	QWORD PTR [rax+80]

; 748  :     setParameter(Param_decay, cp->decay);

	mov	rax, QWORD PTR [rdi]
	mov	edx, 2
	movss	xmm2, DWORD PTR [rbx+8]
	mov	rcx, rdi
	call	QWORD PTR [rax+80]

; 749  :     setParameter(Param_damping, cp->damping);

	mov	rax, QWORD PTR [rdi]
	mov	edx, 5
	movss	xmm2, DWORD PTR [rbx+20]
	mov	rcx, rdi
	call	QWORD PTR [rax+80]

; 750  :     setParameter(Param_space, cp->space);

	mov	rax, QWORD PTR [rdi]
	mov	edx, 6
	movss	xmm2, DWORD PTR [rbx+32]
	mov	rcx, rdi
	call	QWORD PTR [rax+80]

; 751  :     setParameter(Param_shimmer, cp->shimmer);

	mov	rax, QWORD PTR [rdi]
	mov	edx, 3
	movss	xmm2, DWORD PTR [rbx+12]
	mov	rcx, rdi
	call	QWORD PTR [rax+80]

; 752  :     setParameter(Param_intervals, cp->interval);

	mov	rax, QWORD PTR [rdi]
	mov	edx, 4
	movss	xmm2, DWORD PTR [rbx+16]
	mov	rcx, rdi
	call	QWORD PTR [rax+80]

; 753  :     setParameter(Param_modRate, cp->rate);

	mov	rax, QWORD PTR [rdi]
	mov	edx, 8
	movss	xmm2, DWORD PTR [rbx+24]
	mov	rcx, rdi
	call	QWORD PTR [rax+80]

; 754  :     setParameter(Param_modDepth, cp->depth);

	mov	rax, QWORD PTR [rdi]
	mov	edx, 7
	movss	xmm2, DWORD PTR [rbx+28]
	mov	rcx, rdi
	call	QWORD PTR [rax+80]

; 755  :     setParameter(Param_lpf, cp->lpf);

	mov	rax, QWORD PTR [rdi]
	mov	edx, 9
	movss	xmm2, DWORD PTR [rbx+36]
	mov	rcx, rdi
	call	QWORD PTR [rax+80]

; 756  :     setParameter(Param_hpf, cp->hpf);

	mov	rax, QWORD PTR [rdi]
	mov	edx, 10
	movss	xmm2, DWORD PTR [rbx+40]
	mov	rcx, rdi
	call	QWORD PTR [rax+80]

; 757  : 
; 758  :     return 0;
; 759  : }

	mov	rbx, QWORD PTR [rsp+48]
	xor	eax, eax
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?setChunk@Shimmer@@UEAAHPEAXH_N@Z ENDP			; Shimmer::setChunk
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\Shimmer.cpp
; File E:\FoxSuite\shimmer\vst-2.4-sdk\vstsdk2.4\pluginterfaces\vst2.x\aeffect.h
; File E:\FoxSuite\shimmer\Shimmer.cpp
; File E:\FoxSuite\shimmer\vst-2.4-sdk\vstsdk2.4\pluginterfaces\vst2.x\aeffect.h
; File E:\FoxSuite\shimmer\Shimmer.cpp
;	COMDAT ?getEffectName@Shimmer@@UEAA_NPEAD@Z
_TEXT	SEGMENT
this$ = 48
name$ = 56
?getEffectName@Shimmer@@UEAA_NPEAD@Z PROC		; Shimmer::getEffectName, COMDAT

; 767  : {

$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
; File E:\FoxSuite\shimmer\vst-2.4-sdk\vstsdk2.4\pluginterfaces\vst2.x\aeffect.h

; 296  : 	char* result = strncpy (dst, src, maxLen);

	mov	r8d, 32					; 00000020H
	mov	rcx, rbx
	lea	rdx, OFFSET FLAT:??_C@_07CNCNAGDO@Shimmer@
	call	QWORD PTR __imp_strncpy
; File E:\FoxSuite\shimmer\Shimmer.cpp

; 769  :     return true;

	mov	al, 1
; File E:\FoxSuite\shimmer\vst-2.4-sdk\vstsdk2.4\pluginterfaces\vst2.x\aeffect.h

; 297  : 	dst[maxLen] = 0;

	mov	BYTE PTR [rbx+32], 0
; File E:\FoxSuite\shimmer\Shimmer.cpp

; 770  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?getEffectName@Shimmer@@UEAA_NPEAD@Z ENDP		; Shimmer::getEffectName
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\Shimmer.cpp
; File E:\FoxSuite\shimmer\vst-2.4-sdk\vstsdk2.4\pluginterfaces\vst2.x\aeffect.h
; File E:\FoxSuite\shimmer\Shimmer.cpp
; File E:\FoxSuite\shimmer\vst-2.4-sdk\vstsdk2.4\pluginterfaces\vst2.x\aeffect.h
; File E:\FoxSuite\shimmer\Shimmer.cpp
;	COMDAT ?getVendorString@Shimmer@@UEAA_NPEAD@Z
_TEXT	SEGMENT
this$ = 48
name$ = 56
?getVendorString@Shimmer@@UEAA_NPEAD@Z PROC		; Shimmer::getVendorString, COMDAT

; 775  : {

$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
; File E:\FoxSuite\shimmer\vst-2.4-sdk\vstsdk2.4\pluginterfaces\vst2.x\aeffect.h

; 296  : 	char* result = strncpy (dst, src, maxLen);

	mov	r8d, 64					; 00000040H
	mov	rcx, rbx
	lea	rdx, OFFSET FLAT:??_C@_09KHHOPKD@Fox?5Suite@
	call	QWORD PTR __imp_strncpy
; File E:\FoxSuite\shimmer\Shimmer.cpp

; 777  :     return true;

	mov	al, 1
; File E:\FoxSuite\shimmer\vst-2.4-sdk\vstsdk2.4\pluginterfaces\vst2.x\aeffect.h

; 297  : 	dst[maxLen] = 0;

	mov	BYTE PTR [rbx+64], 0
; File E:\FoxSuite\shimmer\Shimmer.cpp

; 778  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?getVendorString@Shimmer@@UEAA_NPEAD@Z ENDP		; Shimmer::getVendorString
_TEXT	ENDS
; Function compile flags: /Ogspy
; File E:\FoxSuite\shimmer\Shimmer.cpp
;	COMDAT ??1Shimmer@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1Shimmer@@UEAA@XZ PROC				; Shimmer::~Shimmer, COMDAT

; 785  : {

$LN23:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 786  :     //Free BranchReverb, MasterReverb and pitch shifters
; 787  :     delete MasterReverb;

	mov	rdi, QWORD PTR [rcx+304]
	lea	rax, OFFSET FLAT:??_7Shimmer@@6B@
	mov	QWORD PTR [rcx], rax
	mov	rbx, rcx
	test	rdi, rdi
	je	SHORT $LN10@Shimmer
	mov	rcx, rdi
	call	??1FDN@@QEAA@XZ				; FDN::~FDN
	mov	edx, 320				; 00000140H
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN10@Shimmer:

; 788  :     delete BranchReverb;

	mov	rdi, QWORD PTR [rbx+296]
	test	rdi, rdi
	je	SHORT $LN13@Shimmer
	mov	rcx, rdi
	call	??1FDN@@QEAA@XZ				; FDN::~FDN
	mov	edx, 320				; 00000140H
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN13@Shimmer:

; 789  :     delete PitchShift_1oct, PitchShift_2oct;

	mov	rdi, QWORD PTR [rbx+312]
	test	rdi, rdi
	je	SHORT $LN16@Shimmer
	mov	rcx, rdi
	call	??1PSMVocoder@@QEAA@XZ			; PSMVocoder::~PSMVocoder
	mov	edx, 491736				; 000780d8H
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN16@Shimmer:
	mov	rcx, rbx

; 790  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	jmp	??1AudioEffect@@UEAA@XZ			; AudioEffect::~AudioEffect
??1Shimmer@@UEAA@XZ ENDP				; Shimmer::~Shimmer
_TEXT	ENDS
; Function compile flags: /Ogspy
;	COMDAT ??_GFDN@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$dead$ = 56
??_GFDN@@QEAAPEAXI@Z PROC				; FDN::`scalar deleting destructor', COMDAT
$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	call	??1FDN@@QEAA@XZ				; FDN::~FDN
	mov	edx, 320				; 00000140H
	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??_GFDN@@QEAAPEAXI@Z ENDP				; FDN::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogspy
;	COMDAT ??_GPSMVocoder@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$dead$ = 56
??_GPSMVocoder@@QEAAPEAXI@Z PROC			; PSMVocoder::`scalar deleting destructor', COMDAT
$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	call	??1PSMVocoder@@QEAA@XZ			; PSMVocoder::~PSMVocoder
	mov	edx, 491736				; 000780d8H
	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??_GPSMVocoder@@QEAAPEAXI@Z ENDP			; PSMVocoder::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??A?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEAAAEAPEAVHighPassFilter@@_K@Z
_TEXT	SEGMENT
this$ = 8
_Pos$ = 16
??A?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEAAAEAPEAVHighPassFilter@@_K@Z PROC ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::operator[], COMDAT

; 1563 :         auto& _My_data = _Mypair._Myval2;
; 1564 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1565 :         _STL_VERIFY(
; 1566 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1567 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1568 : 
; 1569 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rcx]
	lea	rax, QWORD PTR [rax+rdx*8]

; 1570 :     }

	ret	0
??A?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEAAAEAPEAVHighPassFilter@@_K@Z ENDP ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?size@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEBA_KXZ PROC ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::size, COMDAT

; 1548 :         auto& _My_data = _Mypair._Myval2;
; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 3

; 1550 :     }

	ret	0
?size@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::size
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?empty@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?empty@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEBA_NXZ PROC ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::empty, COMDAT

; 1543 :         auto& _My_data = _Mypair._Myval2;
; 1544 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	rax, QWORD PTR [rcx+8]
	cmp	QWORD PTR [rcx], rax
	sete	al

; 1545 :     }

	ret	0
?empty@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEBA_NXZ ENDP ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::empty
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?clear@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?clear@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEAAXXZ PROC ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::clear, COMDAT

; 1450 :         auto& _My_data    = _Mypair._Myval2;
; 1451 :         pointer& _Myfirst = _My_data._Myfirst;
; 1452 :         pointer& _Mylast  = _My_data._Mylast;
; 1453 : 
; 1454 :         _My_data._Orphan_all();
; 1455 :         _Destroy(_Myfirst, _Mylast);
; 1456 :         _Mylast = _Myfirst;

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx+8], rax

; 1457 :     }

	ret	0
?clear@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEAAXXZ ENDP ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?push_back@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEAAX$$QEAPEAVHighPassFilter@@@Z
_TEXT	SEGMENT
this$ = 8
_Val$ = 16
?push_back@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEAAX$$QEAPEAVHighPassFilter@@@Z PROC ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::push_back, COMDAT

; 759  :     _CONSTEXPR20_CONTAINER void push_back(_Ty&& _Val) {

	mov	r8, rdx

; 743  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rcx+8]
	cmp	rdx, QWORD PTR [rcx+16]
	je	SHORT $LN4@push_back

; 726  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rdx], rax

; 727  :         _Orphan_range(_Mylast, _Mylast);
; 728  :         _Ty& _Result = *_Mylast;
; 729  :         ++_Mylast;

	add	QWORD PTR [rcx+8], 8

; 760  :         // insert by moving into element at end, provide strong guarantee
; 761  :         emplace_back(_STD move(_Val));
; 762  :     }

	ret	0
$LN4@push_back:

; 747  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	jmp	??$_Emplace_reallocate@PEAVHighPassFilter@@@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEAAPEAPEAVHighPassFilter@@QEAPEAV2@$$QEAPEAV2@@Z ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::_Emplace_reallocate<HighPassFilter *>
?push_back@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEAAX$$QEAPEAVHighPassFilter@@@Z ENDP ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$emplace_back@PEAVHighPassFilter@@@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEAA?A_T$$QEAPEAVHighPassFilter@@@Z
_TEXT	SEGMENT
this$ = 8
<_Val_0>$ = 16
??$emplace_back@PEAVHighPassFilter@@@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEAA?A_T$$QEAPEAVHighPassFilter@@@Z PROC ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::emplace_back<HighPassFilter *>, COMDAT

; 739  :     _CONSTEXPR20_CONTAINER decltype(auto) emplace_back(_Valty&&... _Val) {

	mov	r8, rdx

; 740  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 741  :         auto& _My_data   = _Mypair._Myval2;
; 742  :         pointer& _Mylast = _My_data._Mylast;
; 743  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rcx+8]
	cmp	rdx, QWORD PTR [rcx+16]
	je	SHORT $LN2@emplace_ba

; 726  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rdx], rax

; 727  :         _Orphan_range(_Mylast, _Mylast);
; 728  :         _Ty& _Result = *_Mylast;
; 729  :         ++_Mylast;

	add	QWORD PTR [rcx+8], 8

; 748  : #if _HAS_CXX17
; 749  :         return _Result;
; 750  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 751  :         (void) _Result;
; 752  : #endif // _HAS_CXX17
; 753  :     }

	ret	0
$LN2@emplace_ba:

; 744  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 745  :         }
; 746  : 
; 747  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	jmp	??$_Emplace_reallocate@PEAVHighPassFilter@@@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEAAPEAPEAVHighPassFilter@@QEAPEAV2@$$QEAPEAV2@@Z ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::_Emplace_reallocate<HighPassFilter *>
??$emplace_back@PEAVHighPassFilter@@@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEAA?A_T$$QEAPEAVHighPassFilter@@@Z ENDP ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::emplace_back<HighPassFilter *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@PEAVHighPassFilter@@@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@AEAA?A_T$$QEAPEAVHighPassFilter@@@Z
_TEXT	SEGMENT
this$ = 8
<_Val_0>$ = 16
??$_Emplace_back_with_unused_capacity@PEAVHighPassFilter@@@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@AEAA?A_T$$QEAPEAVHighPassFilter@@@Z PROC ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::_Emplace_back_with_unused_capacity<HighPassFilter *>, COMDAT

; 722  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 723  :         auto& _My_data   = _Mypair._Myval2;
; 724  :         pointer& _Mylast = _My_data._Mylast;
; 725  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 726  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	r8, QWORD PTR [rcx+8]
	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [r8], rax

; 727  :         _Orphan_range(_Mylast, _Mylast);
; 728  :         _Ty& _Result = *_Mylast;
; 729  :         ++_Mylast;

	add	QWORD PTR [rcx+8], 8

; 730  : #if _HAS_CXX17
; 731  :         return _Result;
; 732  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 733  :         (void) _Result;
; 734  : #endif // _HAS_CXX17
; 735  :     }

	ret	0
??$_Emplace_back_with_unused_capacity@PEAVHighPassFilter@@@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@AEAA?A_T$$QEAPEAVHighPassFilter@@@Z ENDP ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::_Emplace_back_with_unused_capacity<HighPassFilter *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEAA@XZ PROC ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::~vector<HighPassFilter *,std::allocator<HighPassFilter *> >, COMDAT

; 711  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

$LN28:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN4@vector

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN20@vector

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN17@vector

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN20@vector:

; 264  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

	and	QWORD PTR [rbx], 0

; 1768 :             _Mylast  = nullptr;

	and	QWORD PTR [rbx+8], 0

; 1769 :             _Myend   = nullptr;

	and	QWORD PTR [rbx+16], 0
$LN4@vector:

; 717  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN17@vector:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN25@vector:
??1?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEAA@XZ ENDP ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::~vector<HighPassFilter *,std::allocator<HighPassFilter *> >
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEAA@XZ PROC ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::vector<HighPassFilter *,std::allocator<HighPassFilter *> >, COMDAT

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax

; 477  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 478  :     }

	mov	rax, rcx
	ret	0
??0?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEAA@XZ ENDP ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::vector<HighPassFilter *,std::allocator<HighPassFilter *> >
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??A?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@QEAAAEAPEAVModulation@@_K@Z
_TEXT	SEGMENT
this$ = 8
_Pos$ = 16
??A?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@QEAAAEAPEAVModulation@@_K@Z PROC ; std::vector<Modulation *,std::allocator<Modulation *> >::operator[], COMDAT

; 1563 :         auto& _My_data = _Mypair._Myval2;
; 1564 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1565 :         _STL_VERIFY(
; 1566 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1567 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1568 : 
; 1569 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rcx]
	lea	rax, QWORD PTR [rax+rdx*8]

; 1570 :     }

	ret	0
??A?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@QEAAAEAPEAVModulation@@_K@Z ENDP ; std::vector<Modulation *,std::allocator<Modulation *> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?size@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@QEBA_KXZ PROC ; std::vector<Modulation *,std::allocator<Modulation *> >::size, COMDAT

; 1548 :         auto& _My_data = _Mypair._Myval2;
; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 3

; 1550 :     }

	ret	0
?size@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<Modulation *,std::allocator<Modulation *> >::size
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?empty@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?empty@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@QEBA_NXZ PROC ; std::vector<Modulation *,std::allocator<Modulation *> >::empty, COMDAT

; 1543 :         auto& _My_data = _Mypair._Myval2;
; 1544 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	rax, QWORD PTR [rcx+8]
	cmp	QWORD PTR [rcx], rax
	sete	al

; 1545 :     }

	ret	0
?empty@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@QEBA_NXZ ENDP ; std::vector<Modulation *,std::allocator<Modulation *> >::empty
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?clear@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?clear@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@QEAAXXZ PROC ; std::vector<Modulation *,std::allocator<Modulation *> >::clear, COMDAT

; 1450 :         auto& _My_data    = _Mypair._Myval2;
; 1451 :         pointer& _Myfirst = _My_data._Myfirst;
; 1452 :         pointer& _Mylast  = _My_data._Mylast;
; 1453 : 
; 1454 :         _My_data._Orphan_all();
; 1455 :         _Destroy(_Myfirst, _Mylast);
; 1456 :         _Mylast = _Myfirst;

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx+8], rax

; 1457 :     }

	ret	0
?clear@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@QEAAXXZ ENDP ; std::vector<Modulation *,std::allocator<Modulation *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?push_back@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@QEAAX$$QEAPEAVModulation@@@Z
_TEXT	SEGMENT
this$ = 8
_Val$ = 16
?push_back@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@QEAAX$$QEAPEAVModulation@@@Z PROC ; std::vector<Modulation *,std::allocator<Modulation *> >::push_back, COMDAT

; 759  :     _CONSTEXPR20_CONTAINER void push_back(_Ty&& _Val) {

	mov	r8, rdx

; 743  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rcx+8]
	cmp	rdx, QWORD PTR [rcx+16]
	je	SHORT $LN4@push_back

; 726  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rdx], rax

; 727  :         _Orphan_range(_Mylast, _Mylast);
; 728  :         _Ty& _Result = *_Mylast;
; 729  :         ++_Mylast;

	add	QWORD PTR [rcx+8], 8

; 760  :         // insert by moving into element at end, provide strong guarantee
; 761  :         emplace_back(_STD move(_Val));
; 762  :     }

	ret	0
$LN4@push_back:

; 747  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	jmp	??$_Emplace_reallocate@PEAVModulation@@@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@QEAAPEAPEAVModulation@@QEAPEAV2@$$QEAPEAV2@@Z ; std::vector<Modulation *,std::allocator<Modulation *> >::_Emplace_reallocate<Modulation *>
?push_back@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@QEAAX$$QEAPEAVModulation@@@Z ENDP ; std::vector<Modulation *,std::allocator<Modulation *> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$emplace_back@PEAVModulation@@@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@QEAA?A_T$$QEAPEAVModulation@@@Z
_TEXT	SEGMENT
this$ = 8
<_Val_0>$ = 16
??$emplace_back@PEAVModulation@@@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@QEAA?A_T$$QEAPEAVModulation@@@Z PROC ; std::vector<Modulation *,std::allocator<Modulation *> >::emplace_back<Modulation *>, COMDAT

; 739  :     _CONSTEXPR20_CONTAINER decltype(auto) emplace_back(_Valty&&... _Val) {

	mov	r8, rdx

; 740  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 741  :         auto& _My_data   = _Mypair._Myval2;
; 742  :         pointer& _Mylast = _My_data._Mylast;
; 743  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rcx+8]
	cmp	rdx, QWORD PTR [rcx+16]
	je	SHORT $LN2@emplace_ba

; 726  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rdx], rax

; 727  :         _Orphan_range(_Mylast, _Mylast);
; 728  :         _Ty& _Result = *_Mylast;
; 729  :         ++_Mylast;

	add	QWORD PTR [rcx+8], 8

; 748  : #if _HAS_CXX17
; 749  :         return _Result;
; 750  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 751  :         (void) _Result;
; 752  : #endif // _HAS_CXX17
; 753  :     }

	ret	0
$LN2@emplace_ba:

; 744  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 745  :         }
; 746  : 
; 747  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	jmp	??$_Emplace_reallocate@PEAVModulation@@@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@QEAAPEAPEAVModulation@@QEAPEAV2@$$QEAPEAV2@@Z ; std::vector<Modulation *,std::allocator<Modulation *> >::_Emplace_reallocate<Modulation *>
??$emplace_back@PEAVModulation@@@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@QEAA?A_T$$QEAPEAVModulation@@@Z ENDP ; std::vector<Modulation *,std::allocator<Modulation *> >::emplace_back<Modulation *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@PEAVModulation@@@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@AEAA?A_T$$QEAPEAVModulation@@@Z
_TEXT	SEGMENT
this$ = 8
<_Val_0>$ = 16
??$_Emplace_back_with_unused_capacity@PEAVModulation@@@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@AEAA?A_T$$QEAPEAVModulation@@@Z PROC ; std::vector<Modulation *,std::allocator<Modulation *> >::_Emplace_back_with_unused_capacity<Modulation *>, COMDAT

; 722  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 723  :         auto& _My_data   = _Mypair._Myval2;
; 724  :         pointer& _Mylast = _My_data._Mylast;
; 725  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 726  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	r8, QWORD PTR [rcx+8]
	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [r8], rax

; 727  :         _Orphan_range(_Mylast, _Mylast);
; 728  :         _Ty& _Result = *_Mylast;
; 729  :         ++_Mylast;

	add	QWORD PTR [rcx+8], 8

; 730  : #if _HAS_CXX17
; 731  :         return _Result;
; 732  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 733  :         (void) _Result;
; 734  : #endif // _HAS_CXX17
; 735  :     }

	ret	0
??$_Emplace_back_with_unused_capacity@PEAVModulation@@@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@AEAA?A_T$$QEAPEAVModulation@@@Z ENDP ; std::vector<Modulation *,std::allocator<Modulation *> >::_Emplace_back_with_unused_capacity<Modulation *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@QEAA@XZ PROC ; std::vector<Modulation *,std::allocator<Modulation *> >::~vector<Modulation *,std::allocator<Modulation *> >, COMDAT

; 711  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

$LN28:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN4@vector

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN20@vector

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN17@vector

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN20@vector:

; 264  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

	and	QWORD PTR [rbx], 0

; 1768 :             _Mylast  = nullptr;

	and	QWORD PTR [rbx+8], 0

; 1769 :             _Myend   = nullptr;

	and	QWORD PTR [rbx+16], 0
$LN4@vector:

; 717  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN17@vector:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN25@vector:
??1?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@QEAA@XZ ENDP ; std::vector<Modulation *,std::allocator<Modulation *> >::~vector<Modulation *,std::allocator<Modulation *> >
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@QEAA@XZ PROC ; std::vector<Modulation *,std::allocator<Modulation *> >::vector<Modulation *,std::allocator<Modulation *> >, COMDAT

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax

; 477  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 478  :     }

	mov	rax, rcx
	ret	0
??0?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@QEAA@XZ ENDP ; std::vector<Modulation *,std::allocator<Modulation *> >::vector<Modulation *,std::allocator<Modulation *> >
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??A?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEAAAEAPEAVLowPassFilter@@_K@Z
_TEXT	SEGMENT
this$ = 8
_Pos$ = 16
??A?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEAAAEAPEAVLowPassFilter@@_K@Z PROC ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::operator[], COMDAT

; 1563 :         auto& _My_data = _Mypair._Myval2;
; 1564 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1565 :         _STL_VERIFY(
; 1566 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1567 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1568 : 
; 1569 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rcx]
	lea	rax, QWORD PTR [rax+rdx*8]

; 1570 :     }

	ret	0
??A?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEAAAEAPEAVLowPassFilter@@_K@Z ENDP ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?size@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEBA_KXZ PROC ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::size, COMDAT

; 1548 :         auto& _My_data = _Mypair._Myval2;
; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 3

; 1550 :     }

	ret	0
?size@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::size
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?empty@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?empty@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEBA_NXZ PROC ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::empty, COMDAT

; 1543 :         auto& _My_data = _Mypair._Myval2;
; 1544 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	rax, QWORD PTR [rcx+8]
	cmp	QWORD PTR [rcx], rax
	sete	al

; 1545 :     }

	ret	0
?empty@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEBA_NXZ ENDP ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::empty
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?clear@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?clear@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEAAXXZ PROC ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::clear, COMDAT

; 1450 :         auto& _My_data    = _Mypair._Myval2;
; 1451 :         pointer& _Myfirst = _My_data._Myfirst;
; 1452 :         pointer& _Mylast  = _My_data._Mylast;
; 1453 : 
; 1454 :         _My_data._Orphan_all();
; 1455 :         _Destroy(_Myfirst, _Mylast);
; 1456 :         _Mylast = _Myfirst;

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx+8], rax

; 1457 :     }

	ret	0
?clear@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEAAXXZ ENDP ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?push_back@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEAAX$$QEAPEAVLowPassFilter@@@Z
_TEXT	SEGMENT
this$ = 8
_Val$ = 16
?push_back@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEAAX$$QEAPEAVLowPassFilter@@@Z PROC ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::push_back, COMDAT

; 759  :     _CONSTEXPR20_CONTAINER void push_back(_Ty&& _Val) {

	mov	r8, rdx

; 743  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rcx+8]
	cmp	rdx, QWORD PTR [rcx+16]
	je	SHORT $LN4@push_back

; 726  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rdx], rax

; 727  :         _Orphan_range(_Mylast, _Mylast);
; 728  :         _Ty& _Result = *_Mylast;
; 729  :         ++_Mylast;

	add	QWORD PTR [rcx+8], 8

; 760  :         // insert by moving into element at end, provide strong guarantee
; 761  :         emplace_back(_STD move(_Val));
; 762  :     }

	ret	0
$LN4@push_back:

; 747  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	jmp	??$_Emplace_reallocate@PEAVLowPassFilter@@@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEAAPEAPEAVLowPassFilter@@QEAPEAV2@$$QEAPEAV2@@Z ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::_Emplace_reallocate<LowPassFilter *>
?push_back@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEAAX$$QEAPEAVLowPassFilter@@@Z ENDP ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$emplace_back@PEAVLowPassFilter@@@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEAA?A_T$$QEAPEAVLowPassFilter@@@Z
_TEXT	SEGMENT
this$ = 8
<_Val_0>$ = 16
??$emplace_back@PEAVLowPassFilter@@@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEAA?A_T$$QEAPEAVLowPassFilter@@@Z PROC ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::emplace_back<LowPassFilter *>, COMDAT

; 739  :     _CONSTEXPR20_CONTAINER decltype(auto) emplace_back(_Valty&&... _Val) {

	mov	r8, rdx

; 740  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 741  :         auto& _My_data   = _Mypair._Myval2;
; 742  :         pointer& _Mylast = _My_data._Mylast;
; 743  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rcx+8]
	cmp	rdx, QWORD PTR [rcx+16]
	je	SHORT $LN2@emplace_ba

; 726  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rdx], rax

; 727  :         _Orphan_range(_Mylast, _Mylast);
; 728  :         _Ty& _Result = *_Mylast;
; 729  :         ++_Mylast;

	add	QWORD PTR [rcx+8], 8

; 748  : #if _HAS_CXX17
; 749  :         return _Result;
; 750  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 751  :         (void) _Result;
; 752  : #endif // _HAS_CXX17
; 753  :     }

	ret	0
$LN2@emplace_ba:

; 744  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 745  :         }
; 746  : 
; 747  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	jmp	??$_Emplace_reallocate@PEAVLowPassFilter@@@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEAAPEAPEAVLowPassFilter@@QEAPEAV2@$$QEAPEAV2@@Z ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::_Emplace_reallocate<LowPassFilter *>
??$emplace_back@PEAVLowPassFilter@@@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEAA?A_T$$QEAPEAVLowPassFilter@@@Z ENDP ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::emplace_back<LowPassFilter *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@PEAVLowPassFilter@@@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@AEAA?A_T$$QEAPEAVLowPassFilter@@@Z
_TEXT	SEGMENT
this$ = 8
<_Val_0>$ = 16
??$_Emplace_back_with_unused_capacity@PEAVLowPassFilter@@@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@AEAA?A_T$$QEAPEAVLowPassFilter@@@Z PROC ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::_Emplace_back_with_unused_capacity<LowPassFilter *>, COMDAT

; 722  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 723  :         auto& _My_data   = _Mypair._Myval2;
; 724  :         pointer& _Mylast = _My_data._Mylast;
; 725  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 726  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	r8, QWORD PTR [rcx+8]
	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [r8], rax

; 727  :         _Orphan_range(_Mylast, _Mylast);
; 728  :         _Ty& _Result = *_Mylast;
; 729  :         ++_Mylast;

	add	QWORD PTR [rcx+8], 8

; 730  : #if _HAS_CXX17
; 731  :         return _Result;
; 732  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 733  :         (void) _Result;
; 734  : #endif // _HAS_CXX17
; 735  :     }

	ret	0
??$_Emplace_back_with_unused_capacity@PEAVLowPassFilter@@@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@AEAA?A_T$$QEAPEAVLowPassFilter@@@Z ENDP ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::_Emplace_back_with_unused_capacity<LowPassFilter *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEAA@XZ PROC ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::~vector<LowPassFilter *,std::allocator<LowPassFilter *> >, COMDAT

; 711  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

$LN28:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN4@vector

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN20@vector

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN17@vector

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN20@vector:

; 264  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

	and	QWORD PTR [rbx], 0

; 1768 :             _Mylast  = nullptr;

	and	QWORD PTR [rbx+8], 0

; 1769 :             _Myend   = nullptr;

	and	QWORD PTR [rbx+16], 0
$LN4@vector:

; 717  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN17@vector:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN25@vector:
??1?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEAA@XZ ENDP ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::~vector<LowPassFilter *,std::allocator<LowPassFilter *> >
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEAA@XZ PROC ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::vector<LowPassFilter *,std::allocator<LowPassFilter *> >, COMDAT

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax

; 477  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 478  :     }

	mov	rax, rcx
	ret	0
??0?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEAA@XZ ENDP ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::vector<LowPassFilter *,std::allocator<LowPassFilter *> >
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??A?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEAAAEAPEAVModMultiChannelDiffuser@@_K@Z
_TEXT	SEGMENT
this$ = 8
_Pos$ = 16
??A?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEAAAEAPEAVModMultiChannelDiffuser@@_K@Z PROC ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::operator[], COMDAT

; 1563 :         auto& _My_data = _Mypair._Myval2;
; 1564 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1565 :         _STL_VERIFY(
; 1566 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1567 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1568 : 
; 1569 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rcx]
	lea	rax, QWORD PTR [rax+rdx*8]

; 1570 :     }

	ret	0
??A?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEAAAEAPEAVModMultiChannelDiffuser@@_K@Z ENDP ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?size@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEBA_KXZ PROC ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::size, COMDAT

; 1548 :         auto& _My_data = _Mypair._Myval2;
; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 3

; 1550 :     }

	ret	0
?size@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::size
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?empty@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?empty@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEBA_NXZ PROC ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::empty, COMDAT

; 1543 :         auto& _My_data = _Mypair._Myval2;
; 1544 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	rax, QWORD PTR [rcx+8]
	cmp	QWORD PTR [rcx], rax
	sete	al

; 1545 :     }

	ret	0
?empty@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEBA_NXZ ENDP ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::empty
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?clear@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?clear@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEAAXXZ PROC ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::clear, COMDAT

; 1450 :         auto& _My_data    = _Mypair._Myval2;
; 1451 :         pointer& _Myfirst = _My_data._Myfirst;
; 1452 :         pointer& _Mylast  = _My_data._Mylast;
; 1453 : 
; 1454 :         _My_data._Orphan_all();
; 1455 :         _Destroy(_Myfirst, _Mylast);
; 1456 :         _Mylast = _Myfirst;

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx+8], rax

; 1457 :     }

	ret	0
?clear@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEAAXXZ ENDP ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?push_back@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEAAX$$QEAPEAVModMultiChannelDiffuser@@@Z
_TEXT	SEGMENT
this$ = 8
_Val$ = 16
?push_back@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEAAX$$QEAPEAVModMultiChannelDiffuser@@@Z PROC ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::push_back, COMDAT

; 759  :     _CONSTEXPR20_CONTAINER void push_back(_Ty&& _Val) {

	mov	r8, rdx

; 743  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rcx+8]
	cmp	rdx, QWORD PTR [rcx+16]
	je	SHORT $LN4@push_back

; 726  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rdx], rax

; 727  :         _Orphan_range(_Mylast, _Mylast);
; 728  :         _Ty& _Result = *_Mylast;
; 729  :         ++_Mylast;

	add	QWORD PTR [rcx+8], 8

; 760  :         // insert by moving into element at end, provide strong guarantee
; 761  :         emplace_back(_STD move(_Val));
; 762  :     }

	ret	0
$LN4@push_back:

; 747  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	jmp	??$_Emplace_reallocate@PEAVModMultiChannelDiffuser@@@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEAAPEAPEAVModMultiChannelDiffuser@@QEAPEAV2@$$QEAPEAV2@@Z ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::_Emplace_reallocate<ModMultiChannelDiffuser *>
?push_back@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEAAX$$QEAPEAVModMultiChannelDiffuser@@@Z ENDP ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$emplace_back@PEAVModMultiChannelDiffuser@@@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEAA?A_T$$QEAPEAVModMultiChannelDiffuser@@@Z
_TEXT	SEGMENT
this$ = 8
<_Val_0>$ = 16
??$emplace_back@PEAVModMultiChannelDiffuser@@@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEAA?A_T$$QEAPEAVModMultiChannelDiffuser@@@Z PROC ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::emplace_back<ModMultiChannelDiffuser *>, COMDAT

; 739  :     _CONSTEXPR20_CONTAINER decltype(auto) emplace_back(_Valty&&... _Val) {

	mov	r8, rdx

; 740  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 741  :         auto& _My_data   = _Mypair._Myval2;
; 742  :         pointer& _Mylast = _My_data._Mylast;
; 743  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rcx+8]
	cmp	rdx, QWORD PTR [rcx+16]
	je	SHORT $LN2@emplace_ba

; 726  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rdx], rax

; 727  :         _Orphan_range(_Mylast, _Mylast);
; 728  :         _Ty& _Result = *_Mylast;
; 729  :         ++_Mylast;

	add	QWORD PTR [rcx+8], 8

; 748  : #if _HAS_CXX17
; 749  :         return _Result;
; 750  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 751  :         (void) _Result;
; 752  : #endif // _HAS_CXX17
; 753  :     }

	ret	0
$LN2@emplace_ba:

; 744  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 745  :         }
; 746  : 
; 747  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	jmp	??$_Emplace_reallocate@PEAVModMultiChannelDiffuser@@@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEAAPEAPEAVModMultiChannelDiffuser@@QEAPEAV2@$$QEAPEAV2@@Z ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::_Emplace_reallocate<ModMultiChannelDiffuser *>
??$emplace_back@PEAVModMultiChannelDiffuser@@@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEAA?A_T$$QEAPEAVModMultiChannelDiffuser@@@Z ENDP ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::emplace_back<ModMultiChannelDiffuser *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@PEAVModMultiChannelDiffuser@@@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@AEAA?A_T$$QEAPEAVModMultiChannelDiffuser@@@Z
_TEXT	SEGMENT
this$ = 8
<_Val_0>$ = 16
??$_Emplace_back_with_unused_capacity@PEAVModMultiChannelDiffuser@@@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@AEAA?A_T$$QEAPEAVModMultiChannelDiffuser@@@Z PROC ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::_Emplace_back_with_unused_capacity<ModMultiChannelDiffuser *>, COMDAT

; 722  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 723  :         auto& _My_data   = _Mypair._Myval2;
; 724  :         pointer& _Mylast = _My_data._Mylast;
; 725  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 726  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	r8, QWORD PTR [rcx+8]
	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [r8], rax

; 727  :         _Orphan_range(_Mylast, _Mylast);
; 728  :         _Ty& _Result = *_Mylast;
; 729  :         ++_Mylast;

	add	QWORD PTR [rcx+8], 8

; 730  : #if _HAS_CXX17
; 731  :         return _Result;
; 732  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 733  :         (void) _Result;
; 734  : #endif // _HAS_CXX17
; 735  :     }

	ret	0
??$_Emplace_back_with_unused_capacity@PEAVModMultiChannelDiffuser@@@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@AEAA?A_T$$QEAPEAVModMultiChannelDiffuser@@@Z ENDP ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::_Emplace_back_with_unused_capacity<ModMultiChannelDiffuser *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEAA@XZ PROC ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::~vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >, COMDAT

; 711  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

$LN28:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN4@vector

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN20@vector

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN17@vector

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN20@vector:

; 264  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

	and	QWORD PTR [rbx], 0

; 1768 :             _Mylast  = nullptr;

	and	QWORD PTR [rbx+8], 0

; 1769 :             _Myend   = nullptr;

	and	QWORD PTR [rbx+16], 0
$LN4@vector:

; 717  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN17@vector:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN25@vector:
??1?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEAA@XZ ENDP ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::~vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEAA@XZ PROC ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >, COMDAT

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax

; 477  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 478  :     }

	mov	rax, rcx
	ret	0
??0?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEAA@XZ ENDP ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??A?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEAAAEAPEAVMultiChannelDiffuser@@_K@Z
_TEXT	SEGMENT
this$ = 8
_Pos$ = 16
??A?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEAAAEAPEAVMultiChannelDiffuser@@_K@Z PROC ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::operator[], COMDAT

; 1563 :         auto& _My_data = _Mypair._Myval2;
; 1564 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1565 :         _STL_VERIFY(
; 1566 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1567 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1568 : 
; 1569 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rcx]
	lea	rax, QWORD PTR [rax+rdx*8]

; 1570 :     }

	ret	0
??A?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEAAAEAPEAVMultiChannelDiffuser@@_K@Z ENDP ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?size@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEBA_KXZ PROC ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::size, COMDAT

; 1548 :         auto& _My_data = _Mypair._Myval2;
; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 3

; 1550 :     }

	ret	0
?size@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::size
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?empty@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?empty@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEBA_NXZ PROC ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::empty, COMDAT

; 1543 :         auto& _My_data = _Mypair._Myval2;
; 1544 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	rax, QWORD PTR [rcx+8]
	cmp	QWORD PTR [rcx], rax
	sete	al

; 1545 :     }

	ret	0
?empty@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEBA_NXZ ENDP ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::empty
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?clear@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?clear@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEAAXXZ PROC ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::clear, COMDAT

; 1450 :         auto& _My_data    = _Mypair._Myval2;
; 1451 :         pointer& _Myfirst = _My_data._Myfirst;
; 1452 :         pointer& _Mylast  = _My_data._Mylast;
; 1453 : 
; 1454 :         _My_data._Orphan_all();
; 1455 :         _Destroy(_Myfirst, _Mylast);
; 1456 :         _Mylast = _Myfirst;

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx+8], rax

; 1457 :     }

	ret	0
?clear@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEAAXXZ ENDP ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?push_back@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEAAX$$QEAPEAVMultiChannelDiffuser@@@Z
_TEXT	SEGMENT
this$ = 8
_Val$ = 16
?push_back@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEAAX$$QEAPEAVMultiChannelDiffuser@@@Z PROC ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::push_back, COMDAT

; 759  :     _CONSTEXPR20_CONTAINER void push_back(_Ty&& _Val) {

	mov	r8, rdx

; 743  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rcx+8]
	cmp	rdx, QWORD PTR [rcx+16]
	je	SHORT $LN4@push_back

; 726  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rdx], rax

; 727  :         _Orphan_range(_Mylast, _Mylast);
; 728  :         _Ty& _Result = *_Mylast;
; 729  :         ++_Mylast;

	add	QWORD PTR [rcx+8], 8

; 760  :         // insert by moving into element at end, provide strong guarantee
; 761  :         emplace_back(_STD move(_Val));
; 762  :     }

	ret	0
$LN4@push_back:

; 747  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	jmp	??$_Emplace_reallocate@PEAVMultiChannelDiffuser@@@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEAAPEAPEAVMultiChannelDiffuser@@QEAPEAV2@$$QEAPEAV2@@Z ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::_Emplace_reallocate<MultiChannelDiffuser *>
?push_back@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEAAX$$QEAPEAVMultiChannelDiffuser@@@Z ENDP ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$emplace_back@PEAVMultiChannelDiffuser@@@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEAA?A_T$$QEAPEAVMultiChannelDiffuser@@@Z
_TEXT	SEGMENT
this$ = 8
<_Val_0>$ = 16
??$emplace_back@PEAVMultiChannelDiffuser@@@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEAA?A_T$$QEAPEAVMultiChannelDiffuser@@@Z PROC ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::emplace_back<MultiChannelDiffuser *>, COMDAT

; 739  :     _CONSTEXPR20_CONTAINER decltype(auto) emplace_back(_Valty&&... _Val) {

	mov	r8, rdx

; 740  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 741  :         auto& _My_data   = _Mypair._Myval2;
; 742  :         pointer& _Mylast = _My_data._Mylast;
; 743  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rcx+8]
	cmp	rdx, QWORD PTR [rcx+16]
	je	SHORT $LN2@emplace_ba

; 726  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rdx], rax

; 727  :         _Orphan_range(_Mylast, _Mylast);
; 728  :         _Ty& _Result = *_Mylast;
; 729  :         ++_Mylast;

	add	QWORD PTR [rcx+8], 8

; 748  : #if _HAS_CXX17
; 749  :         return _Result;
; 750  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 751  :         (void) _Result;
; 752  : #endif // _HAS_CXX17
; 753  :     }

	ret	0
$LN2@emplace_ba:

; 744  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 745  :         }
; 746  : 
; 747  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	jmp	??$_Emplace_reallocate@PEAVMultiChannelDiffuser@@@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEAAPEAPEAVMultiChannelDiffuser@@QEAPEAV2@$$QEAPEAV2@@Z ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::_Emplace_reallocate<MultiChannelDiffuser *>
??$emplace_back@PEAVMultiChannelDiffuser@@@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEAA?A_T$$QEAPEAVMultiChannelDiffuser@@@Z ENDP ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::emplace_back<MultiChannelDiffuser *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@PEAVMultiChannelDiffuser@@@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@AEAA?A_T$$QEAPEAVMultiChannelDiffuser@@@Z
_TEXT	SEGMENT
this$ = 8
<_Val_0>$ = 16
??$_Emplace_back_with_unused_capacity@PEAVMultiChannelDiffuser@@@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@AEAA?A_T$$QEAPEAVMultiChannelDiffuser@@@Z PROC ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::_Emplace_back_with_unused_capacity<MultiChannelDiffuser *>, COMDAT

; 722  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 723  :         auto& _My_data   = _Mypair._Myval2;
; 724  :         pointer& _Mylast = _My_data._Mylast;
; 725  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 726  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	r8, QWORD PTR [rcx+8]
	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [r8], rax

; 727  :         _Orphan_range(_Mylast, _Mylast);
; 728  :         _Ty& _Result = *_Mylast;
; 729  :         ++_Mylast;

	add	QWORD PTR [rcx+8], 8

; 730  : #if _HAS_CXX17
; 731  :         return _Result;
; 732  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 733  :         (void) _Result;
; 734  : #endif // _HAS_CXX17
; 735  :     }

	ret	0
??$_Emplace_back_with_unused_capacity@PEAVMultiChannelDiffuser@@@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@AEAA?A_T$$QEAPEAVMultiChannelDiffuser@@@Z ENDP ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::_Emplace_back_with_unused_capacity<MultiChannelDiffuser *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEAA@XZ PROC ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::~vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >, COMDAT

; 711  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

$LN28:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN4@vector

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN20@vector

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN17@vector

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN20@vector:

; 264  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

	and	QWORD PTR [rbx], 0

; 1768 :             _Mylast  = nullptr;

	and	QWORD PTR [rbx+8], 0

; 1769 :             _Myend   = nullptr;

	and	QWORD PTR [rbx+16], 0
$LN4@vector:

; 717  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN17@vector:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN25@vector:
??1?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEAA@XZ ENDP ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::~vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEAA@XZ PROC ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >, COMDAT

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax

; 477  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 478  :     }

	mov	rax, rcx
	ret	0
??0?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEAA@XZ ENDP ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??A?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEAAAEAPEAVModDelay@@_K@Z
_TEXT	SEGMENT
this$ = 8
_Pos$ = 16
??A?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEAAAEAPEAVModDelay@@_K@Z PROC ; std::vector<ModDelay *,std::allocator<ModDelay *> >::operator[], COMDAT

; 1563 :         auto& _My_data = _Mypair._Myval2;
; 1564 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1565 :         _STL_VERIFY(
; 1566 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1567 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1568 : 
; 1569 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rcx]
	lea	rax, QWORD PTR [rax+rdx*8]

; 1570 :     }

	ret	0
??A?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEAAAEAPEAVModDelay@@_K@Z ENDP ; std::vector<ModDelay *,std::allocator<ModDelay *> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?size@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEBA_KXZ PROC ; std::vector<ModDelay *,std::allocator<ModDelay *> >::size, COMDAT

; 1548 :         auto& _My_data = _Mypair._Myval2;
; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 3

; 1550 :     }

	ret	0
?size@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<ModDelay *,std::allocator<ModDelay *> >::size
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?empty@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?empty@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEBA_NXZ PROC ; std::vector<ModDelay *,std::allocator<ModDelay *> >::empty, COMDAT

; 1543 :         auto& _My_data = _Mypair._Myval2;
; 1544 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	rax, QWORD PTR [rcx+8]
	cmp	QWORD PTR [rcx], rax
	sete	al

; 1545 :     }

	ret	0
?empty@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEBA_NXZ ENDP ; std::vector<ModDelay *,std::allocator<ModDelay *> >::empty
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?clear@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?clear@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEAAXXZ PROC ; std::vector<ModDelay *,std::allocator<ModDelay *> >::clear, COMDAT

; 1450 :         auto& _My_data    = _Mypair._Myval2;
; 1451 :         pointer& _Myfirst = _My_data._Myfirst;
; 1452 :         pointer& _Mylast  = _My_data._Mylast;
; 1453 : 
; 1454 :         _My_data._Orphan_all();
; 1455 :         _Destroy(_Myfirst, _Mylast);
; 1456 :         _Mylast = _Myfirst;

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx+8], rax

; 1457 :     }

	ret	0
?clear@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEAAXXZ ENDP ; std::vector<ModDelay *,std::allocator<ModDelay *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?push_back@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEAAX$$QEAPEAVModDelay@@@Z
_TEXT	SEGMENT
this$ = 8
_Val$ = 16
?push_back@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEAAX$$QEAPEAVModDelay@@@Z PROC ; std::vector<ModDelay *,std::allocator<ModDelay *> >::push_back, COMDAT

; 759  :     _CONSTEXPR20_CONTAINER void push_back(_Ty&& _Val) {

	mov	r8, rdx

; 743  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rcx+8]
	cmp	rdx, QWORD PTR [rcx+16]
	je	SHORT $LN4@push_back

; 726  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rdx], rax

; 727  :         _Orphan_range(_Mylast, _Mylast);
; 728  :         _Ty& _Result = *_Mylast;
; 729  :         ++_Mylast;

	add	QWORD PTR [rcx+8], 8

; 760  :         // insert by moving into element at end, provide strong guarantee
; 761  :         emplace_back(_STD move(_Val));
; 762  :     }

	ret	0
$LN4@push_back:

; 747  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	jmp	??$_Emplace_reallocate@PEAVModDelay@@@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEAAPEAPEAVModDelay@@QEAPEAV2@$$QEAPEAV2@@Z ; std::vector<ModDelay *,std::allocator<ModDelay *> >::_Emplace_reallocate<ModDelay *>
?push_back@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEAAX$$QEAPEAVModDelay@@@Z ENDP ; std::vector<ModDelay *,std::allocator<ModDelay *> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$emplace_back@PEAVModDelay@@@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEAA?A_T$$QEAPEAVModDelay@@@Z
_TEXT	SEGMENT
this$ = 8
<_Val_0>$ = 16
??$emplace_back@PEAVModDelay@@@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEAA?A_T$$QEAPEAVModDelay@@@Z PROC ; std::vector<ModDelay *,std::allocator<ModDelay *> >::emplace_back<ModDelay *>, COMDAT

; 739  :     _CONSTEXPR20_CONTAINER decltype(auto) emplace_back(_Valty&&... _Val) {

	mov	r8, rdx

; 740  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 741  :         auto& _My_data   = _Mypair._Myval2;
; 742  :         pointer& _Mylast = _My_data._Mylast;
; 743  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rcx+8]
	cmp	rdx, QWORD PTR [rcx+16]
	je	SHORT $LN2@emplace_ba

; 726  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rdx], rax

; 727  :         _Orphan_range(_Mylast, _Mylast);
; 728  :         _Ty& _Result = *_Mylast;
; 729  :         ++_Mylast;

	add	QWORD PTR [rcx+8], 8

; 748  : #if _HAS_CXX17
; 749  :         return _Result;
; 750  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 751  :         (void) _Result;
; 752  : #endif // _HAS_CXX17
; 753  :     }

	ret	0
$LN2@emplace_ba:

; 744  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 745  :         }
; 746  : 
; 747  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	jmp	??$_Emplace_reallocate@PEAVModDelay@@@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEAAPEAPEAVModDelay@@QEAPEAV2@$$QEAPEAV2@@Z ; std::vector<ModDelay *,std::allocator<ModDelay *> >::_Emplace_reallocate<ModDelay *>
??$emplace_back@PEAVModDelay@@@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEAA?A_T$$QEAPEAVModDelay@@@Z ENDP ; std::vector<ModDelay *,std::allocator<ModDelay *> >::emplace_back<ModDelay *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@PEAVModDelay@@@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@AEAA?A_T$$QEAPEAVModDelay@@@Z
_TEXT	SEGMENT
this$ = 8
<_Val_0>$ = 16
??$_Emplace_back_with_unused_capacity@PEAVModDelay@@@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@AEAA?A_T$$QEAPEAVModDelay@@@Z PROC ; std::vector<ModDelay *,std::allocator<ModDelay *> >::_Emplace_back_with_unused_capacity<ModDelay *>, COMDAT

; 722  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 723  :         auto& _My_data   = _Mypair._Myval2;
; 724  :         pointer& _Mylast = _My_data._Mylast;
; 725  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 726  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	r8, QWORD PTR [rcx+8]
	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [r8], rax

; 727  :         _Orphan_range(_Mylast, _Mylast);
; 728  :         _Ty& _Result = *_Mylast;
; 729  :         ++_Mylast;

	add	QWORD PTR [rcx+8], 8

; 730  : #if _HAS_CXX17
; 731  :         return _Result;
; 732  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 733  :         (void) _Result;
; 734  : #endif // _HAS_CXX17
; 735  :     }

	ret	0
??$_Emplace_back_with_unused_capacity@PEAVModDelay@@@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@AEAA?A_T$$QEAPEAVModDelay@@@Z ENDP ; std::vector<ModDelay *,std::allocator<ModDelay *> >::_Emplace_back_with_unused_capacity<ModDelay *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEAA@XZ PROC ; std::vector<ModDelay *,std::allocator<ModDelay *> >::~vector<ModDelay *,std::allocator<ModDelay *> >, COMDAT

; 711  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

$LN28:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN4@vector

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN20@vector

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN17@vector

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN20@vector:

; 264  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

	and	QWORD PTR [rbx], 0

; 1768 :             _Mylast  = nullptr;

	and	QWORD PTR [rbx+8], 0

; 1769 :             _Myend   = nullptr;

	and	QWORD PTR [rbx+16], 0
$LN4@vector:

; 717  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN17@vector:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN25@vector:
??1?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEAA@XZ ENDP ; std::vector<ModDelay *,std::allocator<ModDelay *> >::~vector<ModDelay *,std::allocator<ModDelay *> >
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEAA@XZ PROC ; std::vector<ModDelay *,std::allocator<ModDelay *> >::vector<ModDelay *,std::allocator<ModDelay *> >, COMDAT

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax

; 477  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 478  :     }

	mov	rax, rcx
	ret	0
??0?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEAA@XZ ENDP ; std::vector<ModDelay *,std::allocator<ModDelay *> >::vector<ModDelay *,std::allocator<ModDelay *> >
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??A?$vector@HV?$allocator@H@std@@@std@@QEAAAEAH_K@Z
_TEXT	SEGMENT
this$ = 8
_Pos$ = 16
??A?$vector@HV?$allocator@H@std@@@std@@QEAAAEAH_K@Z PROC ; std::vector<int,std::allocator<int> >::operator[], COMDAT

; 1563 :         auto& _My_data = _Mypair._Myval2;
; 1564 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1565 :         _STL_VERIFY(
; 1566 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1567 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1568 : 
; 1569 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rcx]
	lea	rax, QWORD PTR [rax+rdx*4]

; 1570 :     }

	ret	0
??A?$vector@HV?$allocator@H@std@@@std@@QEAAAEAH_K@Z ENDP ; std::vector<int,std::allocator<int> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?empty@?$vector@HV?$allocator@H@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?empty@?$vector@HV?$allocator@H@std@@@std@@QEBA_NXZ PROC ; std::vector<int,std::allocator<int> >::empty, COMDAT

; 1543 :         auto& _My_data = _Mypair._Myval2;
; 1544 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	rax, QWORD PTR [rcx+8]
	cmp	QWORD PTR [rcx], rax
	sete	al

; 1545 :     }

	ret	0
?empty@?$vector@HV?$allocator@H@std@@@std@@QEBA_NXZ ENDP ; std::vector<int,std::allocator<int> >::empty
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?clear@?$vector@HV?$allocator@H@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?clear@?$vector@HV?$allocator@H@std@@@std@@QEAAXXZ PROC	; std::vector<int,std::allocator<int> >::clear, COMDAT

; 1450 :         auto& _My_data    = _Mypair._Myval2;
; 1451 :         pointer& _Myfirst = _My_data._Myfirst;
; 1452 :         pointer& _Mylast  = _My_data._Mylast;
; 1453 : 
; 1454 :         _My_data._Orphan_all();
; 1455 :         _Destroy(_Myfirst, _Mylast);
; 1456 :         _Mylast = _Myfirst;

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx+8], rax

; 1457 :     }

	ret	0
?clear@?$vector@HV?$allocator@H@std@@@std@@QEAAXXZ ENDP	; std::vector<int,std::allocator<int> >::clear
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?push_back@?$vector@HV?$allocator@H@std@@@std@@QEAAX$$QEAH@Z
_TEXT	SEGMENT
this$ = 8
_Val$ = 16
?push_back@?$vector@HV?$allocator@H@std@@@std@@QEAAX$$QEAH@Z PROC ; std::vector<int,std::allocator<int> >::push_back, COMDAT

; 759  :     _CONSTEXPR20_CONTAINER void push_back(_Ty&& _Val) {

	mov	r8, rdx

; 743  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rcx+8]
	cmp	rdx, QWORD PTR [rcx+16]
	je	SHORT $LN4@push_back

; 726  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rdx], eax

; 727  :         _Orphan_range(_Mylast, _Mylast);
; 728  :         _Ty& _Result = *_Mylast;
; 729  :         ++_Mylast;

	add	QWORD PTR [rcx+8], 4

; 760  :         // insert by moving into element at end, provide strong guarantee
; 761  :         emplace_back(_STD move(_Val));
; 762  :     }

	ret	0
$LN4@push_back:

; 747  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	jmp	??$_Emplace_reallocate@H@?$vector@HV?$allocator@H@std@@@std@@QEAAPEAHQEAH$$QEAH@Z ; std::vector<int,std::allocator<int> >::_Emplace_reallocate<int>
?push_back@?$vector@HV?$allocator@H@std@@@std@@QEAAX$$QEAH@Z ENDP ; std::vector<int,std::allocator<int> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$emplace_back@H@?$vector@HV?$allocator@H@std@@@std@@QEAA?A_T$$QEAH@Z
_TEXT	SEGMENT
this$ = 8
<_Val_0>$ = 16
??$emplace_back@H@?$vector@HV?$allocator@H@std@@@std@@QEAA?A_T$$QEAH@Z PROC ; std::vector<int,std::allocator<int> >::emplace_back<int>, COMDAT

; 739  :     _CONSTEXPR20_CONTAINER decltype(auto) emplace_back(_Valty&&... _Val) {

	mov	r8, rdx

; 740  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 741  :         auto& _My_data   = _Mypair._Myval2;
; 742  :         pointer& _Mylast = _My_data._Mylast;
; 743  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rcx+8]
	cmp	rdx, QWORD PTR [rcx+16]
	je	SHORT $LN2@emplace_ba

; 726  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rdx], eax

; 727  :         _Orphan_range(_Mylast, _Mylast);
; 728  :         _Ty& _Result = *_Mylast;
; 729  :         ++_Mylast;

	add	QWORD PTR [rcx+8], 4

; 748  : #if _HAS_CXX17
; 749  :         return _Result;
; 750  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 751  :         (void) _Result;
; 752  : #endif // _HAS_CXX17
; 753  :     }

	ret	0
$LN2@emplace_ba:

; 744  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 745  :         }
; 746  : 
; 747  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	jmp	??$_Emplace_reallocate@H@?$vector@HV?$allocator@H@std@@@std@@QEAAPEAHQEAH$$QEAH@Z ; std::vector<int,std::allocator<int> >::_Emplace_reallocate<int>
??$emplace_back@H@?$vector@HV?$allocator@H@std@@@std@@QEAA?A_T$$QEAH@Z ENDP ; std::vector<int,std::allocator<int> >::emplace_back<int>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@H@?$vector@HV?$allocator@H@std@@@std@@AEAA?A_T$$QEAH@Z
_TEXT	SEGMENT
this$ = 8
<_Val_0>$ = 16
??$_Emplace_back_with_unused_capacity@H@?$vector@HV?$allocator@H@std@@@std@@AEAA?A_T$$QEAH@Z PROC ; std::vector<int,std::allocator<int> >::_Emplace_back_with_unused_capacity<int>, COMDAT

; 722  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 723  :         auto& _My_data   = _Mypair._Myval2;
; 724  :         pointer& _Mylast = _My_data._Mylast;
; 725  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 726  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	r8, QWORD PTR [rcx+8]
	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [r8], eax

; 727  :         _Orphan_range(_Mylast, _Mylast);
; 728  :         _Ty& _Result = *_Mylast;
; 729  :         ++_Mylast;

	add	QWORD PTR [rcx+8], 4

; 730  : #if _HAS_CXX17
; 731  :         return _Result;
; 732  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 733  :         (void) _Result;
; 734  : #endif // _HAS_CXX17
; 735  :     }

	ret	0
??$_Emplace_back_with_unused_capacity@H@?$vector@HV?$allocator@H@std@@@std@@AEAA?A_T$$QEAH@Z ENDP ; std::vector<int,std::allocator<int> >::_Emplace_back_with_unused_capacity<int>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@HV?$allocator@H@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$vector@HV?$allocator@H@std@@@std@@QEAA@XZ PROC	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >, COMDAT

; 711  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

$LN28:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN4@vector

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -4

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN20@vector

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN17@vector

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN20@vector:

; 264  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

	and	QWORD PTR [rbx], 0

; 1768 :             _Mylast  = nullptr;

	and	QWORD PTR [rbx+8], 0

; 1769 :             _Myend   = nullptr;

	and	QWORD PTR [rbx+16], 0
$LN4@vector:

; 717  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN17@vector:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN25@vector:
??1?$vector@HV?$allocator@H@std@@@std@@QEAA@XZ ENDP	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$vector@HV?$allocator@H@std@@@std@@QEAA@XZ PROC	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >, COMDAT

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax

; 477  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 478  :     }

	mov	rax, rcx
	ret	0
??0?$vector@HV?$allocator@H@std@@@std@@QEAA@XZ ENDP	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??A?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@QEAAAEAPEAVDelay@@_K@Z
_TEXT	SEGMENT
this$ = 8
_Pos$ = 16
??A?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@QEAAAEAPEAVDelay@@_K@Z PROC ; std::vector<Delay *,std::allocator<Delay *> >::operator[], COMDAT

; 1563 :         auto& _My_data = _Mypair._Myval2;
; 1564 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1565 :         _STL_VERIFY(
; 1566 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1567 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1568 : 
; 1569 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rcx]
	lea	rax, QWORD PTR [rax+rdx*8]

; 1570 :     }

	ret	0
??A?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@QEAAAEAPEAVDelay@@_K@Z ENDP ; std::vector<Delay *,std::allocator<Delay *> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?size@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@QEBA_KXZ PROC ; std::vector<Delay *,std::allocator<Delay *> >::size, COMDAT

; 1548 :         auto& _My_data = _Mypair._Myval2;
; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 3

; 1550 :     }

	ret	0
?size@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<Delay *,std::allocator<Delay *> >::size
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?empty@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?empty@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@QEBA_NXZ PROC ; std::vector<Delay *,std::allocator<Delay *> >::empty, COMDAT

; 1543 :         auto& _My_data = _Mypair._Myval2;
; 1544 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	rax, QWORD PTR [rcx+8]
	cmp	QWORD PTR [rcx], rax
	sete	al

; 1545 :     }

	ret	0
?empty@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@QEBA_NXZ ENDP ; std::vector<Delay *,std::allocator<Delay *> >::empty
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?clear@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?clear@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@QEAAXXZ PROC ; std::vector<Delay *,std::allocator<Delay *> >::clear, COMDAT

; 1450 :         auto& _My_data    = _Mypair._Myval2;
; 1451 :         pointer& _Myfirst = _My_data._Myfirst;
; 1452 :         pointer& _Mylast  = _My_data._Mylast;
; 1453 : 
; 1454 :         _My_data._Orphan_all();
; 1455 :         _Destroy(_Myfirst, _Mylast);
; 1456 :         _Mylast = _Myfirst;

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx+8], rax

; 1457 :     }

	ret	0
?clear@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@QEAAXXZ ENDP ; std::vector<Delay *,std::allocator<Delay *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?push_back@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@QEAAX$$QEAPEAVDelay@@@Z
_TEXT	SEGMENT
this$ = 8
_Val$ = 16
?push_back@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@QEAAX$$QEAPEAVDelay@@@Z PROC ; std::vector<Delay *,std::allocator<Delay *> >::push_back, COMDAT

; 759  :     _CONSTEXPR20_CONTAINER void push_back(_Ty&& _Val) {

	mov	r8, rdx

; 743  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rcx+8]
	cmp	rdx, QWORD PTR [rcx+16]
	je	SHORT $LN4@push_back

; 726  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rdx], rax

; 727  :         _Orphan_range(_Mylast, _Mylast);
; 728  :         _Ty& _Result = *_Mylast;
; 729  :         ++_Mylast;

	add	QWORD PTR [rcx+8], 8

; 760  :         // insert by moving into element at end, provide strong guarantee
; 761  :         emplace_back(_STD move(_Val));
; 762  :     }

	ret	0
$LN4@push_back:

; 747  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	jmp	??$_Emplace_reallocate@PEAVDelay@@@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@QEAAPEAPEAVDelay@@QEAPEAV2@$$QEAPEAV2@@Z ; std::vector<Delay *,std::allocator<Delay *> >::_Emplace_reallocate<Delay *>
?push_back@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@QEAAX$$QEAPEAVDelay@@@Z ENDP ; std::vector<Delay *,std::allocator<Delay *> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$emplace_back@PEAVDelay@@@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@QEAA?A_T$$QEAPEAVDelay@@@Z
_TEXT	SEGMENT
this$ = 8
<_Val_0>$ = 16
??$emplace_back@PEAVDelay@@@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@QEAA?A_T$$QEAPEAVDelay@@@Z PROC ; std::vector<Delay *,std::allocator<Delay *> >::emplace_back<Delay *>, COMDAT

; 739  :     _CONSTEXPR20_CONTAINER decltype(auto) emplace_back(_Valty&&... _Val) {

	mov	r8, rdx

; 740  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 741  :         auto& _My_data   = _Mypair._Myval2;
; 742  :         pointer& _Mylast = _My_data._Mylast;
; 743  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rcx+8]
	cmp	rdx, QWORD PTR [rcx+16]
	je	SHORT $LN2@emplace_ba

; 726  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rdx], rax

; 727  :         _Orphan_range(_Mylast, _Mylast);
; 728  :         _Ty& _Result = *_Mylast;
; 729  :         ++_Mylast;

	add	QWORD PTR [rcx+8], 8

; 748  : #if _HAS_CXX17
; 749  :         return _Result;
; 750  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 751  :         (void) _Result;
; 752  : #endif // _HAS_CXX17
; 753  :     }

	ret	0
$LN2@emplace_ba:

; 744  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 745  :         }
; 746  : 
; 747  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	jmp	??$_Emplace_reallocate@PEAVDelay@@@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@QEAAPEAPEAVDelay@@QEAPEAV2@$$QEAPEAV2@@Z ; std::vector<Delay *,std::allocator<Delay *> >::_Emplace_reallocate<Delay *>
??$emplace_back@PEAVDelay@@@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@QEAA?A_T$$QEAPEAVDelay@@@Z ENDP ; std::vector<Delay *,std::allocator<Delay *> >::emplace_back<Delay *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@PEAVDelay@@@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@AEAA?A_T$$QEAPEAVDelay@@@Z
_TEXT	SEGMENT
this$ = 8
<_Val_0>$ = 16
??$_Emplace_back_with_unused_capacity@PEAVDelay@@@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@AEAA?A_T$$QEAPEAVDelay@@@Z PROC ; std::vector<Delay *,std::allocator<Delay *> >::_Emplace_back_with_unused_capacity<Delay *>, COMDAT

; 722  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 723  :         auto& _My_data   = _Mypair._Myval2;
; 724  :         pointer& _Mylast = _My_data._Mylast;
; 725  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 726  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	r8, QWORD PTR [rcx+8]
	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [r8], rax

; 727  :         _Orphan_range(_Mylast, _Mylast);
; 728  :         _Ty& _Result = *_Mylast;
; 729  :         ++_Mylast;

	add	QWORD PTR [rcx+8], 8

; 730  : #if _HAS_CXX17
; 731  :         return _Result;
; 732  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 733  :         (void) _Result;
; 734  : #endif // _HAS_CXX17
; 735  :     }

	ret	0
??$_Emplace_back_with_unused_capacity@PEAVDelay@@@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@AEAA?A_T$$QEAPEAVDelay@@@Z ENDP ; std::vector<Delay *,std::allocator<Delay *> >::_Emplace_back_with_unused_capacity<Delay *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@QEAA@XZ PROC ; std::vector<Delay *,std::allocator<Delay *> >::~vector<Delay *,std::allocator<Delay *> >, COMDAT

; 711  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

$LN28:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN4@vector

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN20@vector

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN17@vector

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN20@vector:

; 264  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

	and	QWORD PTR [rbx], 0

; 1768 :             _Mylast  = nullptr;

	and	QWORD PTR [rbx+8], 0

; 1769 :             _Myend   = nullptr;

	and	QWORD PTR [rbx+16], 0
$LN4@vector:

; 717  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN17@vector:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN25@vector:
??1?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@QEAA@XZ ENDP ; std::vector<Delay *,std::allocator<Delay *> >::~vector<Delay *,std::allocator<Delay *> >
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@QEAA@XZ PROC ; std::vector<Delay *,std::allocator<Delay *> >::vector<Delay *,std::allocator<Delay *> >, COMDAT

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax

; 477  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 478  :     }

	mov	rax, rcx
	ret	0
??0?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@QEAA@XZ ENDP ; std::vector<Delay *,std::allocator<Delay *> >::vector<Delay *,std::allocator<Delay *> >
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?reserve@?$vector@MV?$allocator@M@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newcapacity$dead$ = 56
?reserve@?$vector@MV?$allocator@M@std@@@std@@QEAAX_K@Z PROC ; std::vector<float,std::allocator<float> >::reserve, COMDAT

; 1369 :     _CONSTEXPR20_CONTAINER void reserve(_CRT_GUARDOVERFLOW const size_type _Newcapacity) {

$LN9:
	sub	rsp, 40					; 00000028H

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 2

; 1370 :         // increase capacity to _Newcapacity (without geometric growth), provide strong guarantee
; 1371 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

	cmp	rax, 4096				; 00001000H
	jae	SHORT $LN2@reserve

; 1372 :             if (_Newcapacity > max_size()) {
; 1373 :                 _Xlength();
; 1374 :             }
; 1375 : 
; 1376 :             _Reallocate_exactly(_Newcapacity);

	call	?_Reallocate_exactly@?$vector@MV?$allocator@M@std@@@std@@AEAAX_K@Z ; std::vector<float,std::allocator<float> >::_Reallocate_exactly
$LN2@reserve:

; 1377 :         }
; 1378 :     }

	add	rsp, 40					; 00000028H
	ret	0
?reserve@?$vector@MV?$allocator@M@std@@@std@@QEAAX_K@Z ENDP ; std::vector<float,std::allocator<float> >::reserve
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??4?$vector@MV?$allocator@M@std@@@std@@QEAAAEAV01@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
??4?$vector@MV?$allocator@M@std@@@std@@QEAAAEAV01@$$QEAV01@@Z PROC ; std::vector<float,std::allocator<float> >::operator=, COMDAT

; 703  :         noexcept(_Move_assign(_Right, _Choose_pocma<_Alty>{}))) {

$LN34:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rdx
	mov	rbx, rcx

; 704  :         if (this != _STD addressof(_Right)) {

	cmp	rcx, rdx
	je	SHORT $LN29@operator

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN7@operator

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -4

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN23@operator

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN20@operator

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN23@operator:

; 264  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

	and	QWORD PTR [rbx], 0

; 1768 :             _Mylast  = nullptr;

	and	QWORD PTR [rbx+8], 0

; 1769 :             _Myend   = nullptr;

	and	QWORD PTR [rbx+16], 0
$LN7@operator:

; 415  :         _Myfirst = _Right._Myfirst;

	mov	rax, QWORD PTR [rdi]
	mov	QWORD PTR [rbx], rax

; 416  :         _Mylast  = _Right._Mylast;

	mov	rax, QWORD PTR [rdi+8]
	mov	QWORD PTR [rbx+8], rax

; 417  :         _Myend   = _Right._Myend;

	mov	rax, QWORD PTR [rdi+16]
	mov	QWORD PTR [rbx+16], rax

; 418  : 
; 419  :         _Right._Myfirst = nullptr;

	and	QWORD PTR [rdi], 0

; 420  :         _Right._Mylast  = nullptr;

	and	QWORD PTR [rdi+8], 0

; 421  :         _Right._Myend   = nullptr;

	and	QWORD PTR [rdi+16], 0
$LN29@operator:

; 705  :             _Move_assign(_Right, _Choose_pocma<_Alty>{});
; 706  :         }
; 707  : 
; 708  :         return *this;

	mov	rax, rbx

; 709  :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN20@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN31@operator:
??4?$vector@MV?$allocator@M@std@@@std@@QEAAAEAV01@$$QEAV01@@Z ENDP ; std::vector<float,std::allocator<float> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@MV?$allocator@M@std@@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??0?$vector@MV?$allocator@M@std@@@std@@QEAA@$$QEAV01@@Z PROC ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 616  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]

; 617  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	r10d, r10d
	mov	r9, QWORD PTR [rdx+16]

; 616  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r8, QWORD PTR [rdx+8]

; 617  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx+16], r10
	mov	QWORD PTR [rdx+8], r10
	mov	QWORD PTR [rdx], r10
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 404  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rax

; 622  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 623  :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 624  :     }

	mov	rax, rcx

; 404  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9

; 622  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 623  :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 624  :     }

	ret	0
??0?$vector@MV?$allocator@M@std@@@std@@QEAA@$$QEAV01@@Z ENDP ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@MV?$allocator@M@std@@@std@@QEAA@_KAEBV?$allocator@M@1@@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
_Al$dead$ = 64
_Guard$9 = 64
??0?$vector@MV?$allocator@M@std@@@std@@QEAA@_KAEBV?$allocator@M@1@@Z PROC ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >, COMDAT

; 502  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

$LN68:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], r8
	push	rdi
	sub	rsp, 32					; 00000020H

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	and	QWORD PTR [rcx], 0

; 502  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

	mov	rsi, rcx

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	and	QWORD PTR [rcx+8], 0
	and	QWORD PTR [rcx+16], 0

; 490  :         if (_Count != 0) {

	test	rdx, rdx
	je	$LN8@vector

; 1728 :         if (_Newcapacity > max_size()) {

	mov	rax, 4611686018427387903		; 3fffffffffffffffH
	cmp	rdx, rax
	ja	$LN65@vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 69   :     return _Count * _Ty_size;

	lea	rdi, QWORD PTR [rdx*4]

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdi, 4096				; 00001000H
	jb	SHORT $LN23@vector

; 136  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rdi+39]

; 137  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rdi
	jbe	SHORT $LN66@vector

; 85   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 142  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN32@vector

; 143  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rbx, QWORD PTR [rax+39]
	and	rbx, -32				; ffffffffffffffe0H

; 144  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rbx-8], rax

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN22@vector
$LN32@vector:

; 142  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN23@vector:

; 243  :     if (_Bytes != 0) {

	test	rdi, rdi
	je	SHORT $LN24@vector

; 85   :         return ::operator new(_Bytes);

	mov	rcx, rdi
	call	??2@YAPEAX_K@Z				; operator new
	mov	rbx, rax

; 244  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN22@vector
$LN24@vector:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

	xor	ebx, ebx
$LN22@vector:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1712 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [rsi], rbx

; 1714 :         _Myend             = _Newvec + _Newcapacity;

	lea	rax, QWORD PTR [rdi+rbx]
	mov	QWORD PTR [rsi+8], rbx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1789 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	r8, rdi
	xor	edx, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1714 :         _Myend             = _Newvec + _Newcapacity;

	mov	QWORD PTR [rsi+16], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1789 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	rcx, rbx
	call	QWORD PTR __imp_memset
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 494  :             _Guard._Target   = nullptr;

	and	QWORD PTR _Guard$9[rsp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1805 :             return _First + _Count;

	lea	rax, QWORD PTR [rdi+rbx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 495  :         }

	lea	rcx, QWORD PTR _Guard$9[rsp]
	mov	QWORD PTR [rsi+8], rax
	call	??1?$_Tidy_guard@V?$vector@MV?$allocator@M@std@@@std@@@std@@QEAA@XZ ; std::_Tidy_guard<std::vector<float,std::allocator<float> > >::~_Tidy_guard<std::vector<float,std::allocator<float> > >
$LN8@vector:

; 503  :         _Construct_n_copies_of_ty(_Count, _Value_init_tag{});
; 504  :     }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rsi
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN66@vector:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 138  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN65@vector:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1729 :             _Xlength();

	call	?_Xlength@?$vector@MV?$allocator@M@std@@@std@@CAXXZ ; std::vector<float,std::allocator<float> >::_Xlength
	int	3
$LN63@vector:
??0?$vector@MV?$allocator@M@std@@@std@@QEAA@_KAEBV?$allocator@M@1@@Z ENDP ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@AEAAAEAV?$allocator@PEAVHighPassFilter@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@AEAAAEAV?$allocator@PEAVHighPassFilter@@@2@XZ PROC ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::_Getal, COMDAT

; 1818 :         return _Mypair._Get_first();

	mov	rax, rcx

; 1819 :     }

	ret	0
?_Getal@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@AEAAAEAV?$allocator@PEAVHighPassFilter@@@2@XZ ENDP ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Orphan_range@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@AEBAXPEAPEAVHighPassFilter@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
?_Orphan_range@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@AEBAXPEAPEAVHighPassFilter@@0@Z PROC ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::_Orphan_range, COMDAT

; 1814 :     _CONSTEXPR20_CONTAINER void _Orphan_range(pointer, pointer) const {}

	ret	0
?_Orphan_range@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@AEBAXPEAPEAVHighPassFilter@@0@Z ENDP ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@AEAAXXZ PROC ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::_Tidy, COMDAT

; 1755 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

$LN25:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 1756 :         auto& _My_data    = _Mypair._Myval2;
; 1757 :         pointer& _Myfirst = _My_data._Myfirst;
; 1758 :         pointer& _Mylast  = _My_data._Mylast;
; 1759 :         pointer& _Myend   = _My_data._Myend;
; 1760 : 
; 1761 :         _My_data._Orphan_all();
; 1762 : 
; 1763 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN2@Tidy

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN18@Tidy

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN15@Tidy

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN18@Tidy:

; 264  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

	and	QWORD PTR [rbx], 0

; 1768 :             _Mylast  = nullptr;

	and	QWORD PTR [rbx+8], 0

; 1769 :             _Myend   = nullptr;

	and	QWORD PTR [rbx+16], 0
$LN2@Tidy:

; 1771 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN15@Tidy:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN22@Tidy:
?_Tidy@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@AEAAXXZ ENDP ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@AEAAXPEAPEAVHighPassFilter@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
_First$dead$ = 16
_Last$dead$ = 24
?_Destroy@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@AEAAXPEAPEAVHighPassFilter@@0@Z PROC ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::_Destroy, COMDAT

; 1679 :         // destroy [_First, _Last) using allocator
; 1680 :         _Destroy_range(_First, _Last, _Getal());
; 1681 :     }

	ret	0
?_Destroy@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@AEAAXPEAPEAVHighPassFilter@@0@Z ENDP ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@AEAAAEAV?$allocator@PEAVModulation@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@AEAAAEAV?$allocator@PEAVModulation@@@2@XZ PROC ; std::vector<Modulation *,std::allocator<Modulation *> >::_Getal, COMDAT

; 1818 :         return _Mypair._Get_first();

	mov	rax, rcx

; 1819 :     }

	ret	0
?_Getal@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@AEAAAEAV?$allocator@PEAVModulation@@@2@XZ ENDP ; std::vector<Modulation *,std::allocator<Modulation *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Orphan_range@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@AEBAXPEAPEAVModulation@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
?_Orphan_range@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@AEBAXPEAPEAVModulation@@0@Z PROC ; std::vector<Modulation *,std::allocator<Modulation *> >::_Orphan_range, COMDAT

; 1814 :     _CONSTEXPR20_CONTAINER void _Orphan_range(pointer, pointer) const {}

	ret	0
?_Orphan_range@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@AEBAXPEAPEAVModulation@@0@Z ENDP ; std::vector<Modulation *,std::allocator<Modulation *> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@AEAAXXZ PROC ; std::vector<Modulation *,std::allocator<Modulation *> >::_Tidy, COMDAT

; 1755 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

$LN25:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 1756 :         auto& _My_data    = _Mypair._Myval2;
; 1757 :         pointer& _Myfirst = _My_data._Myfirst;
; 1758 :         pointer& _Mylast  = _My_data._Mylast;
; 1759 :         pointer& _Myend   = _My_data._Myend;
; 1760 : 
; 1761 :         _My_data._Orphan_all();
; 1762 : 
; 1763 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN2@Tidy

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN18@Tidy

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN15@Tidy

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN18@Tidy:

; 264  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

	and	QWORD PTR [rbx], 0

; 1768 :             _Mylast  = nullptr;

	and	QWORD PTR [rbx+8], 0

; 1769 :             _Myend   = nullptr;

	and	QWORD PTR [rbx+16], 0
$LN2@Tidy:

; 1771 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN15@Tidy:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN22@Tidy:
?_Tidy@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@AEAAXXZ ENDP ; std::vector<Modulation *,std::allocator<Modulation *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@AEAAXPEAPEAVModulation@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
_First$dead$ = 16
_Last$dead$ = 24
?_Destroy@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@AEAAXPEAPEAVModulation@@0@Z PROC ; std::vector<Modulation *,std::allocator<Modulation *> >::_Destroy, COMDAT

; 1679 :         // destroy [_First, _Last) using allocator
; 1680 :         _Destroy_range(_First, _Last, _Getal());
; 1681 :     }

	ret	0
?_Destroy@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@AEAAXPEAPEAVModulation@@0@Z ENDP ; std::vector<Modulation *,std::allocator<Modulation *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@AEAAAEAV?$allocator@PEAVLowPassFilter@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@AEAAAEAV?$allocator@PEAVLowPassFilter@@@2@XZ PROC ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::_Getal, COMDAT

; 1818 :         return _Mypair._Get_first();

	mov	rax, rcx

; 1819 :     }

	ret	0
?_Getal@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@AEAAAEAV?$allocator@PEAVLowPassFilter@@@2@XZ ENDP ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Orphan_range@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@AEBAXPEAPEAVLowPassFilter@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
?_Orphan_range@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@AEBAXPEAPEAVLowPassFilter@@0@Z PROC ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::_Orphan_range, COMDAT

; 1814 :     _CONSTEXPR20_CONTAINER void _Orphan_range(pointer, pointer) const {}

	ret	0
?_Orphan_range@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@AEBAXPEAPEAVLowPassFilter@@0@Z ENDP ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@AEAAXXZ PROC ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::_Tidy, COMDAT

; 1755 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

$LN25:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 1756 :         auto& _My_data    = _Mypair._Myval2;
; 1757 :         pointer& _Myfirst = _My_data._Myfirst;
; 1758 :         pointer& _Mylast  = _My_data._Mylast;
; 1759 :         pointer& _Myend   = _My_data._Myend;
; 1760 : 
; 1761 :         _My_data._Orphan_all();
; 1762 : 
; 1763 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN2@Tidy

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN18@Tidy

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN15@Tidy

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN18@Tidy:

; 264  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

	and	QWORD PTR [rbx], 0

; 1768 :             _Mylast  = nullptr;

	and	QWORD PTR [rbx+8], 0

; 1769 :             _Myend   = nullptr;

	and	QWORD PTR [rbx+16], 0
$LN2@Tidy:

; 1771 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN15@Tidy:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN22@Tidy:
?_Tidy@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@AEAAXXZ ENDP ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@AEAAXPEAPEAVLowPassFilter@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
_First$dead$ = 16
_Last$dead$ = 24
?_Destroy@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@AEAAXPEAPEAVLowPassFilter@@0@Z PROC ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::_Destroy, COMDAT

; 1679 :         // destroy [_First, _Last) using allocator
; 1680 :         _Destroy_range(_First, _Last, _Getal());
; 1681 :     }

	ret	0
?_Destroy@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@AEAAXPEAPEAVLowPassFilter@@0@Z ENDP ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@AEAAAEAV?$allocator@PEAVModMultiChannelDiffuser@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@AEAAAEAV?$allocator@PEAVModMultiChannelDiffuser@@@2@XZ PROC ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::_Getal, COMDAT

; 1818 :         return _Mypair._Get_first();

	mov	rax, rcx

; 1819 :     }

	ret	0
?_Getal@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@AEAAAEAV?$allocator@PEAVModMultiChannelDiffuser@@@2@XZ ENDP ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Orphan_range@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@AEBAXPEAPEAVModMultiChannelDiffuser@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
?_Orphan_range@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@AEBAXPEAPEAVModMultiChannelDiffuser@@0@Z PROC ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::_Orphan_range, COMDAT

; 1814 :     _CONSTEXPR20_CONTAINER void _Orphan_range(pointer, pointer) const {}

	ret	0
?_Orphan_range@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@AEBAXPEAPEAVModMultiChannelDiffuser@@0@Z ENDP ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@AEAAXXZ PROC ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::_Tidy, COMDAT

; 1755 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

$LN25:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 1756 :         auto& _My_data    = _Mypair._Myval2;
; 1757 :         pointer& _Myfirst = _My_data._Myfirst;
; 1758 :         pointer& _Mylast  = _My_data._Mylast;
; 1759 :         pointer& _Myend   = _My_data._Myend;
; 1760 : 
; 1761 :         _My_data._Orphan_all();
; 1762 : 
; 1763 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN2@Tidy

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN18@Tidy

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN15@Tidy

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN18@Tidy:

; 264  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

	and	QWORD PTR [rbx], 0

; 1768 :             _Mylast  = nullptr;

	and	QWORD PTR [rbx+8], 0

; 1769 :             _Myend   = nullptr;

	and	QWORD PTR [rbx+16], 0
$LN2@Tidy:

; 1771 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN15@Tidy:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN22@Tidy:
?_Tidy@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@AEAAXXZ ENDP ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@AEAAXPEAPEAVModMultiChannelDiffuser@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
_First$dead$ = 16
_Last$dead$ = 24
?_Destroy@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@AEAAXPEAPEAVModMultiChannelDiffuser@@0@Z PROC ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::_Destroy, COMDAT

; 1679 :         // destroy [_First, _Last) using allocator
; 1680 :         _Destroy_range(_First, _Last, _Getal());
; 1681 :     }

	ret	0
?_Destroy@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@AEAAXPEAPEAVModMultiChannelDiffuser@@0@Z ENDP ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@AEAAAEAV?$allocator@PEAVMultiChannelDiffuser@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@AEAAAEAV?$allocator@PEAVMultiChannelDiffuser@@@2@XZ PROC ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::_Getal, COMDAT

; 1818 :         return _Mypair._Get_first();

	mov	rax, rcx

; 1819 :     }

	ret	0
?_Getal@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@AEAAAEAV?$allocator@PEAVMultiChannelDiffuser@@@2@XZ ENDP ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Orphan_range@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@AEBAXPEAPEAVMultiChannelDiffuser@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
?_Orphan_range@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@AEBAXPEAPEAVMultiChannelDiffuser@@0@Z PROC ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::_Orphan_range, COMDAT

; 1814 :     _CONSTEXPR20_CONTAINER void _Orphan_range(pointer, pointer) const {}

	ret	0
?_Orphan_range@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@AEBAXPEAPEAVMultiChannelDiffuser@@0@Z ENDP ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@AEAAXXZ PROC ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::_Tidy, COMDAT

; 1755 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

$LN25:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 1756 :         auto& _My_data    = _Mypair._Myval2;
; 1757 :         pointer& _Myfirst = _My_data._Myfirst;
; 1758 :         pointer& _Mylast  = _My_data._Mylast;
; 1759 :         pointer& _Myend   = _My_data._Myend;
; 1760 : 
; 1761 :         _My_data._Orphan_all();
; 1762 : 
; 1763 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN2@Tidy

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN18@Tidy

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN15@Tidy

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN18@Tidy:

; 264  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

	and	QWORD PTR [rbx], 0

; 1768 :             _Mylast  = nullptr;

	and	QWORD PTR [rbx+8], 0

; 1769 :             _Myend   = nullptr;

	and	QWORD PTR [rbx+16], 0
$LN2@Tidy:

; 1771 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN15@Tidy:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN22@Tidy:
?_Tidy@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@AEAAXXZ ENDP ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@AEAAXPEAPEAVMultiChannelDiffuser@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
_First$dead$ = 16
_Last$dead$ = 24
?_Destroy@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@AEAAXPEAPEAVMultiChannelDiffuser@@0@Z PROC ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::_Destroy, COMDAT

; 1679 :         // destroy [_First, _Last) using allocator
; 1680 :         _Destroy_range(_First, _Last, _Getal());
; 1681 :     }

	ret	0
?_Destroy@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@AEAAXPEAPEAVMultiChannelDiffuser@@0@Z ENDP ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@AEAAAEAV?$allocator@PEAVModDelay@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@AEAAAEAV?$allocator@PEAVModDelay@@@2@XZ PROC ; std::vector<ModDelay *,std::allocator<ModDelay *> >::_Getal, COMDAT

; 1818 :         return _Mypair._Get_first();

	mov	rax, rcx

; 1819 :     }

	ret	0
?_Getal@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@AEAAAEAV?$allocator@PEAVModDelay@@@2@XZ ENDP ; std::vector<ModDelay *,std::allocator<ModDelay *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Orphan_range@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@AEBAXPEAPEAVModDelay@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
?_Orphan_range@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@AEBAXPEAPEAVModDelay@@0@Z PROC ; std::vector<ModDelay *,std::allocator<ModDelay *> >::_Orphan_range, COMDAT

; 1814 :     _CONSTEXPR20_CONTAINER void _Orphan_range(pointer, pointer) const {}

	ret	0
?_Orphan_range@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@AEBAXPEAPEAVModDelay@@0@Z ENDP ; std::vector<ModDelay *,std::allocator<ModDelay *> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@AEAAXXZ PROC ; std::vector<ModDelay *,std::allocator<ModDelay *> >::_Tidy, COMDAT

; 1755 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

$LN25:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 1756 :         auto& _My_data    = _Mypair._Myval2;
; 1757 :         pointer& _Myfirst = _My_data._Myfirst;
; 1758 :         pointer& _Mylast  = _My_data._Mylast;
; 1759 :         pointer& _Myend   = _My_data._Myend;
; 1760 : 
; 1761 :         _My_data._Orphan_all();
; 1762 : 
; 1763 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN2@Tidy

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN18@Tidy

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN15@Tidy

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN18@Tidy:

; 264  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

	and	QWORD PTR [rbx], 0

; 1768 :             _Mylast  = nullptr;

	and	QWORD PTR [rbx+8], 0

; 1769 :             _Myend   = nullptr;

	and	QWORD PTR [rbx+16], 0
$LN2@Tidy:

; 1771 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN15@Tidy:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN22@Tidy:
?_Tidy@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@AEAAXXZ ENDP ; std::vector<ModDelay *,std::allocator<ModDelay *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@AEAAXPEAPEAVModDelay@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
_First$dead$ = 16
_Last$dead$ = 24
?_Destroy@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@AEAAXPEAPEAVModDelay@@0@Z PROC ; std::vector<ModDelay *,std::allocator<ModDelay *> >::_Destroy, COMDAT

; 1679 :         // destroy [_First, _Last) using allocator
; 1680 :         _Destroy_range(_First, _Last, _Getal());
; 1681 :     }

	ret	0
?_Destroy@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@AEAAXPEAPEAVModDelay@@0@Z ENDP ; std::vector<ModDelay *,std::allocator<ModDelay *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@HV?$allocator@H@std@@@std@@AEAAAEAV?$allocator@H@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@HV?$allocator@H@std@@@std@@AEAAAEAV?$allocator@H@2@XZ PROC ; std::vector<int,std::allocator<int> >::_Getal, COMDAT

; 1818 :         return _Mypair._Get_first();

	mov	rax, rcx

; 1819 :     }

	ret	0
?_Getal@?$vector@HV?$allocator@H@std@@@std@@AEAAAEAV?$allocator@H@2@XZ ENDP ; std::vector<int,std::allocator<int> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@AEBAXPEAH0@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@AEBAXPEAH0@Z PROC ; std::vector<int,std::allocator<int> >::_Orphan_range, COMDAT

; 1814 :     _CONSTEXPR20_CONTAINER void _Orphan_range(pointer, pointer) const {}

	ret	0
?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@AEBAXPEAH0@Z ENDP ; std::vector<int,std::allocator<int> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AEAAXXZ PROC	; std::vector<int,std::allocator<int> >::_Tidy, COMDAT

; 1755 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

$LN25:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 1756 :         auto& _My_data    = _Mypair._Myval2;
; 1757 :         pointer& _Myfirst = _My_data._Myfirst;
; 1758 :         pointer& _Mylast  = _My_data._Mylast;
; 1759 :         pointer& _Myend   = _My_data._Myend;
; 1760 : 
; 1761 :         _My_data._Orphan_all();
; 1762 : 
; 1763 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN2@Tidy

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -4

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN18@Tidy

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN15@Tidy

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN18@Tidy:

; 264  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

	and	QWORD PTR [rbx], 0

; 1768 :             _Mylast  = nullptr;

	and	QWORD PTR [rbx+8], 0

; 1769 :             _Myend   = nullptr;

	and	QWORD PTR [rbx+16], 0
$LN2@Tidy:

; 1771 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN15@Tidy:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN22@Tidy:
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AEAAXXZ ENDP	; std::vector<int,std::allocator<int> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@AEAAXPEAH0@Z
_TEXT	SEGMENT
this$dead$ = 8
_First$dead$ = 16
_Last$dead$ = 24
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@AEAAXPEAH0@Z PROC ; std::vector<int,std::allocator<int> >::_Destroy, COMDAT

; 1679 :         // destroy [_First, _Last) using allocator
; 1680 :         _Destroy_range(_First, _Last, _Getal());
; 1681 :     }

	ret	0
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@AEAAXPEAH0@Z ENDP ; std::vector<int,std::allocator<int> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@AEAAAEAV?$allocator@PEAVDelay@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@AEAAAEAV?$allocator@PEAVDelay@@@2@XZ PROC ; std::vector<Delay *,std::allocator<Delay *> >::_Getal, COMDAT

; 1818 :         return _Mypair._Get_first();

	mov	rax, rcx

; 1819 :     }

	ret	0
?_Getal@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@AEAAAEAV?$allocator@PEAVDelay@@@2@XZ ENDP ; std::vector<Delay *,std::allocator<Delay *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Orphan_range@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@AEBAXPEAPEAVDelay@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
?_Orphan_range@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@AEBAXPEAPEAVDelay@@0@Z PROC ; std::vector<Delay *,std::allocator<Delay *> >::_Orphan_range, COMDAT

; 1814 :     _CONSTEXPR20_CONTAINER void _Orphan_range(pointer, pointer) const {}

	ret	0
?_Orphan_range@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@AEBAXPEAPEAVDelay@@0@Z ENDP ; std::vector<Delay *,std::allocator<Delay *> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@AEAAXXZ PROC ; std::vector<Delay *,std::allocator<Delay *> >::_Tidy, COMDAT

; 1755 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

$LN25:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 1756 :         auto& _My_data    = _Mypair._Myval2;
; 1757 :         pointer& _Myfirst = _My_data._Myfirst;
; 1758 :         pointer& _Mylast  = _My_data._Mylast;
; 1759 :         pointer& _Myend   = _My_data._Myend;
; 1760 : 
; 1761 :         _My_data._Orphan_all();
; 1762 : 
; 1763 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN2@Tidy

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN18@Tidy

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN15@Tidy

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN18@Tidy:

; 264  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

	and	QWORD PTR [rbx], 0

; 1768 :             _Mylast  = nullptr;

	and	QWORD PTR [rbx+8], 0

; 1769 :             _Myend   = nullptr;

	and	QWORD PTR [rbx+16], 0
$LN2@Tidy:

; 1771 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN15@Tidy:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN22@Tidy:
?_Tidy@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@AEAAXXZ ENDP ; std::vector<Delay *,std::allocator<Delay *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@AEAAXPEAPEAVDelay@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
_First$dead$ = 16
_Last$dead$ = 24
?_Destroy@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@AEAAXPEAPEAVDelay@@0@Z PROC ; std::vector<Delay *,std::allocator<Delay *> >::_Destroy, COMDAT

; 1679 :         // destroy [_First, _Last) using allocator
; 1680 :         _Destroy_range(_First, _Last, _Getal());
; 1681 :     }

	ret	0
?_Destroy@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@AEAAXPEAPEAVDelay@@0@Z ENDP ; std::vector<Delay *,std::allocator<Delay *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Reallocate_exactly@?$vector@MV?$allocator@M@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newcapacity$dead$ = 56
?_Reallocate_exactly@?$vector@MV?$allocator@M@std@@@std@@AEAAX_K@Z PROC ; std::vector<float,std::allocator<float> >::_Reallocate_exactly, COMDAT

; 1299 :     _CONSTEXPR20_CONTAINER void _Reallocate_exactly(const size_type _Newcapacity) {

$LN78:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 1305 :         const auto _Size = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rsi, QWORD PTR [rcx+8]
	mov	rbx, rcx
	sub	rsi, QWORD PTR [rcx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 85   :         return ::operator new(_Bytes);

	mov	ecx, 16423				; 00004027H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1305 :         const auto _Size = static_cast<size_type>(_Mylast - _Myfirst);

	sar	rsi, 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 85   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 142  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN68@Reallocate

; 143  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rdi, QWORD PTR [rax+39]
	and	rdi, -32				; ffffffffffffffe0H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, rdi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 144  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rdi-8], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	r8, QWORD PTR [rbx+8]
	sub	r8, QWORD PTR [rbx]

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, QWORD PTR [rbx]
	call	QWORD PTR __imp_memmove
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1745 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rbx]
	test	rcx, rcx
	je	SHORT $LN61@Reallocate

; 1746 :             _Destroy(_Myfirst, _Mylast);
; 1747 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -4

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN71@Reallocate

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN68@Reallocate

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN71@Reallocate:

; 264  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN61@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1751 :         _Mylast  = _Newvec + _Newsize;

	lea	rax, QWORD PTR [rdi+rsi*4]
	mov	QWORD PTR [rbx], rdi

; 1317 :     }

	mov	rsi, QWORD PTR [rsp+56]

; 1751 :         _Mylast  = _Newvec + _Newsize;

	mov	QWORD PTR [rbx+8], rax

; 1752 :         _Myend   = _Newvec + _Newcapacity;

	lea	rax, QWORD PTR [rdi+16384]
	mov	QWORD PTR [rbx+16], rax

; 1317 :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN68@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN75@Reallocate:
?_Reallocate_exactly@?$vector@MV?$allocator@M@std@@@std@@AEAAX_K@Z ENDP ; std::vector<float,std::allocator<float> >::_Reallocate_exactly
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Move_assign@?$vector@MV?$allocator@M@std@@@std@@AEAAXAEAV12@U_Equal_allocators@2@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
__formal$dead$ = 64
?_Move_assign@?$vector@MV?$allocator@M@std@@@std@@AEAAXAEAV12@U_Equal_allocators@2@@Z PROC ; std::vector<float,std::allocator<float> >::_Move_assign, COMDAT

; 636  :     _CONSTEXPR20_CONTAINER void _Move_assign(vector& _Right, _Equal_allocators) noexcept {

$LN30:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	rdi, rdx

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN4@Move_assig

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -4

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN20@Move_assig

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN17@Move_assig

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN20@Move_assig:

; 264  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

	and	QWORD PTR [rbx], 0

; 1768 :             _Mylast  = nullptr;

	and	QWORD PTR [rbx+8], 0

; 1769 :             _Myend   = nullptr;

	and	QWORD PTR [rbx+16], 0
$LN4@Move_assig:

; 415  :         _Myfirst = _Right._Myfirst;

	mov	rax, QWORD PTR [rdi]
	mov	QWORD PTR [rbx], rax

; 416  :         _Mylast  = _Right._Mylast;

	mov	rax, QWORD PTR [rdi+8]
	mov	QWORD PTR [rbx+8], rax

; 417  :         _Myend   = _Right._Myend;

	mov	rax, QWORD PTR [rdi+16]
	mov	QWORD PTR [rbx+16], rax

; 418  : 
; 419  :         _Right._Myfirst = nullptr;

	and	QWORD PTR [rdi], 0

; 420  :         _Right._Mylast  = nullptr;

	and	QWORD PTR [rdi+8], 0

; 421  :         _Right._Myend   = nullptr;

	and	QWORD PTR [rdi+16], 0

; 640  :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN17@Move_assig:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN27@Move_assig:
?_Move_assign@?$vector@MV?$allocator@M@std@@@std@@AEAAXAEAV12@U_Equal_allocators@2@@Z ENDP ; std::vector<float,std::allocator<float> >::_Move_assign
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@PEAVHighPassFilter@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVHighPassFilter@@@std@@@2@$00@std@@QEAAAEAV?$allocator@PEAVHighPassFilter@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@PEAVHighPassFilter@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVHighPassFilter@@@std@@@2@$00@std@@QEAAAEAV?$allocator@PEAVHighPassFilter@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<HighPassFilter *>,std::_Vector_val<std::_Simple_types<HighPassFilter *> >,1>::_Get_first, COMDAT

; 1378 :         return *this;

	mov	rax, rcx

; 1379 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@PEAVHighPassFilter@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVHighPassFilter@@@std@@@2@$00@std@@QEAAAEAV?$allocator@PEAVHighPassFilter@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<HighPassFilter *>,std::_Vector_val<std::_Simple_types<HighPassFilter *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?deallocate@?$allocator@PEAVHighPassFilter@@@std@@QEAAXQEAPEAVHighPassFilter@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@PEAVHighPassFilter@@@std@@QEAAXQEAPEAVHighPassFilter@@_K@Z PROC ; std::allocator<HighPassFilter *>::deallocate, COMDAT

; 833  :     _CONSTEXPR20_DYNALLOC void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN21:
	sub	rsp, 40					; 00000028H
	mov	rax, rdx

; 834  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [r8*8]

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN15@deallocate

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rax-8]
	add	rdx, 39					; 00000027H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rax, rcx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN12@deallocate

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rax, rcx
$LN15@deallocate:

; 264  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rax

; 836  :     }

	add	rsp, 40					; 00000028H

; 264  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN12@deallocate:

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN18@deallocate:
?deallocate@?$allocator@PEAVHighPassFilter@@@std@@QEAAXQEAPEAVHighPassFilter@@_K@Z ENDP ; std::allocator<HighPassFilter *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@PEAVModulation@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVModulation@@@std@@@2@$00@std@@QEAAAEAV?$allocator@PEAVModulation@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@PEAVModulation@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVModulation@@@std@@@2@$00@std@@QEAAAEAV?$allocator@PEAVModulation@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<Modulation *>,std::_Vector_val<std::_Simple_types<Modulation *> >,1>::_Get_first, COMDAT

; 1378 :         return *this;

	mov	rax, rcx

; 1379 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@PEAVModulation@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVModulation@@@std@@@2@$00@std@@QEAAAEAV?$allocator@PEAVModulation@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<Modulation *>,std::_Vector_val<std::_Simple_types<Modulation *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?deallocate@?$allocator@PEAVModulation@@@std@@QEAAXQEAPEAVModulation@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@PEAVModulation@@@std@@QEAAXQEAPEAVModulation@@_K@Z PROC ; std::allocator<Modulation *>::deallocate, COMDAT

; 833  :     _CONSTEXPR20_DYNALLOC void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN21:
	sub	rsp, 40					; 00000028H
	mov	rax, rdx

; 834  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [r8*8]

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN15@deallocate

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rax-8]
	add	rdx, 39					; 00000027H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rax, rcx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN12@deallocate

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rax, rcx
$LN15@deallocate:

; 264  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rax

; 836  :     }

	add	rsp, 40					; 00000028H

; 264  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN12@deallocate:

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN18@deallocate:
?deallocate@?$allocator@PEAVModulation@@@std@@QEAAXQEAPEAVModulation@@_K@Z ENDP ; std::allocator<Modulation *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@PEAVLowPassFilter@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVLowPassFilter@@@std@@@2@$00@std@@QEAAAEAV?$allocator@PEAVLowPassFilter@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@PEAVLowPassFilter@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVLowPassFilter@@@std@@@2@$00@std@@QEAAAEAV?$allocator@PEAVLowPassFilter@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<LowPassFilter *>,std::_Vector_val<std::_Simple_types<LowPassFilter *> >,1>::_Get_first, COMDAT

; 1378 :         return *this;

	mov	rax, rcx

; 1379 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@PEAVLowPassFilter@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVLowPassFilter@@@std@@@2@$00@std@@QEAAAEAV?$allocator@PEAVLowPassFilter@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<LowPassFilter *>,std::_Vector_val<std::_Simple_types<LowPassFilter *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?deallocate@?$allocator@PEAVLowPassFilter@@@std@@QEAAXQEAPEAVLowPassFilter@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@PEAVLowPassFilter@@@std@@QEAAXQEAPEAVLowPassFilter@@_K@Z PROC ; std::allocator<LowPassFilter *>::deallocate, COMDAT

; 833  :     _CONSTEXPR20_DYNALLOC void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN21:
	sub	rsp, 40					; 00000028H
	mov	rax, rdx

; 834  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [r8*8]

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN15@deallocate

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rax-8]
	add	rdx, 39					; 00000027H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rax, rcx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN12@deallocate

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rax, rcx
$LN15@deallocate:

; 264  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rax

; 836  :     }

	add	rsp, 40					; 00000028H

; 264  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN12@deallocate:

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN18@deallocate:
?deallocate@?$allocator@PEAVLowPassFilter@@@std@@QEAAXQEAPEAVLowPassFilter@@_K@Z ENDP ; std::allocator<LowPassFilter *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVModMultiChannelDiffuser@@@std@@@2@$00@std@@QEAAAEAV?$allocator@PEAVModMultiChannelDiffuser@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVModMultiChannelDiffuser@@@std@@@2@$00@std@@QEAAAEAV?$allocator@PEAVModMultiChannelDiffuser@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<ModMultiChannelDiffuser *>,std::_Vector_val<std::_Simple_types<ModMultiChannelDiffuser *> >,1>::_Get_first, COMDAT

; 1378 :         return *this;

	mov	rax, rcx

; 1379 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVModMultiChannelDiffuser@@@std@@@2@$00@std@@QEAAAEAV?$allocator@PEAVModMultiChannelDiffuser@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<ModMultiChannelDiffuser *>,std::_Vector_val<std::_Simple_types<ModMultiChannelDiffuser *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?deallocate@?$allocator@PEAVModMultiChannelDiffuser@@@std@@QEAAXQEAPEAVModMultiChannelDiffuser@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@PEAVModMultiChannelDiffuser@@@std@@QEAAXQEAPEAVModMultiChannelDiffuser@@_K@Z PROC ; std::allocator<ModMultiChannelDiffuser *>::deallocate, COMDAT

; 833  :     _CONSTEXPR20_DYNALLOC void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN21:
	sub	rsp, 40					; 00000028H
	mov	rax, rdx

; 834  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [r8*8]

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN15@deallocate

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rax-8]
	add	rdx, 39					; 00000027H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rax, rcx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN12@deallocate

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rax, rcx
$LN15@deallocate:

; 264  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rax

; 836  :     }

	add	rsp, 40					; 00000028H

; 264  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN12@deallocate:

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN18@deallocate:
?deallocate@?$allocator@PEAVModMultiChannelDiffuser@@@std@@QEAAXQEAPEAVModMultiChannelDiffuser@@_K@Z ENDP ; std::allocator<ModMultiChannelDiffuser *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@PEAVMultiChannelDiffuser@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVMultiChannelDiffuser@@@std@@@2@$00@std@@QEAAAEAV?$allocator@PEAVMultiChannelDiffuser@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@PEAVMultiChannelDiffuser@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVMultiChannelDiffuser@@@std@@@2@$00@std@@QEAAAEAV?$allocator@PEAVMultiChannelDiffuser@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<MultiChannelDiffuser *>,std::_Vector_val<std::_Simple_types<MultiChannelDiffuser *> >,1>::_Get_first, COMDAT

; 1378 :         return *this;

	mov	rax, rcx

; 1379 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@PEAVMultiChannelDiffuser@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVMultiChannelDiffuser@@@std@@@2@$00@std@@QEAAAEAV?$allocator@PEAVMultiChannelDiffuser@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<MultiChannelDiffuser *>,std::_Vector_val<std::_Simple_types<MultiChannelDiffuser *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?deallocate@?$allocator@PEAVMultiChannelDiffuser@@@std@@QEAAXQEAPEAVMultiChannelDiffuser@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@PEAVMultiChannelDiffuser@@@std@@QEAAXQEAPEAVMultiChannelDiffuser@@_K@Z PROC ; std::allocator<MultiChannelDiffuser *>::deallocate, COMDAT

; 833  :     _CONSTEXPR20_DYNALLOC void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN21:
	sub	rsp, 40					; 00000028H
	mov	rax, rdx

; 834  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [r8*8]

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN15@deallocate

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rax-8]
	add	rdx, 39					; 00000027H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rax, rcx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN12@deallocate

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rax, rcx
$LN15@deallocate:

; 264  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rax

; 836  :     }

	add	rsp, 40					; 00000028H

; 264  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN12@deallocate:

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN18@deallocate:
?deallocate@?$allocator@PEAVMultiChannelDiffuser@@@std@@QEAAXQEAPEAVMultiChannelDiffuser@@_K@Z ENDP ; std::allocator<MultiChannelDiffuser *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@PEAVModDelay@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVModDelay@@@std@@@2@$00@std@@QEAAAEAV?$allocator@PEAVModDelay@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@PEAVModDelay@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVModDelay@@@std@@@2@$00@std@@QEAAAEAV?$allocator@PEAVModDelay@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<ModDelay *>,std::_Vector_val<std::_Simple_types<ModDelay *> >,1>::_Get_first, COMDAT

; 1378 :         return *this;

	mov	rax, rcx

; 1379 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@PEAVModDelay@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVModDelay@@@std@@@2@$00@std@@QEAAAEAV?$allocator@PEAVModDelay@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<ModDelay *>,std::_Vector_val<std::_Simple_types<ModDelay *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?deallocate@?$allocator@PEAVModDelay@@@std@@QEAAXQEAPEAVModDelay@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@PEAVModDelay@@@std@@QEAAXQEAPEAVModDelay@@_K@Z PROC ; std::allocator<ModDelay *>::deallocate, COMDAT

; 833  :     _CONSTEXPR20_DYNALLOC void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN21:
	sub	rsp, 40					; 00000028H
	mov	rax, rdx

; 834  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [r8*8]

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN15@deallocate

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rax-8]
	add	rdx, 39					; 00000027H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rax, rcx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN12@deallocate

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rax, rcx
$LN15@deallocate:

; 264  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rax

; 836  :     }

	add	rsp, 40					; 00000028H

; 264  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN12@deallocate:

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN18@deallocate:
?deallocate@?$allocator@PEAVModDelay@@@std@@QEAAXQEAPEAVModDelay@@_K@Z ENDP ; std::allocator<ModDelay *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QEAAAEAV?$allocator@H@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QEAAAEAV?$allocator@H@2@XZ PROC ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first, COMDAT

; 1378 :         return *this;

	mov	rax, rcx

; 1379 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QEAAAEAV?$allocator@H@2@XZ ENDP ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?deallocate@?$allocator@H@std@@QEAAXQEAH_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@H@std@@QEAAXQEAH_K@Z PROC	; std::allocator<int>::deallocate, COMDAT

; 833  :     _CONSTEXPR20_DYNALLOC void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN21:
	sub	rsp, 40					; 00000028H
	mov	rax, rdx

; 834  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [r8*4]

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN15@deallocate

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rax-8]
	add	rdx, 39					; 00000027H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rax, rcx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN12@deallocate

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rax, rcx
$LN15@deallocate:

; 264  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rax

; 836  :     }

	add	rsp, 40					; 00000028H

; 264  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN12@deallocate:

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN18@deallocate:
?deallocate@?$allocator@H@std@@QEAAXQEAH_K@Z ENDP	; std::allocator<int>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@PEAVDelay@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVDelay@@@std@@@2@$00@std@@QEAAAEAV?$allocator@PEAVDelay@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@PEAVDelay@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVDelay@@@std@@@2@$00@std@@QEAAAEAV?$allocator@PEAVDelay@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<Delay *>,std::_Vector_val<std::_Simple_types<Delay *> >,1>::_Get_first, COMDAT

; 1378 :         return *this;

	mov	rax, rcx

; 1379 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@PEAVDelay@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVDelay@@@std@@@2@$00@std@@QEAAAEAV?$allocator@PEAVDelay@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<Delay *>,std::_Vector_val<std::_Simple_types<Delay *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?deallocate@?$allocator@PEAVDelay@@@std@@QEAAXQEAPEAVDelay@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@PEAVDelay@@@std@@QEAAXQEAPEAVDelay@@_K@Z PROC ; std::allocator<Delay *>::deallocate, COMDAT

; 833  :     _CONSTEXPR20_DYNALLOC void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN21:
	sub	rsp, 40					; 00000028H
	mov	rax, rdx

; 834  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [r8*8]

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN15@deallocate

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rax-8]
	add	rdx, 39					; 00000027H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rax, rcx

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN12@deallocate

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rax, rcx
$LN15@deallocate:

; 264  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rax

; 836  :     }

	add	rsp, 40					; 00000028H

; 264  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN12@deallocate:

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN18@deallocate:
?deallocate@?$allocator@PEAVDelay@@@std@@QEAAXQEAPEAVDelay@@_K@Z ENDP ; std::allocator<Delay *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Take_contents@?$_Vector_val@U?$_Simple_types@M@std@@@std@@QEAAXAEAV12@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
?_Take_contents@?$_Vector_val@U?$_Simple_types@M@std@@@std@@QEAAXAEAV12@@Z PROC ; std::_Vector_val<std::_Simple_types<float> >::_Take_contents, COMDAT

; 414  :         this->_Swap_proxy_and_iterators(_Right);
; 415  :         _Myfirst = _Right._Myfirst;

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax

; 416  :         _Mylast  = _Right._Mylast;

	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR [rcx+8], rax

; 417  :         _Myend   = _Right._Myend;

	mov	rax, QWORD PTR [rdx+16]
	mov	QWORD PTR [rcx+16], rax

; 418  : 
; 419  :         _Right._Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rdx], rax

; 420  :         _Right._Mylast  = nullptr;

	mov	QWORD PTR [rdx+8], rax

; 421  :         _Right._Myend   = nullptr;

	mov	QWORD PTR [rdx+16], rax

; 422  :     }

	ret	0
?_Take_contents@?$_Vector_val@U?$_Simple_types@M@std@@@std@@QEAAXAEAV12@@Z ENDP ; std::_Vector_val<std::_Simple_types<float> >::_Take_contents
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AEAPEAVHighPassFilter@@@std@@YA$$QEAPEAVHighPassFilter@@AEAPEAV1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAPEAVHighPassFilter@@@std@@YA$$QEAPEAVHighPassFilter@@AEAPEAV1@@Z PROC ; std::move<HighPassFilter * &>, COMDAT

; 1456 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1457 : }

	ret	0
??$move@AEAPEAVHighPassFilter@@@std@@YA$$QEAPEAVHighPassFilter@@AEAPEAV1@@Z ENDP ; std::move<HighPassFilter * &>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@PEAVHighPassFilter@@@std@@YA$$QEAPEAVHighPassFilter@@AEAPEAV1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAVHighPassFilter@@@std@@YA$$QEAPEAVHighPassFilter@@AEAPEAV1@@Z PROC ; std::forward<HighPassFilter *>, COMDAT

; 1444 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1445 : }

	ret	0
??$forward@PEAVHighPassFilter@@@std@@YA$$QEAPEAVHighPassFilter@@AEAPEAV1@@Z ENDP ; std::forward<HighPassFilter *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@PEAVHighPassFilter@@@std@@YAPEAPEAVHighPassFilter@@PEAPEAV1@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@PEAVHighPassFilter@@@std@@YAPEAPEAVHighPassFilter@@PEAPEAV1@@Z PROC ; std::_Unfancy<HighPassFilter *>, COMDAT

; 289  :     return _Ptr;

	mov	rax, rcx

; 290  : }

	ret	0
??$_Unfancy@PEAVHighPassFilter@@@std@@YAPEAPEAVHighPassFilter@@PEAPEAV1@@Z ENDP ; std::_Unfancy<HighPassFilter *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@PEAVHighPassFilter@@PEAV1@@?$_Default_allocator_traits@V?$allocator@PEAVHighPassFilter@@@std@@@std@@SAXAEAV?$allocator@PEAVHighPassFilter@@@1@QEAPEAVHighPassFilter@@$$QEAPEAV3@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@PEAVHighPassFilter@@PEAV1@@?$_Default_allocator_traits@V?$allocator@PEAVHighPassFilter@@@std@@@std@@SAXAEAV?$allocator@PEAVHighPassFilter@@@1@QEAPEAVHighPassFilter@@$$QEAPEAV3@@Z PROC ; std::_Default_allocator_traits<std::allocator<HighPassFilter *> >::construct<HighPassFilter *,HighPassFilter *>, COMDAT

; 708  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 709  :         if (_STD is_constant_evaluated()) {
; 710  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 711  :         } else
; 712  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 713  :         {
; 714  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rdx], rax

; 715  :         }
; 716  :     }

	ret	0
??$construct@PEAVHighPassFilter@@PEAV1@@?$_Default_allocator_traits@V?$allocator@PEAVHighPassFilter@@@std@@@std@@SAXAEAV?$allocator@PEAVHighPassFilter@@@1@QEAPEAVHighPassFilter@@$$QEAPEAV3@@Z ENDP ; std::_Default_allocator_traits<std::allocator<HighPassFilter *> >::construct<HighPassFilter *,HighPassFilter *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_reallocate@PEAVHighPassFilter@@@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEAAPEAPEAVHighPassFilter@@QEAPEAV2@$$QEAPEAV2@@Z
_TEXT	SEGMENT
this$ = 80
_Whereptr$ = 88
<_Val_0>$ = 96
??$_Emplace_reallocate@PEAVHighPassFilter@@@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEAAPEAPEAVHighPassFilter@@QEAPEAV2@$$QEAPEAV2@@Z PROC ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::_Emplace_reallocate<HighPassFilter *>, COMDAT

; 765  :     _CONSTEXPR20_CONTAINER pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

$LN120:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 766  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 767  :         _Alty& _Al        = _Getal();
; 768  :         auto& _My_data    = _Mypair._Myval2;
; 769  :         pointer& _Myfirst = _My_data._Myfirst;
; 770  :         pointer& _Mylast  = _My_data._Mylast;
; 771  : 
; 772  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 773  : 
; 774  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);
; 775  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rax, QWORD PTR [rcx+8]
	mov	rbp, rdx
	sub	rbp, QWORD PTR [rcx]
	mov	r13, r8
	sub	rax, QWORD PTR [rcx]

; 776  : 
; 777  :         if (_Oldsize == max_size()) {

	mov	r8, 2305843009213693951			; 1fffffffffffffffH
	sar	rbp, 3
	mov	r15, rdx
	sar	rax, 3
	mov	rdi, rcx
	cmp	rax, r8
	je	$LN118@Emplace_re

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rcx+16]

; 779  :         }
; 780  : 
; 781  :         const size_type _Newsize     = _Oldsize + 1;

	lea	r12, QWORD PTR [rax+1]

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sub	rcx, QWORD PTR [rdi]

; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, r8

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	rcx, 3

; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx
	shr	rdx, 1
	sub	rax, rdx
	cmp	rcx, rax
	ja	$LN114@Emplace_re

; 1689 :             return _Max; // geometric growth would overflow
; 1690 :         }
; 1691 : 
; 1692 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rax, QWORD PTR [rdx+rcx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 64   :         if (_Count > _Max_possible) {

	mov	rsi, r12
	cmp	rax, r12
	cmovae	rsi, rax
	cmp	rsi, r8
	ja	$LN114@Emplace_re

; 65   :             _Throw_bad_array_new_length(); // multiply overflow
; 66   :         }
; 67   :     }
; 68   : 
; 69   :     return _Count * _Ty_size;

	shl	rsi, 3

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rsi, 4096				; 00001000H
	jb	SHORT $LN24@Emplace_re

; 136  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rsi+39]

; 137  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rsi
	jbe	$LN114@Emplace_re

; 85   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 142  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN105@Emplace_re

; 143  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rbx, QWORD PTR [rax+39]
	and	rbx, -32				; ffffffffffffffe0H

; 144  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rbx-8], rax

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN23@Emplace_re
$LN24@Emplace_re:

; 239  :         }
; 240  :     }
; 241  : #endif // defined(_M_IX86) || defined(_M_X64)
; 242  : 
; 243  :     if (_Bytes != 0) {

	test	rsi, rsi
	je	SHORT $LN25@Emplace_re

; 85   :         return ::operator new(_Bytes);

	mov	rcx, rsi
	call	??2@YAPEAX_K@Z				; operator new
	mov	rbx, rax

; 244  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN23@Emplace_re
$LN25@Emplace_re:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

	xor	ebx, ebx
$LN23@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 789  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	mov	rax, QWORD PTR [r13]
	lea	r14, QWORD PTR [rbx+rbp*8]
	mov	QWORD PTR [r14], rax

; 790  :         _Constructed_first = _Newvec + _Whereoff;
; 791  : 
; 792  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	rcx, rbx
	mov	r8, QWORD PTR [rdi+8]
	mov	rdx, QWORD PTR [rdi]
	cmp	r15, r8
	jne	SHORT $LN4@Emplace_re
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 794  :         } else { // provide basic guarantee

	jmp	SHORT $LN116@Emplace_re
$LN4@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	r8, r15
	sub	r8, QWORD PTR [rdi]

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	call	QWORD PTR __imp_memmove

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	r8, QWORD PTR [rdi+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 797  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

	lea	rcx, QWORD PTR [r14+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, r15

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, r15
$LN116@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 797  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

	call	QWORD PTR __imp_memmove

; 1745 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rdi]
	test	rcx, rcx
	je	SHORT $LN98@Emplace_re

; 1746 :             _Destroy(_Myfirst, _Mylast);
; 1747 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rdi+16]
	sub	rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN108@Emplace_re

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN105@Emplace_re

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN108@Emplace_re:

; 264  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN98@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 807  :     }

	mov	rbp, QWORD PTR [rsp+88]

; 1751 :         _Mylast  = _Newvec + _Newsize;

	lea	rcx, QWORD PTR [rbx+r12*8]
	mov	QWORD PTR [rdi], rbx

; 798  :         }
; 799  :         _CATCH_ALL
; 800  :         _Destroy(_Constructed_first, _Constructed_last);
; 801  :         _Al.deallocate(_Newvec, _Newcapacity);
; 802  :         _RERAISE;
; 803  :         _CATCH_END
; 804  : 
; 805  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 806  :         return _Newvec + _Whereoff;

	mov	rax, r14

; 1751 :         _Mylast  = _Newvec + _Newsize;

	mov	QWORD PTR [rdi+8], rcx

; 1752 :         _Myend   = _Newvec + _Newcapacity;

	lea	rcx, QWORD PTR [rsi+rbx]

; 807  :     }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+96]

; 1752 :         _Myend   = _Newvec + _Newcapacity;

	mov	QWORD PTR [rdi+16], rcx

; 807  :     }

	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
$LN105@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN118@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 778  :             _Xlength();

	call	?_Xlength@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@CAXXZ ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::_Xlength
	int	3
$LN114@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 138  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN115@Emplace_re:
??$_Emplace_reallocate@PEAVHighPassFilter@@@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEAAPEAPEAVHighPassFilter@@QEAPEAV2@$$QEAPEAV2@@Z ENDP ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::_Emplace_reallocate<HighPassFilter *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@PEAVHighPassFilter@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVHighPassFilter@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0$$V@?$_Compressed_pair@V?$allocator@PEAVHighPassFilter@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVHighPassFilter@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<HighPassFilter *>,std::_Vector_val<std::_Simple_types<HighPassFilter *> >,1>::_Compressed_pair<std::allocator<HighPassFilter *>,std::_Vector_val<std::_Simple_types<HighPassFilter *> >,1><>, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1370 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@PEAVHighPassFilter@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVHighPassFilter@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<HighPassFilter *>,std::_Vector_val<std::_Simple_types<HighPassFilter *> >,1>::_Compressed_pair<std::allocator<HighPassFilter *>,std::_Vector_val<std::_Simple_types<HighPassFilter *> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AEAPEAVModulation@@@std@@YA$$QEAPEAVModulation@@AEAPEAV1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAPEAVModulation@@@std@@YA$$QEAPEAVModulation@@AEAPEAV1@@Z PROC ; std::move<Modulation * &>, COMDAT

; 1456 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1457 : }

	ret	0
??$move@AEAPEAVModulation@@@std@@YA$$QEAPEAVModulation@@AEAPEAV1@@Z ENDP ; std::move<Modulation * &>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@PEAVModulation@@@std@@YA$$QEAPEAVModulation@@AEAPEAV1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAVModulation@@@std@@YA$$QEAPEAVModulation@@AEAPEAV1@@Z PROC ; std::forward<Modulation *>, COMDAT

; 1444 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1445 : }

	ret	0
??$forward@PEAVModulation@@@std@@YA$$QEAPEAVModulation@@AEAPEAV1@@Z ENDP ; std::forward<Modulation *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@PEAVModulation@@@std@@YAPEAPEAVModulation@@PEAPEAV1@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@PEAVModulation@@@std@@YAPEAPEAVModulation@@PEAPEAV1@@Z PROC ; std::_Unfancy<Modulation *>, COMDAT

; 289  :     return _Ptr;

	mov	rax, rcx

; 290  : }

	ret	0
??$_Unfancy@PEAVModulation@@@std@@YAPEAPEAVModulation@@PEAPEAV1@@Z ENDP ; std::_Unfancy<Modulation *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@PEAVModulation@@PEAV1@@?$_Default_allocator_traits@V?$allocator@PEAVModulation@@@std@@@std@@SAXAEAV?$allocator@PEAVModulation@@@1@QEAPEAVModulation@@$$QEAPEAV3@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@PEAVModulation@@PEAV1@@?$_Default_allocator_traits@V?$allocator@PEAVModulation@@@std@@@std@@SAXAEAV?$allocator@PEAVModulation@@@1@QEAPEAVModulation@@$$QEAPEAV3@@Z PROC ; std::_Default_allocator_traits<std::allocator<Modulation *> >::construct<Modulation *,Modulation *>, COMDAT

; 708  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 709  :         if (_STD is_constant_evaluated()) {
; 710  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 711  :         } else
; 712  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 713  :         {
; 714  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rdx], rax

; 715  :         }
; 716  :     }

	ret	0
??$construct@PEAVModulation@@PEAV1@@?$_Default_allocator_traits@V?$allocator@PEAVModulation@@@std@@@std@@SAXAEAV?$allocator@PEAVModulation@@@1@QEAPEAVModulation@@$$QEAPEAV3@@Z ENDP ; std::_Default_allocator_traits<std::allocator<Modulation *> >::construct<Modulation *,Modulation *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_reallocate@PEAVModulation@@@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@QEAAPEAPEAVModulation@@QEAPEAV2@$$QEAPEAV2@@Z
_TEXT	SEGMENT
this$ = 80
_Whereptr$ = 88
<_Val_0>$ = 96
??$_Emplace_reallocate@PEAVModulation@@@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@QEAAPEAPEAVModulation@@QEAPEAV2@$$QEAPEAV2@@Z PROC ; std::vector<Modulation *,std::allocator<Modulation *> >::_Emplace_reallocate<Modulation *>, COMDAT

; 765  :     _CONSTEXPR20_CONTAINER pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

$LN120:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 766  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 767  :         _Alty& _Al        = _Getal();
; 768  :         auto& _My_data    = _Mypair._Myval2;
; 769  :         pointer& _Myfirst = _My_data._Myfirst;
; 770  :         pointer& _Mylast  = _My_data._Mylast;
; 771  : 
; 772  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 773  : 
; 774  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);
; 775  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rax, QWORD PTR [rcx+8]
	mov	rbp, rdx
	sub	rbp, QWORD PTR [rcx]
	mov	r13, r8
	sub	rax, QWORD PTR [rcx]

; 776  : 
; 777  :         if (_Oldsize == max_size()) {

	mov	r8, 2305843009213693951			; 1fffffffffffffffH
	sar	rbp, 3
	mov	r15, rdx
	sar	rax, 3
	mov	rdi, rcx
	cmp	rax, r8
	je	$LN118@Emplace_re

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rcx+16]

; 779  :         }
; 780  : 
; 781  :         const size_type _Newsize     = _Oldsize + 1;

	lea	r12, QWORD PTR [rax+1]

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sub	rcx, QWORD PTR [rdi]

; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, r8

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	rcx, 3

; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx
	shr	rdx, 1
	sub	rax, rdx
	cmp	rcx, rax
	ja	$LN114@Emplace_re

; 1689 :             return _Max; // geometric growth would overflow
; 1690 :         }
; 1691 : 
; 1692 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rax, QWORD PTR [rdx+rcx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 64   :         if (_Count > _Max_possible) {

	mov	rsi, r12
	cmp	rax, r12
	cmovae	rsi, rax
	cmp	rsi, r8
	ja	$LN114@Emplace_re

; 65   :             _Throw_bad_array_new_length(); // multiply overflow
; 66   :         }
; 67   :     }
; 68   : 
; 69   :     return _Count * _Ty_size;

	shl	rsi, 3

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rsi, 4096				; 00001000H
	jb	SHORT $LN24@Emplace_re

; 136  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rsi+39]

; 137  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rsi
	jbe	$LN114@Emplace_re

; 85   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 142  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN105@Emplace_re

; 143  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rbx, QWORD PTR [rax+39]
	and	rbx, -32				; ffffffffffffffe0H

; 144  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rbx-8], rax

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN23@Emplace_re
$LN24@Emplace_re:

; 239  :         }
; 240  :     }
; 241  : #endif // defined(_M_IX86) || defined(_M_X64)
; 242  : 
; 243  :     if (_Bytes != 0) {

	test	rsi, rsi
	je	SHORT $LN25@Emplace_re

; 85   :         return ::operator new(_Bytes);

	mov	rcx, rsi
	call	??2@YAPEAX_K@Z				; operator new
	mov	rbx, rax

; 244  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN23@Emplace_re
$LN25@Emplace_re:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

	xor	ebx, ebx
$LN23@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 789  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	mov	rax, QWORD PTR [r13]
	lea	r14, QWORD PTR [rbx+rbp*8]
	mov	QWORD PTR [r14], rax

; 790  :         _Constructed_first = _Newvec + _Whereoff;
; 791  : 
; 792  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	rcx, rbx
	mov	r8, QWORD PTR [rdi+8]
	mov	rdx, QWORD PTR [rdi]
	cmp	r15, r8
	jne	SHORT $LN4@Emplace_re
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 794  :         } else { // provide basic guarantee

	jmp	SHORT $LN116@Emplace_re
$LN4@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	r8, r15
	sub	r8, QWORD PTR [rdi]

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	call	QWORD PTR __imp_memmove

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	r8, QWORD PTR [rdi+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 797  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

	lea	rcx, QWORD PTR [r14+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, r15

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, r15
$LN116@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 797  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

	call	QWORD PTR __imp_memmove

; 1745 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rdi]
	test	rcx, rcx
	je	SHORT $LN98@Emplace_re

; 1746 :             _Destroy(_Myfirst, _Mylast);
; 1747 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rdi+16]
	sub	rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN108@Emplace_re

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN105@Emplace_re

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN108@Emplace_re:

; 264  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN98@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 807  :     }

	mov	rbp, QWORD PTR [rsp+88]

; 1751 :         _Mylast  = _Newvec + _Newsize;

	lea	rcx, QWORD PTR [rbx+r12*8]
	mov	QWORD PTR [rdi], rbx

; 798  :         }
; 799  :         _CATCH_ALL
; 800  :         _Destroy(_Constructed_first, _Constructed_last);
; 801  :         _Al.deallocate(_Newvec, _Newcapacity);
; 802  :         _RERAISE;
; 803  :         _CATCH_END
; 804  : 
; 805  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 806  :         return _Newvec + _Whereoff;

	mov	rax, r14

; 1751 :         _Mylast  = _Newvec + _Newsize;

	mov	QWORD PTR [rdi+8], rcx

; 1752 :         _Myend   = _Newvec + _Newcapacity;

	lea	rcx, QWORD PTR [rsi+rbx]

; 807  :     }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+96]

; 1752 :         _Myend   = _Newvec + _Newcapacity;

	mov	QWORD PTR [rdi+16], rcx

; 807  :     }

	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
$LN105@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN118@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 778  :             _Xlength();

	call	?_Xlength@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@CAXXZ ; std::vector<Modulation *,std::allocator<Modulation *> >::_Xlength
	int	3
$LN114@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 138  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN115@Emplace_re:
??$_Emplace_reallocate@PEAVModulation@@@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@QEAAPEAPEAVModulation@@QEAPEAV2@$$QEAPEAV2@@Z ENDP ; std::vector<Modulation *,std::allocator<Modulation *> >::_Emplace_reallocate<Modulation *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@PEAVModulation@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVModulation@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0$$V@?$_Compressed_pair@V?$allocator@PEAVModulation@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVModulation@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<Modulation *>,std::_Vector_val<std::_Simple_types<Modulation *> >,1>::_Compressed_pair<std::allocator<Modulation *>,std::_Vector_val<std::_Simple_types<Modulation *> >,1><>, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1370 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@PEAVModulation@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVModulation@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<Modulation *>,std::_Vector_val<std::_Simple_types<Modulation *> >,1>::_Compressed_pair<std::allocator<Modulation *>,std::_Vector_val<std::_Simple_types<Modulation *> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AEAPEAVLowPassFilter@@@std@@YA$$QEAPEAVLowPassFilter@@AEAPEAV1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAPEAVLowPassFilter@@@std@@YA$$QEAPEAVLowPassFilter@@AEAPEAV1@@Z PROC ; std::move<LowPassFilter * &>, COMDAT

; 1456 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1457 : }

	ret	0
??$move@AEAPEAVLowPassFilter@@@std@@YA$$QEAPEAVLowPassFilter@@AEAPEAV1@@Z ENDP ; std::move<LowPassFilter * &>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@PEAVLowPassFilter@@@std@@YA$$QEAPEAVLowPassFilter@@AEAPEAV1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAVLowPassFilter@@@std@@YA$$QEAPEAVLowPassFilter@@AEAPEAV1@@Z PROC ; std::forward<LowPassFilter *>, COMDAT

; 1444 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1445 : }

	ret	0
??$forward@PEAVLowPassFilter@@@std@@YA$$QEAPEAVLowPassFilter@@AEAPEAV1@@Z ENDP ; std::forward<LowPassFilter *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@PEAVLowPassFilter@@@std@@YAPEAPEAVLowPassFilter@@PEAPEAV1@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@PEAVLowPassFilter@@@std@@YAPEAPEAVLowPassFilter@@PEAPEAV1@@Z PROC ; std::_Unfancy<LowPassFilter *>, COMDAT

; 289  :     return _Ptr;

	mov	rax, rcx

; 290  : }

	ret	0
??$_Unfancy@PEAVLowPassFilter@@@std@@YAPEAPEAVLowPassFilter@@PEAPEAV1@@Z ENDP ; std::_Unfancy<LowPassFilter *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@PEAVLowPassFilter@@PEAV1@@?$_Default_allocator_traits@V?$allocator@PEAVLowPassFilter@@@std@@@std@@SAXAEAV?$allocator@PEAVLowPassFilter@@@1@QEAPEAVLowPassFilter@@$$QEAPEAV3@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@PEAVLowPassFilter@@PEAV1@@?$_Default_allocator_traits@V?$allocator@PEAVLowPassFilter@@@std@@@std@@SAXAEAV?$allocator@PEAVLowPassFilter@@@1@QEAPEAVLowPassFilter@@$$QEAPEAV3@@Z PROC ; std::_Default_allocator_traits<std::allocator<LowPassFilter *> >::construct<LowPassFilter *,LowPassFilter *>, COMDAT

; 708  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 709  :         if (_STD is_constant_evaluated()) {
; 710  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 711  :         } else
; 712  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 713  :         {
; 714  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rdx], rax

; 715  :         }
; 716  :     }

	ret	0
??$construct@PEAVLowPassFilter@@PEAV1@@?$_Default_allocator_traits@V?$allocator@PEAVLowPassFilter@@@std@@@std@@SAXAEAV?$allocator@PEAVLowPassFilter@@@1@QEAPEAVLowPassFilter@@$$QEAPEAV3@@Z ENDP ; std::_Default_allocator_traits<std::allocator<LowPassFilter *> >::construct<LowPassFilter *,LowPassFilter *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_reallocate@PEAVLowPassFilter@@@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEAAPEAPEAVLowPassFilter@@QEAPEAV2@$$QEAPEAV2@@Z
_TEXT	SEGMENT
this$ = 80
_Whereptr$ = 88
<_Val_0>$ = 96
??$_Emplace_reallocate@PEAVLowPassFilter@@@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEAAPEAPEAVLowPassFilter@@QEAPEAV2@$$QEAPEAV2@@Z PROC ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::_Emplace_reallocate<LowPassFilter *>, COMDAT

; 765  :     _CONSTEXPR20_CONTAINER pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

$LN120:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 766  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 767  :         _Alty& _Al        = _Getal();
; 768  :         auto& _My_data    = _Mypair._Myval2;
; 769  :         pointer& _Myfirst = _My_data._Myfirst;
; 770  :         pointer& _Mylast  = _My_data._Mylast;
; 771  : 
; 772  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 773  : 
; 774  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);
; 775  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rax, QWORD PTR [rcx+8]
	mov	rbp, rdx
	sub	rbp, QWORD PTR [rcx]
	mov	r13, r8
	sub	rax, QWORD PTR [rcx]

; 776  : 
; 777  :         if (_Oldsize == max_size()) {

	mov	r8, 2305843009213693951			; 1fffffffffffffffH
	sar	rbp, 3
	mov	r15, rdx
	sar	rax, 3
	mov	rdi, rcx
	cmp	rax, r8
	je	$LN118@Emplace_re

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rcx+16]

; 779  :         }
; 780  : 
; 781  :         const size_type _Newsize     = _Oldsize + 1;

	lea	r12, QWORD PTR [rax+1]

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sub	rcx, QWORD PTR [rdi]

; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, r8

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	rcx, 3

; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx
	shr	rdx, 1
	sub	rax, rdx
	cmp	rcx, rax
	ja	$LN114@Emplace_re

; 1689 :             return _Max; // geometric growth would overflow
; 1690 :         }
; 1691 : 
; 1692 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rax, QWORD PTR [rdx+rcx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 64   :         if (_Count > _Max_possible) {

	mov	rsi, r12
	cmp	rax, r12
	cmovae	rsi, rax
	cmp	rsi, r8
	ja	$LN114@Emplace_re

; 65   :             _Throw_bad_array_new_length(); // multiply overflow
; 66   :         }
; 67   :     }
; 68   : 
; 69   :     return _Count * _Ty_size;

	shl	rsi, 3

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rsi, 4096				; 00001000H
	jb	SHORT $LN24@Emplace_re

; 136  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rsi+39]

; 137  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rsi
	jbe	$LN114@Emplace_re

; 85   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 142  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN105@Emplace_re

; 143  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rbx, QWORD PTR [rax+39]
	and	rbx, -32				; ffffffffffffffe0H

; 144  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rbx-8], rax

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN23@Emplace_re
$LN24@Emplace_re:

; 239  :         }
; 240  :     }
; 241  : #endif // defined(_M_IX86) || defined(_M_X64)
; 242  : 
; 243  :     if (_Bytes != 0) {

	test	rsi, rsi
	je	SHORT $LN25@Emplace_re

; 85   :         return ::operator new(_Bytes);

	mov	rcx, rsi
	call	??2@YAPEAX_K@Z				; operator new
	mov	rbx, rax

; 244  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN23@Emplace_re
$LN25@Emplace_re:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

	xor	ebx, ebx
$LN23@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 789  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	mov	rax, QWORD PTR [r13]
	lea	r14, QWORD PTR [rbx+rbp*8]
	mov	QWORD PTR [r14], rax

; 790  :         _Constructed_first = _Newvec + _Whereoff;
; 791  : 
; 792  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	rcx, rbx
	mov	r8, QWORD PTR [rdi+8]
	mov	rdx, QWORD PTR [rdi]
	cmp	r15, r8
	jne	SHORT $LN4@Emplace_re
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 794  :         } else { // provide basic guarantee

	jmp	SHORT $LN116@Emplace_re
$LN4@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	r8, r15
	sub	r8, QWORD PTR [rdi]

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	call	QWORD PTR __imp_memmove

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	r8, QWORD PTR [rdi+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 797  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

	lea	rcx, QWORD PTR [r14+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, r15

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, r15
$LN116@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 797  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

	call	QWORD PTR __imp_memmove

; 1745 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rdi]
	test	rcx, rcx
	je	SHORT $LN98@Emplace_re

; 1746 :             _Destroy(_Myfirst, _Mylast);
; 1747 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rdi+16]
	sub	rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN108@Emplace_re

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN105@Emplace_re

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN108@Emplace_re:

; 264  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN98@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 807  :     }

	mov	rbp, QWORD PTR [rsp+88]

; 1751 :         _Mylast  = _Newvec + _Newsize;

	lea	rcx, QWORD PTR [rbx+r12*8]
	mov	QWORD PTR [rdi], rbx

; 798  :         }
; 799  :         _CATCH_ALL
; 800  :         _Destroy(_Constructed_first, _Constructed_last);
; 801  :         _Al.deallocate(_Newvec, _Newcapacity);
; 802  :         _RERAISE;
; 803  :         _CATCH_END
; 804  : 
; 805  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 806  :         return _Newvec + _Whereoff;

	mov	rax, r14

; 1751 :         _Mylast  = _Newvec + _Newsize;

	mov	QWORD PTR [rdi+8], rcx

; 1752 :         _Myend   = _Newvec + _Newcapacity;

	lea	rcx, QWORD PTR [rsi+rbx]

; 807  :     }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+96]

; 1752 :         _Myend   = _Newvec + _Newcapacity;

	mov	QWORD PTR [rdi+16], rcx

; 807  :     }

	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
$LN105@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN118@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 778  :             _Xlength();

	call	?_Xlength@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@CAXXZ ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::_Xlength
	int	3
$LN114@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 138  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN115@Emplace_re:
??$_Emplace_reallocate@PEAVLowPassFilter@@@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEAAPEAPEAVLowPassFilter@@QEAPEAV2@$$QEAPEAV2@@Z ENDP ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::_Emplace_reallocate<LowPassFilter *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@PEAVLowPassFilter@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVLowPassFilter@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0$$V@?$_Compressed_pair@V?$allocator@PEAVLowPassFilter@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVLowPassFilter@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<LowPassFilter *>,std::_Vector_val<std::_Simple_types<LowPassFilter *> >,1>::_Compressed_pair<std::allocator<LowPassFilter *>,std::_Vector_val<std::_Simple_types<LowPassFilter *> >,1><>, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1370 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@PEAVLowPassFilter@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVLowPassFilter@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<LowPassFilter *>,std::_Vector_val<std::_Simple_types<LowPassFilter *> >,1>::_Compressed_pair<std::allocator<LowPassFilter *>,std::_Vector_val<std::_Simple_types<LowPassFilter *> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AEAPEAVModMultiChannelDiffuser@@@std@@YA$$QEAPEAVModMultiChannelDiffuser@@AEAPEAV1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAPEAVModMultiChannelDiffuser@@@std@@YA$$QEAPEAVModMultiChannelDiffuser@@AEAPEAV1@@Z PROC ; std::move<ModMultiChannelDiffuser * &>, COMDAT

; 1456 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1457 : }

	ret	0
??$move@AEAPEAVModMultiChannelDiffuser@@@std@@YA$$QEAPEAVModMultiChannelDiffuser@@AEAPEAV1@@Z ENDP ; std::move<ModMultiChannelDiffuser * &>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@PEAVModMultiChannelDiffuser@@@std@@YA$$QEAPEAVModMultiChannelDiffuser@@AEAPEAV1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAVModMultiChannelDiffuser@@@std@@YA$$QEAPEAVModMultiChannelDiffuser@@AEAPEAV1@@Z PROC ; std::forward<ModMultiChannelDiffuser *>, COMDAT

; 1444 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1445 : }

	ret	0
??$forward@PEAVModMultiChannelDiffuser@@@std@@YA$$QEAPEAVModMultiChannelDiffuser@@AEAPEAV1@@Z ENDP ; std::forward<ModMultiChannelDiffuser *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@PEAVModMultiChannelDiffuser@@@std@@YAPEAPEAVModMultiChannelDiffuser@@PEAPEAV1@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@PEAVModMultiChannelDiffuser@@@std@@YAPEAPEAVModMultiChannelDiffuser@@PEAPEAV1@@Z PROC ; std::_Unfancy<ModMultiChannelDiffuser *>, COMDAT

; 289  :     return _Ptr;

	mov	rax, rcx

; 290  : }

	ret	0
??$_Unfancy@PEAVModMultiChannelDiffuser@@@std@@YAPEAPEAVModMultiChannelDiffuser@@PEAPEAV1@@Z ENDP ; std::_Unfancy<ModMultiChannelDiffuser *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@PEAVModMultiChannelDiffuser@@PEAV1@@?$_Default_allocator_traits@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@SAXAEAV?$allocator@PEAVModMultiChannelDiffuser@@@1@QEAPEAVModMultiChannelDiffuser@@$$QEAPEAV3@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@PEAVModMultiChannelDiffuser@@PEAV1@@?$_Default_allocator_traits@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@SAXAEAV?$allocator@PEAVModMultiChannelDiffuser@@@1@QEAPEAVModMultiChannelDiffuser@@$$QEAPEAV3@@Z PROC ; std::_Default_allocator_traits<std::allocator<ModMultiChannelDiffuser *> >::construct<ModMultiChannelDiffuser *,ModMultiChannelDiffuser *>, COMDAT

; 708  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 709  :         if (_STD is_constant_evaluated()) {
; 710  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 711  :         } else
; 712  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 713  :         {
; 714  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rdx], rax

; 715  :         }
; 716  :     }

	ret	0
??$construct@PEAVModMultiChannelDiffuser@@PEAV1@@?$_Default_allocator_traits@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@SAXAEAV?$allocator@PEAVModMultiChannelDiffuser@@@1@QEAPEAVModMultiChannelDiffuser@@$$QEAPEAV3@@Z ENDP ; std::_Default_allocator_traits<std::allocator<ModMultiChannelDiffuser *> >::construct<ModMultiChannelDiffuser *,ModMultiChannelDiffuser *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_reallocate@PEAVModMultiChannelDiffuser@@@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEAAPEAPEAVModMultiChannelDiffuser@@QEAPEAV2@$$QEAPEAV2@@Z
_TEXT	SEGMENT
this$ = 80
_Whereptr$ = 88
<_Val_0>$ = 96
??$_Emplace_reallocate@PEAVModMultiChannelDiffuser@@@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEAAPEAPEAVModMultiChannelDiffuser@@QEAPEAV2@$$QEAPEAV2@@Z PROC ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::_Emplace_reallocate<ModMultiChannelDiffuser *>, COMDAT

; 765  :     _CONSTEXPR20_CONTAINER pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

$LN120:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 766  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 767  :         _Alty& _Al        = _Getal();
; 768  :         auto& _My_data    = _Mypair._Myval2;
; 769  :         pointer& _Myfirst = _My_data._Myfirst;
; 770  :         pointer& _Mylast  = _My_data._Mylast;
; 771  : 
; 772  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 773  : 
; 774  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);
; 775  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rax, QWORD PTR [rcx+8]
	mov	rbp, rdx
	sub	rbp, QWORD PTR [rcx]
	mov	r13, r8
	sub	rax, QWORD PTR [rcx]

; 776  : 
; 777  :         if (_Oldsize == max_size()) {

	mov	r8, 2305843009213693951			; 1fffffffffffffffH
	sar	rbp, 3
	mov	r15, rdx
	sar	rax, 3
	mov	rdi, rcx
	cmp	rax, r8
	je	$LN118@Emplace_re

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rcx+16]

; 779  :         }
; 780  : 
; 781  :         const size_type _Newsize     = _Oldsize + 1;

	lea	r12, QWORD PTR [rax+1]

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sub	rcx, QWORD PTR [rdi]

; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, r8

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	rcx, 3

; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx
	shr	rdx, 1
	sub	rax, rdx
	cmp	rcx, rax
	ja	$LN114@Emplace_re

; 1689 :             return _Max; // geometric growth would overflow
; 1690 :         }
; 1691 : 
; 1692 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rax, QWORD PTR [rdx+rcx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 64   :         if (_Count > _Max_possible) {

	mov	rsi, r12
	cmp	rax, r12
	cmovae	rsi, rax
	cmp	rsi, r8
	ja	$LN114@Emplace_re

; 65   :             _Throw_bad_array_new_length(); // multiply overflow
; 66   :         }
; 67   :     }
; 68   : 
; 69   :     return _Count * _Ty_size;

	shl	rsi, 3

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rsi, 4096				; 00001000H
	jb	SHORT $LN24@Emplace_re

; 136  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rsi+39]

; 137  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rsi
	jbe	$LN114@Emplace_re

; 85   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 142  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN105@Emplace_re

; 143  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rbx, QWORD PTR [rax+39]
	and	rbx, -32				; ffffffffffffffe0H

; 144  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rbx-8], rax

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN23@Emplace_re
$LN24@Emplace_re:

; 239  :         }
; 240  :     }
; 241  : #endif // defined(_M_IX86) || defined(_M_X64)
; 242  : 
; 243  :     if (_Bytes != 0) {

	test	rsi, rsi
	je	SHORT $LN25@Emplace_re

; 85   :         return ::operator new(_Bytes);

	mov	rcx, rsi
	call	??2@YAPEAX_K@Z				; operator new
	mov	rbx, rax

; 244  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN23@Emplace_re
$LN25@Emplace_re:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

	xor	ebx, ebx
$LN23@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 789  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	mov	rax, QWORD PTR [r13]
	lea	r14, QWORD PTR [rbx+rbp*8]
	mov	QWORD PTR [r14], rax

; 790  :         _Constructed_first = _Newvec + _Whereoff;
; 791  : 
; 792  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	rcx, rbx
	mov	r8, QWORD PTR [rdi+8]
	mov	rdx, QWORD PTR [rdi]
	cmp	r15, r8
	jne	SHORT $LN4@Emplace_re
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 794  :         } else { // provide basic guarantee

	jmp	SHORT $LN116@Emplace_re
$LN4@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	r8, r15
	sub	r8, QWORD PTR [rdi]

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	call	QWORD PTR __imp_memmove

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	r8, QWORD PTR [rdi+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 797  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

	lea	rcx, QWORD PTR [r14+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, r15

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, r15
$LN116@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 797  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

	call	QWORD PTR __imp_memmove

; 1745 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rdi]
	test	rcx, rcx
	je	SHORT $LN98@Emplace_re

; 1746 :             _Destroy(_Myfirst, _Mylast);
; 1747 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rdi+16]
	sub	rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN108@Emplace_re

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN105@Emplace_re

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN108@Emplace_re:

; 264  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN98@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 807  :     }

	mov	rbp, QWORD PTR [rsp+88]

; 1751 :         _Mylast  = _Newvec + _Newsize;

	lea	rcx, QWORD PTR [rbx+r12*8]
	mov	QWORD PTR [rdi], rbx

; 798  :         }
; 799  :         _CATCH_ALL
; 800  :         _Destroy(_Constructed_first, _Constructed_last);
; 801  :         _Al.deallocate(_Newvec, _Newcapacity);
; 802  :         _RERAISE;
; 803  :         _CATCH_END
; 804  : 
; 805  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 806  :         return _Newvec + _Whereoff;

	mov	rax, r14

; 1751 :         _Mylast  = _Newvec + _Newsize;

	mov	QWORD PTR [rdi+8], rcx

; 1752 :         _Myend   = _Newvec + _Newcapacity;

	lea	rcx, QWORD PTR [rsi+rbx]

; 807  :     }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+96]

; 1752 :         _Myend   = _Newvec + _Newcapacity;

	mov	QWORD PTR [rdi+16], rcx

; 807  :     }

	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
$LN105@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN118@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 778  :             _Xlength();

	call	?_Xlength@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@CAXXZ ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::_Xlength
	int	3
$LN114@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 138  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN115@Emplace_re:
??$_Emplace_reallocate@PEAVModMultiChannelDiffuser@@@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEAAPEAPEAVModMultiChannelDiffuser@@QEAPEAV2@$$QEAPEAV2@@Z ENDP ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::_Emplace_reallocate<ModMultiChannelDiffuser *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVModMultiChannelDiffuser@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0$$V@?$_Compressed_pair@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVModMultiChannelDiffuser@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<ModMultiChannelDiffuser *>,std::_Vector_val<std::_Simple_types<ModMultiChannelDiffuser *> >,1>::_Compressed_pair<std::allocator<ModMultiChannelDiffuser *>,std::_Vector_val<std::_Simple_types<ModMultiChannelDiffuser *> >,1><>, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1370 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVModMultiChannelDiffuser@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<ModMultiChannelDiffuser *>,std::_Vector_val<std::_Simple_types<ModMultiChannelDiffuser *> >,1>::_Compressed_pair<std::allocator<ModMultiChannelDiffuser *>,std::_Vector_val<std::_Simple_types<ModMultiChannelDiffuser *> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AEAPEAVMultiChannelDiffuser@@@std@@YA$$QEAPEAVMultiChannelDiffuser@@AEAPEAV1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAPEAVMultiChannelDiffuser@@@std@@YA$$QEAPEAVMultiChannelDiffuser@@AEAPEAV1@@Z PROC ; std::move<MultiChannelDiffuser * &>, COMDAT

; 1456 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1457 : }

	ret	0
??$move@AEAPEAVMultiChannelDiffuser@@@std@@YA$$QEAPEAVMultiChannelDiffuser@@AEAPEAV1@@Z ENDP ; std::move<MultiChannelDiffuser * &>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@PEAVMultiChannelDiffuser@@@std@@YA$$QEAPEAVMultiChannelDiffuser@@AEAPEAV1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAVMultiChannelDiffuser@@@std@@YA$$QEAPEAVMultiChannelDiffuser@@AEAPEAV1@@Z PROC ; std::forward<MultiChannelDiffuser *>, COMDAT

; 1444 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1445 : }

	ret	0
??$forward@PEAVMultiChannelDiffuser@@@std@@YA$$QEAPEAVMultiChannelDiffuser@@AEAPEAV1@@Z ENDP ; std::forward<MultiChannelDiffuser *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@PEAVMultiChannelDiffuser@@@std@@YAPEAPEAVMultiChannelDiffuser@@PEAPEAV1@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@PEAVMultiChannelDiffuser@@@std@@YAPEAPEAVMultiChannelDiffuser@@PEAPEAV1@@Z PROC ; std::_Unfancy<MultiChannelDiffuser *>, COMDAT

; 289  :     return _Ptr;

	mov	rax, rcx

; 290  : }

	ret	0
??$_Unfancy@PEAVMultiChannelDiffuser@@@std@@YAPEAPEAVMultiChannelDiffuser@@PEAPEAV1@@Z ENDP ; std::_Unfancy<MultiChannelDiffuser *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@PEAVMultiChannelDiffuser@@PEAV1@@?$_Default_allocator_traits@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@SAXAEAV?$allocator@PEAVMultiChannelDiffuser@@@1@QEAPEAVMultiChannelDiffuser@@$$QEAPEAV3@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@PEAVMultiChannelDiffuser@@PEAV1@@?$_Default_allocator_traits@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@SAXAEAV?$allocator@PEAVMultiChannelDiffuser@@@1@QEAPEAVMultiChannelDiffuser@@$$QEAPEAV3@@Z PROC ; std::_Default_allocator_traits<std::allocator<MultiChannelDiffuser *> >::construct<MultiChannelDiffuser *,MultiChannelDiffuser *>, COMDAT

; 708  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 709  :         if (_STD is_constant_evaluated()) {
; 710  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 711  :         } else
; 712  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 713  :         {
; 714  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rdx], rax

; 715  :         }
; 716  :     }

	ret	0
??$construct@PEAVMultiChannelDiffuser@@PEAV1@@?$_Default_allocator_traits@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@SAXAEAV?$allocator@PEAVMultiChannelDiffuser@@@1@QEAPEAVMultiChannelDiffuser@@$$QEAPEAV3@@Z ENDP ; std::_Default_allocator_traits<std::allocator<MultiChannelDiffuser *> >::construct<MultiChannelDiffuser *,MultiChannelDiffuser *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_reallocate@PEAVMultiChannelDiffuser@@@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEAAPEAPEAVMultiChannelDiffuser@@QEAPEAV2@$$QEAPEAV2@@Z
_TEXT	SEGMENT
this$ = 80
_Whereptr$ = 88
<_Val_0>$ = 96
??$_Emplace_reallocate@PEAVMultiChannelDiffuser@@@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEAAPEAPEAVMultiChannelDiffuser@@QEAPEAV2@$$QEAPEAV2@@Z PROC ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::_Emplace_reallocate<MultiChannelDiffuser *>, COMDAT

; 765  :     _CONSTEXPR20_CONTAINER pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

$LN120:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 766  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 767  :         _Alty& _Al        = _Getal();
; 768  :         auto& _My_data    = _Mypair._Myval2;
; 769  :         pointer& _Myfirst = _My_data._Myfirst;
; 770  :         pointer& _Mylast  = _My_data._Mylast;
; 771  : 
; 772  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 773  : 
; 774  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);
; 775  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rax, QWORD PTR [rcx+8]
	mov	rbp, rdx
	sub	rbp, QWORD PTR [rcx]
	mov	r13, r8
	sub	rax, QWORD PTR [rcx]

; 776  : 
; 777  :         if (_Oldsize == max_size()) {

	mov	r8, 2305843009213693951			; 1fffffffffffffffH
	sar	rbp, 3
	mov	r15, rdx
	sar	rax, 3
	mov	rdi, rcx
	cmp	rax, r8
	je	$LN118@Emplace_re

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rcx+16]

; 779  :         }
; 780  : 
; 781  :         const size_type _Newsize     = _Oldsize + 1;

	lea	r12, QWORD PTR [rax+1]

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sub	rcx, QWORD PTR [rdi]

; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, r8

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	rcx, 3

; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx
	shr	rdx, 1
	sub	rax, rdx
	cmp	rcx, rax
	ja	$LN114@Emplace_re

; 1689 :             return _Max; // geometric growth would overflow
; 1690 :         }
; 1691 : 
; 1692 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rax, QWORD PTR [rdx+rcx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 64   :         if (_Count > _Max_possible) {

	mov	rsi, r12
	cmp	rax, r12
	cmovae	rsi, rax
	cmp	rsi, r8
	ja	$LN114@Emplace_re

; 65   :             _Throw_bad_array_new_length(); // multiply overflow
; 66   :         }
; 67   :     }
; 68   : 
; 69   :     return _Count * _Ty_size;

	shl	rsi, 3

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rsi, 4096				; 00001000H
	jb	SHORT $LN24@Emplace_re

; 136  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rsi+39]

; 137  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rsi
	jbe	$LN114@Emplace_re

; 85   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 142  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN105@Emplace_re

; 143  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rbx, QWORD PTR [rax+39]
	and	rbx, -32				; ffffffffffffffe0H

; 144  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rbx-8], rax

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN23@Emplace_re
$LN24@Emplace_re:

; 239  :         }
; 240  :     }
; 241  : #endif // defined(_M_IX86) || defined(_M_X64)
; 242  : 
; 243  :     if (_Bytes != 0) {

	test	rsi, rsi
	je	SHORT $LN25@Emplace_re

; 85   :         return ::operator new(_Bytes);

	mov	rcx, rsi
	call	??2@YAPEAX_K@Z				; operator new
	mov	rbx, rax

; 244  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN23@Emplace_re
$LN25@Emplace_re:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

	xor	ebx, ebx
$LN23@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 789  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	mov	rax, QWORD PTR [r13]
	lea	r14, QWORD PTR [rbx+rbp*8]
	mov	QWORD PTR [r14], rax

; 790  :         _Constructed_first = _Newvec + _Whereoff;
; 791  : 
; 792  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	rcx, rbx
	mov	r8, QWORD PTR [rdi+8]
	mov	rdx, QWORD PTR [rdi]
	cmp	r15, r8
	jne	SHORT $LN4@Emplace_re
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 794  :         } else { // provide basic guarantee

	jmp	SHORT $LN116@Emplace_re
$LN4@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	r8, r15
	sub	r8, QWORD PTR [rdi]

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	call	QWORD PTR __imp_memmove

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	r8, QWORD PTR [rdi+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 797  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

	lea	rcx, QWORD PTR [r14+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, r15

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, r15
$LN116@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 797  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

	call	QWORD PTR __imp_memmove

; 1745 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rdi]
	test	rcx, rcx
	je	SHORT $LN98@Emplace_re

; 1746 :             _Destroy(_Myfirst, _Mylast);
; 1747 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rdi+16]
	sub	rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN108@Emplace_re

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN105@Emplace_re

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN108@Emplace_re:

; 264  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN98@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 807  :     }

	mov	rbp, QWORD PTR [rsp+88]

; 1751 :         _Mylast  = _Newvec + _Newsize;

	lea	rcx, QWORD PTR [rbx+r12*8]
	mov	QWORD PTR [rdi], rbx

; 798  :         }
; 799  :         _CATCH_ALL
; 800  :         _Destroy(_Constructed_first, _Constructed_last);
; 801  :         _Al.deallocate(_Newvec, _Newcapacity);
; 802  :         _RERAISE;
; 803  :         _CATCH_END
; 804  : 
; 805  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 806  :         return _Newvec + _Whereoff;

	mov	rax, r14

; 1751 :         _Mylast  = _Newvec + _Newsize;

	mov	QWORD PTR [rdi+8], rcx

; 1752 :         _Myend   = _Newvec + _Newcapacity;

	lea	rcx, QWORD PTR [rsi+rbx]

; 807  :     }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+96]

; 1752 :         _Myend   = _Newvec + _Newcapacity;

	mov	QWORD PTR [rdi+16], rcx

; 807  :     }

	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
$LN105@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN118@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 778  :             _Xlength();

	call	?_Xlength@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@CAXXZ ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::_Xlength
	int	3
$LN114@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 138  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN115@Emplace_re:
??$_Emplace_reallocate@PEAVMultiChannelDiffuser@@@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEAAPEAPEAVMultiChannelDiffuser@@QEAPEAV2@$$QEAPEAV2@@Z ENDP ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::_Emplace_reallocate<MultiChannelDiffuser *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@PEAVMultiChannelDiffuser@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVMultiChannelDiffuser@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0$$V@?$_Compressed_pair@V?$allocator@PEAVMultiChannelDiffuser@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVMultiChannelDiffuser@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<MultiChannelDiffuser *>,std::_Vector_val<std::_Simple_types<MultiChannelDiffuser *> >,1>::_Compressed_pair<std::allocator<MultiChannelDiffuser *>,std::_Vector_val<std::_Simple_types<MultiChannelDiffuser *> >,1><>, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1370 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@PEAVMultiChannelDiffuser@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVMultiChannelDiffuser@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<MultiChannelDiffuser *>,std::_Vector_val<std::_Simple_types<MultiChannelDiffuser *> >,1>::_Compressed_pair<std::allocator<MultiChannelDiffuser *>,std::_Vector_val<std::_Simple_types<MultiChannelDiffuser *> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AEAPEAVModDelay@@@std@@YA$$QEAPEAVModDelay@@AEAPEAV1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAPEAVModDelay@@@std@@YA$$QEAPEAVModDelay@@AEAPEAV1@@Z PROC ; std::move<ModDelay * &>, COMDAT

; 1456 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1457 : }

	ret	0
??$move@AEAPEAVModDelay@@@std@@YA$$QEAPEAVModDelay@@AEAPEAV1@@Z ENDP ; std::move<ModDelay * &>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@PEAVModDelay@@@std@@YA$$QEAPEAVModDelay@@AEAPEAV1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAVModDelay@@@std@@YA$$QEAPEAVModDelay@@AEAPEAV1@@Z PROC ; std::forward<ModDelay *>, COMDAT

; 1444 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1445 : }

	ret	0
??$forward@PEAVModDelay@@@std@@YA$$QEAPEAVModDelay@@AEAPEAV1@@Z ENDP ; std::forward<ModDelay *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@PEAVModDelay@@@std@@YAPEAPEAVModDelay@@PEAPEAV1@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@PEAVModDelay@@@std@@YAPEAPEAVModDelay@@PEAPEAV1@@Z PROC ; std::_Unfancy<ModDelay *>, COMDAT

; 289  :     return _Ptr;

	mov	rax, rcx

; 290  : }

	ret	0
??$_Unfancy@PEAVModDelay@@@std@@YAPEAPEAVModDelay@@PEAPEAV1@@Z ENDP ; std::_Unfancy<ModDelay *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@PEAVModDelay@@PEAV1@@?$_Default_allocator_traits@V?$allocator@PEAVModDelay@@@std@@@std@@SAXAEAV?$allocator@PEAVModDelay@@@1@QEAPEAVModDelay@@$$QEAPEAV3@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@PEAVModDelay@@PEAV1@@?$_Default_allocator_traits@V?$allocator@PEAVModDelay@@@std@@@std@@SAXAEAV?$allocator@PEAVModDelay@@@1@QEAPEAVModDelay@@$$QEAPEAV3@@Z PROC ; std::_Default_allocator_traits<std::allocator<ModDelay *> >::construct<ModDelay *,ModDelay *>, COMDAT

; 708  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 709  :         if (_STD is_constant_evaluated()) {
; 710  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 711  :         } else
; 712  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 713  :         {
; 714  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rdx], rax

; 715  :         }
; 716  :     }

	ret	0
??$construct@PEAVModDelay@@PEAV1@@?$_Default_allocator_traits@V?$allocator@PEAVModDelay@@@std@@@std@@SAXAEAV?$allocator@PEAVModDelay@@@1@QEAPEAVModDelay@@$$QEAPEAV3@@Z ENDP ; std::_Default_allocator_traits<std::allocator<ModDelay *> >::construct<ModDelay *,ModDelay *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_reallocate@PEAVModDelay@@@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEAAPEAPEAVModDelay@@QEAPEAV2@$$QEAPEAV2@@Z
_TEXT	SEGMENT
this$ = 80
_Whereptr$ = 88
<_Val_0>$ = 96
??$_Emplace_reallocate@PEAVModDelay@@@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEAAPEAPEAVModDelay@@QEAPEAV2@$$QEAPEAV2@@Z PROC ; std::vector<ModDelay *,std::allocator<ModDelay *> >::_Emplace_reallocate<ModDelay *>, COMDAT

; 765  :     _CONSTEXPR20_CONTAINER pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

$LN120:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 766  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 767  :         _Alty& _Al        = _Getal();
; 768  :         auto& _My_data    = _Mypair._Myval2;
; 769  :         pointer& _Myfirst = _My_data._Myfirst;
; 770  :         pointer& _Mylast  = _My_data._Mylast;
; 771  : 
; 772  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 773  : 
; 774  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);
; 775  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rax, QWORD PTR [rcx+8]
	mov	rbp, rdx
	sub	rbp, QWORD PTR [rcx]
	mov	r13, r8
	sub	rax, QWORD PTR [rcx]

; 776  : 
; 777  :         if (_Oldsize == max_size()) {

	mov	r8, 2305843009213693951			; 1fffffffffffffffH
	sar	rbp, 3
	mov	r15, rdx
	sar	rax, 3
	mov	rdi, rcx
	cmp	rax, r8
	je	$LN118@Emplace_re

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rcx+16]

; 779  :         }
; 780  : 
; 781  :         const size_type _Newsize     = _Oldsize + 1;

	lea	r12, QWORD PTR [rax+1]

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sub	rcx, QWORD PTR [rdi]

; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, r8

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	rcx, 3

; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx
	shr	rdx, 1
	sub	rax, rdx
	cmp	rcx, rax
	ja	$LN114@Emplace_re

; 1689 :             return _Max; // geometric growth would overflow
; 1690 :         }
; 1691 : 
; 1692 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rax, QWORD PTR [rdx+rcx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 64   :         if (_Count > _Max_possible) {

	mov	rsi, r12
	cmp	rax, r12
	cmovae	rsi, rax
	cmp	rsi, r8
	ja	$LN114@Emplace_re

; 65   :             _Throw_bad_array_new_length(); // multiply overflow
; 66   :         }
; 67   :     }
; 68   : 
; 69   :     return _Count * _Ty_size;

	shl	rsi, 3

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rsi, 4096				; 00001000H
	jb	SHORT $LN24@Emplace_re

; 136  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rsi+39]

; 137  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rsi
	jbe	$LN114@Emplace_re

; 85   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 142  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN105@Emplace_re

; 143  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rbx, QWORD PTR [rax+39]
	and	rbx, -32				; ffffffffffffffe0H

; 144  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rbx-8], rax

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN23@Emplace_re
$LN24@Emplace_re:

; 239  :         }
; 240  :     }
; 241  : #endif // defined(_M_IX86) || defined(_M_X64)
; 242  : 
; 243  :     if (_Bytes != 0) {

	test	rsi, rsi
	je	SHORT $LN25@Emplace_re

; 85   :         return ::operator new(_Bytes);

	mov	rcx, rsi
	call	??2@YAPEAX_K@Z				; operator new
	mov	rbx, rax

; 244  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN23@Emplace_re
$LN25@Emplace_re:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

	xor	ebx, ebx
$LN23@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 789  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	mov	rax, QWORD PTR [r13]
	lea	r14, QWORD PTR [rbx+rbp*8]
	mov	QWORD PTR [r14], rax

; 790  :         _Constructed_first = _Newvec + _Whereoff;
; 791  : 
; 792  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	rcx, rbx
	mov	r8, QWORD PTR [rdi+8]
	mov	rdx, QWORD PTR [rdi]
	cmp	r15, r8
	jne	SHORT $LN4@Emplace_re
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 794  :         } else { // provide basic guarantee

	jmp	SHORT $LN116@Emplace_re
$LN4@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	r8, r15
	sub	r8, QWORD PTR [rdi]

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	call	QWORD PTR __imp_memmove

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	r8, QWORD PTR [rdi+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 797  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

	lea	rcx, QWORD PTR [r14+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, r15

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, r15
$LN116@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 797  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

	call	QWORD PTR __imp_memmove

; 1745 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rdi]
	test	rcx, rcx
	je	SHORT $LN98@Emplace_re

; 1746 :             _Destroy(_Myfirst, _Mylast);
; 1747 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rdi+16]
	sub	rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN108@Emplace_re

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN105@Emplace_re

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN108@Emplace_re:

; 264  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN98@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 807  :     }

	mov	rbp, QWORD PTR [rsp+88]

; 1751 :         _Mylast  = _Newvec + _Newsize;

	lea	rcx, QWORD PTR [rbx+r12*8]
	mov	QWORD PTR [rdi], rbx

; 798  :         }
; 799  :         _CATCH_ALL
; 800  :         _Destroy(_Constructed_first, _Constructed_last);
; 801  :         _Al.deallocate(_Newvec, _Newcapacity);
; 802  :         _RERAISE;
; 803  :         _CATCH_END
; 804  : 
; 805  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 806  :         return _Newvec + _Whereoff;

	mov	rax, r14

; 1751 :         _Mylast  = _Newvec + _Newsize;

	mov	QWORD PTR [rdi+8], rcx

; 1752 :         _Myend   = _Newvec + _Newcapacity;

	lea	rcx, QWORD PTR [rsi+rbx]

; 807  :     }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+96]

; 1752 :         _Myend   = _Newvec + _Newcapacity;

	mov	QWORD PTR [rdi+16], rcx

; 807  :     }

	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
$LN105@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN118@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 778  :             _Xlength();

	call	?_Xlength@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@CAXXZ ; std::vector<ModDelay *,std::allocator<ModDelay *> >::_Xlength
	int	3
$LN114@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 138  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN115@Emplace_re:
??$_Emplace_reallocate@PEAVModDelay@@@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEAAPEAPEAVModDelay@@QEAPEAV2@$$QEAPEAV2@@Z ENDP ; std::vector<ModDelay *,std::allocator<ModDelay *> >::_Emplace_reallocate<ModDelay *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@PEAVModDelay@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVModDelay@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0$$V@?$_Compressed_pair@V?$allocator@PEAVModDelay@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVModDelay@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<ModDelay *>,std::_Vector_val<std::_Simple_types<ModDelay *> >,1>::_Compressed_pair<std::allocator<ModDelay *>,std::_Vector_val<std::_Simple_types<ModDelay *> >,1><>, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1370 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@PEAVModDelay@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVModDelay@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<ModDelay *>,std::_Vector_val<std::_Simple_types<ModDelay *> >,1>::_Compressed_pair<std::allocator<ModDelay *>,std::_Vector_val<std::_Simple_types<ModDelay *> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AEAH@std@@YA$$QEAHAEAH@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAH@std@@YA$$QEAHAEAH@Z PROC			; std::move<int &>, COMDAT

; 1456 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1457 : }

	ret	0
??$move@AEAH@std@@YA$$QEAHAEAH@Z ENDP			; std::move<int &>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@H@std@@YA$$QEAHAEAH@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@H@std@@YA$$QEAHAEAH@Z PROC			; std::forward<int>, COMDAT

; 1444 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1445 : }

	ret	0
??$forward@H@std@@YA$$QEAHAEAH@Z ENDP			; std::forward<int>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@H@std@@YAPEAHPEAH@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@H@std@@YAPEAHPEAH@Z PROC			; std::_Unfancy<int>, COMDAT

; 289  :     return _Ptr;

	mov	rax, rcx

; 290  : }

	ret	0
??$_Unfancy@H@std@@YAPEAHPEAH@Z ENDP			; std::_Unfancy<int>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@HH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAEAV?$allocator@H@1@QEAH$$QEAH@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@HH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAEAV?$allocator@H@1@QEAH$$QEAH@Z PROC ; std::_Default_allocator_traits<std::allocator<int> >::construct<int,int>, COMDAT

; 708  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 709  :         if (_STD is_constant_evaluated()) {
; 710  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 711  :         } else
; 712  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 713  :         {
; 714  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rdx], eax

; 715  :         }
; 716  :     }

	ret	0
??$construct@HH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAEAV?$allocator@H@1@QEAH$$QEAH@Z ENDP ; std::_Default_allocator_traits<std::allocator<int> >::construct<int,int>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_reallocate@H@?$vector@HV?$allocator@H@std@@@std@@QEAAPEAHQEAH$$QEAH@Z
_TEXT	SEGMENT
this$ = 80
_Whereptr$ = 88
<_Val_0>$ = 96
??$_Emplace_reallocate@H@?$vector@HV?$allocator@H@std@@@std@@QEAAPEAHQEAH$$QEAH@Z PROC ; std::vector<int,std::allocator<int> >::_Emplace_reallocate<int>, COMDAT

; 765  :     _CONSTEXPR20_CONTAINER pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

$LN120:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 766  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 767  :         _Alty& _Al        = _Getal();
; 768  :         auto& _My_data    = _Mypair._Myval2;
; 769  :         pointer& _Myfirst = _My_data._Myfirst;
; 770  :         pointer& _Mylast  = _My_data._Mylast;
; 771  : 
; 772  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 773  : 
; 774  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);
; 775  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rax, QWORD PTR [rcx+8]
	mov	rbp, rdx
	sub	rbp, QWORD PTR [rcx]
	mov	r13, r8
	sub	rax, QWORD PTR [rcx]

; 776  : 
; 777  :         if (_Oldsize == max_size()) {

	mov	r8, 4611686018427387903			; 3fffffffffffffffH
	sar	rbp, 2
	mov	r15, rdx
	sar	rax, 2
	mov	rdi, rcx
	cmp	rax, r8
	je	$LN118@Emplace_re

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rcx+16]

; 779  :         }
; 780  : 
; 781  :         const size_type _Newsize     = _Oldsize + 1;

	lea	r12, QWORD PTR [rax+1]

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sub	rcx, QWORD PTR [rdi]

; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, r8

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	rcx, 2

; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx
	shr	rdx, 1
	sub	rax, rdx
	cmp	rcx, rax
	ja	$LN114@Emplace_re

; 1689 :             return _Max; // geometric growth would overflow
; 1690 :         }
; 1691 : 
; 1692 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rax, QWORD PTR [rdx+rcx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 64   :         if (_Count > _Max_possible) {

	mov	rsi, r12
	cmp	rax, r12
	cmovae	rsi, rax
	cmp	rsi, r8
	ja	$LN114@Emplace_re

; 65   :             _Throw_bad_array_new_length(); // multiply overflow
; 66   :         }
; 67   :     }
; 68   : 
; 69   :     return _Count * _Ty_size;

	shl	rsi, 2

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rsi, 4096				; 00001000H
	jb	SHORT $LN24@Emplace_re

; 136  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rsi+39]

; 137  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rsi
	jbe	$LN114@Emplace_re

; 85   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 142  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN105@Emplace_re

; 143  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rbx, QWORD PTR [rax+39]
	and	rbx, -32				; ffffffffffffffe0H

; 144  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rbx-8], rax

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN23@Emplace_re
$LN24@Emplace_re:

; 239  :         }
; 240  :     }
; 241  : #endif // defined(_M_IX86) || defined(_M_X64)
; 242  : 
; 243  :     if (_Bytes != 0) {

	test	rsi, rsi
	je	SHORT $LN25@Emplace_re

; 85   :         return ::operator new(_Bytes);

	mov	rcx, rsi
	call	??2@YAPEAX_K@Z				; operator new
	mov	rbx, rax

; 244  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN23@Emplace_re
$LN25@Emplace_re:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

	xor	ebx, ebx
$LN23@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 789  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR [r13]
	lea	r14, QWORD PTR [rbx+rbp*4]
	mov	DWORD PTR [r14], eax

; 790  :         _Constructed_first = _Newvec + _Whereoff;
; 791  : 
; 792  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	rcx, rbx
	mov	r8, QWORD PTR [rdi+8]
	mov	rdx, QWORD PTR [rdi]
	cmp	r15, r8
	jne	SHORT $LN4@Emplace_re
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 794  :         } else { // provide basic guarantee

	jmp	SHORT $LN116@Emplace_re
$LN4@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	r8, r15
	sub	r8, QWORD PTR [rdi]

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	call	QWORD PTR __imp_memmove

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	r8, QWORD PTR [rdi+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 797  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

	lea	rcx, QWORD PTR [r14+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, r15

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, r15
$LN116@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 797  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

	call	QWORD PTR __imp_memmove

; 1745 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rdi]
	test	rcx, rcx
	je	SHORT $LN98@Emplace_re

; 1746 :             _Destroy(_Myfirst, _Mylast);
; 1747 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rdi+16]
	sub	rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -4

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN108@Emplace_re

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN105@Emplace_re

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN108@Emplace_re:

; 264  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN98@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 807  :     }

	mov	rbp, QWORD PTR [rsp+88]

; 1751 :         _Mylast  = _Newvec + _Newsize;

	lea	rcx, QWORD PTR [rbx+r12*4]
	mov	QWORD PTR [rdi], rbx

; 798  :         }
; 799  :         _CATCH_ALL
; 800  :         _Destroy(_Constructed_first, _Constructed_last);
; 801  :         _Al.deallocate(_Newvec, _Newcapacity);
; 802  :         _RERAISE;
; 803  :         _CATCH_END
; 804  : 
; 805  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 806  :         return _Newvec + _Whereoff;

	mov	rax, r14

; 1751 :         _Mylast  = _Newvec + _Newsize;

	mov	QWORD PTR [rdi+8], rcx

; 1752 :         _Myend   = _Newvec + _Newcapacity;

	lea	rcx, QWORD PTR [rsi+rbx]

; 807  :     }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+96]

; 1752 :         _Myend   = _Newvec + _Newcapacity;

	mov	QWORD PTR [rdi+16], rcx

; 807  :     }

	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
$LN105@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN118@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 778  :             _Xlength();

	call	?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ ; std::vector<int,std::allocator<int> >::_Xlength
	int	3
$LN114@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 138  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN115@Emplace_re:
??$_Emplace_reallocate@H@?$vector@HV?$allocator@H@std@@@std@@QEAAPEAHQEAH$$QEAH@Z ENDP ; std::vector<int,std::allocator<int> >::_Emplace_reallocate<int>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><>, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1370 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AEAPEAVDelay@@@std@@YA$$QEAPEAVDelay@@AEAPEAV1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAPEAVDelay@@@std@@YA$$QEAPEAVDelay@@AEAPEAV1@@Z PROC ; std::move<Delay * &>, COMDAT

; 1456 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1457 : }

	ret	0
??$move@AEAPEAVDelay@@@std@@YA$$QEAPEAVDelay@@AEAPEAV1@@Z ENDP ; std::move<Delay * &>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@PEAVDelay@@@std@@YA$$QEAPEAVDelay@@AEAPEAV1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAVDelay@@@std@@YA$$QEAPEAVDelay@@AEAPEAV1@@Z PROC ; std::forward<Delay *>, COMDAT

; 1444 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1445 : }

	ret	0
??$forward@PEAVDelay@@@std@@YA$$QEAPEAVDelay@@AEAPEAV1@@Z ENDP ; std::forward<Delay *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@PEAVDelay@@@std@@YAPEAPEAVDelay@@PEAPEAV1@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@PEAVDelay@@@std@@YAPEAPEAVDelay@@PEAPEAV1@@Z PROC ; std::_Unfancy<Delay *>, COMDAT

; 289  :     return _Ptr;

	mov	rax, rcx

; 290  : }

	ret	0
??$_Unfancy@PEAVDelay@@@std@@YAPEAPEAVDelay@@PEAPEAV1@@Z ENDP ; std::_Unfancy<Delay *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@PEAVDelay@@PEAV1@@?$_Default_allocator_traits@V?$allocator@PEAVDelay@@@std@@@std@@SAXAEAV?$allocator@PEAVDelay@@@1@QEAPEAVDelay@@$$QEAPEAV3@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@PEAVDelay@@PEAV1@@?$_Default_allocator_traits@V?$allocator@PEAVDelay@@@std@@@std@@SAXAEAV?$allocator@PEAVDelay@@@1@QEAPEAVDelay@@$$QEAPEAV3@@Z PROC ; std::_Default_allocator_traits<std::allocator<Delay *> >::construct<Delay *,Delay *>, COMDAT

; 708  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 709  :         if (_STD is_constant_evaluated()) {
; 710  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 711  :         } else
; 712  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 713  :         {
; 714  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rdx], rax

; 715  :         }
; 716  :     }

	ret	0
??$construct@PEAVDelay@@PEAV1@@?$_Default_allocator_traits@V?$allocator@PEAVDelay@@@std@@@std@@SAXAEAV?$allocator@PEAVDelay@@@1@QEAPEAVDelay@@$$QEAPEAV3@@Z ENDP ; std::_Default_allocator_traits<std::allocator<Delay *> >::construct<Delay *,Delay *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_reallocate@PEAVDelay@@@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@QEAAPEAPEAVDelay@@QEAPEAV2@$$QEAPEAV2@@Z
_TEXT	SEGMENT
this$ = 80
_Whereptr$ = 88
<_Val_0>$ = 96
??$_Emplace_reallocate@PEAVDelay@@@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@QEAAPEAPEAVDelay@@QEAPEAV2@$$QEAPEAV2@@Z PROC ; std::vector<Delay *,std::allocator<Delay *> >::_Emplace_reallocate<Delay *>, COMDAT

; 765  :     _CONSTEXPR20_CONTAINER pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

$LN120:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 766  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 767  :         _Alty& _Al        = _Getal();
; 768  :         auto& _My_data    = _Mypair._Myval2;
; 769  :         pointer& _Myfirst = _My_data._Myfirst;
; 770  :         pointer& _Mylast  = _My_data._Mylast;
; 771  : 
; 772  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 773  : 
; 774  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);
; 775  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rax, QWORD PTR [rcx+8]
	mov	rbp, rdx
	sub	rbp, QWORD PTR [rcx]
	mov	r13, r8
	sub	rax, QWORD PTR [rcx]

; 776  : 
; 777  :         if (_Oldsize == max_size()) {

	mov	r8, 2305843009213693951			; 1fffffffffffffffH
	sar	rbp, 3
	mov	r15, rdx
	sar	rax, 3
	mov	rdi, rcx
	cmp	rax, r8
	je	$LN118@Emplace_re

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rcx+16]

; 779  :         }
; 780  : 
; 781  :         const size_type _Newsize     = _Oldsize + 1;

	lea	r12, QWORD PTR [rax+1]

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sub	rcx, QWORD PTR [rdi]

; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, r8

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	rcx, 3

; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx
	shr	rdx, 1
	sub	rax, rdx
	cmp	rcx, rax
	ja	$LN114@Emplace_re

; 1689 :             return _Max; // geometric growth would overflow
; 1690 :         }
; 1691 : 
; 1692 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rax, QWORD PTR [rdx+rcx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 64   :         if (_Count > _Max_possible) {

	mov	rsi, r12
	cmp	rax, r12
	cmovae	rsi, rax
	cmp	rsi, r8
	ja	$LN114@Emplace_re

; 65   :             _Throw_bad_array_new_length(); // multiply overflow
; 66   :         }
; 67   :     }
; 68   : 
; 69   :     return _Count * _Ty_size;

	shl	rsi, 3

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rsi, 4096				; 00001000H
	jb	SHORT $LN24@Emplace_re

; 136  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rsi+39]

; 137  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rsi
	jbe	$LN114@Emplace_re

; 85   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 142  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN105@Emplace_re

; 143  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rbx, QWORD PTR [rax+39]
	and	rbx, -32				; ffffffffffffffe0H

; 144  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rbx-8], rax

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN23@Emplace_re
$LN24@Emplace_re:

; 239  :         }
; 240  :     }
; 241  : #endif // defined(_M_IX86) || defined(_M_X64)
; 242  : 
; 243  :     if (_Bytes != 0) {

	test	rsi, rsi
	je	SHORT $LN25@Emplace_re

; 85   :         return ::operator new(_Bytes);

	mov	rcx, rsi
	call	??2@YAPEAX_K@Z				; operator new
	mov	rbx, rax

; 244  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN23@Emplace_re
$LN25@Emplace_re:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

	xor	ebx, ebx
$LN23@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 789  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	mov	rax, QWORD PTR [r13]
	lea	r14, QWORD PTR [rbx+rbp*8]
	mov	QWORD PTR [r14], rax

; 790  :         _Constructed_first = _Newvec + _Whereoff;
; 791  : 
; 792  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	rcx, rbx
	mov	r8, QWORD PTR [rdi+8]
	mov	rdx, QWORD PTR [rdi]
	cmp	r15, r8
	jne	SHORT $LN4@Emplace_re
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 794  :         } else { // provide basic guarantee

	jmp	SHORT $LN116@Emplace_re
$LN4@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	r8, r15
	sub	r8, QWORD PTR [rdi]

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	call	QWORD PTR __imp_memmove

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	r8, QWORD PTR [rdi+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 797  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

	lea	rcx, QWORD PTR [r14+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, r15

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, r15
$LN116@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 797  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

	call	QWORD PTR __imp_memmove

; 1745 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rdi]
	test	rcx, rcx
	je	SHORT $LN98@Emplace_re

; 1746 :             _Destroy(_Myfirst, _Mylast);
; 1747 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rdi+16]
	sub	rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN108@Emplace_re

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN105@Emplace_re

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN108@Emplace_re:

; 264  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN98@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 807  :     }

	mov	rbp, QWORD PTR [rsp+88]

; 1751 :         _Mylast  = _Newvec + _Newsize;

	lea	rcx, QWORD PTR [rbx+r12*8]
	mov	QWORD PTR [rdi], rbx

; 798  :         }
; 799  :         _CATCH_ALL
; 800  :         _Destroy(_Constructed_first, _Constructed_last);
; 801  :         _Al.deallocate(_Newvec, _Newcapacity);
; 802  :         _RERAISE;
; 803  :         _CATCH_END
; 804  : 
; 805  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 806  :         return _Newvec + _Whereoff;

	mov	rax, r14

; 1751 :         _Mylast  = _Newvec + _Newsize;

	mov	QWORD PTR [rdi+8], rcx

; 1752 :         _Myend   = _Newvec + _Newcapacity;

	lea	rcx, QWORD PTR [rsi+rbx]

; 807  :     }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+96]

; 1752 :         _Myend   = _Newvec + _Newcapacity;

	mov	QWORD PTR [rdi+16], rcx

; 807  :     }

	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
$LN105@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN118@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 778  :             _Xlength();

	call	?_Xlength@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@CAXXZ ; std::vector<Delay *,std::allocator<Delay *> >::_Xlength
	int	3
$LN114@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 138  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN115@Emplace_re:
??$_Emplace_reallocate@PEAVDelay@@@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@QEAAPEAPEAVDelay@@QEAPEAV2@$$QEAPEAV2@@Z ENDP ; std::vector<Delay *,std::allocator<Delay *> >::_Emplace_reallocate<Delay *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@PEAVDelay@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVDelay@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0$$V@?$_Compressed_pair@V?$allocator@PEAVDelay@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVDelay@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<Delay *>,std::_Vector_val<std::_Simple_types<Delay *> >,1>::_Compressed_pair<std::allocator<Delay *>,std::_Vector_val<std::_Simple_types<Delay *> >,1><>, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1370 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@PEAVDelay@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVDelay@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<Delay *>,std::_Vector_val<std::_Simple_types<Delay *> >,1>::_Compressed_pair<std::allocator<Delay *>,std::_Vector_val<std::_Simple_types<Delay *> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@V?$vector@MV?$allocator@M@std@@@std@@@std@@YAPEAV?$vector@MV?$allocator@M@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$vector@MV?$allocator@M@std@@@std@@@std@@YAPEAV?$vector@MV?$allocator@M@std@@@0@AEAV10@@Z PROC ; std::addressof<std::vector<float,std::allocator<float> > >, COMDAT

; 275  :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 276  : }

	ret	0
??$addressof@V?$vector@MV?$allocator@M@std@@@std@@@std@@YAPEAV?$vector@MV?$allocator@M@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::vector<float,std::allocator<float> > >
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AEAV?$allocator@M@std@@@std@@YA$$QEAV?$allocator@M@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$allocator@M@std@@@std@@YA$$QEAV?$allocator@M@0@AEAV10@@Z PROC ; std::move<std::allocator<float> &>, COMDAT

; 1456 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1457 : }

	ret	0
??$move@AEAV?$allocator@M@std@@@std@@YA$$QEAV?$allocator@M@0@AEAV10@@Z ENDP ; std::move<std::allocator<float> &>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$exchange@PEAM$$T@std@@YAPEAMAEAPEAM$$QEA$$T@Z
_TEXT	SEGMENT
_Val$ = 8
_New_val$ = 16
??$exchange@PEAM$$T@std@@YAPEAMAEAPEAM$$QEA$$T@Z PROC	; std::exchange<float *,std::nullptr_t>, COMDAT

; 615  :     // assign _New_val to _Val, return previous _Val
; 616  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);
; 617  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rdx, QWORD PTR [rdx]
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rdx

; 618  :     return _Old_val;
; 619  : }

	ret	0
??$exchange@PEAM$$T@std@@YAPEAMAEAPEAM$$QEA$$T@Z ENDP	; std::exchange<float *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0V?$allocator@M@std@@PEAMPEAMPEAM@?$_Compressed_pair@V?$allocator@M@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@M@1@$$QEAPEAM22@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
<_Val2_0>$ = 32
<_Val2_1>$ = 40
<_Val2_2>$ = 48
??$?0V?$allocator@M@std@@PEAMPEAMPEAM@?$_Compressed_pair@V?$allocator@M@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@M@1@$$QEAPEAM22@Z PROC ; std::_Compressed_pair<std::allocator<float>,std::_Vector_val<std::_Simple_types<float> >,1>::_Compressed_pair<std::allocator<float>,std::_Vector_val<std::_Simple_types<float> >,1><std::allocator<float>,float *,float *,float *>, COMDAT

; 1375 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, QWORD PTR <_Val2_2>$[rsp]
	mov	r8, QWORD PTR [rax]
	mov	rax, QWORD PTR <_Val2_1>$[rsp]
	mov	rdx, QWORD PTR [rax]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 404  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	rax, QWORD PTR [r9]
	mov	QWORD PTR [rcx], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1375 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 404  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1375 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	0
??$?0V?$allocator@M@std@@PEAMPEAMPEAM@?$_Compressed_pair@V?$allocator@M@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@M@1@$$QEAPEAM22@Z ENDP ; std::_Compressed_pair<std::allocator<float>,std::_Vector_val<std::_Simple_types<float> >,1>::_Compressed_pair<std::allocator<float>,std::_Vector_val<std::_Simple_types<float> >,1><std::allocator<float>,float *,float *,float *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0AEBV?$allocator@M@std@@$$V@?$_Compressed_pair@V?$allocator@M@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@M@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
??$?0AEBV?$allocator@M@std@@$$V@?$_Compressed_pair@V?$allocator@M@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@M@1@@Z PROC ; std::_Compressed_pair<std::allocator<float>,std::_Vector_val<std::_Simple_types<float> >,1>::_Compressed_pair<std::allocator<float>,std::_Vector_val<std::_Simple_types<float> >,1><std::allocator<float> const &>, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1375 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0AEBV?$allocator@M@std@@$$V@?$_Compressed_pair@V?$allocator@M@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@M@1@@Z ENDP ; std::_Compressed_pair<std::allocator<float>,std::_Vector_val<std::_Simple_types<float> >,1>::_Compressed_pair<std::allocator<float>,std::_Vector_val<std::_Simple_types<float> >,1><std::allocator<float> const &>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Construct_n_copies_of_ty@U_Value_init_tag@std@@@?$vector@MV?$allocator@M@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
_Val$dead$ = 64
_Guard$8 = 64
??$_Construct_n_copies_of_ty@U_Value_init_tag@std@@@?$vector@MV?$allocator@M@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z PROC ; std::vector<float,std::allocator<float> >::_Construct_n_copies_of_ty<std::_Value_init_tag>, COMDAT

; 486  :     _CONSTEXPR20_CONTAINER void _Construct_n_copies_of_ty(_CRT_GUARDOVERFLOW const size_type _Count, const _Ty2& _Val) {

$LN62:

; 487  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 488  :         auto& _My_data  = _Mypair._Myval2;
; 489  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 490  :         if (_Count != 0) {

	test	rdx, rdx
	je	$LN57@Construct_

; 486  :     _CONSTEXPR20_CONTAINER void _Construct_n_copies_of_ty(_CRT_GUARDOVERFLOW const size_type _Count, const _Ty2& _Val) {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], r8
	push	rdi
	sub	rsp, 32					; 00000020H

; 1728 :         if (_Newcapacity > max_size()) {

	mov	rax, 4611686018427387903		; 3fffffffffffffffH

; 486  :     _CONSTEXPR20_CONTAINER void _Construct_n_copies_of_ty(_CRT_GUARDOVERFLOW const size_type _Count, const _Ty2& _Val) {

	mov	rsi, rcx

; 1728 :         if (_Newcapacity > max_size()) {

	cmp	rdx, rax
	ja	$LN59@Construct_
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 69   :     return _Count * _Ty_size;

	lea	rbx, QWORD PTR [rdx*4]

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rbx, 4096				; 00001000H
	jb	SHORT $LN17@Construct_

; 136  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rbx+39]

; 137  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rbx
	jbe	SHORT $LN60@Construct_

; 85   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 142  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN26@Construct_

; 143  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rdi, QWORD PTR [rax+39]
	and	rdi, -32				; ffffffffffffffe0H

; 144  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rdi-8], rax

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN16@Construct_
$LN26@Construct_:

; 142  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN17@Construct_:

; 243  :     if (_Bytes != 0) {

	test	rbx, rbx
	je	SHORT $LN18@Construct_

; 85   :         return ::operator new(_Bytes);

	mov	rcx, rbx
	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax

; 244  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN16@Construct_
$LN18@Construct_:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

	xor	edi, edi
$LN16@Construct_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1712 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [rsi], rdi

; 1714 :         _Myend             = _Newvec + _Newcapacity;

	lea	rax, QWORD PTR [rbx+rdi]
	mov	QWORD PTR [rsi+8], rdi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1789 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	r8, rbx
	xor	edx, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1714 :         _Myend             = _Newvec + _Newcapacity;

	mov	QWORD PTR [rsi+16], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1789 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	rcx, rdi
	call	QWORD PTR __imp_memset
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 494  :             _Guard._Target   = nullptr;

	and	QWORD PTR _Guard$8[rsp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1805 :             return _First + _Count;

	lea	rax, QWORD PTR [rbx+rdi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 495  :         }

	lea	rcx, QWORD PTR _Guard$8[rsp]
	mov	QWORD PTR [rsi+8], rax
	call	??1?$_Tidy_guard@V?$vector@MV?$allocator@M@std@@@std@@@std@@QEAA@XZ ; std::_Tidy_guard<std::vector<float,std::allocator<float> > >::~_Tidy_guard<std::vector<float,std::allocator<float> > >

; 496  : 
; 497  :         _Proxy._Release();
; 498  :     }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
$LN57@Construct_:
	ret	0
$LN60@Construct_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 138  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN59@Construct_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1729 :             _Xlength();

	call	?_Xlength@?$vector@MV?$allocator@M@std@@@std@@CAXXZ ; std::vector<float,std::allocator<float> >::_Xlength
	int	3
$LN56@Construct_:
??$_Construct_n_copies_of_ty@U_Value_init_tag@std@@@?$vector@MV?$allocator@M@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ENDP ; std::vector<float,std::allocator<float> >::_Construct_n_copies_of_ty<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PEAVHighPassFilter@@@std@@@std@@YAXPEAPEAVHighPassFilter@@QEAPEAV1@AEAV?$allocator@PEAVHighPassFilter@@@0@@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
_Al$dead$ = 24
??$_Destroy_range@V?$allocator@PEAVHighPassFilter@@@std@@@std@@YAXPEAPEAVHighPassFilter@@QEAPEAV1@AEAV?$allocator@PEAVHighPassFilter@@@0@@Z PROC ; std::_Destroy_range<std::allocator<HighPassFilter *> >, COMDAT

; 946  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 947  :     using _Ty = typename _Alloc::value_type;
; 948  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 949  :         for (; _First != _Last; ++_First) {
; 950  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 951  :         }
; 952  :     }
; 953  : }

	ret	0
??$_Destroy_range@V?$allocator@PEAVHighPassFilter@@@std@@@std@@YAXPEAPEAVHighPassFilter@@QEAPEAV1@AEAV?$allocator@PEAVHighPassFilter@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<HighPassFilter *> >
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PEAVModulation@@@std@@@std@@YAXPEAPEAVModulation@@QEAPEAV1@AEAV?$allocator@PEAVModulation@@@0@@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
_Al$dead$ = 24
??$_Destroy_range@V?$allocator@PEAVModulation@@@std@@@std@@YAXPEAPEAVModulation@@QEAPEAV1@AEAV?$allocator@PEAVModulation@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Modulation *> >, COMDAT

; 946  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 947  :     using _Ty = typename _Alloc::value_type;
; 948  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 949  :         for (; _First != _Last; ++_First) {
; 950  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 951  :         }
; 952  :     }
; 953  : }

	ret	0
??$_Destroy_range@V?$allocator@PEAVModulation@@@std@@@std@@YAXPEAPEAVModulation@@QEAPEAV1@AEAV?$allocator@PEAVModulation@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Modulation *> >
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PEAVLowPassFilter@@@std@@@std@@YAXPEAPEAVLowPassFilter@@QEAPEAV1@AEAV?$allocator@PEAVLowPassFilter@@@0@@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
_Al$dead$ = 24
??$_Destroy_range@V?$allocator@PEAVLowPassFilter@@@std@@@std@@YAXPEAPEAVLowPassFilter@@QEAPEAV1@AEAV?$allocator@PEAVLowPassFilter@@@0@@Z PROC ; std::_Destroy_range<std::allocator<LowPassFilter *> >, COMDAT

; 946  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 947  :     using _Ty = typename _Alloc::value_type;
; 948  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 949  :         for (; _First != _Last; ++_First) {
; 950  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 951  :         }
; 952  :     }
; 953  : }

	ret	0
??$_Destroy_range@V?$allocator@PEAVLowPassFilter@@@std@@@std@@YAXPEAPEAVLowPassFilter@@QEAPEAV1@AEAV?$allocator@PEAVLowPassFilter@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<LowPassFilter *> >
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@YAXPEAPEAVModMultiChannelDiffuser@@QEAPEAV1@AEAV?$allocator@PEAVModMultiChannelDiffuser@@@0@@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
_Al$dead$ = 24
??$_Destroy_range@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@YAXPEAPEAVModMultiChannelDiffuser@@QEAPEAV1@AEAV?$allocator@PEAVModMultiChannelDiffuser@@@0@@Z PROC ; std::_Destroy_range<std::allocator<ModMultiChannelDiffuser *> >, COMDAT

; 946  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 947  :     using _Ty = typename _Alloc::value_type;
; 948  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 949  :         for (; _First != _Last; ++_First) {
; 950  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 951  :         }
; 952  :     }
; 953  : }

	ret	0
??$_Destroy_range@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@YAXPEAPEAVModMultiChannelDiffuser@@QEAPEAV1@AEAV?$allocator@PEAVModMultiChannelDiffuser@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<ModMultiChannelDiffuser *> >
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@YAXPEAPEAVMultiChannelDiffuser@@QEAPEAV1@AEAV?$allocator@PEAVMultiChannelDiffuser@@@0@@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
_Al$dead$ = 24
??$_Destroy_range@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@YAXPEAPEAVMultiChannelDiffuser@@QEAPEAV1@AEAV?$allocator@PEAVMultiChannelDiffuser@@@0@@Z PROC ; std::_Destroy_range<std::allocator<MultiChannelDiffuser *> >, COMDAT

; 946  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 947  :     using _Ty = typename _Alloc::value_type;
; 948  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 949  :         for (; _First != _Last; ++_First) {
; 950  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 951  :         }
; 952  :     }
; 953  : }

	ret	0
??$_Destroy_range@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@YAXPEAPEAVMultiChannelDiffuser@@QEAPEAV1@AEAV?$allocator@PEAVMultiChannelDiffuser@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<MultiChannelDiffuser *> >
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PEAVModDelay@@@std@@@std@@YAXPEAPEAVModDelay@@QEAPEAV1@AEAV?$allocator@PEAVModDelay@@@0@@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
_Al$dead$ = 24
??$_Destroy_range@V?$allocator@PEAVModDelay@@@std@@@std@@YAXPEAPEAVModDelay@@QEAPEAV1@AEAV?$allocator@PEAVModDelay@@@0@@Z PROC ; std::_Destroy_range<std::allocator<ModDelay *> >, COMDAT

; 946  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 947  :     using _Ty = typename _Alloc::value_type;
; 948  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 949  :         for (; _First != _Last; ++_First) {
; 950  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 951  :         }
; 952  :     }
; 953  : }

	ret	0
??$_Destroy_range@V?$allocator@PEAVModDelay@@@std@@@std@@YAXPEAPEAVModDelay@@QEAPEAV1@AEAV?$allocator@PEAVModDelay@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<ModDelay *> >
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPEAHQEAHAEAV?$allocator@H@0@@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
_Al$dead$ = 24
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPEAHQEAHAEAV?$allocator@H@0@@Z PROC ; std::_Destroy_range<std::allocator<int> >, COMDAT

; 946  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 947  :     using _Ty = typename _Alloc::value_type;
; 948  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 949  :         for (; _First != _Last; ++_First) {
; 950  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 951  :         }
; 952  :     }
; 953  : }

	ret	0
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPEAHQEAHAEAV?$allocator@H@0@@Z ENDP ; std::_Destroy_range<std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PEAVDelay@@@std@@@std@@YAXPEAPEAVDelay@@QEAPEAV1@AEAV?$allocator@PEAVDelay@@@0@@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
_Al$dead$ = 24
??$_Destroy_range@V?$allocator@PEAVDelay@@@std@@@std@@YAXPEAPEAVDelay@@QEAPEAV1@AEAV?$allocator@PEAVDelay@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Delay *> >, COMDAT

; 946  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 947  :     using _Ty = typename _Alloc::value_type;
; 948  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 949  :         for (; _First != _Last; ++_First) {
; 950  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 951  :         }
; 952  :     }
; 953  : }

	ret	0
??$_Destroy_range@V?$allocator@PEAVDelay@@@std@@@std@@YAXPEAPEAVDelay@@QEAPEAV1@AEAV?$allocator@PEAVDelay@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Delay *> >
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Pocma@V?$allocator@M@std@@@std@@YAXAEAV?$allocator@M@0@0@Z
_TEXT	SEGMENT
_Left$dead$ = 8
_Right$dead$ = 16
??$_Pocma@V?$allocator@M@std@@@std@@YAXAEAV?$allocator@M@0@0@Z PROC ; std::_Pocma<std::allocator<float> >, COMDAT

; 927  :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_move_assignment::value) {
; 928  :         _Left = _STD move(_Right);
; 929  :     }
; 930  : }

	ret	0
??$_Pocma@V?$allocator@M@std@@@std@@YAXAEAV?$allocator@M@0@0@Z ENDP ; std::_Pocma<std::allocator<float> >
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Tidy_guard@V?$vector@MV?$allocator@M@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Tidy_guard@V?$vector@MV?$allocator@M@std@@@std@@@std@@QEAA@XZ PROC ; std::_Tidy_guard<std::vector<float,std::allocator<float> > >::~_Tidy_guard<std::vector<float,std::allocator<float> > >, COMDAT

; 34   :     _CONSTEXPR20_DYNALLOC ~_Tidy_guard() {

$LN29:
	push	rbx
	sub	rsp, 32					; 00000020H

; 35   :         if (_Target) {

	mov	rbx, QWORD PTR [rcx]
	test	rbx, rbx
	je	SHORT $LN5@Tidy_guard
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1763 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rbx]
	test	rcx, rcx
	je	SHORT $LN5@Tidy_guard

; 1764 :             _Destroy(_Myfirst, _Mylast);
; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -4

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN21@Tidy_guard

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN18@Tidy_guard

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN21@Tidy_guard:

; 264  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1767 :             _Myfirst = nullptr;

	and	QWORD PTR [rbx], 0

; 1768 :             _Mylast  = nullptr;

	and	QWORD PTR [rbx+8], 0

; 1769 :             _Myend   = nullptr;

	and	QWORD PTR [rbx+16], 0
$LN5@Tidy_guard:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 38   :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN18@Tidy_guard:

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN26@Tidy_guard:
??1?$_Tidy_guard@V?$vector@MV?$allocator@M@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Tidy_guard<std::vector<float,std::allocator<float> > >::~_Tidy_guard<std::vector<float,std::allocator<float> > >
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PEAVHighPassFilter@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@PEAVHighPassFilter@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<HighPassFilter *> >::_Vector_val<std::_Simple_types<HighPassFilter *> >, COMDAT

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	rax, rcx
	ret	0
??0?$_Vector_val@U?$_Simple_types@PEAVHighPassFilter@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<HighPassFilter *> >::_Vector_val<std::_Simple_types<HighPassFilter *> >
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@CAXXZ PROC ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::_Xlength, COMDAT

; 1773 :     [[noreturn]] static void _Xlength() {

$LN4:
	sub	rsp, 40					; 00000028H

; 1774 :         _Xlength_error("vector too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Xlength:
?_Xlength@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@CAXXZ ENDP ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Change_array@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@AEAAXQEAPEAVHighPassFilter@@_K1@Z
_TEXT	SEGMENT
this$ = 48
_Newvec$ = 56
_Newsize$ = 64
_Newcapacity$ = 72
?_Change_array@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@AEAAXQEAPEAVHighPassFilter@@_K1@Z PROC ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::_Change_array, COMDAT

; 1736 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

$LN25:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	rsi, r9

; 1737 :         // orphan all iterators, discard old array, acquire new array
; 1738 :         auto& _My_data    = _Mypair._Myval2;
; 1739 :         pointer& _Myfirst = _My_data._Myfirst;
; 1740 :         pointer& _Mylast  = _My_data._Mylast;
; 1741 :         pointer& _Myend   = _My_data._Myend;
; 1742 : 
; 1743 :         _My_data._Orphan_all();
; 1744 : 
; 1745 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	mov	rbp, r8
	mov	rdi, rdx
	test	rcx, rcx
	je	SHORT $LN8@Change_arr

; 1746 :             _Destroy(_Myfirst, _Mylast);
; 1747 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN18@Change_arr

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN15@Change_arr

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN18@Change_arr:

; 264  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN8@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1751 :         _Mylast  = _Newvec + _Newsize;

	lea	rax, QWORD PTR [rdi+rbp*8]
	mov	QWORD PTR [rbx], rdi

; 1753 :     }

	mov	rbp, QWORD PTR [rsp+56]
	mov	QWORD PTR [rbx+8], rax
	lea	rax, QWORD PTR [rdi+rsi*8]
	mov	rsi, QWORD PTR [rsp+64]
	mov	QWORD PTR [rbx+16], rax
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN15@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN22@Change_arr:
?_Change_array@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@AEAAXQEAPEAVHighPassFilter@@_K1@Z ENDP ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Calculate_growth@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Newsize$ = 16
?_Calculate_growth@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@AEBA_K_K@Z PROC ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::_Calculate_growth, COMDAT

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	r8, QWORD PTR [rcx+16]

; 1684 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1685 :         const size_type _Oldcapacity = capacity();
; 1686 :         const auto _Max              = max_size();
; 1687 : 
; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sub	r8, QWORD PTR [rcx]

; 1684 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1685 :         const size_type _Oldcapacity = capacity();
; 1686 :         const auto _Max              = max_size();
; 1687 : 
; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rcx, rax

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	r8, 3

; 1684 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1685 :         const size_type _Oldcapacity = capacity();
; 1686 :         const auto _Max              = max_size();
; 1687 : 
; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	r9, r8
	shr	r9, 1
	sub	rcx, r9
	cmp	r8, rcx
	ja	SHORT $LN3@Calculate_

; 1689 :             return _Max; // geometric growth would overflow
; 1690 :         }
; 1691 : 
; 1692 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rax, QWORD PTR [r9+r8]

; 1693 : 
; 1694 :         if (_Geometric < _Newsize) {

	cmp	rax, rdx
	cmovb	rax, rdx
$LN3@Calculate_:

; 1695 :             return _Newsize; // geometric growth would be insufficient
; 1696 :         }
; 1697 : 
; 1698 :         return _Geometric; // geometric growth is sufficient
; 1699 :     }

	ret	0
?_Calculate_growth@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@AEBA_K_K@Z ENDP ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@AEAAXPEAPEAVHighPassFilter@@00@Z
_TEXT	SEGMENT
this$dead$ = 8
_First$ = 16
_Last$ = 24
_Dest$ = 32
?_Umove_if_noexcept@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@AEAAXPEAPEAVHighPassFilter@@00@Z PROC ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::_Umove_if_noexcept, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, rdx

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, r9
	rex_jmp	QWORD PTR __imp_memmove
?_Umove_if_noexcept@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@AEAAXPEAPEAVHighPassFilter@@00@Z ENDP ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@AEAAPEAPEAVHighPassFilter@@PEAPEAV3@00@Z
_TEXT	SEGMENT
this$dead$ = 48
_First$ = 56
_Last$ = 64
_Dest$ = 72
?_Umove@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@AEAAPEAPEAVHighPassFilter@@PEAPEAV3@00@Z PROC ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::_Umove, COMDAT

; 1657 :     _CONSTEXPR20_CONTAINER pointer _Umove(pointer _First, pointer _Last, pointer _Dest) {

$LN18:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, r8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, r9
	sub	rbx, rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1657 :     _CONSTEXPR20_CONTAINER pointer _Umove(pointer _First, pointer _Last, pointer _Dest) {

	mov	rdi, r9
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbx
	call	QWORD PTR __imp_memmove
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1706 :             return _Dest + (_ULast - _UFirst);

	sar	rbx, 3
	lea	rax, QWORD PTR [rdi+rbx*8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1660 :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?_Umove@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@AEAAPEAPEAVHighPassFilter@@PEAPEAV3@00@Z ENDP ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::_Umove
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEBA_KXZ PROC ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::max_size, COMDAT

; 1553 :         return (_STD min)(

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 1554 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1555 :     }

	ret	0
?max_size@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?allocate@?$allocator@PEAVHighPassFilter@@@std@@QEAAPEAPEAVHighPassFilter@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@PEAVHighPassFilter@@@std@@QEAAPEAPEAVHighPassFilter@@_K@Z PROC ; std::allocator<HighPassFilter *>::allocate, COMDAT

; 838  :     _NODISCARD _CONSTEXPR20_DYNALLOC __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN30:
	sub	rsp, 40					; 00000028H

; 64   :         if (_Count > _Max_possible) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	cmp	rdx, rax
	ja	SHORT $LN27@allocate

; 65   :             _Throw_bad_array_new_length(); // multiply overflow
; 66   :         }
; 67   :     }
; 68   : 
; 69   :     return _Count * _Ty_size;

	lea	rcx, QWORD PTR [rdx*8]

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN8@allocate

; 136  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 137  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN27@allocate

; 85   :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 142  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN17@allocate

; 143  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rax, QWORD PTR [rax+39]
	and	rax, -32				; ffffffffffffffe0H

; 144  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx
$LN6@allocate:

; 839  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 840  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN17@allocate:

; 142  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN8@allocate:

; 243  :     if (_Bytes != 0) {

	xor	eax, eax
	test	rcx, rcx
	je	SHORT $LN6@allocate

; 839  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 840  :     }

	add	rsp, 40					; 00000028H

; 85   :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN27@allocate:

; 138  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN28@allocate:
?allocate@?$allocator@PEAVHighPassFilter@@@std@@QEAAPEAPEAVHighPassFilter@@_K@Z ENDP ; std::allocator<HighPassFilter *>::allocate
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$allocator@PEAVHighPassFilter@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@PEAVHighPassFilter@@@std@@QEAA@XZ PROC	; std::allocator<HighPassFilter *>::allocator<HighPassFilter *>, COMDAT

; 825  :     constexpr allocator() noexcept {}

	mov	rax, rcx
	ret	0
??0?$allocator@PEAVHighPassFilter@@@std@@QEAA@XZ ENDP	; std::allocator<HighPassFilter *>::allocator<HighPassFilter *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PEAVModulation@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@PEAVModulation@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<Modulation *> >::_Vector_val<std::_Simple_types<Modulation *> >, COMDAT

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	rax, rcx
	ret	0
??0?$_Vector_val@U?$_Simple_types@PEAVModulation@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<Modulation *> >::_Vector_val<std::_Simple_types<Modulation *> >
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@CAXXZ PROC ; std::vector<Modulation *,std::allocator<Modulation *> >::_Xlength, COMDAT

; 1773 :     [[noreturn]] static void _Xlength() {

$LN4:
	sub	rsp, 40					; 00000028H

; 1774 :         _Xlength_error("vector too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Xlength:
?_Xlength@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@CAXXZ ENDP ; std::vector<Modulation *,std::allocator<Modulation *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Change_array@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@AEAAXQEAPEAVModulation@@_K1@Z
_TEXT	SEGMENT
this$ = 48
_Newvec$ = 56
_Newsize$ = 64
_Newcapacity$ = 72
?_Change_array@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@AEAAXQEAPEAVModulation@@_K1@Z PROC ; std::vector<Modulation *,std::allocator<Modulation *> >::_Change_array, COMDAT

; 1736 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

$LN25:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	rsi, r9

; 1737 :         // orphan all iterators, discard old array, acquire new array
; 1738 :         auto& _My_data    = _Mypair._Myval2;
; 1739 :         pointer& _Myfirst = _My_data._Myfirst;
; 1740 :         pointer& _Mylast  = _My_data._Mylast;
; 1741 :         pointer& _Myend   = _My_data._Myend;
; 1742 : 
; 1743 :         _My_data._Orphan_all();
; 1744 : 
; 1745 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	mov	rbp, r8
	mov	rdi, rdx
	test	rcx, rcx
	je	SHORT $LN8@Change_arr

; 1746 :             _Destroy(_Myfirst, _Mylast);
; 1747 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN18@Change_arr

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN15@Change_arr

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN18@Change_arr:

; 264  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN8@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1751 :         _Mylast  = _Newvec + _Newsize;

	lea	rax, QWORD PTR [rdi+rbp*8]
	mov	QWORD PTR [rbx], rdi

; 1753 :     }

	mov	rbp, QWORD PTR [rsp+56]
	mov	QWORD PTR [rbx+8], rax
	lea	rax, QWORD PTR [rdi+rsi*8]
	mov	rsi, QWORD PTR [rsp+64]
	mov	QWORD PTR [rbx+16], rax
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN15@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN22@Change_arr:
?_Change_array@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@AEAAXQEAPEAVModulation@@_K1@Z ENDP ; std::vector<Modulation *,std::allocator<Modulation *> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Calculate_growth@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Newsize$ = 16
?_Calculate_growth@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@AEBA_K_K@Z PROC ; std::vector<Modulation *,std::allocator<Modulation *> >::_Calculate_growth, COMDAT

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	r8, QWORD PTR [rcx+16]

; 1684 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1685 :         const size_type _Oldcapacity = capacity();
; 1686 :         const auto _Max              = max_size();
; 1687 : 
; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sub	r8, QWORD PTR [rcx]

; 1684 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1685 :         const size_type _Oldcapacity = capacity();
; 1686 :         const auto _Max              = max_size();
; 1687 : 
; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rcx, rax

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	r8, 3

; 1684 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1685 :         const size_type _Oldcapacity = capacity();
; 1686 :         const auto _Max              = max_size();
; 1687 : 
; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	r9, r8
	shr	r9, 1
	sub	rcx, r9
	cmp	r8, rcx
	ja	SHORT $LN3@Calculate_

; 1689 :             return _Max; // geometric growth would overflow
; 1690 :         }
; 1691 : 
; 1692 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rax, QWORD PTR [r9+r8]

; 1693 : 
; 1694 :         if (_Geometric < _Newsize) {

	cmp	rax, rdx
	cmovb	rax, rdx
$LN3@Calculate_:

; 1695 :             return _Newsize; // geometric growth would be insufficient
; 1696 :         }
; 1697 : 
; 1698 :         return _Geometric; // geometric growth is sufficient
; 1699 :     }

	ret	0
?_Calculate_growth@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@AEBA_K_K@Z ENDP ; std::vector<Modulation *,std::allocator<Modulation *> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@AEAAXPEAPEAVModulation@@00@Z
_TEXT	SEGMENT
this$dead$ = 8
_First$ = 16
_Last$ = 24
_Dest$ = 32
?_Umove_if_noexcept@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@AEAAXPEAPEAVModulation@@00@Z PROC ; std::vector<Modulation *,std::allocator<Modulation *> >::_Umove_if_noexcept, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, rdx

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, r9
	rex_jmp	QWORD PTR __imp_memmove
?_Umove_if_noexcept@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@AEAAXPEAPEAVModulation@@00@Z ENDP ; std::vector<Modulation *,std::allocator<Modulation *> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@AEAAPEAPEAVModulation@@PEAPEAV3@00@Z
_TEXT	SEGMENT
this$dead$ = 48
_First$ = 56
_Last$ = 64
_Dest$ = 72
?_Umove@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@AEAAPEAPEAVModulation@@PEAPEAV3@00@Z PROC ; std::vector<Modulation *,std::allocator<Modulation *> >::_Umove, COMDAT

; 1657 :     _CONSTEXPR20_CONTAINER pointer _Umove(pointer _First, pointer _Last, pointer _Dest) {

$LN18:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, r8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, r9
	sub	rbx, rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1657 :     _CONSTEXPR20_CONTAINER pointer _Umove(pointer _First, pointer _Last, pointer _Dest) {

	mov	rdi, r9
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbx
	call	QWORD PTR __imp_memmove
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1706 :             return _Dest + (_ULast - _UFirst);

	sar	rbx, 3
	lea	rax, QWORD PTR [rdi+rbx*8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1660 :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?_Umove@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@AEAAPEAPEAVModulation@@PEAPEAV3@00@Z ENDP ; std::vector<Modulation *,std::allocator<Modulation *> >::_Umove
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@QEBA_KXZ PROC ; std::vector<Modulation *,std::allocator<Modulation *> >::max_size, COMDAT

; 1553 :         return (_STD min)(

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 1554 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1555 :     }

	ret	0
?max_size@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<Modulation *,std::allocator<Modulation *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?allocate@?$allocator@PEAVModulation@@@std@@QEAAPEAPEAVModulation@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@PEAVModulation@@@std@@QEAAPEAPEAVModulation@@_K@Z PROC ; std::allocator<Modulation *>::allocate, COMDAT

; 838  :     _NODISCARD _CONSTEXPR20_DYNALLOC __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN30:
	sub	rsp, 40					; 00000028H

; 64   :         if (_Count > _Max_possible) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	cmp	rdx, rax
	ja	SHORT $LN27@allocate

; 65   :             _Throw_bad_array_new_length(); // multiply overflow
; 66   :         }
; 67   :     }
; 68   : 
; 69   :     return _Count * _Ty_size;

	lea	rcx, QWORD PTR [rdx*8]

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN8@allocate

; 136  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 137  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN27@allocate

; 85   :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 142  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN17@allocate

; 143  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rax, QWORD PTR [rax+39]
	and	rax, -32				; ffffffffffffffe0H

; 144  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx
$LN6@allocate:

; 839  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 840  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN17@allocate:

; 142  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN8@allocate:

; 243  :     if (_Bytes != 0) {

	xor	eax, eax
	test	rcx, rcx
	je	SHORT $LN6@allocate

; 839  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 840  :     }

	add	rsp, 40					; 00000028H

; 85   :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN27@allocate:

; 138  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN28@allocate:
?allocate@?$allocator@PEAVModulation@@@std@@QEAAPEAPEAVModulation@@_K@Z ENDP ; std::allocator<Modulation *>::allocate
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$allocator@PEAVModulation@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@PEAVModulation@@@std@@QEAA@XZ PROC	; std::allocator<Modulation *>::allocator<Modulation *>, COMDAT

; 825  :     constexpr allocator() noexcept {}

	mov	rax, rcx
	ret	0
??0?$allocator@PEAVModulation@@@std@@QEAA@XZ ENDP	; std::allocator<Modulation *>::allocator<Modulation *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PEAVLowPassFilter@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@PEAVLowPassFilter@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<LowPassFilter *> >::_Vector_val<std::_Simple_types<LowPassFilter *> >, COMDAT

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	rax, rcx
	ret	0
??0?$_Vector_val@U?$_Simple_types@PEAVLowPassFilter@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<LowPassFilter *> >::_Vector_val<std::_Simple_types<LowPassFilter *> >
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@CAXXZ PROC ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::_Xlength, COMDAT

; 1773 :     [[noreturn]] static void _Xlength() {

$LN4:
	sub	rsp, 40					; 00000028H

; 1774 :         _Xlength_error("vector too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Xlength:
?_Xlength@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@CAXXZ ENDP ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Change_array@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@AEAAXQEAPEAVLowPassFilter@@_K1@Z
_TEXT	SEGMENT
this$ = 48
_Newvec$ = 56
_Newsize$ = 64
_Newcapacity$ = 72
?_Change_array@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@AEAAXQEAPEAVLowPassFilter@@_K1@Z PROC ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::_Change_array, COMDAT

; 1736 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

$LN25:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	rsi, r9

; 1737 :         // orphan all iterators, discard old array, acquire new array
; 1738 :         auto& _My_data    = _Mypair._Myval2;
; 1739 :         pointer& _Myfirst = _My_data._Myfirst;
; 1740 :         pointer& _Mylast  = _My_data._Mylast;
; 1741 :         pointer& _Myend   = _My_data._Myend;
; 1742 : 
; 1743 :         _My_data._Orphan_all();
; 1744 : 
; 1745 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	mov	rbp, r8
	mov	rdi, rdx
	test	rcx, rcx
	je	SHORT $LN8@Change_arr

; 1746 :             _Destroy(_Myfirst, _Mylast);
; 1747 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN18@Change_arr

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN15@Change_arr

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN18@Change_arr:

; 264  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN8@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1751 :         _Mylast  = _Newvec + _Newsize;

	lea	rax, QWORD PTR [rdi+rbp*8]
	mov	QWORD PTR [rbx], rdi

; 1753 :     }

	mov	rbp, QWORD PTR [rsp+56]
	mov	QWORD PTR [rbx+8], rax
	lea	rax, QWORD PTR [rdi+rsi*8]
	mov	rsi, QWORD PTR [rsp+64]
	mov	QWORD PTR [rbx+16], rax
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN15@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN22@Change_arr:
?_Change_array@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@AEAAXQEAPEAVLowPassFilter@@_K1@Z ENDP ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Calculate_growth@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Newsize$ = 16
?_Calculate_growth@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@AEBA_K_K@Z PROC ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::_Calculate_growth, COMDAT

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	r8, QWORD PTR [rcx+16]

; 1684 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1685 :         const size_type _Oldcapacity = capacity();
; 1686 :         const auto _Max              = max_size();
; 1687 : 
; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sub	r8, QWORD PTR [rcx]

; 1684 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1685 :         const size_type _Oldcapacity = capacity();
; 1686 :         const auto _Max              = max_size();
; 1687 : 
; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rcx, rax

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	r8, 3

; 1684 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1685 :         const size_type _Oldcapacity = capacity();
; 1686 :         const auto _Max              = max_size();
; 1687 : 
; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	r9, r8
	shr	r9, 1
	sub	rcx, r9
	cmp	r8, rcx
	ja	SHORT $LN3@Calculate_

; 1689 :             return _Max; // geometric growth would overflow
; 1690 :         }
; 1691 : 
; 1692 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rax, QWORD PTR [r9+r8]

; 1693 : 
; 1694 :         if (_Geometric < _Newsize) {

	cmp	rax, rdx
	cmovb	rax, rdx
$LN3@Calculate_:

; 1695 :             return _Newsize; // geometric growth would be insufficient
; 1696 :         }
; 1697 : 
; 1698 :         return _Geometric; // geometric growth is sufficient
; 1699 :     }

	ret	0
?_Calculate_growth@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@AEBA_K_K@Z ENDP ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@AEAAXPEAPEAVLowPassFilter@@00@Z
_TEXT	SEGMENT
this$dead$ = 8
_First$ = 16
_Last$ = 24
_Dest$ = 32
?_Umove_if_noexcept@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@AEAAXPEAPEAVLowPassFilter@@00@Z PROC ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::_Umove_if_noexcept, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, rdx

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, r9
	rex_jmp	QWORD PTR __imp_memmove
?_Umove_if_noexcept@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@AEAAXPEAPEAVLowPassFilter@@00@Z ENDP ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@AEAAPEAPEAVLowPassFilter@@PEAPEAV3@00@Z
_TEXT	SEGMENT
this$dead$ = 48
_First$ = 56
_Last$ = 64
_Dest$ = 72
?_Umove@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@AEAAPEAPEAVLowPassFilter@@PEAPEAV3@00@Z PROC ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::_Umove, COMDAT

; 1657 :     _CONSTEXPR20_CONTAINER pointer _Umove(pointer _First, pointer _Last, pointer _Dest) {

$LN18:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, r8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, r9
	sub	rbx, rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1657 :     _CONSTEXPR20_CONTAINER pointer _Umove(pointer _First, pointer _Last, pointer _Dest) {

	mov	rdi, r9
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbx
	call	QWORD PTR __imp_memmove
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1706 :             return _Dest + (_ULast - _UFirst);

	sar	rbx, 3
	lea	rax, QWORD PTR [rdi+rbx*8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1660 :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?_Umove@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@AEAAPEAPEAVLowPassFilter@@PEAPEAV3@00@Z ENDP ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::_Umove
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEBA_KXZ PROC ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::max_size, COMDAT

; 1553 :         return (_STD min)(

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 1554 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1555 :     }

	ret	0
?max_size@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?allocate@?$allocator@PEAVLowPassFilter@@@std@@QEAAPEAPEAVLowPassFilter@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@PEAVLowPassFilter@@@std@@QEAAPEAPEAVLowPassFilter@@_K@Z PROC ; std::allocator<LowPassFilter *>::allocate, COMDAT

; 838  :     _NODISCARD _CONSTEXPR20_DYNALLOC __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN30:
	sub	rsp, 40					; 00000028H

; 64   :         if (_Count > _Max_possible) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	cmp	rdx, rax
	ja	SHORT $LN27@allocate

; 65   :             _Throw_bad_array_new_length(); // multiply overflow
; 66   :         }
; 67   :     }
; 68   : 
; 69   :     return _Count * _Ty_size;

	lea	rcx, QWORD PTR [rdx*8]

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN8@allocate

; 136  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 137  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN27@allocate

; 85   :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 142  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN17@allocate

; 143  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rax, QWORD PTR [rax+39]
	and	rax, -32				; ffffffffffffffe0H

; 144  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx
$LN6@allocate:

; 839  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 840  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN17@allocate:

; 142  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN8@allocate:

; 243  :     if (_Bytes != 0) {

	xor	eax, eax
	test	rcx, rcx
	je	SHORT $LN6@allocate

; 839  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 840  :     }

	add	rsp, 40					; 00000028H

; 85   :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN27@allocate:

; 138  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN28@allocate:
?allocate@?$allocator@PEAVLowPassFilter@@@std@@QEAAPEAPEAVLowPassFilter@@_K@Z ENDP ; std::allocator<LowPassFilter *>::allocate
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$allocator@PEAVLowPassFilter@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@PEAVLowPassFilter@@@std@@QEAA@XZ PROC	; std::allocator<LowPassFilter *>::allocator<LowPassFilter *>, COMDAT

; 825  :     constexpr allocator() noexcept {}

	mov	rax, rcx
	ret	0
??0?$allocator@PEAVLowPassFilter@@@std@@QEAA@XZ ENDP	; std::allocator<LowPassFilter *>::allocator<LowPassFilter *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PEAVModMultiChannelDiffuser@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@PEAVModMultiChannelDiffuser@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<ModMultiChannelDiffuser *> >::_Vector_val<std::_Simple_types<ModMultiChannelDiffuser *> >, COMDAT

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	rax, rcx
	ret	0
??0?$_Vector_val@U?$_Simple_types@PEAVModMultiChannelDiffuser@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<ModMultiChannelDiffuser *> >::_Vector_val<std::_Simple_types<ModMultiChannelDiffuser *> >
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@CAXXZ PROC ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::_Xlength, COMDAT

; 1773 :     [[noreturn]] static void _Xlength() {

$LN4:
	sub	rsp, 40					; 00000028H

; 1774 :         _Xlength_error("vector too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Xlength:
?_Xlength@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@CAXXZ ENDP ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Change_array@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@AEAAXQEAPEAVModMultiChannelDiffuser@@_K1@Z
_TEXT	SEGMENT
this$ = 48
_Newvec$ = 56
_Newsize$ = 64
_Newcapacity$ = 72
?_Change_array@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@AEAAXQEAPEAVModMultiChannelDiffuser@@_K1@Z PROC ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::_Change_array, COMDAT

; 1736 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

$LN25:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	rsi, r9

; 1737 :         // orphan all iterators, discard old array, acquire new array
; 1738 :         auto& _My_data    = _Mypair._Myval2;
; 1739 :         pointer& _Myfirst = _My_data._Myfirst;
; 1740 :         pointer& _Mylast  = _My_data._Mylast;
; 1741 :         pointer& _Myend   = _My_data._Myend;
; 1742 : 
; 1743 :         _My_data._Orphan_all();
; 1744 : 
; 1745 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	mov	rbp, r8
	mov	rdi, rdx
	test	rcx, rcx
	je	SHORT $LN8@Change_arr

; 1746 :             _Destroy(_Myfirst, _Mylast);
; 1747 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN18@Change_arr

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN15@Change_arr

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN18@Change_arr:

; 264  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN8@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1751 :         _Mylast  = _Newvec + _Newsize;

	lea	rax, QWORD PTR [rdi+rbp*8]
	mov	QWORD PTR [rbx], rdi

; 1753 :     }

	mov	rbp, QWORD PTR [rsp+56]
	mov	QWORD PTR [rbx+8], rax
	lea	rax, QWORD PTR [rdi+rsi*8]
	mov	rsi, QWORD PTR [rsp+64]
	mov	QWORD PTR [rbx+16], rax
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN15@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN22@Change_arr:
?_Change_array@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@AEAAXQEAPEAVModMultiChannelDiffuser@@_K1@Z ENDP ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Calculate_growth@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Newsize$ = 16
?_Calculate_growth@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@AEBA_K_K@Z PROC ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::_Calculate_growth, COMDAT

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	r8, QWORD PTR [rcx+16]

; 1684 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1685 :         const size_type _Oldcapacity = capacity();
; 1686 :         const auto _Max              = max_size();
; 1687 : 
; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sub	r8, QWORD PTR [rcx]

; 1684 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1685 :         const size_type _Oldcapacity = capacity();
; 1686 :         const auto _Max              = max_size();
; 1687 : 
; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rcx, rax

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	r8, 3

; 1684 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1685 :         const size_type _Oldcapacity = capacity();
; 1686 :         const auto _Max              = max_size();
; 1687 : 
; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	r9, r8
	shr	r9, 1
	sub	rcx, r9
	cmp	r8, rcx
	ja	SHORT $LN3@Calculate_

; 1689 :             return _Max; // geometric growth would overflow
; 1690 :         }
; 1691 : 
; 1692 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rax, QWORD PTR [r9+r8]

; 1693 : 
; 1694 :         if (_Geometric < _Newsize) {

	cmp	rax, rdx
	cmovb	rax, rdx
$LN3@Calculate_:

; 1695 :             return _Newsize; // geometric growth would be insufficient
; 1696 :         }
; 1697 : 
; 1698 :         return _Geometric; // geometric growth is sufficient
; 1699 :     }

	ret	0
?_Calculate_growth@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@AEBA_K_K@Z ENDP ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@AEAAXPEAPEAVModMultiChannelDiffuser@@00@Z
_TEXT	SEGMENT
this$dead$ = 8
_First$ = 16
_Last$ = 24
_Dest$ = 32
?_Umove_if_noexcept@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@AEAAXPEAPEAVModMultiChannelDiffuser@@00@Z PROC ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::_Umove_if_noexcept, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, rdx

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, r9
	rex_jmp	QWORD PTR __imp_memmove
?_Umove_if_noexcept@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@AEAAXPEAPEAVModMultiChannelDiffuser@@00@Z ENDP ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@AEAAPEAPEAVModMultiChannelDiffuser@@PEAPEAV3@00@Z
_TEXT	SEGMENT
this$dead$ = 48
_First$ = 56
_Last$ = 64
_Dest$ = 72
?_Umove@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@AEAAPEAPEAVModMultiChannelDiffuser@@PEAPEAV3@00@Z PROC ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::_Umove, COMDAT

; 1657 :     _CONSTEXPR20_CONTAINER pointer _Umove(pointer _First, pointer _Last, pointer _Dest) {

$LN18:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, r8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, r9
	sub	rbx, rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1657 :     _CONSTEXPR20_CONTAINER pointer _Umove(pointer _First, pointer _Last, pointer _Dest) {

	mov	rdi, r9
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbx
	call	QWORD PTR __imp_memmove
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1706 :             return _Dest + (_ULast - _UFirst);

	sar	rbx, 3
	lea	rax, QWORD PTR [rdi+rbx*8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1660 :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?_Umove@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@AEAAPEAPEAVModMultiChannelDiffuser@@PEAPEAV3@00@Z ENDP ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::_Umove
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEBA_KXZ PROC ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::max_size, COMDAT

; 1553 :         return (_STD min)(

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 1554 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1555 :     }

	ret	0
?max_size@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?allocate@?$allocator@PEAVModMultiChannelDiffuser@@@std@@QEAAPEAPEAVModMultiChannelDiffuser@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@PEAVModMultiChannelDiffuser@@@std@@QEAAPEAPEAVModMultiChannelDiffuser@@_K@Z PROC ; std::allocator<ModMultiChannelDiffuser *>::allocate, COMDAT

; 838  :     _NODISCARD _CONSTEXPR20_DYNALLOC __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN30:
	sub	rsp, 40					; 00000028H

; 64   :         if (_Count > _Max_possible) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	cmp	rdx, rax
	ja	SHORT $LN27@allocate

; 65   :             _Throw_bad_array_new_length(); // multiply overflow
; 66   :         }
; 67   :     }
; 68   : 
; 69   :     return _Count * _Ty_size;

	lea	rcx, QWORD PTR [rdx*8]

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN8@allocate

; 136  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 137  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN27@allocate

; 85   :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 142  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN17@allocate

; 143  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rax, QWORD PTR [rax+39]
	and	rax, -32				; ffffffffffffffe0H

; 144  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx
$LN6@allocate:

; 839  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 840  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN17@allocate:

; 142  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN8@allocate:

; 243  :     if (_Bytes != 0) {

	xor	eax, eax
	test	rcx, rcx
	je	SHORT $LN6@allocate

; 839  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 840  :     }

	add	rsp, 40					; 00000028H

; 85   :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN27@allocate:

; 138  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN28@allocate:
?allocate@?$allocator@PEAVModMultiChannelDiffuser@@@std@@QEAAPEAPEAVModMultiChannelDiffuser@@_K@Z ENDP ; std::allocator<ModMultiChannelDiffuser *>::allocate
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$allocator@PEAVModMultiChannelDiffuser@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@PEAVModMultiChannelDiffuser@@@std@@QEAA@XZ PROC ; std::allocator<ModMultiChannelDiffuser *>::allocator<ModMultiChannelDiffuser *>, COMDAT

; 825  :     constexpr allocator() noexcept {}

	mov	rax, rcx
	ret	0
??0?$allocator@PEAVModMultiChannelDiffuser@@@std@@QEAA@XZ ENDP ; std::allocator<ModMultiChannelDiffuser *>::allocator<ModMultiChannelDiffuser *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PEAVMultiChannelDiffuser@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@PEAVMultiChannelDiffuser@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<MultiChannelDiffuser *> >::_Vector_val<std::_Simple_types<MultiChannelDiffuser *> >, COMDAT

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	rax, rcx
	ret	0
??0?$_Vector_val@U?$_Simple_types@PEAVMultiChannelDiffuser@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<MultiChannelDiffuser *> >::_Vector_val<std::_Simple_types<MultiChannelDiffuser *> >
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@CAXXZ PROC ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::_Xlength, COMDAT

; 1773 :     [[noreturn]] static void _Xlength() {

$LN4:
	sub	rsp, 40					; 00000028H

; 1774 :         _Xlength_error("vector too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Xlength:
?_Xlength@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@CAXXZ ENDP ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Change_array@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@AEAAXQEAPEAVMultiChannelDiffuser@@_K1@Z
_TEXT	SEGMENT
this$ = 48
_Newvec$ = 56
_Newsize$ = 64
_Newcapacity$ = 72
?_Change_array@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@AEAAXQEAPEAVMultiChannelDiffuser@@_K1@Z PROC ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::_Change_array, COMDAT

; 1736 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

$LN25:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	rsi, r9

; 1737 :         // orphan all iterators, discard old array, acquire new array
; 1738 :         auto& _My_data    = _Mypair._Myval2;
; 1739 :         pointer& _Myfirst = _My_data._Myfirst;
; 1740 :         pointer& _Mylast  = _My_data._Mylast;
; 1741 :         pointer& _Myend   = _My_data._Myend;
; 1742 : 
; 1743 :         _My_data._Orphan_all();
; 1744 : 
; 1745 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	mov	rbp, r8
	mov	rdi, rdx
	test	rcx, rcx
	je	SHORT $LN8@Change_arr

; 1746 :             _Destroy(_Myfirst, _Mylast);
; 1747 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN18@Change_arr

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN15@Change_arr

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN18@Change_arr:

; 264  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN8@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1751 :         _Mylast  = _Newvec + _Newsize;

	lea	rax, QWORD PTR [rdi+rbp*8]
	mov	QWORD PTR [rbx], rdi

; 1753 :     }

	mov	rbp, QWORD PTR [rsp+56]
	mov	QWORD PTR [rbx+8], rax
	lea	rax, QWORD PTR [rdi+rsi*8]
	mov	rsi, QWORD PTR [rsp+64]
	mov	QWORD PTR [rbx+16], rax
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN15@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN22@Change_arr:
?_Change_array@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@AEAAXQEAPEAVMultiChannelDiffuser@@_K1@Z ENDP ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Calculate_growth@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Newsize$ = 16
?_Calculate_growth@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@AEBA_K_K@Z PROC ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::_Calculate_growth, COMDAT

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	r8, QWORD PTR [rcx+16]

; 1684 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1685 :         const size_type _Oldcapacity = capacity();
; 1686 :         const auto _Max              = max_size();
; 1687 : 
; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sub	r8, QWORD PTR [rcx]

; 1684 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1685 :         const size_type _Oldcapacity = capacity();
; 1686 :         const auto _Max              = max_size();
; 1687 : 
; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rcx, rax

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	r8, 3

; 1684 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1685 :         const size_type _Oldcapacity = capacity();
; 1686 :         const auto _Max              = max_size();
; 1687 : 
; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	r9, r8
	shr	r9, 1
	sub	rcx, r9
	cmp	r8, rcx
	ja	SHORT $LN3@Calculate_

; 1689 :             return _Max; // geometric growth would overflow
; 1690 :         }
; 1691 : 
; 1692 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rax, QWORD PTR [r9+r8]

; 1693 : 
; 1694 :         if (_Geometric < _Newsize) {

	cmp	rax, rdx
	cmovb	rax, rdx
$LN3@Calculate_:

; 1695 :             return _Newsize; // geometric growth would be insufficient
; 1696 :         }
; 1697 : 
; 1698 :         return _Geometric; // geometric growth is sufficient
; 1699 :     }

	ret	0
?_Calculate_growth@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@AEBA_K_K@Z ENDP ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@AEAAXPEAPEAVMultiChannelDiffuser@@00@Z
_TEXT	SEGMENT
this$dead$ = 8
_First$ = 16
_Last$ = 24
_Dest$ = 32
?_Umove_if_noexcept@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@AEAAXPEAPEAVMultiChannelDiffuser@@00@Z PROC ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::_Umove_if_noexcept, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, rdx

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, r9
	rex_jmp	QWORD PTR __imp_memmove
?_Umove_if_noexcept@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@AEAAXPEAPEAVMultiChannelDiffuser@@00@Z ENDP ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@AEAAPEAPEAVMultiChannelDiffuser@@PEAPEAV3@00@Z
_TEXT	SEGMENT
this$dead$ = 48
_First$ = 56
_Last$ = 64
_Dest$ = 72
?_Umove@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@AEAAPEAPEAVMultiChannelDiffuser@@PEAPEAV3@00@Z PROC ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::_Umove, COMDAT

; 1657 :     _CONSTEXPR20_CONTAINER pointer _Umove(pointer _First, pointer _Last, pointer _Dest) {

$LN18:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, r8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, r9
	sub	rbx, rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1657 :     _CONSTEXPR20_CONTAINER pointer _Umove(pointer _First, pointer _Last, pointer _Dest) {

	mov	rdi, r9
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbx
	call	QWORD PTR __imp_memmove
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1706 :             return _Dest + (_ULast - _UFirst);

	sar	rbx, 3
	lea	rax, QWORD PTR [rdi+rbx*8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1660 :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?_Umove@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@AEAAPEAPEAVMultiChannelDiffuser@@PEAPEAV3@00@Z ENDP ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::_Umove
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEBA_KXZ PROC ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::max_size, COMDAT

; 1553 :         return (_STD min)(

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 1554 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1555 :     }

	ret	0
?max_size@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?allocate@?$allocator@PEAVMultiChannelDiffuser@@@std@@QEAAPEAPEAVMultiChannelDiffuser@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@PEAVMultiChannelDiffuser@@@std@@QEAAPEAPEAVMultiChannelDiffuser@@_K@Z PROC ; std::allocator<MultiChannelDiffuser *>::allocate, COMDAT

; 838  :     _NODISCARD _CONSTEXPR20_DYNALLOC __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN30:
	sub	rsp, 40					; 00000028H

; 64   :         if (_Count > _Max_possible) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	cmp	rdx, rax
	ja	SHORT $LN27@allocate

; 65   :             _Throw_bad_array_new_length(); // multiply overflow
; 66   :         }
; 67   :     }
; 68   : 
; 69   :     return _Count * _Ty_size;

	lea	rcx, QWORD PTR [rdx*8]

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN8@allocate

; 136  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 137  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN27@allocate

; 85   :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 142  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN17@allocate

; 143  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rax, QWORD PTR [rax+39]
	and	rax, -32				; ffffffffffffffe0H

; 144  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx
$LN6@allocate:

; 839  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 840  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN17@allocate:

; 142  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN8@allocate:

; 243  :     if (_Bytes != 0) {

	xor	eax, eax
	test	rcx, rcx
	je	SHORT $LN6@allocate

; 839  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 840  :     }

	add	rsp, 40					; 00000028H

; 85   :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN27@allocate:

; 138  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN28@allocate:
?allocate@?$allocator@PEAVMultiChannelDiffuser@@@std@@QEAAPEAPEAVMultiChannelDiffuser@@_K@Z ENDP ; std::allocator<MultiChannelDiffuser *>::allocate
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$allocator@PEAVMultiChannelDiffuser@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@PEAVMultiChannelDiffuser@@@std@@QEAA@XZ PROC ; std::allocator<MultiChannelDiffuser *>::allocator<MultiChannelDiffuser *>, COMDAT

; 825  :     constexpr allocator() noexcept {}

	mov	rax, rcx
	ret	0
??0?$allocator@PEAVMultiChannelDiffuser@@@std@@QEAA@XZ ENDP ; std::allocator<MultiChannelDiffuser *>::allocator<MultiChannelDiffuser *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PEAVModDelay@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@PEAVModDelay@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<ModDelay *> >::_Vector_val<std::_Simple_types<ModDelay *> >, COMDAT

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	rax, rcx
	ret	0
??0?$_Vector_val@U?$_Simple_types@PEAVModDelay@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<ModDelay *> >::_Vector_val<std::_Simple_types<ModDelay *> >
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@CAXXZ PROC ; std::vector<ModDelay *,std::allocator<ModDelay *> >::_Xlength, COMDAT

; 1773 :     [[noreturn]] static void _Xlength() {

$LN4:
	sub	rsp, 40					; 00000028H

; 1774 :         _Xlength_error("vector too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Xlength:
?_Xlength@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@CAXXZ ENDP ; std::vector<ModDelay *,std::allocator<ModDelay *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Change_array@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@AEAAXQEAPEAVModDelay@@_K1@Z
_TEXT	SEGMENT
this$ = 48
_Newvec$ = 56
_Newsize$ = 64
_Newcapacity$ = 72
?_Change_array@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@AEAAXQEAPEAVModDelay@@_K1@Z PROC ; std::vector<ModDelay *,std::allocator<ModDelay *> >::_Change_array, COMDAT

; 1736 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

$LN25:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	rsi, r9

; 1737 :         // orphan all iterators, discard old array, acquire new array
; 1738 :         auto& _My_data    = _Mypair._Myval2;
; 1739 :         pointer& _Myfirst = _My_data._Myfirst;
; 1740 :         pointer& _Mylast  = _My_data._Mylast;
; 1741 :         pointer& _Myend   = _My_data._Myend;
; 1742 : 
; 1743 :         _My_data._Orphan_all();
; 1744 : 
; 1745 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	mov	rbp, r8
	mov	rdi, rdx
	test	rcx, rcx
	je	SHORT $LN8@Change_arr

; 1746 :             _Destroy(_Myfirst, _Mylast);
; 1747 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN18@Change_arr

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN15@Change_arr

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN18@Change_arr:

; 264  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN8@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1751 :         _Mylast  = _Newvec + _Newsize;

	lea	rax, QWORD PTR [rdi+rbp*8]
	mov	QWORD PTR [rbx], rdi

; 1753 :     }

	mov	rbp, QWORD PTR [rsp+56]
	mov	QWORD PTR [rbx+8], rax
	lea	rax, QWORD PTR [rdi+rsi*8]
	mov	rsi, QWORD PTR [rsp+64]
	mov	QWORD PTR [rbx+16], rax
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN15@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN22@Change_arr:
?_Change_array@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@AEAAXQEAPEAVModDelay@@_K1@Z ENDP ; std::vector<ModDelay *,std::allocator<ModDelay *> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Calculate_growth@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Newsize$ = 16
?_Calculate_growth@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@AEBA_K_K@Z PROC ; std::vector<ModDelay *,std::allocator<ModDelay *> >::_Calculate_growth, COMDAT

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	r8, QWORD PTR [rcx+16]

; 1684 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1685 :         const size_type _Oldcapacity = capacity();
; 1686 :         const auto _Max              = max_size();
; 1687 : 
; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sub	r8, QWORD PTR [rcx]

; 1684 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1685 :         const size_type _Oldcapacity = capacity();
; 1686 :         const auto _Max              = max_size();
; 1687 : 
; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rcx, rax

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	r8, 3

; 1684 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1685 :         const size_type _Oldcapacity = capacity();
; 1686 :         const auto _Max              = max_size();
; 1687 : 
; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	r9, r8
	shr	r9, 1
	sub	rcx, r9
	cmp	r8, rcx
	ja	SHORT $LN3@Calculate_

; 1689 :             return _Max; // geometric growth would overflow
; 1690 :         }
; 1691 : 
; 1692 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rax, QWORD PTR [r9+r8]

; 1693 : 
; 1694 :         if (_Geometric < _Newsize) {

	cmp	rax, rdx
	cmovb	rax, rdx
$LN3@Calculate_:

; 1695 :             return _Newsize; // geometric growth would be insufficient
; 1696 :         }
; 1697 : 
; 1698 :         return _Geometric; // geometric growth is sufficient
; 1699 :     }

	ret	0
?_Calculate_growth@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@AEBA_K_K@Z ENDP ; std::vector<ModDelay *,std::allocator<ModDelay *> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@AEAAXPEAPEAVModDelay@@00@Z
_TEXT	SEGMENT
this$dead$ = 8
_First$ = 16
_Last$ = 24
_Dest$ = 32
?_Umove_if_noexcept@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@AEAAXPEAPEAVModDelay@@00@Z PROC ; std::vector<ModDelay *,std::allocator<ModDelay *> >::_Umove_if_noexcept, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, rdx

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, r9
	rex_jmp	QWORD PTR __imp_memmove
?_Umove_if_noexcept@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@AEAAXPEAPEAVModDelay@@00@Z ENDP ; std::vector<ModDelay *,std::allocator<ModDelay *> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@AEAAPEAPEAVModDelay@@PEAPEAV3@00@Z
_TEXT	SEGMENT
this$dead$ = 48
_First$ = 56
_Last$ = 64
_Dest$ = 72
?_Umove@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@AEAAPEAPEAVModDelay@@PEAPEAV3@00@Z PROC ; std::vector<ModDelay *,std::allocator<ModDelay *> >::_Umove, COMDAT

; 1657 :     _CONSTEXPR20_CONTAINER pointer _Umove(pointer _First, pointer _Last, pointer _Dest) {

$LN18:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, r8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, r9
	sub	rbx, rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1657 :     _CONSTEXPR20_CONTAINER pointer _Umove(pointer _First, pointer _Last, pointer _Dest) {

	mov	rdi, r9
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbx
	call	QWORD PTR __imp_memmove
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1706 :             return _Dest + (_ULast - _UFirst);

	sar	rbx, 3
	lea	rax, QWORD PTR [rdi+rbx*8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1660 :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?_Umove@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@AEAAPEAPEAVModDelay@@PEAPEAV3@00@Z ENDP ; std::vector<ModDelay *,std::allocator<ModDelay *> >::_Umove
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEBA_KXZ PROC ; std::vector<ModDelay *,std::allocator<ModDelay *> >::max_size, COMDAT

; 1553 :         return (_STD min)(

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 1554 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1555 :     }

	ret	0
?max_size@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<ModDelay *,std::allocator<ModDelay *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?allocate@?$allocator@PEAVModDelay@@@std@@QEAAPEAPEAVModDelay@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@PEAVModDelay@@@std@@QEAAPEAPEAVModDelay@@_K@Z PROC ; std::allocator<ModDelay *>::allocate, COMDAT

; 838  :     _NODISCARD _CONSTEXPR20_DYNALLOC __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN30:
	sub	rsp, 40					; 00000028H

; 64   :         if (_Count > _Max_possible) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	cmp	rdx, rax
	ja	SHORT $LN27@allocate

; 65   :             _Throw_bad_array_new_length(); // multiply overflow
; 66   :         }
; 67   :     }
; 68   : 
; 69   :     return _Count * _Ty_size;

	lea	rcx, QWORD PTR [rdx*8]

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN8@allocate

; 136  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 137  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN27@allocate

; 85   :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 142  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN17@allocate

; 143  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rax, QWORD PTR [rax+39]
	and	rax, -32				; ffffffffffffffe0H

; 144  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx
$LN6@allocate:

; 839  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 840  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN17@allocate:

; 142  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN8@allocate:

; 243  :     if (_Bytes != 0) {

	xor	eax, eax
	test	rcx, rcx
	je	SHORT $LN6@allocate

; 839  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 840  :     }

	add	rsp, 40					; 00000028H

; 85   :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN27@allocate:

; 138  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN28@allocate:
?allocate@?$allocator@PEAVModDelay@@@std@@QEAAPEAPEAVModDelay@@_K@Z ENDP ; std::allocator<ModDelay *>::allocate
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$allocator@PEAVModDelay@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@PEAVModDelay@@@std@@QEAA@XZ PROC		; std::allocator<ModDelay *>::allocator<ModDelay *>, COMDAT

; 825  :     constexpr allocator() noexcept {}

	mov	rax, rcx
	ret	0
??0?$allocator@PEAVModDelay@@@std@@QEAA@XZ ENDP		; std::allocator<ModDelay *>::allocator<ModDelay *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<int> >::_Vector_val<std::_Simple_types<int> >, COMDAT

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	rax, rcx
	ret	0
??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<int> >::_Vector_val<std::_Simple_types<int> >
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ PROC ; std::vector<int,std::allocator<int> >::_Xlength, COMDAT

; 1773 :     [[noreturn]] static void _Xlength() {

$LN4:
	sub	rsp, 40					; 00000028H

; 1774 :         _Xlength_error("vector too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Xlength:
?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ ENDP ; std::vector<int,std::allocator<int> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Change_array@?$vector@HV?$allocator@H@std@@@std@@AEAAXQEAH_K1@Z
_TEXT	SEGMENT
this$ = 48
_Newvec$ = 56
_Newsize$ = 64
_Newcapacity$ = 72
?_Change_array@?$vector@HV?$allocator@H@std@@@std@@AEAAXQEAH_K1@Z PROC ; std::vector<int,std::allocator<int> >::_Change_array, COMDAT

; 1736 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

$LN25:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	rsi, r9

; 1737 :         // orphan all iterators, discard old array, acquire new array
; 1738 :         auto& _My_data    = _Mypair._Myval2;
; 1739 :         pointer& _Myfirst = _My_data._Myfirst;
; 1740 :         pointer& _Mylast  = _My_data._Mylast;
; 1741 :         pointer& _Myend   = _My_data._Myend;
; 1742 : 
; 1743 :         _My_data._Orphan_all();
; 1744 : 
; 1745 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	mov	rbp, r8
	mov	rdi, rdx
	test	rcx, rcx
	je	SHORT $LN8@Change_arr

; 1746 :             _Destroy(_Myfirst, _Mylast);
; 1747 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -4

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN18@Change_arr

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN15@Change_arr

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN18@Change_arr:

; 264  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN8@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1751 :         _Mylast  = _Newvec + _Newsize;

	lea	rax, QWORD PTR [rdi+rbp*4]
	mov	QWORD PTR [rbx], rdi

; 1753 :     }

	mov	rbp, QWORD PTR [rsp+56]
	mov	QWORD PTR [rbx+8], rax
	lea	rax, QWORD PTR [rdi+rsi*4]
	mov	rsi, QWORD PTR [rsp+64]
	mov	QWORD PTR [rbx+16], rax
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN15@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN22@Change_arr:
?_Change_array@?$vector@HV?$allocator@H@std@@@std@@AEAAXQEAH_K1@Z ENDP ; std::vector<int,std::allocator<int> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Calculate_growth@?$vector@HV?$allocator@H@std@@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Newsize$ = 16
?_Calculate_growth@?$vector@HV?$allocator@H@std@@@std@@AEBA_K_K@Z PROC ; std::vector<int,std::allocator<int> >::_Calculate_growth, COMDAT

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	r8, QWORD PTR [rcx+16]

; 1684 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1685 :         const size_type _Oldcapacity = capacity();
; 1686 :         const auto _Max              = max_size();
; 1687 : 
; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, 4611686018427387903		; 3fffffffffffffffH

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sub	r8, QWORD PTR [rcx]

; 1684 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1685 :         const size_type _Oldcapacity = capacity();
; 1686 :         const auto _Max              = max_size();
; 1687 : 
; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rcx, rax

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	r8, 2

; 1684 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1685 :         const size_type _Oldcapacity = capacity();
; 1686 :         const auto _Max              = max_size();
; 1687 : 
; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	r9, r8
	shr	r9, 1
	sub	rcx, r9
	cmp	r8, rcx
	ja	SHORT $LN3@Calculate_

; 1689 :             return _Max; // geometric growth would overflow
; 1690 :         }
; 1691 : 
; 1692 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rax, QWORD PTR [r9+r8]

; 1693 : 
; 1694 :         if (_Geometric < _Newsize) {

	cmp	rax, rdx
	cmovb	rax, rdx
$LN3@Calculate_:

; 1695 :             return _Newsize; // geometric growth would be insufficient
; 1696 :         }
; 1697 : 
; 1698 :         return _Geometric; // geometric growth is sufficient
; 1699 :     }

	ret	0
?_Calculate_growth@?$vector@HV?$allocator@H@std@@@std@@AEBA_K_K@Z ENDP ; std::vector<int,std::allocator<int> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@HV?$allocator@H@std@@@std@@AEAAXPEAH00@Z
_TEXT	SEGMENT
this$dead$ = 8
_First$ = 16
_Last$ = 24
_Dest$ = 32
?_Umove_if_noexcept@?$vector@HV?$allocator@H@std@@@std@@AEAAXPEAH00@Z PROC ; std::vector<int,std::allocator<int> >::_Umove_if_noexcept, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, rdx

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, r9
	rex_jmp	QWORD PTR __imp_memmove
?_Umove_if_noexcept@?$vector@HV?$allocator@H@std@@@std@@AEAAXPEAH00@Z ENDP ; std::vector<int,std::allocator<int> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove@?$vector@HV?$allocator@H@std@@@std@@AEAAPEAHPEAH00@Z
_TEXT	SEGMENT
this$dead$ = 48
_First$ = 56
_Last$ = 64
_Dest$ = 72
?_Umove@?$vector@HV?$allocator@H@std@@@std@@AEAAPEAHPEAH00@Z PROC ; std::vector<int,std::allocator<int> >::_Umove, COMDAT

; 1657 :     _CONSTEXPR20_CONTAINER pointer _Umove(pointer _First, pointer _Last, pointer _Dest) {

$LN18:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, r8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, r9
	sub	rbx, rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1657 :     _CONSTEXPR20_CONTAINER pointer _Umove(pointer _First, pointer _Last, pointer _Dest) {

	mov	rdi, r9
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbx
	call	QWORD PTR __imp_memmove
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1706 :             return _Dest + (_ULast - _UFirst);

	sar	rbx, 2
	lea	rax, QWORD PTR [rdi+rbx*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1660 :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?_Umove@?$vector@HV?$allocator@H@std@@@std@@AEAAPEAHPEAH00@Z ENDP ; std::vector<int,std::allocator<int> >::_Umove
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@HV?$allocator@H@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$vector@HV?$allocator@H@std@@@std@@QEBA_KXZ PROC ; std::vector<int,std::allocator<int> >::max_size, COMDAT

; 1553 :         return (_STD min)(

	mov	rax, 4611686018427387903		; 3fffffffffffffffH

; 1554 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1555 :     }

	ret	0
?max_size@?$vector@HV?$allocator@H@std@@@std@@QEBA_KXZ ENDP ; std::vector<int,std::allocator<int> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?allocate@?$allocator@H@std@@QEAAPEAH_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@H@std@@QEAAPEAH_K@Z PROC		; std::allocator<int>::allocate, COMDAT

; 838  :     _NODISCARD _CONSTEXPR20_DYNALLOC __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN30:
	sub	rsp, 40					; 00000028H

; 64   :         if (_Count > _Max_possible) {

	mov	rax, 4611686018427387903		; 3fffffffffffffffH
	cmp	rdx, rax
	ja	SHORT $LN27@allocate

; 65   :             _Throw_bad_array_new_length(); // multiply overflow
; 66   :         }
; 67   :     }
; 68   : 
; 69   :     return _Count * _Ty_size;

	lea	rcx, QWORD PTR [rdx*4]

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN8@allocate

; 136  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 137  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN27@allocate

; 85   :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 142  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN17@allocate

; 143  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rax, QWORD PTR [rax+39]
	and	rax, -32				; ffffffffffffffe0H

; 144  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx
$LN6@allocate:

; 839  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 840  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN17@allocate:

; 142  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN8@allocate:

; 243  :     if (_Bytes != 0) {

	xor	eax, eax
	test	rcx, rcx
	je	SHORT $LN6@allocate

; 839  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 840  :     }

	add	rsp, 40					; 00000028H

; 85   :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN27@allocate:

; 138  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN28@allocate:
?allocate@?$allocator@H@std@@QEAAPEAH_K@Z ENDP		; std::allocator<int>::allocate
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$allocator@H@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@H@std@@QEAA@XZ PROC			; std::allocator<int>::allocator<int>, COMDAT

; 825  :     constexpr allocator() noexcept {}

	mov	rax, rcx
	ret	0
??0?$allocator@H@std@@QEAA@XZ ENDP			; std::allocator<int>::allocator<int>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PEAVDelay@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@PEAVDelay@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<Delay *> >::_Vector_val<std::_Simple_types<Delay *> >, COMDAT

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	rax, rcx
	ret	0
??0?$_Vector_val@U?$_Simple_types@PEAVDelay@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<Delay *> >::_Vector_val<std::_Simple_types<Delay *> >
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@CAXXZ PROC ; std::vector<Delay *,std::allocator<Delay *> >::_Xlength, COMDAT

; 1773 :     [[noreturn]] static void _Xlength() {

$LN4:
	sub	rsp, 40					; 00000028H

; 1774 :         _Xlength_error("vector too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Xlength:
?_Xlength@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@CAXXZ ENDP ; std::vector<Delay *,std::allocator<Delay *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Change_array@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@AEAAXQEAPEAVDelay@@_K1@Z
_TEXT	SEGMENT
this$ = 48
_Newvec$ = 56
_Newsize$ = 64
_Newcapacity$ = 72
?_Change_array@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@AEAAXQEAPEAVDelay@@_K1@Z PROC ; std::vector<Delay *,std::allocator<Delay *> >::_Change_array, COMDAT

; 1736 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

$LN25:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	rsi, r9

; 1737 :         // orphan all iterators, discard old array, acquire new array
; 1738 :         auto& _My_data    = _Mypair._Myval2;
; 1739 :         pointer& _Myfirst = _My_data._Myfirst;
; 1740 :         pointer& _Mylast  = _My_data._Mylast;
; 1741 :         pointer& _Myend   = _My_data._Myend;
; 1742 : 
; 1743 :         _My_data._Orphan_all();
; 1744 : 
; 1745 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	mov	rbp, r8
	mov	rdi, rdx
	test	rcx, rcx
	je	SHORT $LN8@Change_arr

; 1746 :             _Destroy(_Myfirst, _Mylast);
; 1747 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN18@Change_arr

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN15@Change_arr

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN18@Change_arr:

; 264  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN8@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1751 :         _Mylast  = _Newvec + _Newsize;

	lea	rax, QWORD PTR [rdi+rbp*8]
	mov	QWORD PTR [rbx], rdi

; 1753 :     }

	mov	rbp, QWORD PTR [rsp+56]
	mov	QWORD PTR [rbx+8], rax
	lea	rax, QWORD PTR [rdi+rsi*8]
	mov	rsi, QWORD PTR [rsp+64]
	mov	QWORD PTR [rbx+16], rax
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN15@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN22@Change_arr:
?_Change_array@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@AEAAXQEAPEAVDelay@@_K1@Z ENDP ; std::vector<Delay *,std::allocator<Delay *> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Calculate_growth@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Newsize$ = 16
?_Calculate_growth@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@AEBA_K_K@Z PROC ; std::vector<Delay *,std::allocator<Delay *> >::_Calculate_growth, COMDAT

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	r8, QWORD PTR [rcx+16]

; 1684 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1685 :         const size_type _Oldcapacity = capacity();
; 1686 :         const auto _Max              = max_size();
; 1687 : 
; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sub	r8, QWORD PTR [rcx]

; 1684 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1685 :         const size_type _Oldcapacity = capacity();
; 1686 :         const auto _Max              = max_size();
; 1687 : 
; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rcx, rax

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	r8, 3

; 1684 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1685 :         const size_type _Oldcapacity = capacity();
; 1686 :         const auto _Max              = max_size();
; 1687 : 
; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	r9, r8
	shr	r9, 1
	sub	rcx, r9
	cmp	r8, rcx
	ja	SHORT $LN3@Calculate_

; 1689 :             return _Max; // geometric growth would overflow
; 1690 :         }
; 1691 : 
; 1692 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rax, QWORD PTR [r9+r8]

; 1693 : 
; 1694 :         if (_Geometric < _Newsize) {

	cmp	rax, rdx
	cmovb	rax, rdx
$LN3@Calculate_:

; 1695 :             return _Newsize; // geometric growth would be insufficient
; 1696 :         }
; 1697 : 
; 1698 :         return _Geometric; // geometric growth is sufficient
; 1699 :     }

	ret	0
?_Calculate_growth@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@AEBA_K_K@Z ENDP ; std::vector<Delay *,std::allocator<Delay *> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@AEAAXPEAPEAVDelay@@00@Z
_TEXT	SEGMENT
this$dead$ = 8
_First$ = 16
_Last$ = 24
_Dest$ = 32
?_Umove_if_noexcept@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@AEAAXPEAPEAVDelay@@00@Z PROC ; std::vector<Delay *,std::allocator<Delay *> >::_Umove_if_noexcept, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, rdx

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, r9
	rex_jmp	QWORD PTR __imp_memmove
?_Umove_if_noexcept@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@AEAAXPEAPEAVDelay@@00@Z ENDP ; std::vector<Delay *,std::allocator<Delay *> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@AEAAPEAPEAVDelay@@PEAPEAV3@00@Z
_TEXT	SEGMENT
this$dead$ = 48
_First$ = 56
_Last$ = 64
_Dest$ = 72
?_Umove@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@AEAAPEAPEAVDelay@@PEAPEAV3@00@Z PROC ; std::vector<Delay *,std::allocator<Delay *> >::_Umove, COMDAT

; 1657 :     _CONSTEXPR20_CONTAINER pointer _Umove(pointer _First, pointer _Last, pointer _Dest) {

$LN18:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, r8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, r9
	sub	rbx, rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1657 :     _CONSTEXPR20_CONTAINER pointer _Umove(pointer _First, pointer _Last, pointer _Dest) {

	mov	rdi, r9
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbx
	call	QWORD PTR __imp_memmove
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1706 :             return _Dest + (_ULast - _UFirst);

	sar	rbx, 3
	lea	rax, QWORD PTR [rdi+rbx*8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1660 :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?_Umove@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@AEAAPEAPEAVDelay@@PEAPEAV3@00@Z ENDP ; std::vector<Delay *,std::allocator<Delay *> >::_Umove
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@QEBA_KXZ PROC ; std::vector<Delay *,std::allocator<Delay *> >::max_size, COMDAT

; 1553 :         return (_STD min)(

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 1554 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1555 :     }

	ret	0
?max_size@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<Delay *,std::allocator<Delay *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?allocate@?$allocator@PEAVDelay@@@std@@QEAAPEAPEAVDelay@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@PEAVDelay@@@std@@QEAAPEAPEAVDelay@@_K@Z PROC ; std::allocator<Delay *>::allocate, COMDAT

; 838  :     _NODISCARD _CONSTEXPR20_DYNALLOC __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN30:
	sub	rsp, 40					; 00000028H

; 64   :         if (_Count > _Max_possible) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	cmp	rdx, rax
	ja	SHORT $LN27@allocate

; 65   :             _Throw_bad_array_new_length(); // multiply overflow
; 66   :         }
; 67   :     }
; 68   : 
; 69   :     return _Count * _Ty_size;

	lea	rcx, QWORD PTR [rdx*8]

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN8@allocate

; 136  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 137  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN27@allocate

; 85   :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 142  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN17@allocate

; 143  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rax, QWORD PTR [rax+39]
	and	rax, -32				; ffffffffffffffe0H

; 144  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx
$LN6@allocate:

; 839  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 840  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN17@allocate:

; 142  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN8@allocate:

; 243  :     if (_Bytes != 0) {

	xor	eax, eax
	test	rcx, rcx
	je	SHORT $LN6@allocate

; 839  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 840  :     }

	add	rsp, 40					; 00000028H

; 85   :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN27@allocate:

; 138  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN28@allocate:
?allocate@?$allocator@PEAVDelay@@@std@@QEAAPEAPEAVDelay@@_K@Z ENDP ; std::allocator<Delay *>::allocate
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$allocator@PEAVDelay@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@PEAVDelay@@@std@@QEAA@XZ PROC		; std::allocator<Delay *>::allocator<Delay *>, COMDAT

; 825  :     constexpr allocator() noexcept {}

	mov	rax, rcx
	ret	0
??0?$allocator@PEAVDelay@@@std@@QEAA@XZ ENDP		; std::allocator<Delay *>::allocator<Delay *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@M@std@@@std@@QEAA@PEAM00@Z
_TEXT	SEGMENT
this$ = 8
_First$ = 16
_Last$ = 24
_End$ = 32
??0?$_Vector_val@U?$_Simple_types@M@std@@@std@@QEAA@PEAM00@Z PROC ; std::_Vector_val<std::_Simple_types<float> >::_Vector_val<std::_Simple_types<float> >, COMDAT

; 404  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9
	ret	0
??0?$_Vector_val@U?$_Simple_types@M@std@@@std@@QEAA@PEAM00@Z ENDP ; std::_Vector_val<std::_Simple_types<float> >::_Vector_val<std::_Simple_types<float> >
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Buy_nonzero@?$vector@MV?$allocator@M@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newcapacity$ = 56
?_Buy_nonzero@?$vector@MV?$allocator@M@std@@@std@@AEAAX_K@Z PROC ; std::vector<float,std::allocator<float> >::_Buy_nonzero, COMDAT

; 1717 :     _CONSTEXPR20_CONTAINER void _Buy_nonzero(const size_type _Newcapacity) {

$LN38:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1718 :         // allocate array with _Newcapacity elements
; 1719 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1720 :         auto& _My_data    = _Mypair._Myval2;
; 1721 :         pointer& _Myfirst = _My_data._Myfirst;
; 1722 :         pointer& _Mylast  = _My_data._Mylast;
; 1723 :         pointer& _Myend   = _My_data._Myend;
; 1724 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 1725 :         _STL_INTERNAL_CHECK(0 < _Newcapacity);
; 1726 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 1727 : 
; 1728 :         if (_Newcapacity > max_size()) {

	mov	rax, 4611686018427387903		; 3fffffffffffffffH
	mov	rdi, rcx
	cmp	rdx, rax
	ja	SHORT $LN36@Buy_nonzer
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 69   :     return _Count * _Ty_size;

	lea	rbx, QWORD PTR [rdx*4]

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rbx, 4096				; 00001000H
	jb	SHORT $LN13@Buy_nonzer

; 136  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rbx+39]

; 137  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rbx
	jbe	SHORT $LN37@Buy_nonzer

; 85   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 142  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN22@Buy_nonzer

; 143  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rax, QWORD PTR [rax+39]
	and	rax, -32				; ffffffffffffffe0H

; 144  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN12@Buy_nonzer
$LN22@Buy_nonzer:

; 142  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN13@Buy_nonzer:

; 243  :     if (_Bytes != 0) {

	xor	eax, eax
	test	rbx, rbx
	je	SHORT $LN12@Buy_nonzer

; 85   :         return ::operator new(_Bytes);

	mov	rcx, rbx
	call	??2@YAPEAX_K@Z				; operator new
$LN12@Buy_nonzer:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1712 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [rdi], rax

; 1713 :         _Mylast            = _Newvec;

	mov	QWORD PTR [rdi+8], rax

; 1714 :         _Myend             = _Newvec + _Newcapacity;

	add	rax, rbx

; 1733 :     }

	mov	rbx, QWORD PTR [rsp+48]

; 1714 :         _Myend             = _Newvec + _Newcapacity;

	mov	QWORD PTR [rdi+16], rax

; 1733 :     }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN36@Buy_nonzer:

; 1729 :             _Xlength();

	call	?_Xlength@?$vector@MV?$allocator@M@std@@@std@@CAXXZ ; std::vector<float,std::allocator<float> >::_Xlength
	int	3
$LN37@Buy_nonzer:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 138  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN34@Buy_nonzer:
?_Buy_nonzero@?$vector@MV?$allocator@M@std@@@std@@AEAAX_K@Z ENDP ; std::vector<float,std::allocator<float> >::_Buy_nonzero
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Ufill@?$vector@MV?$allocator@M@std@@@std@@AEAAPEAMPEAM_KU_Value_init_tag@2@@Z
_TEXT	SEGMENT
this$dead$ = 48
_Dest$ = 56
_Count$ = 64
__formal$dead$ = 72
?_Ufill@?$vector@MV?$allocator@M@std@@@std@@AEAAPEAMPEAM_KU_Value_init_tag@2@@Z PROC ; std::vector<float,std::allocator<float> >::_Ufill, COMDAT

; 1646 :     _CONSTEXPR20_CONTAINER pointer _Ufill(pointer _Dest, const size_type _Count, _Value_init_tag) {

$LN20:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1804 :             _Zero_range(_PFirst, _PFirst + _Count);

	lea	rbx, QWORD PTR [r8*4]

; 1789 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	r8, rbx
	mov	rcx, rdi
	xor	edx, edx
	call	QWORD PTR __imp_memset

; 1805 :             return _First + _Count;

	lea	rax, QWORD PTR [rbx+rdi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1649 :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?_Ufill@?$vector@MV?$allocator@M@std@@@std@@AEAAPEAMPEAM_KU_Value_init_tag@2@@Z ENDP ; std::vector<float,std::allocator<float> >::_Ufill
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@AEBAAEBV?$allocator@PEAVHighPassFilter@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@AEBAAEBV?$allocator@PEAVHighPassFilter@@@2@XZ PROC ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::_Getal, COMDAT

; 1822 :         return _Mypair._Get_first();

	mov	rax, rcx

; 1823 :     }

	ret	0
?_Getal@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@AEBAAEBV?$allocator@PEAVHighPassFilter@@@2@XZ ENDP ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@AEAAXPEAPEAVHighPassFilter@@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
this$dead$ = 8
_First$ = 16
_Last$ = 24
_Dest$ = 32
__formal$dead$ = 40
?_Umove_if_noexcept1@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@AEAAXPEAPEAVHighPassFilter@@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::_Umove_if_noexcept1, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, rdx

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, r9
	rex_jmp	QWORD PTR __imp_memmove
?_Umove_if_noexcept1@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@AEAAXPEAPEAVHighPassFilter@@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?capacity@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEBA_KXZ PROC ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::capacity, COMDAT

; 1558 :         auto& _My_data = _Mypair._Myval2;
; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 3

; 1560 :     }

	ret	0
?capacity@?$vector@PEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<HighPassFilter *,std::allocator<HighPassFilter *> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@PEAVHighPassFilter@@@std@@@std@@SA_KAEBV?$allocator@PEAVHighPassFilter@@@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@PEAVHighPassFilter@@@std@@@std@@SA_KAEBV?$allocator@PEAVHighPassFilter@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<HighPassFilter *> >::max_size, COMDAT

; 728  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 729  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@PEAVHighPassFilter@@@std@@@std@@SA_KAEBV?$allocator@PEAVHighPassFilter@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<HighPassFilter *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@AEBAAEBV?$allocator@PEAVModulation@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@AEBAAEBV?$allocator@PEAVModulation@@@2@XZ PROC ; std::vector<Modulation *,std::allocator<Modulation *> >::_Getal, COMDAT

; 1822 :         return _Mypair._Get_first();

	mov	rax, rcx

; 1823 :     }

	ret	0
?_Getal@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@AEBAAEBV?$allocator@PEAVModulation@@@2@XZ ENDP ; std::vector<Modulation *,std::allocator<Modulation *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@AEAAXPEAPEAVModulation@@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
this$dead$ = 8
_First$ = 16
_Last$ = 24
_Dest$ = 32
__formal$dead$ = 40
?_Umove_if_noexcept1@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@AEAAXPEAPEAVModulation@@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<Modulation *,std::allocator<Modulation *> >::_Umove_if_noexcept1, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, rdx

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, r9
	rex_jmp	QWORD PTR __imp_memmove
?_Umove_if_noexcept1@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@AEAAXPEAPEAVModulation@@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<Modulation *,std::allocator<Modulation *> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?capacity@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@QEBA_KXZ PROC ; std::vector<Modulation *,std::allocator<Modulation *> >::capacity, COMDAT

; 1558 :         auto& _My_data = _Mypair._Myval2;
; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 3

; 1560 :     }

	ret	0
?capacity@?$vector@PEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<Modulation *,std::allocator<Modulation *> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@PEAVModulation@@@std@@@std@@SA_KAEBV?$allocator@PEAVModulation@@@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@PEAVModulation@@@std@@@std@@SA_KAEBV?$allocator@PEAVModulation@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<Modulation *> >::max_size, COMDAT

; 728  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 729  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@PEAVModulation@@@std@@@std@@SA_KAEBV?$allocator@PEAVModulation@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<Modulation *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@AEBAAEBV?$allocator@PEAVLowPassFilter@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@AEBAAEBV?$allocator@PEAVLowPassFilter@@@2@XZ PROC ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::_Getal, COMDAT

; 1822 :         return _Mypair._Get_first();

	mov	rax, rcx

; 1823 :     }

	ret	0
?_Getal@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@AEBAAEBV?$allocator@PEAVLowPassFilter@@@2@XZ ENDP ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@AEAAXPEAPEAVLowPassFilter@@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
this$dead$ = 8
_First$ = 16
_Last$ = 24
_Dest$ = 32
__formal$dead$ = 40
?_Umove_if_noexcept1@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@AEAAXPEAPEAVLowPassFilter@@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::_Umove_if_noexcept1, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, rdx

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, r9
	rex_jmp	QWORD PTR __imp_memmove
?_Umove_if_noexcept1@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@AEAAXPEAPEAVLowPassFilter@@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?capacity@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEBA_KXZ PROC ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::capacity, COMDAT

; 1558 :         auto& _My_data = _Mypair._Myval2;
; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 3

; 1560 :     }

	ret	0
?capacity@?$vector@PEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<LowPassFilter *,std::allocator<LowPassFilter *> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@PEAVLowPassFilter@@@std@@@std@@SA_KAEBV?$allocator@PEAVLowPassFilter@@@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@PEAVLowPassFilter@@@std@@@std@@SA_KAEBV?$allocator@PEAVLowPassFilter@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<LowPassFilter *> >::max_size, COMDAT

; 728  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 729  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@PEAVLowPassFilter@@@std@@@std@@SA_KAEBV?$allocator@PEAVLowPassFilter@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<LowPassFilter *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@AEBAAEBV?$allocator@PEAVModMultiChannelDiffuser@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@AEBAAEBV?$allocator@PEAVModMultiChannelDiffuser@@@2@XZ PROC ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::_Getal, COMDAT

; 1822 :         return _Mypair._Get_first();

	mov	rax, rcx

; 1823 :     }

	ret	0
?_Getal@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@AEBAAEBV?$allocator@PEAVModMultiChannelDiffuser@@@2@XZ ENDP ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@AEAAXPEAPEAVModMultiChannelDiffuser@@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
this$dead$ = 8
_First$ = 16
_Last$ = 24
_Dest$ = 32
__formal$dead$ = 40
?_Umove_if_noexcept1@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@AEAAXPEAPEAVModMultiChannelDiffuser@@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::_Umove_if_noexcept1, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, rdx

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, r9
	rex_jmp	QWORD PTR __imp_memmove
?_Umove_if_noexcept1@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@AEAAXPEAPEAVModMultiChannelDiffuser@@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?capacity@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEBA_KXZ PROC ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::capacity, COMDAT

; 1558 :         auto& _My_data = _Mypair._Myval2;
; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 3

; 1560 :     }

	ret	0
?capacity@?$vector@PEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<ModMultiChannelDiffuser *,std::allocator<ModMultiChannelDiffuser *> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@SA_KAEBV?$allocator@PEAVModMultiChannelDiffuser@@@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@SA_KAEBV?$allocator@PEAVModMultiChannelDiffuser@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<ModMultiChannelDiffuser *> >::max_size, COMDAT

; 728  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 729  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@SA_KAEBV?$allocator@PEAVModMultiChannelDiffuser@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<ModMultiChannelDiffuser *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@AEBAAEBV?$allocator@PEAVMultiChannelDiffuser@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@AEBAAEBV?$allocator@PEAVMultiChannelDiffuser@@@2@XZ PROC ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::_Getal, COMDAT

; 1822 :         return _Mypair._Get_first();

	mov	rax, rcx

; 1823 :     }

	ret	0
?_Getal@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@AEBAAEBV?$allocator@PEAVMultiChannelDiffuser@@@2@XZ ENDP ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@AEAAXPEAPEAVMultiChannelDiffuser@@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
this$dead$ = 8
_First$ = 16
_Last$ = 24
_Dest$ = 32
__formal$dead$ = 40
?_Umove_if_noexcept1@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@AEAAXPEAPEAVMultiChannelDiffuser@@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::_Umove_if_noexcept1, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, rdx

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, r9
	rex_jmp	QWORD PTR __imp_memmove
?_Umove_if_noexcept1@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@AEAAXPEAPEAVMultiChannelDiffuser@@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?capacity@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEBA_KXZ PROC ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::capacity, COMDAT

; 1558 :         auto& _My_data = _Mypair._Myval2;
; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 3

; 1560 :     }

	ret	0
?capacity@?$vector@PEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<MultiChannelDiffuser *,std::allocator<MultiChannelDiffuser *> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@SA_KAEBV?$allocator@PEAVMultiChannelDiffuser@@@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@SA_KAEBV?$allocator@PEAVMultiChannelDiffuser@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<MultiChannelDiffuser *> >::max_size, COMDAT

; 728  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 729  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@SA_KAEBV?$allocator@PEAVMultiChannelDiffuser@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<MultiChannelDiffuser *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@AEBAAEBV?$allocator@PEAVModDelay@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@AEBAAEBV?$allocator@PEAVModDelay@@@2@XZ PROC ; std::vector<ModDelay *,std::allocator<ModDelay *> >::_Getal, COMDAT

; 1822 :         return _Mypair._Get_first();

	mov	rax, rcx

; 1823 :     }

	ret	0
?_Getal@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@AEBAAEBV?$allocator@PEAVModDelay@@@2@XZ ENDP ; std::vector<ModDelay *,std::allocator<ModDelay *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@AEAAXPEAPEAVModDelay@@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
this$dead$ = 8
_First$ = 16
_Last$ = 24
_Dest$ = 32
__formal$dead$ = 40
?_Umove_if_noexcept1@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@AEAAXPEAPEAVModDelay@@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<ModDelay *,std::allocator<ModDelay *> >::_Umove_if_noexcept1, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, rdx

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, r9
	rex_jmp	QWORD PTR __imp_memmove
?_Umove_if_noexcept1@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@AEAAXPEAPEAVModDelay@@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<ModDelay *,std::allocator<ModDelay *> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?capacity@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEBA_KXZ PROC ; std::vector<ModDelay *,std::allocator<ModDelay *> >::capacity, COMDAT

; 1558 :         auto& _My_data = _Mypair._Myval2;
; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 3

; 1560 :     }

	ret	0
?capacity@?$vector@PEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<ModDelay *,std::allocator<ModDelay *> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@PEAVModDelay@@@std@@@std@@SA_KAEBV?$allocator@PEAVModDelay@@@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@PEAVModDelay@@@std@@@std@@SA_KAEBV?$allocator@PEAVModDelay@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<ModDelay *> >::max_size, COMDAT

; 728  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 729  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@PEAVModDelay@@@std@@@std@@SA_KAEBV?$allocator@PEAVModDelay@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<ModDelay *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@HV?$allocator@H@std@@@std@@AEBAAEBV?$allocator@H@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@HV?$allocator@H@std@@@std@@AEBAAEBV?$allocator@H@2@XZ PROC ; std::vector<int,std::allocator<int> >::_Getal, COMDAT

; 1822 :         return _Mypair._Get_first();

	mov	rax, rcx

; 1823 :     }

	ret	0
?_Getal@?$vector@HV?$allocator@H@std@@@std@@AEBAAEBV?$allocator@H@2@XZ ENDP ; std::vector<int,std::allocator<int> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@HV?$allocator@H@std@@@std@@AEAAXPEAH00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
this$dead$ = 8
_First$ = 16
_Last$ = 24
_Dest$ = 32
__formal$dead$ = 40
?_Umove_if_noexcept1@?$vector@HV?$allocator@H@std@@@std@@AEAAXPEAH00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<int,std::allocator<int> >::_Umove_if_noexcept1, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, rdx

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, r9
	rex_jmp	QWORD PTR __imp_memmove
?_Umove_if_noexcept1@?$vector@HV?$allocator@H@std@@@std@@AEAAXPEAH00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<int,std::allocator<int> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?capacity@?$vector@HV?$allocator@H@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$vector@HV?$allocator@H@std@@@std@@QEBA_KXZ PROC ; std::vector<int,std::allocator<int> >::capacity, COMDAT

; 1558 :         auto& _My_data = _Mypair._Myval2;
; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 2

; 1560 :     }

	ret	0
?capacity@?$vector@HV?$allocator@H@std@@@std@@QEBA_KXZ ENDP ; std::vector<int,std::allocator<int> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SA_KAEBV?$allocator@H@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SA_KAEBV?$allocator@H@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<int> >::max_size, COMDAT

; 728  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 4611686018427387903		; 3fffffffffffffffH

; 729  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SA_KAEBV?$allocator@H@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<int> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@AEBAAEBV?$allocator@PEAVDelay@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@AEBAAEBV?$allocator@PEAVDelay@@@2@XZ PROC ; std::vector<Delay *,std::allocator<Delay *> >::_Getal, COMDAT

; 1822 :         return _Mypair._Get_first();

	mov	rax, rcx

; 1823 :     }

	ret	0
?_Getal@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@AEBAAEBV?$allocator@PEAVDelay@@@2@XZ ENDP ; std::vector<Delay *,std::allocator<Delay *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@AEAAXPEAPEAVDelay@@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
this$dead$ = 8
_First$ = 16
_Last$ = 24
_Dest$ = 32
__formal$dead$ = 40
?_Umove_if_noexcept1@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@AEAAXPEAPEAVDelay@@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<Delay *,std::allocator<Delay *> >::_Umove_if_noexcept1, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, rdx

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, r9
	rex_jmp	QWORD PTR __imp_memmove
?_Umove_if_noexcept1@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@AEAAXPEAPEAVDelay@@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<Delay *,std::allocator<Delay *> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?capacity@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@QEBA_KXZ PROC ; std::vector<Delay *,std::allocator<Delay *> >::capacity, COMDAT

; 1558 :         auto& _My_data = _Mypair._Myval2;
; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 3

; 1560 :     }

	ret	0
?capacity@?$vector@PEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<Delay *,std::allocator<Delay *> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@PEAVDelay@@@std@@@std@@SA_KAEBV?$allocator@PEAVDelay@@@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@PEAVDelay@@@std@@@std@@SA_KAEBV?$allocator@PEAVDelay@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<Delay *> >::max_size, COMDAT

; 728  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 729  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@PEAVDelay@@@std@@@std@@SA_KAEBV?$allocator@PEAVDelay@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<Delay *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Buy_raw@?$vector@MV?$allocator@M@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newcapacity$ = 56
?_Buy_raw@?$vector@MV?$allocator@M@std@@@std@@AEAAX_K@Z PROC ; std::vector<float,std::allocator<float> >::_Buy_raw, COMDAT

; 1701 :     _CONSTEXPR20_CONTAINER void _Buy_raw(const size_type _Newcapacity) {

$LN33:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 64   :         if (_Count > _Max_possible) {

	mov	rax, 4611686018427387903		; 3fffffffffffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1701 :     _CONSTEXPR20_CONTAINER void _Buy_raw(const size_type _Newcapacity) {

	mov	rdi, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 64   :         if (_Count > _Max_possible) {

	cmp	rdx, rax
	ja	SHORT $LN30@Buy_raw

; 65   :             _Throw_bad_array_new_length(); // multiply overflow
; 66   :         }
; 67   :     }
; 68   : 
; 69   :     return _Count * _Ty_size;

	lea	rbx, QWORD PTR [rdx*4]

; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rbx, 4096				; 00001000H
	jb	SHORT $LN10@Buy_raw

; 136  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rbx+39]

; 137  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rbx
	jbe	SHORT $LN30@Buy_raw

; 85   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 142  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN19@Buy_raw

; 143  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rax, QWORD PTR [rax+39]
	and	rax, -32				; ffffffffffffffe0H

; 144  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN9@Buy_raw
$LN19@Buy_raw:

; 142  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN10@Buy_raw:

; 243  :     if (_Bytes != 0) {

	xor	eax, eax
	test	rbx, rbx
	je	SHORT $LN9@Buy_raw

; 85   :         return ::operator new(_Bytes);

	mov	rcx, rbx
	call	??2@YAPEAX_K@Z				; operator new
$LN9@Buy_raw:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1712 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [rdi], rax

; 1713 :         _Mylast            = _Newvec;

	mov	QWORD PTR [rdi+8], rax

; 1714 :         _Myend             = _Newvec + _Newcapacity;

	add	rax, rbx

; 1715 :     }

	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [rdi+16], rax
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN30@Buy_raw:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 138  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN31@Buy_raw:
?_Buy_raw@?$vector@MV?$allocator@M@std@@@std@@AEAAX_K@Z ENDP ; std::vector<float,std::allocator<float> >::_Buy_raw
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@PEAVHighPassFilter@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVHighPassFilter@@@std@@@2@$00@std@@QEBAAEBV?$allocator@PEAVHighPassFilter@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@PEAVHighPassFilter@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVHighPassFilter@@@std@@@2@$00@std@@QEBAAEBV?$allocator@PEAVHighPassFilter@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<HighPassFilter *>,std::_Vector_val<std::_Simple_types<HighPassFilter *> >,1>::_Get_first, COMDAT

; 1382 :         return *this;

	mov	rax, rcx

; 1383 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@PEAVHighPassFilter@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVHighPassFilter@@@std@@@2@$00@std@@QEBAAEBV?$allocator@PEAVHighPassFilter@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<HighPassFilter *>,std::_Vector_val<std::_Simple_types<HighPassFilter *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@PEAVModulation@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVModulation@@@std@@@2@$00@std@@QEBAAEBV?$allocator@PEAVModulation@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@PEAVModulation@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVModulation@@@std@@@2@$00@std@@QEBAAEBV?$allocator@PEAVModulation@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<Modulation *>,std::_Vector_val<std::_Simple_types<Modulation *> >,1>::_Get_first, COMDAT

; 1382 :         return *this;

	mov	rax, rcx

; 1383 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@PEAVModulation@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVModulation@@@std@@@2@$00@std@@QEBAAEBV?$allocator@PEAVModulation@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<Modulation *>,std::_Vector_val<std::_Simple_types<Modulation *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@PEAVLowPassFilter@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVLowPassFilter@@@std@@@2@$00@std@@QEBAAEBV?$allocator@PEAVLowPassFilter@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@PEAVLowPassFilter@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVLowPassFilter@@@std@@@2@$00@std@@QEBAAEBV?$allocator@PEAVLowPassFilter@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<LowPassFilter *>,std::_Vector_val<std::_Simple_types<LowPassFilter *> >,1>::_Get_first, COMDAT

; 1382 :         return *this;

	mov	rax, rcx

; 1383 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@PEAVLowPassFilter@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVLowPassFilter@@@std@@@2@$00@std@@QEBAAEBV?$allocator@PEAVLowPassFilter@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<LowPassFilter *>,std::_Vector_val<std::_Simple_types<LowPassFilter *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVModMultiChannelDiffuser@@@std@@@2@$00@std@@QEBAAEBV?$allocator@PEAVModMultiChannelDiffuser@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVModMultiChannelDiffuser@@@std@@@2@$00@std@@QEBAAEBV?$allocator@PEAVModMultiChannelDiffuser@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<ModMultiChannelDiffuser *>,std::_Vector_val<std::_Simple_types<ModMultiChannelDiffuser *> >,1>::_Get_first, COMDAT

; 1382 :         return *this;

	mov	rax, rcx

; 1383 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVModMultiChannelDiffuser@@@std@@@2@$00@std@@QEBAAEBV?$allocator@PEAVModMultiChannelDiffuser@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<ModMultiChannelDiffuser *>,std::_Vector_val<std::_Simple_types<ModMultiChannelDiffuser *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@PEAVMultiChannelDiffuser@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVMultiChannelDiffuser@@@std@@@2@$00@std@@QEBAAEBV?$allocator@PEAVMultiChannelDiffuser@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@PEAVMultiChannelDiffuser@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVMultiChannelDiffuser@@@std@@@2@$00@std@@QEBAAEBV?$allocator@PEAVMultiChannelDiffuser@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<MultiChannelDiffuser *>,std::_Vector_val<std::_Simple_types<MultiChannelDiffuser *> >,1>::_Get_first, COMDAT

; 1382 :         return *this;

	mov	rax, rcx

; 1383 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@PEAVMultiChannelDiffuser@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVMultiChannelDiffuser@@@std@@@2@$00@std@@QEBAAEBV?$allocator@PEAVMultiChannelDiffuser@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<MultiChannelDiffuser *>,std::_Vector_val<std::_Simple_types<MultiChannelDiffuser *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@PEAVModDelay@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVModDelay@@@std@@@2@$00@std@@QEBAAEBV?$allocator@PEAVModDelay@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@PEAVModDelay@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVModDelay@@@std@@@2@$00@std@@QEBAAEBV?$allocator@PEAVModDelay@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<ModDelay *>,std::_Vector_val<std::_Simple_types<ModDelay *> >,1>::_Get_first, COMDAT

; 1382 :         return *this;

	mov	rax, rcx

; 1383 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@PEAVModDelay@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVModDelay@@@std@@@2@$00@std@@QEBAAEBV?$allocator@PEAVModDelay@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<ModDelay *>,std::_Vector_val<std::_Simple_types<ModDelay *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QEBAAEBV?$allocator@H@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QEBAAEBV?$allocator@H@2@XZ PROC ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first, COMDAT

; 1382 :         return *this;

	mov	rax, rcx

; 1383 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QEBAAEBV?$allocator@H@2@XZ ENDP ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@PEAVDelay@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVDelay@@@std@@@2@$00@std@@QEBAAEBV?$allocator@PEAVDelay@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@PEAVDelay@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVDelay@@@std@@@2@$00@std@@QEBAAEBV?$allocator@PEAVDelay@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<Delay *>,std::_Vector_val<std::_Simple_types<Delay *> >,1>::_Get_first, COMDAT

; 1382 :         return *this;

	mov	rax, rcx

; 1383 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@PEAVDelay@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVDelay@@@std@@@2@$00@std@@QEBAAEBV?$allocator@PEAVDelay@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<Delay *>,std::_Vector_val<std::_Simple_types<Delay *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Voidify_iter@PEAPEAVHighPassFilter@@@std@@YAPEAXPEAPEAVHighPassFilter@@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Voidify_iter@PEAPEAVHighPassFilter@@@std@@YAPEAXPEAPEAVHighPassFilter@@@Z PROC ; std::_Voidify_iter<HighPassFilter * *>, COMDAT

; 131  :     if constexpr (is_pointer_v<_Iter>) {
; 132  :         return const_cast<void*>(static_cast<const volatile void*>(_It));

	mov	rax, rcx

; 133  :     } else {
; 134  :         return const_cast<void*>(static_cast<const volatile void*>(_STD addressof(*_It)));
; 135  :     }
; 136  : }

	ret	0
??$_Voidify_iter@PEAPEAVHighPassFilter@@@std@@YAPEAXPEAPEAVHighPassFilter@@@Z ENDP ; std::_Voidify_iter<HighPassFilter * *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Voidify_iter@PEAPEAVModulation@@@std@@YAPEAXPEAPEAVModulation@@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Voidify_iter@PEAPEAVModulation@@@std@@YAPEAXPEAPEAVModulation@@@Z PROC ; std::_Voidify_iter<Modulation * *>, COMDAT

; 131  :     if constexpr (is_pointer_v<_Iter>) {
; 132  :         return const_cast<void*>(static_cast<const volatile void*>(_It));

	mov	rax, rcx

; 133  :     } else {
; 134  :         return const_cast<void*>(static_cast<const volatile void*>(_STD addressof(*_It)));
; 135  :     }
; 136  : }

	ret	0
??$_Voidify_iter@PEAPEAVModulation@@@std@@YAPEAXPEAPEAVModulation@@@Z ENDP ; std::_Voidify_iter<Modulation * *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Voidify_iter@PEAPEAVLowPassFilter@@@std@@YAPEAXPEAPEAVLowPassFilter@@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Voidify_iter@PEAPEAVLowPassFilter@@@std@@YAPEAXPEAPEAVLowPassFilter@@@Z PROC ; std::_Voidify_iter<LowPassFilter * *>, COMDAT

; 131  :     if constexpr (is_pointer_v<_Iter>) {
; 132  :         return const_cast<void*>(static_cast<const volatile void*>(_It));

	mov	rax, rcx

; 133  :     } else {
; 134  :         return const_cast<void*>(static_cast<const volatile void*>(_STD addressof(*_It)));
; 135  :     }
; 136  : }

	ret	0
??$_Voidify_iter@PEAPEAVLowPassFilter@@@std@@YAPEAXPEAPEAVLowPassFilter@@@Z ENDP ; std::_Voidify_iter<LowPassFilter * *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Voidify_iter@PEAPEAVModMultiChannelDiffuser@@@std@@YAPEAXPEAPEAVModMultiChannelDiffuser@@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Voidify_iter@PEAPEAVModMultiChannelDiffuser@@@std@@YAPEAXPEAPEAVModMultiChannelDiffuser@@@Z PROC ; std::_Voidify_iter<ModMultiChannelDiffuser * *>, COMDAT

; 131  :     if constexpr (is_pointer_v<_Iter>) {
; 132  :         return const_cast<void*>(static_cast<const volatile void*>(_It));

	mov	rax, rcx

; 133  :     } else {
; 134  :         return const_cast<void*>(static_cast<const volatile void*>(_STD addressof(*_It)));
; 135  :     }
; 136  : }

	ret	0
??$_Voidify_iter@PEAPEAVModMultiChannelDiffuser@@@std@@YAPEAXPEAPEAVModMultiChannelDiffuser@@@Z ENDP ; std::_Voidify_iter<ModMultiChannelDiffuser * *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Voidify_iter@PEAPEAVMultiChannelDiffuser@@@std@@YAPEAXPEAPEAVMultiChannelDiffuser@@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Voidify_iter@PEAPEAVMultiChannelDiffuser@@@std@@YAPEAXPEAPEAVMultiChannelDiffuser@@@Z PROC ; std::_Voidify_iter<MultiChannelDiffuser * *>, COMDAT

; 131  :     if constexpr (is_pointer_v<_Iter>) {
; 132  :         return const_cast<void*>(static_cast<const volatile void*>(_It));

	mov	rax, rcx

; 133  :     } else {
; 134  :         return const_cast<void*>(static_cast<const volatile void*>(_STD addressof(*_It)));
; 135  :     }
; 136  : }

	ret	0
??$_Voidify_iter@PEAPEAVMultiChannelDiffuser@@@std@@YAPEAXPEAPEAVMultiChannelDiffuser@@@Z ENDP ; std::_Voidify_iter<MultiChannelDiffuser * *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Voidify_iter@PEAPEAVModDelay@@@std@@YAPEAXPEAPEAVModDelay@@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Voidify_iter@PEAPEAVModDelay@@@std@@YAPEAXPEAPEAVModDelay@@@Z PROC ; std::_Voidify_iter<ModDelay * *>, COMDAT

; 131  :     if constexpr (is_pointer_v<_Iter>) {
; 132  :         return const_cast<void*>(static_cast<const volatile void*>(_It));

	mov	rax, rcx

; 133  :     } else {
; 134  :         return const_cast<void*>(static_cast<const volatile void*>(_STD addressof(*_It)));
; 135  :     }
; 136  : }

	ret	0
??$_Voidify_iter@PEAPEAVModDelay@@@std@@YAPEAXPEAPEAVModDelay@@@Z ENDP ; std::_Voidify_iter<ModDelay * *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Voidify_iter@PEAH@std@@YAPEAXPEAH@Z
_TEXT	SEGMENT
_It$ = 8
??$_Voidify_iter@PEAH@std@@YAPEAXPEAH@Z PROC		; std::_Voidify_iter<int *>, COMDAT

; 131  :     if constexpr (is_pointer_v<_Iter>) {
; 132  :         return const_cast<void*>(static_cast<const volatile void*>(_It));

	mov	rax, rcx

; 133  :     } else {
; 134  :         return const_cast<void*>(static_cast<const volatile void*>(_STD addressof(*_It)));
; 135  :     }
; 136  : }

	ret	0
??$_Voidify_iter@PEAH@std@@YAPEAXPEAH@Z ENDP		; std::_Voidify_iter<int *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Voidify_iter@PEAPEAVDelay@@@std@@YAPEAXPEAPEAVDelay@@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Voidify_iter@PEAPEAVDelay@@@std@@YAPEAXPEAPEAVDelay@@@Z PROC ; std::_Voidify_iter<Delay * *>, COMDAT

; 131  :     if constexpr (is_pointer_v<_Iter>) {
; 132  :         return const_cast<void*>(static_cast<const volatile void*>(_It));

	mov	rax, rcx

; 133  :     } else {
; 134  :         return const_cast<void*>(static_cast<const volatile void*>(_STD addressof(*_It)));
; 135  :     }
; 136  : }

	ret	0
??$_Voidify_iter@PEAPEAVDelay@@@std@@YAPEAXPEAPEAVDelay@@@Z ENDP ; std::_Voidify_iter<Delay * *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@V?$allocator@M@std@@@std@@YA$$QEAV?$allocator@M@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$allocator@M@std@@@std@@YA$$QEAV?$allocator@M@0@AEAV10@@Z PROC ; std::forward<std::allocator<float> >, COMDAT

; 1444 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1445 : }

	ret	0
??$forward@V?$allocator@M@std@@@std@@YA$$QEAV?$allocator@M@0@AEAV10@@Z ENDP ; std::forward<std::allocator<float> >
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@PEAM@std@@YA$$QEAPEAMAEAPEAM@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAM@std@@YA$$QEAPEAMAEAPEAM@Z PROC		; std::forward<float *>, COMDAT

; 1444 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1445 : }

	ret	0
??$forward@PEAM@std@@YA$$QEAPEAMAEAPEAM@Z ENDP		; std::forward<float *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@AEBV?$allocator@M@std@@@std@@YAAEBV?$allocator@M@0@AEBV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV?$allocator@M@std@@@std@@YAAEBV?$allocator@M@0@AEBV10@@Z PROC ; std::forward<std::allocator<float> const &>, COMDAT

; 1444 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1445 : }

	ret	0
??$forward@AEBV?$allocator@M@std@@@std@@YAAEBV?$allocator@M@0@AEBV10@@Z ENDP ; std::forward<std::allocator<float> const &>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAPEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@YAPEAPEAVHighPassFilter@@QEAPEAV1@0PEAPEAV1@AEAV?$allocator@PEAVHighPassFilter@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
_Al$dead$ = 72
??$_Uninitialized_move@PEAPEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@YAPEAPEAVHighPassFilter@@QEAPEAV1@0PEAPEAV1@AEAV?$allocator@PEAVHighPassFilter@@@0@@Z PROC ; std::_Uninitialized_move<HighPassFilter * *,std::allocator<HighPassFilter *> >, COMDAT

; 1693 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN16:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rcx

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	QWORD PTR __imp_memmove
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1706 :             return _Dest + (_ULast - _UFirst);

	sar	rbx, 3
	lea	rax, QWORD PTR [rdi+rbx*8]

; 1707 :         }
; 1708 :     }
; 1709 : 
; 1710 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1711 :     for (; _UFirst != _ULast; ++_UFirst) {
; 1712 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1713 :     }
; 1714 : 
; 1715 :     return _Backout._Release();
; 1716 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Uninitialized_move@PEAPEAVHighPassFilter@@V?$allocator@PEAVHighPassFilter@@@std@@@std@@YAPEAPEAVHighPassFilter@@QEAPEAV1@0PEAPEAV1@AEAV?$allocator@PEAVHighPassFilter@@@0@@Z ENDP ; std::_Uninitialized_move<HighPassFilter * *,std::allocator<HighPassFilter *> >
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAPEAVHighPassFilter@@@std@@YA?A_TAEBQEAPEAVHighPassFilter@@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAPEAVHighPassFilter@@@std@@YA?A_TAEBQEAPEAVHighPassFilter@@@Z PROC ; std::_Get_unwrapped<HighPassFilter * * const &>, COMDAT

; 1325 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1326 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1327 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1328 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1329 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1330 :     } else {
; 1331 :         return static_cast<_Iter&&>(_It);
; 1332 :     }
; 1333 : }

	ret	0
??$_Get_unwrapped@AEBQEAPEAVHighPassFilter@@@std@@YA?A_TAEBQEAPEAVHighPassFilter@@@Z ENDP ; std::_Get_unwrapped<HighPassFilter * * const &>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Get_size_of_n@$07@std@@YA_K_K@Z
_TEXT	SEGMENT
_Count$ = 48
??$_Get_size_of_n@$07@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<8>, COMDAT

; 59   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

$LN7:
	sub	rsp, 40					; 00000028H

; 60   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;
; 61   : 
; 62   :     if constexpr (_Overflow_is_possible) {
; 63   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 64   :         if (_Count > _Max_possible) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	cmp	rcx, rax
	ja	SHORT $LN6@Get_size_o

; 66   :         }
; 67   :     }
; 68   : 
; 69   :     return _Count * _Ty_size;

	lea	rax, QWORD PTR [rcx*8]

; 70   : }

	add	rsp, 40					; 00000028H
	ret	0
$LN6@Get_size_o:

; 65   :             _Throw_bad_array_new_length(); // multiply overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN4@Get_size_o:
??$_Get_size_of_n@$07@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<8>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAPEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@YAPEAPEAVModulation@@QEAPEAV1@0PEAPEAV1@AEAV?$allocator@PEAVModulation@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
_Al$dead$ = 72
??$_Uninitialized_move@PEAPEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@YAPEAPEAVModulation@@QEAPEAV1@0PEAPEAV1@AEAV?$allocator@PEAVModulation@@@0@@Z PROC ; std::_Uninitialized_move<Modulation * *,std::allocator<Modulation *> >, COMDAT

; 1693 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN16:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rcx

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	QWORD PTR __imp_memmove
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1706 :             return _Dest + (_ULast - _UFirst);

	sar	rbx, 3
	lea	rax, QWORD PTR [rdi+rbx*8]

; 1707 :         }
; 1708 :     }
; 1709 : 
; 1710 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1711 :     for (; _UFirst != _ULast; ++_UFirst) {
; 1712 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1713 :     }
; 1714 : 
; 1715 :     return _Backout._Release();
; 1716 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Uninitialized_move@PEAPEAVModulation@@V?$allocator@PEAVModulation@@@std@@@std@@YAPEAPEAVModulation@@QEAPEAV1@0PEAPEAV1@AEAV?$allocator@PEAVModulation@@@0@@Z ENDP ; std::_Uninitialized_move<Modulation * *,std::allocator<Modulation *> >
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAPEAVModulation@@@std@@YA?A_TAEBQEAPEAVModulation@@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAPEAVModulation@@@std@@YA?A_TAEBQEAPEAVModulation@@@Z PROC ; std::_Get_unwrapped<Modulation * * const &>, COMDAT

; 1325 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1326 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1327 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1328 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1329 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1330 :     } else {
; 1331 :         return static_cast<_Iter&&>(_It);
; 1332 :     }
; 1333 : }

	ret	0
??$_Get_unwrapped@AEBQEAPEAVModulation@@@std@@YA?A_TAEBQEAPEAVModulation@@@Z ENDP ; std::_Get_unwrapped<Modulation * * const &>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAPEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@YAPEAPEAVLowPassFilter@@QEAPEAV1@0PEAPEAV1@AEAV?$allocator@PEAVLowPassFilter@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
_Al$dead$ = 72
??$_Uninitialized_move@PEAPEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@YAPEAPEAVLowPassFilter@@QEAPEAV1@0PEAPEAV1@AEAV?$allocator@PEAVLowPassFilter@@@0@@Z PROC ; std::_Uninitialized_move<LowPassFilter * *,std::allocator<LowPassFilter *> >, COMDAT

; 1693 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN16:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rcx

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	QWORD PTR __imp_memmove
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1706 :             return _Dest + (_ULast - _UFirst);

	sar	rbx, 3
	lea	rax, QWORD PTR [rdi+rbx*8]

; 1707 :         }
; 1708 :     }
; 1709 : 
; 1710 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1711 :     for (; _UFirst != _ULast; ++_UFirst) {
; 1712 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1713 :     }
; 1714 : 
; 1715 :     return _Backout._Release();
; 1716 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Uninitialized_move@PEAPEAVLowPassFilter@@V?$allocator@PEAVLowPassFilter@@@std@@@std@@YAPEAPEAVLowPassFilter@@QEAPEAV1@0PEAPEAV1@AEAV?$allocator@PEAVLowPassFilter@@@0@@Z ENDP ; std::_Uninitialized_move<LowPassFilter * *,std::allocator<LowPassFilter *> >
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAPEAVLowPassFilter@@@std@@YA?A_TAEBQEAPEAVLowPassFilter@@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAPEAVLowPassFilter@@@std@@YA?A_TAEBQEAPEAVLowPassFilter@@@Z PROC ; std::_Get_unwrapped<LowPassFilter * * const &>, COMDAT

; 1325 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1326 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1327 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1328 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1329 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1330 :     } else {
; 1331 :         return static_cast<_Iter&&>(_It);
; 1332 :     }
; 1333 : }

	ret	0
??$_Get_unwrapped@AEBQEAPEAVLowPassFilter@@@std@@YA?A_TAEBQEAPEAVLowPassFilter@@@Z ENDP ; std::_Get_unwrapped<LowPassFilter * * const &>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAPEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@YAPEAPEAVModMultiChannelDiffuser@@QEAPEAV1@0PEAPEAV1@AEAV?$allocator@PEAVModMultiChannelDiffuser@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
_Al$dead$ = 72
??$_Uninitialized_move@PEAPEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@YAPEAPEAVModMultiChannelDiffuser@@QEAPEAV1@0PEAPEAV1@AEAV?$allocator@PEAVModMultiChannelDiffuser@@@0@@Z PROC ; std::_Uninitialized_move<ModMultiChannelDiffuser * *,std::allocator<ModMultiChannelDiffuser *> >, COMDAT

; 1693 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN16:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rcx

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	QWORD PTR __imp_memmove
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1706 :             return _Dest + (_ULast - _UFirst);

	sar	rbx, 3
	lea	rax, QWORD PTR [rdi+rbx*8]

; 1707 :         }
; 1708 :     }
; 1709 : 
; 1710 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1711 :     for (; _UFirst != _ULast; ++_UFirst) {
; 1712 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1713 :     }
; 1714 : 
; 1715 :     return _Backout._Release();
; 1716 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Uninitialized_move@PEAPEAVModMultiChannelDiffuser@@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@YAPEAPEAVModMultiChannelDiffuser@@QEAPEAV1@0PEAPEAV1@AEAV?$allocator@PEAVModMultiChannelDiffuser@@@0@@Z ENDP ; std::_Uninitialized_move<ModMultiChannelDiffuser * *,std::allocator<ModMultiChannelDiffuser *> >
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAPEAVModMultiChannelDiffuser@@@std@@YA?A_TAEBQEAPEAVModMultiChannelDiffuser@@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAPEAVModMultiChannelDiffuser@@@std@@YA?A_TAEBQEAPEAVModMultiChannelDiffuser@@@Z PROC ; std::_Get_unwrapped<ModMultiChannelDiffuser * * const &>, COMDAT

; 1325 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1326 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1327 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1328 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1329 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1330 :     } else {
; 1331 :         return static_cast<_Iter&&>(_It);
; 1332 :     }
; 1333 : }

	ret	0
??$_Get_unwrapped@AEBQEAPEAVModMultiChannelDiffuser@@@std@@YA?A_TAEBQEAPEAVModMultiChannelDiffuser@@@Z ENDP ; std::_Get_unwrapped<ModMultiChannelDiffuser * * const &>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAPEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@YAPEAPEAVMultiChannelDiffuser@@QEAPEAV1@0PEAPEAV1@AEAV?$allocator@PEAVMultiChannelDiffuser@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
_Al$dead$ = 72
??$_Uninitialized_move@PEAPEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@YAPEAPEAVMultiChannelDiffuser@@QEAPEAV1@0PEAPEAV1@AEAV?$allocator@PEAVMultiChannelDiffuser@@@0@@Z PROC ; std::_Uninitialized_move<MultiChannelDiffuser * *,std::allocator<MultiChannelDiffuser *> >, COMDAT

; 1693 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN16:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rcx

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	QWORD PTR __imp_memmove
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1706 :             return _Dest + (_ULast - _UFirst);

	sar	rbx, 3
	lea	rax, QWORD PTR [rdi+rbx*8]

; 1707 :         }
; 1708 :     }
; 1709 : 
; 1710 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1711 :     for (; _UFirst != _ULast; ++_UFirst) {
; 1712 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1713 :     }
; 1714 : 
; 1715 :     return _Backout._Release();
; 1716 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Uninitialized_move@PEAPEAVMultiChannelDiffuser@@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@YAPEAPEAVMultiChannelDiffuser@@QEAPEAV1@0PEAPEAV1@AEAV?$allocator@PEAVMultiChannelDiffuser@@@0@@Z ENDP ; std::_Uninitialized_move<MultiChannelDiffuser * *,std::allocator<MultiChannelDiffuser *> >
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAPEAVMultiChannelDiffuser@@@std@@YA?A_TAEBQEAPEAVMultiChannelDiffuser@@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAPEAVMultiChannelDiffuser@@@std@@YA?A_TAEBQEAPEAVMultiChannelDiffuser@@@Z PROC ; std::_Get_unwrapped<MultiChannelDiffuser * * const &>, COMDAT

; 1325 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1326 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1327 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1328 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1329 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1330 :     } else {
; 1331 :         return static_cast<_Iter&&>(_It);
; 1332 :     }
; 1333 : }

	ret	0
??$_Get_unwrapped@AEBQEAPEAVMultiChannelDiffuser@@@std@@YA?A_TAEBQEAPEAVMultiChannelDiffuser@@@Z ENDP ; std::_Get_unwrapped<MultiChannelDiffuser * * const &>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAPEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@YAPEAPEAVModDelay@@QEAPEAV1@0PEAPEAV1@AEAV?$allocator@PEAVModDelay@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
_Al$dead$ = 72
??$_Uninitialized_move@PEAPEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@YAPEAPEAVModDelay@@QEAPEAV1@0PEAPEAV1@AEAV?$allocator@PEAVModDelay@@@0@@Z PROC ; std::_Uninitialized_move<ModDelay * *,std::allocator<ModDelay *> >, COMDAT

; 1693 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN16:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rcx

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	QWORD PTR __imp_memmove
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1706 :             return _Dest + (_ULast - _UFirst);

	sar	rbx, 3
	lea	rax, QWORD PTR [rdi+rbx*8]

; 1707 :         }
; 1708 :     }
; 1709 : 
; 1710 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1711 :     for (; _UFirst != _ULast; ++_UFirst) {
; 1712 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1713 :     }
; 1714 : 
; 1715 :     return _Backout._Release();
; 1716 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Uninitialized_move@PEAPEAVModDelay@@V?$allocator@PEAVModDelay@@@std@@@std@@YAPEAPEAVModDelay@@QEAPEAV1@0PEAPEAV1@AEAV?$allocator@PEAVModDelay@@@0@@Z ENDP ; std::_Uninitialized_move<ModDelay * *,std::allocator<ModDelay *> >
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAPEAVModDelay@@@std@@YA?A_TAEBQEAPEAVModDelay@@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAPEAVModDelay@@@std@@YA?A_TAEBQEAPEAVModDelay@@@Z PROC ; std::_Get_unwrapped<ModDelay * * const &>, COMDAT

; 1325 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1326 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1327 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1328 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1329 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1330 :     } else {
; 1331 :         return static_cast<_Iter&&>(_It);
; 1332 :     }
; 1333 : }

	ret	0
??$_Get_unwrapped@AEBQEAPEAVModDelay@@@std@@YA?A_TAEBQEAPEAVModDelay@@@Z ENDP ; std::_Get_unwrapped<ModDelay * * const &>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAHV?$allocator@H@std@@@std@@YAPEAHQEAH0PEAHAEAV?$allocator@H@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
_Al$dead$ = 72
??$_Uninitialized_move@PEAHV?$allocator@H@std@@@std@@YAPEAHQEAH0PEAHAEAV?$allocator@H@0@@Z PROC ; std::_Uninitialized_move<int *,std::allocator<int> >, COMDAT

; 1693 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN16:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rcx

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	QWORD PTR __imp_memmove
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1706 :             return _Dest + (_ULast - _UFirst);

	sar	rbx, 2
	lea	rax, QWORD PTR [rdi+rbx*4]

; 1707 :         }
; 1708 :     }
; 1709 : 
; 1710 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1711 :     for (; _UFirst != _ULast; ++_UFirst) {
; 1712 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1713 :     }
; 1714 : 
; 1715 :     return _Backout._Release();
; 1716 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Uninitialized_move@PEAHV?$allocator@H@std@@@std@@YAPEAHQEAH0PEAHAEAV?$allocator@H@0@@Z ENDP ; std::_Uninitialized_move<int *,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAH@std@@YA?A_TAEBQEAH@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAH@std@@YA?A_TAEBQEAH@Z PROC	; std::_Get_unwrapped<int * const &>, COMDAT

; 1325 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1326 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1327 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1328 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1329 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1330 :     } else {
; 1331 :         return static_cast<_Iter&&>(_It);
; 1332 :     }
; 1333 : }

	ret	0
??$_Get_unwrapped@AEBQEAH@std@@YA?A_TAEBQEAH@Z ENDP	; std::_Get_unwrapped<int * const &>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAPEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@YAPEAPEAVDelay@@QEAPEAV1@0PEAPEAV1@AEAV?$allocator@PEAVDelay@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
_Al$dead$ = 72
??$_Uninitialized_move@PEAPEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@YAPEAPEAVDelay@@QEAPEAV1@0PEAPEAV1@AEAV?$allocator@PEAVDelay@@@0@@Z PROC ; std::_Uninitialized_move<Delay * *,std::allocator<Delay *> >, COMDAT

; 1693 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN16:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rcx

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	QWORD PTR __imp_memmove
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1706 :             return _Dest + (_ULast - _UFirst);

	sar	rbx, 3
	lea	rax, QWORD PTR [rdi+rbx*8]

; 1707 :         }
; 1708 :     }
; 1709 : 
; 1710 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1711 :     for (; _UFirst != _ULast; ++_UFirst) {
; 1712 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1713 :     }
; 1714 : 
; 1715 :     return _Backout._Release();
; 1716 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Uninitialized_move@PEAPEAVDelay@@V?$allocator@PEAVDelay@@@std@@@std@@YAPEAPEAVDelay@@QEAPEAV1@0PEAPEAV1@AEAV?$allocator@PEAVDelay@@@0@@Z ENDP ; std::_Uninitialized_move<Delay * *,std::allocator<Delay *> >
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAPEAVDelay@@@std@@YA?A_TAEBQEAPEAVDelay@@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAPEAVDelay@@@std@@YA?A_TAEBQEAPEAVDelay@@@Z PROC ; std::_Get_unwrapped<Delay * * const &>, COMDAT

; 1325 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1326 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1327 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1328 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1329 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1330 :     } else {
; 1331 :         return static_cast<_Iter&&>(_It);
; 1332 :     }
; 1333 : }

	ret	0
??$_Get_unwrapped@AEBQEAPEAVDelay@@@std@@YA?A_TAEBQEAPEAVDelay@@@Z ENDP ; std::_Get_unwrapped<Delay * * const &>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$allocator@M@std@@@std@@YAPEAMPEAM_KAEAV?$allocator@M@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Count$ = 56
_Al$dead$ = 64
??$_Uninitialized_value_construct_n@V?$allocator@M@std@@@std@@YAPEAMPEAM_KAEAV?$allocator@M@0@@Z PROC ; std::_Uninitialized_value_construct_n<std::allocator<float> >, COMDAT

; 1795 :     _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {

$LN18:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1796 :     // value-initialize _Count objects to raw _First, using _Al
; 1797 :     using _Ptrty = typename _Alloc::value_type*;
; 1798 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 1799 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1800 :         if (!_STD is_constant_evaluated())
; 1801 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1802 :         {
; 1803 :             auto _PFirst = _Unfancy(_First);
; 1804 :             _Zero_range(_PFirst, _PFirst + _Count);

	lea	rbx, QWORD PTR [rdx*4]
	mov	rdi, rcx

; 1789 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	r8, rbx
	xor	edx, edx
	call	QWORD PTR __imp_memset

; 1805 :             return _First + _Count;

	lea	rax, QWORD PTR [rbx+rdi]

; 1806 :         }
; 1807 :     }
; 1808 : 
; 1809 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 1810 :     for (; 0 < _Count; --_Count) {
; 1811 :         _Backout._Emplace_back();
; 1812 :     }
; 1813 : 
; 1814 :     return _Backout._Release();
; 1815 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Uninitialized_value_construct_n@V?$allocator@M@std@@@std@@YAPEAMPEAM_KAEAV?$allocator@M@0@@Z ENDP ; std::_Uninitialized_value_construct_n<std::allocator<float> >
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@PEAVDelay@@@std@@@std@@QEAAPEAPEAVDelay@@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout_al@V?$allocator@PEAVDelay@@@std@@@std@@QEAAPEAPEAVDelay@@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<Delay *> >::_Release, COMDAT

; 1616 :         _First = _Last;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rcx], rax

; 1617 :         return _Last;
; 1618 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$allocator@PEAVDelay@@@std@@@std@@QEAAPEAPEAVDelay@@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<Delay *> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@PEAVDelay@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Uninitialized_backout_al@V?$allocator@PEAVDelay@@@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<Delay *> >::~_Uninitialized_backout_al<std::allocator<Delay *> >, COMDAT

; 1606 :         _Destroy_range(_First, _Last, _Al);
; 1607 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$allocator@PEAVDelay@@@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<Delay *> >::~_Uninitialized_backout_al<std::allocator<Delay *> >
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@PEAVDelay@@@std@@@std@@QEAA@PEAPEAVDelay@@AEAV?$allocator@PEAVDelay@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
_Al_$ = 24
??0?$_Uninitialized_backout_al@V?$allocator@PEAVDelay@@@std@@@std@@QEAA@PEAPEAVDelay@@AEAV?$allocator@PEAVDelay@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<Delay *> >::_Uninitialized_backout_al<std::allocator<Delay *> >, COMDAT

; 1600 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
	ret	0
??0?$_Uninitialized_backout_al@V?$allocator@PEAVDelay@@@std@@@std@@QEAA@PEAPEAVDelay@@AEAV?$allocator@PEAVDelay@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<Delay *> >::_Uninitialized_backout_al<std::allocator<Delay *> >
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QEAAPEAHXZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QEAAPEAHXZ PROC ; std::_Uninitialized_backout_al<std::allocator<int> >::_Release, COMDAT

; 1616 :         _First = _Last;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rcx], rax

; 1617 :         return _Last;
; 1618 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QEAAPEAHXZ ENDP ; std::_Uninitialized_backout_al<std::allocator<int> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<int> >::~_Uninitialized_backout_al<std::allocator<int> >, COMDAT

; 1606 :         _Destroy_range(_First, _Last, _Al);
; 1607 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<int> >::~_Uninitialized_backout_al<std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QEAA@PEAHAEAV?$allocator@H@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
_Al_$ = 24
??0?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QEAA@PEAHAEAV?$allocator@H@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<int> >::_Uninitialized_backout_al<std::allocator<int> >, COMDAT

; 1600 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
	ret	0
??0?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QEAA@PEAHAEAV?$allocator@H@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<int> >::_Uninitialized_backout_al<std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@PEAVModDelay@@@std@@@std@@QEAAPEAPEAVModDelay@@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout_al@V?$allocator@PEAVModDelay@@@std@@@std@@QEAAPEAPEAVModDelay@@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<ModDelay *> >::_Release, COMDAT

; 1616 :         _First = _Last;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rcx], rax

; 1617 :         return _Last;
; 1618 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$allocator@PEAVModDelay@@@std@@@std@@QEAAPEAPEAVModDelay@@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<ModDelay *> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@PEAVModDelay@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Uninitialized_backout_al@V?$allocator@PEAVModDelay@@@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<ModDelay *> >::~_Uninitialized_backout_al<std::allocator<ModDelay *> >, COMDAT

; 1606 :         _Destroy_range(_First, _Last, _Al);
; 1607 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$allocator@PEAVModDelay@@@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<ModDelay *> >::~_Uninitialized_backout_al<std::allocator<ModDelay *> >
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@PEAVModDelay@@@std@@@std@@QEAA@PEAPEAVModDelay@@AEAV?$allocator@PEAVModDelay@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
_Al_$ = 24
??0?$_Uninitialized_backout_al@V?$allocator@PEAVModDelay@@@std@@@std@@QEAA@PEAPEAVModDelay@@AEAV?$allocator@PEAVModDelay@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<ModDelay *> >::_Uninitialized_backout_al<std::allocator<ModDelay *> >, COMDAT

; 1600 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
	ret	0
??0?$_Uninitialized_backout_al@V?$allocator@PEAVModDelay@@@std@@@std@@QEAA@PEAPEAVModDelay@@AEAV?$allocator@PEAVModDelay@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<ModDelay *> >::_Uninitialized_backout_al<std::allocator<ModDelay *> >
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEAAPEAPEAVMultiChannelDiffuser@@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout_al@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEAAPEAPEAVMultiChannelDiffuser@@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<MultiChannelDiffuser *> >::_Release, COMDAT

; 1616 :         _First = _Last;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rcx], rax

; 1617 :         return _Last;
; 1618 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEAAPEAPEAVMultiChannelDiffuser@@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<MultiChannelDiffuser *> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Uninitialized_backout_al@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<MultiChannelDiffuser *> >::~_Uninitialized_backout_al<std::allocator<MultiChannelDiffuser *> >, COMDAT

; 1606 :         _Destroy_range(_First, _Last, _Al);
; 1607 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<MultiChannelDiffuser *> >::~_Uninitialized_backout_al<std::allocator<MultiChannelDiffuser *> >
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEAA@PEAPEAVMultiChannelDiffuser@@AEAV?$allocator@PEAVMultiChannelDiffuser@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
_Al_$ = 24
??0?$_Uninitialized_backout_al@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEAA@PEAPEAVMultiChannelDiffuser@@AEAV?$allocator@PEAVMultiChannelDiffuser@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<MultiChannelDiffuser *> >::_Uninitialized_backout_al<std::allocator<MultiChannelDiffuser *> >, COMDAT

; 1600 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
	ret	0
??0?$_Uninitialized_backout_al@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEAA@PEAPEAVMultiChannelDiffuser@@AEAV?$allocator@PEAVMultiChannelDiffuser@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<MultiChannelDiffuser *> >::_Uninitialized_backout_al<std::allocator<MultiChannelDiffuser *> >
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEAAPEAPEAVModMultiChannelDiffuser@@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout_al@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEAAPEAPEAVModMultiChannelDiffuser@@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<ModMultiChannelDiffuser *> >::_Release, COMDAT

; 1616 :         _First = _Last;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rcx], rax

; 1617 :         return _Last;
; 1618 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEAAPEAPEAVModMultiChannelDiffuser@@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<ModMultiChannelDiffuser *> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Uninitialized_backout_al@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<ModMultiChannelDiffuser *> >::~_Uninitialized_backout_al<std::allocator<ModMultiChannelDiffuser *> >, COMDAT

; 1606 :         _Destroy_range(_First, _Last, _Al);
; 1607 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<ModMultiChannelDiffuser *> >::~_Uninitialized_backout_al<std::allocator<ModMultiChannelDiffuser *> >
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEAA@PEAPEAVModMultiChannelDiffuser@@AEAV?$allocator@PEAVModMultiChannelDiffuser@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
_Al_$ = 24
??0?$_Uninitialized_backout_al@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEAA@PEAPEAVModMultiChannelDiffuser@@AEAV?$allocator@PEAVModMultiChannelDiffuser@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<ModMultiChannelDiffuser *> >::_Uninitialized_backout_al<std::allocator<ModMultiChannelDiffuser *> >, COMDAT

; 1600 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
	ret	0
??0?$_Uninitialized_backout_al@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEAA@PEAPEAVModMultiChannelDiffuser@@AEAV?$allocator@PEAVModMultiChannelDiffuser@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<ModMultiChannelDiffuser *> >::_Uninitialized_backout_al<std::allocator<ModMultiChannelDiffuser *> >
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEAAPEAPEAVLowPassFilter@@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout_al@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEAAPEAPEAVLowPassFilter@@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<LowPassFilter *> >::_Release, COMDAT

; 1616 :         _First = _Last;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rcx], rax

; 1617 :         return _Last;
; 1618 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEAAPEAPEAVLowPassFilter@@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<LowPassFilter *> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Uninitialized_backout_al@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<LowPassFilter *> >::~_Uninitialized_backout_al<std::allocator<LowPassFilter *> >, COMDAT

; 1606 :         _Destroy_range(_First, _Last, _Al);
; 1607 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<LowPassFilter *> >::~_Uninitialized_backout_al<std::allocator<LowPassFilter *> >
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEAA@PEAPEAVLowPassFilter@@AEAV?$allocator@PEAVLowPassFilter@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
_Al_$ = 24
??0?$_Uninitialized_backout_al@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEAA@PEAPEAVLowPassFilter@@AEAV?$allocator@PEAVLowPassFilter@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<LowPassFilter *> >::_Uninitialized_backout_al<std::allocator<LowPassFilter *> >, COMDAT

; 1600 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
	ret	0
??0?$_Uninitialized_backout_al@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEAA@PEAPEAVLowPassFilter@@AEAV?$allocator@PEAVLowPassFilter@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<LowPassFilter *> >::_Uninitialized_backout_al<std::allocator<LowPassFilter *> >
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@PEAVModulation@@@std@@@std@@QEAAPEAPEAVModulation@@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout_al@V?$allocator@PEAVModulation@@@std@@@std@@QEAAPEAPEAVModulation@@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<Modulation *> >::_Release, COMDAT

; 1616 :         _First = _Last;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rcx], rax

; 1617 :         return _Last;
; 1618 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$allocator@PEAVModulation@@@std@@@std@@QEAAPEAPEAVModulation@@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<Modulation *> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@PEAVModulation@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Uninitialized_backout_al@V?$allocator@PEAVModulation@@@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<Modulation *> >::~_Uninitialized_backout_al<std::allocator<Modulation *> >, COMDAT

; 1606 :         _Destroy_range(_First, _Last, _Al);
; 1607 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$allocator@PEAVModulation@@@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<Modulation *> >::~_Uninitialized_backout_al<std::allocator<Modulation *> >
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@PEAVModulation@@@std@@@std@@QEAA@PEAPEAVModulation@@AEAV?$allocator@PEAVModulation@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
_Al_$ = 24
??0?$_Uninitialized_backout_al@V?$allocator@PEAVModulation@@@std@@@std@@QEAA@PEAPEAVModulation@@AEAV?$allocator@PEAVModulation@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<Modulation *> >::_Uninitialized_backout_al<std::allocator<Modulation *> >, COMDAT

; 1600 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
	ret	0
??0?$_Uninitialized_backout_al@V?$allocator@PEAVModulation@@@std@@@std@@QEAA@PEAPEAVModulation@@AEAV?$allocator@PEAVModulation@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<Modulation *> >::_Uninitialized_backout_al<std::allocator<Modulation *> >
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEAAPEAPEAVHighPassFilter@@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout_al@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEAAPEAPEAVHighPassFilter@@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<HighPassFilter *> >::_Release, COMDAT

; 1616 :         _First = _Last;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rcx], rax

; 1617 :         return _Last;
; 1618 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEAAPEAPEAVHighPassFilter@@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<HighPassFilter *> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Uninitialized_backout_al@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<HighPassFilter *> >::~_Uninitialized_backout_al<std::allocator<HighPassFilter *> >, COMDAT

; 1606 :         _Destroy_range(_First, _Last, _Al);
; 1607 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<HighPassFilter *> >::~_Uninitialized_backout_al<std::allocator<HighPassFilter *> >
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEAA@PEAPEAVHighPassFilter@@AEAV?$allocator@PEAVHighPassFilter@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
_Al_$ = 24
??0?$_Uninitialized_backout_al@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEAA@PEAPEAVHighPassFilter@@AEAV?$allocator@PEAVHighPassFilter@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<HighPassFilter *> >::_Uninitialized_backout_al<std::allocator<HighPassFilter *> >, COMDAT

; 1600 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
	ret	0
??0?$_Uninitialized_backout_al@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEAA@PEAPEAVHighPassFilter@@AEAV?$allocator@PEAVHighPassFilter@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<HighPassFilter *> >::_Uninitialized_backout_al<std::allocator<HighPassFilter *> >
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Copy_memmove@PEAPEAVHighPassFilter@@PEAPEAV1@@std@@YAPEAPEAVHighPassFilter@@PEAPEAV1@00@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
??$_Copy_memmove@PEAPEAVHighPassFilter@@PEAPEAV1@@std@@YAPEAPEAVHighPassFilter@@PEAPEAV1@00@Z PROC ; std::_Copy_memmove<HighPassFilter * *,HighPassFilter * *>, COMDAT

; 4159 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8

; 4160 :     auto _FirstPtr              = _To_address(_First);
; 4161 :     auto _LastPtr               = _To_address(_Last);
; 4162 :     auto _DestPtr               = _To_address(_Dest);
; 4163 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
; 4164 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
; 4165 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rcx

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	QWORD PTR __imp_memmove

; 4168 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4169 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	rax, QWORD PTR [rbx+rdi]

; 4170 :     } else {
; 4171 :         return _Dest + (_LastPtr - _FirstPtr);
; 4172 :     }
; 4173 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Copy_memmove@PEAPEAVHighPassFilter@@PEAPEAV1@@std@@YAPEAPEAVHighPassFilter@@PEAPEAV1@00@Z ENDP ; std::_Copy_memmove<HighPassFilter * *,HighPassFilter * *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_To_address@PEAPEAVHighPassFilter@@@std@@YA?A_PAEBQEAPEAVHighPassFilter@@@Z
_TEXT	SEGMENT
_Val$ = 8
??$_To_address@PEAPEAVHighPassFilter@@@std@@YA?A_PAEBQEAPEAVHighPassFilter@@@Z PROC ; std::_To_address<HighPassFilter * *>, COMDAT

; 4081 :     _STL_INTERNAL_STATIC_ASSERT(is_pointer_v<_Iter>);
; 4082 :     return _Val;

	mov	rax, QWORD PTR [rcx]

; 4083 : }

	ret	0
??$_To_address@PEAPEAVHighPassFilter@@@std@@YA?A_PAEBQEAPEAVHighPassFilter@@@Z ENDP ; std::_To_address<HighPassFilter * *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@PEAVHighPassFilter@@@?$_Uninitialized_backout_al@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEAAX$$QEAPEAVHighPassFilter@@@Z
_TEXT	SEGMENT
this$ = 8
<_Vals_0>$ = 16
??$_Emplace_back@PEAVHighPassFilter@@@?$_Uninitialized_backout_al@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEAAX$$QEAPEAVHighPassFilter@@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<HighPassFilter *> >::_Emplace_back<HighPassFilter *>, COMDAT

; 1611 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	r8, QWORD PTR [rcx+8]
	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [r8], rax

; 1612 :         ++_Last;

	add	QWORD PTR [rcx+8], 8

; 1613 :     }

	ret	0
??$_Emplace_back@PEAVHighPassFilter@@@?$_Uninitialized_backout_al@V?$allocator@PEAVHighPassFilter@@@std@@@std@@QEAAX$$QEAPEAVHighPassFilter@@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<HighPassFilter *> >::_Emplace_back<HighPassFilter *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Copy_memmove@PEAPEAVModulation@@PEAPEAV1@@std@@YAPEAPEAVModulation@@PEAPEAV1@00@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
??$_Copy_memmove@PEAPEAVModulation@@PEAPEAV1@@std@@YAPEAPEAVModulation@@PEAPEAV1@00@Z PROC ; std::_Copy_memmove<Modulation * *,Modulation * *>, COMDAT

; 4159 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8

; 4160 :     auto _FirstPtr              = _To_address(_First);
; 4161 :     auto _LastPtr               = _To_address(_Last);
; 4162 :     auto _DestPtr               = _To_address(_Dest);
; 4163 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
; 4164 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
; 4165 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rcx

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	QWORD PTR __imp_memmove

; 4168 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4169 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	rax, QWORD PTR [rbx+rdi]

; 4170 :     } else {
; 4171 :         return _Dest + (_LastPtr - _FirstPtr);
; 4172 :     }
; 4173 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Copy_memmove@PEAPEAVModulation@@PEAPEAV1@@std@@YAPEAPEAVModulation@@PEAPEAV1@00@Z ENDP ; std::_Copy_memmove<Modulation * *,Modulation * *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_To_address@PEAPEAVModulation@@@std@@YA?A_PAEBQEAPEAVModulation@@@Z
_TEXT	SEGMENT
_Val$ = 8
??$_To_address@PEAPEAVModulation@@@std@@YA?A_PAEBQEAPEAVModulation@@@Z PROC ; std::_To_address<Modulation * *>, COMDAT

; 4081 :     _STL_INTERNAL_STATIC_ASSERT(is_pointer_v<_Iter>);
; 4082 :     return _Val;

	mov	rax, QWORD PTR [rcx]

; 4083 : }

	ret	0
??$_To_address@PEAPEAVModulation@@@std@@YA?A_PAEBQEAPEAVModulation@@@Z ENDP ; std::_To_address<Modulation * *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@PEAVModulation@@@?$_Uninitialized_backout_al@V?$allocator@PEAVModulation@@@std@@@std@@QEAAX$$QEAPEAVModulation@@@Z
_TEXT	SEGMENT
this$ = 8
<_Vals_0>$ = 16
??$_Emplace_back@PEAVModulation@@@?$_Uninitialized_backout_al@V?$allocator@PEAVModulation@@@std@@@std@@QEAAX$$QEAPEAVModulation@@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<Modulation *> >::_Emplace_back<Modulation *>, COMDAT

; 1611 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	r8, QWORD PTR [rcx+8]
	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [r8], rax

; 1612 :         ++_Last;

	add	QWORD PTR [rcx+8], 8

; 1613 :     }

	ret	0
??$_Emplace_back@PEAVModulation@@@?$_Uninitialized_backout_al@V?$allocator@PEAVModulation@@@std@@@std@@QEAAX$$QEAPEAVModulation@@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<Modulation *> >::_Emplace_back<Modulation *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Copy_memmove@PEAPEAVLowPassFilter@@PEAPEAV1@@std@@YAPEAPEAVLowPassFilter@@PEAPEAV1@00@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
??$_Copy_memmove@PEAPEAVLowPassFilter@@PEAPEAV1@@std@@YAPEAPEAVLowPassFilter@@PEAPEAV1@00@Z PROC ; std::_Copy_memmove<LowPassFilter * *,LowPassFilter * *>, COMDAT

; 4159 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8

; 4160 :     auto _FirstPtr              = _To_address(_First);
; 4161 :     auto _LastPtr               = _To_address(_Last);
; 4162 :     auto _DestPtr               = _To_address(_Dest);
; 4163 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
; 4164 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
; 4165 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rcx

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	QWORD PTR __imp_memmove

; 4168 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4169 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	rax, QWORD PTR [rbx+rdi]

; 4170 :     } else {
; 4171 :         return _Dest + (_LastPtr - _FirstPtr);
; 4172 :     }
; 4173 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Copy_memmove@PEAPEAVLowPassFilter@@PEAPEAV1@@std@@YAPEAPEAVLowPassFilter@@PEAPEAV1@00@Z ENDP ; std::_Copy_memmove<LowPassFilter * *,LowPassFilter * *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_To_address@PEAPEAVLowPassFilter@@@std@@YA?A_PAEBQEAPEAVLowPassFilter@@@Z
_TEXT	SEGMENT
_Val$ = 8
??$_To_address@PEAPEAVLowPassFilter@@@std@@YA?A_PAEBQEAPEAVLowPassFilter@@@Z PROC ; std::_To_address<LowPassFilter * *>, COMDAT

; 4081 :     _STL_INTERNAL_STATIC_ASSERT(is_pointer_v<_Iter>);
; 4082 :     return _Val;

	mov	rax, QWORD PTR [rcx]

; 4083 : }

	ret	0
??$_To_address@PEAPEAVLowPassFilter@@@std@@YA?A_PAEBQEAPEAVLowPassFilter@@@Z ENDP ; std::_To_address<LowPassFilter * *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@PEAVLowPassFilter@@@?$_Uninitialized_backout_al@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEAAX$$QEAPEAVLowPassFilter@@@Z
_TEXT	SEGMENT
this$ = 8
<_Vals_0>$ = 16
??$_Emplace_back@PEAVLowPassFilter@@@?$_Uninitialized_backout_al@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEAAX$$QEAPEAVLowPassFilter@@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<LowPassFilter *> >::_Emplace_back<LowPassFilter *>, COMDAT

; 1611 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	r8, QWORD PTR [rcx+8]
	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [r8], rax

; 1612 :         ++_Last;

	add	QWORD PTR [rcx+8], 8

; 1613 :     }

	ret	0
??$_Emplace_back@PEAVLowPassFilter@@@?$_Uninitialized_backout_al@V?$allocator@PEAVLowPassFilter@@@std@@@std@@QEAAX$$QEAPEAVLowPassFilter@@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<LowPassFilter *> >::_Emplace_back<LowPassFilter *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Copy_memmove@PEAPEAVModMultiChannelDiffuser@@PEAPEAV1@@std@@YAPEAPEAVModMultiChannelDiffuser@@PEAPEAV1@00@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
??$_Copy_memmove@PEAPEAVModMultiChannelDiffuser@@PEAPEAV1@@std@@YAPEAPEAVModMultiChannelDiffuser@@PEAPEAV1@00@Z PROC ; std::_Copy_memmove<ModMultiChannelDiffuser * *,ModMultiChannelDiffuser * *>, COMDAT

; 4159 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8

; 4160 :     auto _FirstPtr              = _To_address(_First);
; 4161 :     auto _LastPtr               = _To_address(_Last);
; 4162 :     auto _DestPtr               = _To_address(_Dest);
; 4163 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
; 4164 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
; 4165 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rcx

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	QWORD PTR __imp_memmove

; 4168 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4169 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	rax, QWORD PTR [rbx+rdi]

; 4170 :     } else {
; 4171 :         return _Dest + (_LastPtr - _FirstPtr);
; 4172 :     }
; 4173 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Copy_memmove@PEAPEAVModMultiChannelDiffuser@@PEAPEAV1@@std@@YAPEAPEAVModMultiChannelDiffuser@@PEAPEAV1@00@Z ENDP ; std::_Copy_memmove<ModMultiChannelDiffuser * *,ModMultiChannelDiffuser * *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_To_address@PEAPEAVModMultiChannelDiffuser@@@std@@YA?A_PAEBQEAPEAVModMultiChannelDiffuser@@@Z
_TEXT	SEGMENT
_Val$ = 8
??$_To_address@PEAPEAVModMultiChannelDiffuser@@@std@@YA?A_PAEBQEAPEAVModMultiChannelDiffuser@@@Z PROC ; std::_To_address<ModMultiChannelDiffuser * *>, COMDAT

; 4081 :     _STL_INTERNAL_STATIC_ASSERT(is_pointer_v<_Iter>);
; 4082 :     return _Val;

	mov	rax, QWORD PTR [rcx]

; 4083 : }

	ret	0
??$_To_address@PEAPEAVModMultiChannelDiffuser@@@std@@YA?A_PAEBQEAPEAVModMultiChannelDiffuser@@@Z ENDP ; std::_To_address<ModMultiChannelDiffuser * *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@PEAVModMultiChannelDiffuser@@@?$_Uninitialized_backout_al@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEAAX$$QEAPEAVModMultiChannelDiffuser@@@Z
_TEXT	SEGMENT
this$ = 8
<_Vals_0>$ = 16
??$_Emplace_back@PEAVModMultiChannelDiffuser@@@?$_Uninitialized_backout_al@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEAAX$$QEAPEAVModMultiChannelDiffuser@@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<ModMultiChannelDiffuser *> >::_Emplace_back<ModMultiChannelDiffuser *>, COMDAT

; 1611 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	r8, QWORD PTR [rcx+8]
	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [r8], rax

; 1612 :         ++_Last;

	add	QWORD PTR [rcx+8], 8

; 1613 :     }

	ret	0
??$_Emplace_back@PEAVModMultiChannelDiffuser@@@?$_Uninitialized_backout_al@V?$allocator@PEAVModMultiChannelDiffuser@@@std@@@std@@QEAAX$$QEAPEAVModMultiChannelDiffuser@@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<ModMultiChannelDiffuser *> >::_Emplace_back<ModMultiChannelDiffuser *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Copy_memmove@PEAPEAVMultiChannelDiffuser@@PEAPEAV1@@std@@YAPEAPEAVMultiChannelDiffuser@@PEAPEAV1@00@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
??$_Copy_memmove@PEAPEAVMultiChannelDiffuser@@PEAPEAV1@@std@@YAPEAPEAVMultiChannelDiffuser@@PEAPEAV1@00@Z PROC ; std::_Copy_memmove<MultiChannelDiffuser * *,MultiChannelDiffuser * *>, COMDAT

; 4159 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8

; 4160 :     auto _FirstPtr              = _To_address(_First);
; 4161 :     auto _LastPtr               = _To_address(_Last);
; 4162 :     auto _DestPtr               = _To_address(_Dest);
; 4163 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
; 4164 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
; 4165 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rcx

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	QWORD PTR __imp_memmove

; 4168 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4169 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	rax, QWORD PTR [rbx+rdi]

; 4170 :     } else {
; 4171 :         return _Dest + (_LastPtr - _FirstPtr);
; 4172 :     }
; 4173 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Copy_memmove@PEAPEAVMultiChannelDiffuser@@PEAPEAV1@@std@@YAPEAPEAVMultiChannelDiffuser@@PEAPEAV1@00@Z ENDP ; std::_Copy_memmove<MultiChannelDiffuser * *,MultiChannelDiffuser * *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_To_address@PEAPEAVMultiChannelDiffuser@@@std@@YA?A_PAEBQEAPEAVMultiChannelDiffuser@@@Z
_TEXT	SEGMENT
_Val$ = 8
??$_To_address@PEAPEAVMultiChannelDiffuser@@@std@@YA?A_PAEBQEAPEAVMultiChannelDiffuser@@@Z PROC ; std::_To_address<MultiChannelDiffuser * *>, COMDAT

; 4081 :     _STL_INTERNAL_STATIC_ASSERT(is_pointer_v<_Iter>);
; 4082 :     return _Val;

	mov	rax, QWORD PTR [rcx]

; 4083 : }

	ret	0
??$_To_address@PEAPEAVMultiChannelDiffuser@@@std@@YA?A_PAEBQEAPEAVMultiChannelDiffuser@@@Z ENDP ; std::_To_address<MultiChannelDiffuser * *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@PEAVMultiChannelDiffuser@@@?$_Uninitialized_backout_al@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEAAX$$QEAPEAVMultiChannelDiffuser@@@Z
_TEXT	SEGMENT
this$ = 8
<_Vals_0>$ = 16
??$_Emplace_back@PEAVMultiChannelDiffuser@@@?$_Uninitialized_backout_al@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEAAX$$QEAPEAVMultiChannelDiffuser@@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<MultiChannelDiffuser *> >::_Emplace_back<MultiChannelDiffuser *>, COMDAT

; 1611 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	r8, QWORD PTR [rcx+8]
	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [r8], rax

; 1612 :         ++_Last;

	add	QWORD PTR [rcx+8], 8

; 1613 :     }

	ret	0
??$_Emplace_back@PEAVMultiChannelDiffuser@@@?$_Uninitialized_backout_al@V?$allocator@PEAVMultiChannelDiffuser@@@std@@@std@@QEAAX$$QEAPEAVMultiChannelDiffuser@@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<MultiChannelDiffuser *> >::_Emplace_back<MultiChannelDiffuser *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Copy_memmove@PEAPEAVModDelay@@PEAPEAV1@@std@@YAPEAPEAVModDelay@@PEAPEAV1@00@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
??$_Copy_memmove@PEAPEAVModDelay@@PEAPEAV1@@std@@YAPEAPEAVModDelay@@PEAPEAV1@00@Z PROC ; std::_Copy_memmove<ModDelay * *,ModDelay * *>, COMDAT

; 4159 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8

; 4160 :     auto _FirstPtr              = _To_address(_First);
; 4161 :     auto _LastPtr               = _To_address(_Last);
; 4162 :     auto _DestPtr               = _To_address(_Dest);
; 4163 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
; 4164 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
; 4165 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rcx

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	QWORD PTR __imp_memmove

; 4168 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4169 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	rax, QWORD PTR [rbx+rdi]

; 4170 :     } else {
; 4171 :         return _Dest + (_LastPtr - _FirstPtr);
; 4172 :     }
; 4173 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Copy_memmove@PEAPEAVModDelay@@PEAPEAV1@@std@@YAPEAPEAVModDelay@@PEAPEAV1@00@Z ENDP ; std::_Copy_memmove<ModDelay * *,ModDelay * *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_To_address@PEAPEAVModDelay@@@std@@YA?A_PAEBQEAPEAVModDelay@@@Z
_TEXT	SEGMENT
_Val$ = 8
??$_To_address@PEAPEAVModDelay@@@std@@YA?A_PAEBQEAPEAVModDelay@@@Z PROC ; std::_To_address<ModDelay * *>, COMDAT

; 4081 :     _STL_INTERNAL_STATIC_ASSERT(is_pointer_v<_Iter>);
; 4082 :     return _Val;

	mov	rax, QWORD PTR [rcx]

; 4083 : }

	ret	0
??$_To_address@PEAPEAVModDelay@@@std@@YA?A_PAEBQEAPEAVModDelay@@@Z ENDP ; std::_To_address<ModDelay * *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@PEAVModDelay@@@?$_Uninitialized_backout_al@V?$allocator@PEAVModDelay@@@std@@@std@@QEAAX$$QEAPEAVModDelay@@@Z
_TEXT	SEGMENT
this$ = 8
<_Vals_0>$ = 16
??$_Emplace_back@PEAVModDelay@@@?$_Uninitialized_backout_al@V?$allocator@PEAVModDelay@@@std@@@std@@QEAAX$$QEAPEAVModDelay@@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<ModDelay *> >::_Emplace_back<ModDelay *>, COMDAT

; 1611 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	r8, QWORD PTR [rcx+8]
	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [r8], rax

; 1612 :         ++_Last;

	add	QWORD PTR [rcx+8], 8

; 1613 :     }

	ret	0
??$_Emplace_back@PEAVModDelay@@@?$_Uninitialized_backout_al@V?$allocator@PEAVModDelay@@@std@@@std@@QEAAX$$QEAPEAVModDelay@@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<ModDelay *> >::_Emplace_back<ModDelay *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Copy_memmove@PEAHPEAH@std@@YAPEAHPEAH00@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
??$_Copy_memmove@PEAHPEAH@std@@YAPEAHPEAH00@Z PROC	; std::_Copy_memmove<int *,int *>, COMDAT

; 4159 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8

; 4160 :     auto _FirstPtr              = _To_address(_First);
; 4161 :     auto _LastPtr               = _To_address(_Last);
; 4162 :     auto _DestPtr               = _To_address(_Dest);
; 4163 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
; 4164 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
; 4165 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rcx

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	QWORD PTR __imp_memmove

; 4168 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4169 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	rax, QWORD PTR [rbx+rdi]

; 4170 :     } else {
; 4171 :         return _Dest + (_LastPtr - _FirstPtr);
; 4172 :     }
; 4173 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Copy_memmove@PEAHPEAH@std@@YAPEAHPEAH00@Z ENDP	; std::_Copy_memmove<int *,int *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_To_address@PEAH@std@@YA?A_PAEBQEAH@Z
_TEXT	SEGMENT
_Val$ = 8
??$_To_address@PEAH@std@@YA?A_PAEBQEAH@Z PROC		; std::_To_address<int *>, COMDAT

; 4081 :     _STL_INTERNAL_STATIC_ASSERT(is_pointer_v<_Iter>);
; 4082 :     return _Val;

	mov	rax, QWORD PTR [rcx]

; 4083 : }

	ret	0
??$_To_address@PEAH@std@@YA?A_PAEBQEAH@Z ENDP		; std::_To_address<int *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@H@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QEAAX$$QEAH@Z
_TEXT	SEGMENT
this$ = 8
<_Vals_0>$ = 16
??$_Emplace_back@H@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QEAAX$$QEAH@Z PROC ; std::_Uninitialized_backout_al<std::allocator<int> >::_Emplace_back<int>, COMDAT

; 1611 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	r8, QWORD PTR [rcx+8]
	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [r8], eax

; 1612 :         ++_Last;

	add	QWORD PTR [rcx+8], 4

; 1613 :     }

	ret	0
??$_Emplace_back@H@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QEAAX$$QEAH@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<int> >::_Emplace_back<int>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Copy_memmove@PEAPEAVDelay@@PEAPEAV1@@std@@YAPEAPEAVDelay@@PEAPEAV1@00@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
??$_Copy_memmove@PEAPEAVDelay@@PEAPEAV1@@std@@YAPEAPEAVDelay@@PEAPEAV1@00@Z PROC ; std::_Copy_memmove<Delay * *,Delay * *>, COMDAT

; 4159 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8

; 4160 :     auto _FirstPtr              = _To_address(_First);
; 4161 :     auto _LastPtr               = _To_address(_Last);
; 4162 :     auto _DestPtr               = _To_address(_Dest);
; 4163 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
; 4164 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
; 4165 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rcx

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	QWORD PTR __imp_memmove

; 4168 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4169 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	rax, QWORD PTR [rbx+rdi]

; 4170 :     } else {
; 4171 :         return _Dest + (_LastPtr - _FirstPtr);
; 4172 :     }
; 4173 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Copy_memmove@PEAPEAVDelay@@PEAPEAV1@@std@@YAPEAPEAVDelay@@PEAPEAV1@00@Z ENDP ; std::_Copy_memmove<Delay * *,Delay * *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_To_address@PEAPEAVDelay@@@std@@YA?A_PAEBQEAPEAVDelay@@@Z
_TEXT	SEGMENT
_Val$ = 8
??$_To_address@PEAPEAVDelay@@@std@@YA?A_PAEBQEAPEAVDelay@@@Z PROC ; std::_To_address<Delay * *>, COMDAT

; 4081 :     _STL_INTERNAL_STATIC_ASSERT(is_pointer_v<_Iter>);
; 4082 :     return _Val;

	mov	rax, QWORD PTR [rcx]

; 4083 : }

	ret	0
??$_To_address@PEAPEAVDelay@@@std@@YA?A_PAEBQEAPEAVDelay@@@Z ENDP ; std::_To_address<Delay * *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@PEAVDelay@@@?$_Uninitialized_backout_al@V?$allocator@PEAVDelay@@@std@@@std@@QEAAX$$QEAPEAVDelay@@@Z
_TEXT	SEGMENT
this$ = 8
<_Vals_0>$ = 16
??$_Emplace_back@PEAVDelay@@@?$_Uninitialized_backout_al@V?$allocator@PEAVDelay@@@std@@@std@@QEAAX$$QEAPEAVDelay@@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<Delay *> >::_Emplace_back<Delay *>, COMDAT

; 1611 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	r8, QWORD PTR [rcx+8]
	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [r8], rax

; 1612 :         ++_Last;

	add	QWORD PTR [rcx+8], 8

; 1613 :     }

	ret	0
??$_Emplace_back@PEAVDelay@@@?$_Uninitialized_backout_al@V?$allocator@PEAVDelay@@@std@@@std@@QEAAX$$QEAPEAVDelay@@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<Delay *> >::_Emplace_back<Delay *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Zero_range@PEAM@std@@YAPEAMQEAM0@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
??$_Zero_range@PEAM@std@@YAPEAMQEAM0@Z PROC		; std::_Zero_range<float *>, COMDAT

; 1786 : _Ptr _Zero_range(const _Ptr _First, const _Ptr _Last) { // fill [_First, _Last) with zeroes

$LN4:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1787 :     char* const _First_ch = reinterpret_cast<char*>(_To_address(_First));
; 1788 :     char* const _Last_ch  = reinterpret_cast<char*>(_To_address(_Last));
; 1789 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	r8, rdx
	mov	rbx, rdx
	sub	r8, rcx
	xor	edx, edx
	call	QWORD PTR __imp_memset

; 1790 :     return _Last;

	mov	rax, rbx

; 1791 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$_Zero_range@PEAM@std@@YAPEAMQEAM0@Z ENDP		; std::_Zero_range<float *>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@M@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@M@std@@@std@@QEAAXXZ PROC ; std::_Uninitialized_backout_al<std::allocator<float> >::_Emplace_back<>, COMDAT

; 714  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rcx+8]
	xor	edx, edx
	mov	DWORD PTR [rax], edx

; 1611 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);
; 1612 :         ++_Last;

	add	QWORD PTR [rcx+8], 4

; 1613 :     }

	ret	0
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@M@std@@@std@@QEAAXXZ ENDP ; std::_Uninitialized_backout_al<std::allocator<float> >::_Emplace_back<>
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@M$$V@?$_Default_allocator_traits@V?$allocator@M@std@@@std@@SAXAEAV?$allocator@M@1@QEAM@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
??$construct@M$$V@?$_Default_allocator_traits@V?$allocator@M@std@@@std@@SAXAEAV?$allocator@M@1@QEAM@Z PROC ; std::_Default_allocator_traits<std::allocator<float> >::construct<float>, COMDAT

; 708  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 709  :         if (_STD is_constant_evaluated()) {
; 710  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 711  :         } else
; 712  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 713  :         {
; 714  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);

	xor	eax, eax
	mov	DWORD PTR [rdx], eax

; 715  :         }
; 716  :     }

	ret	0
??$construct@M$$V@?$_Default_allocator_traits@V?$allocator@M@std@@@std@@SAXAEAV?$allocator@M@1@QEAM@Z ENDP ; std::_Default_allocator_traits<std::allocator<float> >::construct<float>
_TEXT	ENDS
END
